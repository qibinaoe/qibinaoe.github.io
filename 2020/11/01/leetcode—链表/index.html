<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#f3a683"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-bin.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-bin.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-bin.png">
  <link rel="mask-icon" href="/images/logo-bin.svg" color="#f3a683">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"qibinaoe.top","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":true,"color":"#FF8B8B","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/config.js"></script>

    <meta name="description" content="leetcode 链表专题的刷题记录">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode—链表">
<meta property="og:url" content="http://qibinaoe.top/2020/11/01/leetcode%E2%80%94%E9%93%BE%E8%A1%A8/index.html">
<meta property="og:site_name" content="Qibin&#39;s Blog">
<meta property="og:description" content="leetcode 链表专题的刷题记录">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/%E7%A4%BA%E4%BE%8B1.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/%E7%A4%BA%E4%BE%8B2.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/%E7%A4%BA%E4%BE%8B3.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/floyd_route.jpg">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/160_%E7%A4%BA%E4%BE%8B1.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/160_%E7%A4%BA%E4%BE%8B2.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/e1.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/circularlinkedlist.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/circularlinkedlist_test3.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/multilevellinkedlist.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/multilevellinkedlistflattened.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/sample_1_1720.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/sample_2_1720.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/fig1.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/merge_linked_list_ex1.png">
<meta property="article:published_time" content="2020-11-01T01:07:14.000Z">
<meta property="article:modified_time" content="2022-06-08T04:59:36.479Z">
<meta property="article:author" content="ZQB">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="leetcode">
<meta property="article:tag" content="链表">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://algorithm-image.qibinaoe.top/%E7%A4%BA%E4%BE%8B1.png">


<link rel="canonical" href="http://qibinaoe.top/2020/11/01/leetcode%E2%80%94%E9%93%BE%E8%A1%A8/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://qibinaoe.top/2020/11/01/leetcode%E2%80%94%E9%93%BE%E8%A1%A8/","path":"2020/11/01/leetcode—链表/","title":"leetcode—链表"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>leetcode—链表 | Qibin's Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Qibin's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">better and better</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook/" rel="section"><i class="fa fa-book fa-fw"></i>留言板</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8TAG"><span class="nav-number">1.</span> <span class="nav-text">leetcode——链表TAG</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#leetcode21%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">1.1.</span> <span class="nav-text">leetcode21——合并两个有序链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v71"><span class="nav-number">1.1.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.1.2.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%BB%A3%E7%A0%81"><span class="nav-number">1.1.3.</span> <span class="nav-text">C++代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%84%9F%E6%82%9F"><span class="nav-number">1.1.4.</span> <span class="nav-text">解题感悟</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#leetcode83%E2%80%94%E2%80%94%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-number">1.2.</span> <span class="nav-text">leetcode83——删除排序链表中的重复元素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v72"><span class="nav-number">1.2.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B1"><span class="nav-number">1.2.2.</span> <span class="nav-text">示例1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B2"><span class="nav-number">1.2.3.</span> <span class="nav-text">示例2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%BB%A3%E7%A0%81-v2"><span class="nav-number">1.2.4.</span> <span class="nav-text">C++代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%84%9F%E6%82%9F-v2"><span class="nav-number">1.2.5.</span> <span class="nav-text">解题感悟</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#leetcode141%E2%80%94%E2%80%94%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="nav-number">1.3.</span> <span class="nav-text">leetcode141——环形链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v73"><span class="nav-number">1.3.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B1-v2"><span class="nav-number">1.3.2.</span> <span class="nav-text">示例1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B2-v2"><span class="nav-number">1.3.3.</span> <span class="nav-text">示例2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B3"><span class="nav-number">1.3.4.</span> <span class="nav-text">示例3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95%E4%B8%80"><span class="nav-number">1.3.5.</span> <span class="nav-text">解法一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95%E4%BA%8C"><span class="nav-number">1.3.6.</span> <span class="nav-text">解法二</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Floyd-%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95-Floyd-cycle-detection"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">Floyd 判圈算法(Floyd cycle detection)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.6.2.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-v2"><span class="nav-number">1.3.6.3.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-v3"><span class="nav-number">1.3.6.4.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95%E4%B8%89"><span class="nav-number">1.3.6.5.</span> <span class="nav-text">解法三</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="nav-number">1.3.6.6.</span> <span class="nav-text">实现代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#leetcode160%E2%80%94%E2%80%94%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="nav-number">1.4.</span> <span class="nav-text">leetcode160——相交链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v74"><span class="nav-number">1.4.1.</span> <span class="nav-text">题目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B1-v3"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">示例1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B2-v3"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">示例2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">注意：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95%E4%B8%80-v2"><span class="nav-number">1.4.2.</span> <span class="nav-text">解法一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95%E4%BA%8C-v2"><span class="nav-number">1.4.3.</span> <span class="nav-text">解法二</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-v4"><span class="nav-number">1.4.4.</span> <span class="nav-text">代码实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%98%8E"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">代码说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#leetcode203%E2%80%94%E2%80%94%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="nav-number">1.5.</span> <span class="nav-text">leetcode203——移除链表元素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v75"><span class="nav-number">1.5.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-v2"><span class="nav-number">1.5.2.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v58"><span class="nav-number">1.5.3.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%811"><span class="nav-number">1.5.4.</span> <span class="nav-text">实现代码1</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%A8%E5%85%B5%E7%BB%93%E7%82%B9%E5%81%9A%E6%B3%95"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">哨兵结点做法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%812"><span class="nav-number">1.5.5.</span> <span class="nav-text">实现代码2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#leetcode206%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">1.6.</span> <span class="nav-text">leetcode206——反转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v76"><span class="nav-number">1.6.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v59"><span class="nav-number">1.6.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="nav-number">1.6.3.</span> <span class="nav-text">迭代实现代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E2%80%94%E2%80%94%E6%95%88%E7%8E%87%E4%BD%8E%E4%B8%8B%E7%89%88"><span class="nav-number">1.6.4.</span> <span class="nav-text">递归实现代码——效率低下版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E2%80%94%E2%80%94%E6%94%B9%E8%BF%9B%E7%89%88"><span class="nav-number">1.6.5.</span> <span class="nav-text">递归实现代码——改进版</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#leetcode234%E2%80%94%E2%80%94%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="nav-number">1.7.</span> <span class="nav-text">leetcode234——回文链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v77"><span class="nav-number">1.7.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v60"><span class="nav-number">1.7.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="nav-number">1.7.3.</span> <span class="nav-text">双指针解题代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="nav-number">1.7.4.</span> <span class="nav-text">快慢指针+反转链表解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">1.8.</span> <span class="nav-text">237. 删除链表中的节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v78"><span class="nav-number">1.8.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v61"><span class="nav-number">1.8.2.</span> <span class="nav-text">解题思路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9"><span class="nav-number">1.9.</span> <span class="nav-text">876. 链表的中间结点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v79"><span class="nav-number">1.9.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v62"><span class="nav-number">1.9.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v53"><span class="nav-number">1.9.3.</span> <span class="nav-text">解题代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%8D%E6%AC%A1%E4%BC%98%E5%8C%96"><span class="nav-number">1.9.4.</span> <span class="nav-text">再次优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-v5"><span class="nav-number">1.9.5.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1290-%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%95%B4%E6%95%B0"><span class="nav-number">1.10.</span> <span class="nav-text">1290. 二进制链表转整数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v80"><span class="nav-number">1.10.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v63"><span class="nav-number">1.10.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v54"><span class="nav-number">1.10.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8"><span class="nav-number">1.11.</span> <span class="nav-text">剑指 Offer 06. 从尾到头打印链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v81"><span class="nav-number">1.11.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v64"><span class="nav-number">1.11.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="nav-number">1.11.3.</span> <span class="nav-text">栈实现代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.11.4.</span> <span class="nav-text">反转链表实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">1.12.</span> <span class="nav-text">剑指 Offer 18. 删除链表的节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v82"><span class="nav-number">1.12.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v65"><span class="nav-number">1.12.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v55"><span class="nav-number">1.12.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">1.13.</span> <span class="nav-text">剑指 Offer 22. 链表中倒数第k个节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v83"><span class="nav-number">1.13.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v66"><span class="nav-number">1.13.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E6%B3%95%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="nav-number">1.13.3.</span> <span class="nav-text">遍历法解题代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E5%81%9A%E6%B3%95"><span class="nav-number">1.13.4.</span> <span class="nav-text">双指针做法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E5%80%9F%E9%89%B4"><span class="nav-number">1.13.5.</span> <span class="nav-text">学习借鉴</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9"><span class="nav-number">1.14.</span> <span class="nav-text">剑指 Offer 52. 两个链表的第一个公共节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v84"><span class="nav-number">1.14.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v67"><span class="nav-number">1.14.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v56"><span class="nav-number">1.14.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-02-01-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9"><span class="nav-number">1.15.</span> <span class="nav-text">面试题 02.01. 移除重复节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v85"><span class="nav-number">1.15.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v68"><span class="nav-number">1.15.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E8%A7%A3%E6%B3%95"><span class="nav-number">1.15.3.</span> <span class="nav-text">集合解法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-02-02-%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">1.16.</span> <span class="nav-text">面试题 02.02. 返回倒数第 k 个节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v86"><span class="nav-number">1.16.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v69"><span class="nav-number">1.16.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v57"><span class="nav-number">1.16.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-02-03-%E5%88%A0%E9%99%A4%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9"><span class="nav-number">1.17.</span> <span class="nav-text">面试题 02.03. 删除中间节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v87"><span class="nav-number">1.17.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v70"><span class="nav-number">1.17.2.</span> <span class="nav-text">解题思路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-02-06-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="nav-number">1.18.</span> <span class="nav-text">面试题 02.06. 回文链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v71"><span class="nav-number">1.18.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E5%AF%BB%E6%89%BE%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93"><span class="nav-number">1.18.2.</span> <span class="nav-text">快慢指针寻找中间节点学习总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-02-07-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4"><span class="nav-number">1.19.</span> <span class="nav-text">面试题 02.07. 链表相交</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v88"><span class="nav-number">1.19.1.</span> <span class="nav-text">题目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="nav-number">1.20.</span> <span class="nav-text">2. 两数相加</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v89"><span class="nav-number">1.20.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v72"><span class="nav-number">1.20.2.</span> <span class="nav-text">解题思路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E8%A7%A3%E9%A2%98"><span class="nav-number">1.20.2.1.</span> <span class="nav-text">错误解题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E7%A1%AE%E8%A7%A3%E6%B3%95"><span class="nav-number">1.20.3.</span> <span class="nav-text">正确解法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">1.21.</span> <span class="nav-text">19. 删除链表的倒数第N个节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v90"><span class="nav-number">1.21.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v73"><span class="nav-number">1.21.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%811-v9"><span class="nav-number">1.21.3.</span> <span class="nav-text">解题代码1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81"><span class="nav-number">1.21.4.</span> <span class="nav-text">优化代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">1.22.</span> <span class="nav-text">24. 两两交换链表中的节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v91"><span class="nav-number">1.22.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF1-v10"><span class="nav-number">1.22.2.</span> <span class="nav-text">解题思路1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%811-v10"><span class="nav-number">1.22.3.</span> <span class="nav-text">解题代码1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v24"><span class="nav-number">1.22.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v23"><span class="nav-number">1.22.5.</span> <span class="nav-text">解题代码2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF3-v5"><span class="nav-number">1.22.6.</span> <span class="nav-text">解题思路3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%813-v9"><span class="nav-number">1.22.7.</span> <span class="nav-text">解题代码3</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">1.23.</span> <span class="nav-text">61. 旋转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v92"><span class="nav-number">1.23.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v74"><span class="nav-number">1.23.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v58"><span class="nav-number">1.23.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II"><span class="nav-number">1.24.</span> <span class="nav-text">82. 删除排序链表中的重复元素 II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v93"><span class="nav-number">1.24.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v75"><span class="nav-number">1.24.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v59"><span class="nav-number">1.24.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8"><span class="nav-number">1.25.</span> <span class="nav-text">86. 分隔链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v94"><span class="nav-number">1.25.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF1-v11"><span class="nav-number">1.25.2.</span> <span class="nav-text">解题思路1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%811-v11"><span class="nav-number">1.25.3.</span> <span class="nav-text">解题代码1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v25"><span class="nav-number">1.25.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v24"><span class="nav-number">1.25.5.</span> <span class="nav-text">解题代码2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II"><span class="nav-number">1.26.</span> <span class="nav-text">92. 反转链表 II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v95"><span class="nav-number">1.26.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v76"><span class="nav-number">1.26.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%811-v12"><span class="nav-number">1.26.3.</span> <span class="nav-text">解题代码1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v25"><span class="nav-number">1.26.4.</span> <span class="nav-text">解题代码2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#109-%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">1.27.</span> <span class="nav-text">109. 有序链表转换二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v96"><span class="nav-number">1.27.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF1-v12"><span class="nav-number">1.27.2.</span> <span class="nav-text">解题思路1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%811-v13"><span class="nav-number">1.27.3.</span> <span class="nav-text">解题代码1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v26"><span class="nav-number">1.27.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v26"><span class="nav-number">1.27.5.</span> <span class="nav-text">解题代码2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="nav-number">1.28.</span> <span class="nav-text">138. 复制带随机指针的链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v97"><span class="nav-number">1.28.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF1-v13"><span class="nav-number">1.28.2.</span> <span class="nav-text">解题思路1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%811-v14"><span class="nav-number">1.28.3.</span> <span class="nav-text">解题代码1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v27"><span class="nav-number">1.28.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v27"><span class="nav-number">1.28.5.</span> <span class="nav-text">解题代码2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II"><span class="nav-number">1.29.</span> <span class="nav-text">142. 环形链表 II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v98"><span class="nav-number">1.29.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v77"><span class="nav-number">1.29.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v60"><span class="nav-number">1.29.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8"><span class="nav-number">1.30.</span> <span class="nav-text">143. 重排链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v99"><span class="nav-number">1.30.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v78"><span class="nav-number">1.30.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v61"><span class="nav-number">1.30.3.</span> <span class="nav-text">解题代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v28"><span class="nav-number">1.30.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v28"><span class="nav-number">1.30.5.</span> <span class="nav-text">解题代码2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF3-v6"><span class="nav-number">1.30.6.</span> <span class="nav-text">解题思路3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%813-v10"><span class="nav-number">1.30.7.</span> <span class="nav-text">解题代码3</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">1.31.</span> <span class="nav-text">147. 对链表进行插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v100"><span class="nav-number">1.31.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v79"><span class="nav-number">1.31.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v62"><span class="nav-number">1.31.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">1.32.</span> <span class="nav-text">148. 排序链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v80"><span class="nav-number">1.32.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.32.2.</span> <span class="nav-text">自顶向下代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.32.3.</span> <span class="nav-text">自底向上代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8"><span class="nav-number">1.33.</span> <span class="nav-text">328. 奇偶链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v101"><span class="nav-number">1.33.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v81"><span class="nav-number">1.33.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v63"><span class="nav-number">1.33.3.</span> <span class="nav-text">解题代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v29"><span class="nav-number">1.33.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v29"><span class="nav-number">1.33.5.</span> <span class="nav-text">解题代码2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#430-%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">1.34.</span> <span class="nav-text">430. 扁平化多级双向链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v102"><span class="nav-number">1.34.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v82"><span class="nav-number">1.34.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v64"><span class="nav-number">1.34.3.</span> <span class="nav-text">解题代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v30"><span class="nav-number">1.34.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="nav-number">1.34.5.</span> <span class="nav-text">递归解题代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF3-v7"><span class="nav-number">1.34.6.</span> <span class="nav-text">解题思路3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%813-v11"><span class="nav-number">1.34.7.</span> <span class="nav-text">解题代码3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF4-v2"><span class="nav-number">1.34.8.</span> <span class="nav-text">解题思路4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%814-v3"><span class="nav-number">1.34.9.</span> <span class="nav-text">解题代码4</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#445-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-II"><span class="nav-number">1.35.</span> <span class="nav-text">445. 两数相加 II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v103"><span class="nav-number">1.35.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF1-v14"><span class="nav-number">1.35.2.</span> <span class="nav-text">解题思路1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%811-v15"><span class="nav-number">1.35.3.</span> <span class="nav-text">解题代码1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v31"><span class="nav-number">1.35.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v30"><span class="nav-number">1.35.5.</span> <span class="nav-text">解题代码2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8"><span class="nav-number">1.36.</span> <span class="nav-text">707. 设计链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v104"><span class="nav-number">1.36.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v83"><span class="nav-number">1.36.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E4%BB%A3%E7%A0%81"><span class="nav-number">1.36.3.</span> <span class="nav-text">单向链表代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E4%BB%A3%E7%A0%81"><span class="nav-number">1.36.4.</span> <span class="nav-text">双向链表代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#725-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8"><span class="nav-number">1.37.</span> <span class="nav-text">725. 分隔链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v105"><span class="nav-number">1.37.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v84"><span class="nav-number">1.37.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v65"><span class="nav-number">1.37.3.</span> <span class="nav-text">解题代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v32"><span class="nav-number">1.37.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v31"><span class="nav-number">1.37.5.</span> <span class="nav-text">解题代码2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#817-%E9%93%BE%E8%A1%A8%E7%BB%84%E4%BB%B6"><span class="nav-number">1.38.</span> <span class="nav-text">817. 链表组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v106"><span class="nav-number">1.38.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF1-v15"><span class="nav-number">1.38.2.</span> <span class="nav-text">解题思路1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%811-v16"><span class="nav-number">1.38.3.</span> <span class="nav-text">解题代码1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v33"><span class="nav-number">1.38.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v32"><span class="nav-number">1.38.5.</span> <span class="nav-text">解题代码2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1019-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E8%8A%82%E7%82%B9"><span class="nav-number">1.39.</span> <span class="nav-text">1019. 链表中的下一个更大节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v107"><span class="nav-number">1.39.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF1-v16"><span class="nav-number">1.39.2.</span> <span class="nav-text">解题思路1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%811-v17"><span class="nav-number">1.39.3.</span> <span class="nav-text">解题代码1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v34"><span class="nav-number">1.39.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v33"><span class="nav-number">1.39.5.</span> <span class="nav-text">解题代码2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1171-%E4%BB%8E%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E5%8E%BB%E6%80%BB%E5%92%8C%E5%80%BC%E4%B8%BA%E9%9B%B6%E7%9A%84%E8%BF%9E%E7%BB%AD%E8%8A%82%E7%82%B9"><span class="nav-number">1.40.</span> <span class="nav-text">1171. 从链表中删去总和值为零的连续节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v108"><span class="nav-number">1.40.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v85"><span class="nav-number">1.40.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v66"><span class="nav-number">1.40.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1367-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8"><span class="nav-number">1.41.</span> <span class="nav-text">1367. 二叉树中的列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v109"><span class="nav-number">1.41.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v86"><span class="nav-number">1.41.2.</span> <span class="nav-text">解题思路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v67"><span class="nav-number">1.41.2.1.</span> <span class="nav-text">解题代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1669-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8"><span class="nav-number">1.42.</span> <span class="nav-text">1669. 合并两个链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v110"><span class="nav-number">1.42.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v87"><span class="nav-number">1.42.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v68"><span class="nav-number">1.42.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1670-%E8%AE%BE%E8%AE%A1%E5%89%8D%E4%B8%AD%E5%90%8E%E9%98%9F%E5%88%97"><span class="nav-number">1.43.</span> <span class="nav-text">1670. 设计前中后队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v111"><span class="nav-number">1.43.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v88"><span class="nav-number">1.43.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">1.43.3.</span> <span class="nav-text">解题代码单向链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="nav-number">1.44.</span> <span class="nav-text">剑指 Offer 35. 复杂链表的复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v112"><span class="nav-number">1.44.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v69"><span class="nav-number">1.44.2.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-02-04-%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8"><span class="nav-number">1.45.</span> <span class="nav-text">面试题 02.04. 分割链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-02-05-%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C"><span class="nav-number">1.46.</span> <span class="nav-text">面试题 02.05. 链表求和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v70"><span class="nav-number">1.46.1.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-02-08-%E7%8E%AF%E8%B7%AF%E6%A3%80%E6%B5%8B"><span class="nav-number">1.47.</span> <span class="nav-text">面试题 02.08. 环路检测</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">1.48.</span> <span class="nav-text">23. 合并K个升序链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v113"><span class="nav-number">1.48.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF1-v17"><span class="nav-number">1.48.2.</span> <span class="nav-text">解题思路1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%811-v18"><span class="nav-number">1.48.3.</span> <span class="nav-text">解题代码1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v35"><span class="nav-number">1.48.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v34"><span class="nav-number">1.48.5.</span> <span class="nav-text">解题代码2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF3-v8"><span class="nav-number">1.48.6.</span> <span class="nav-text">解题思路3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%813-v12"><span class="nav-number">1.48.7.</span> <span class="nav-text">解题代码3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF4-v3"><span class="nav-number">1.48.8.</span> <span class="nav-text">解题思路4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%814-v4"><span class="nav-number">1.48.9.</span> <span class="nav-text">解题代码4</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">1.49.</span> <span class="nav-text">25. K 个一组翻转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v114"><span class="nav-number">1.49.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v89"><span class="nav-number">1.49.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v71"><span class="nav-number">1.49.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZQB"
      src="/images/me_avatar.png">
  <p class="site-author-name" itemprop="name">ZQB</p>
  <div class="site-description" itemprop="description">Better Me</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/qibinaoe" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;qibinaoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:780891896@qq.com" title="E-Mail → mailto:780891896@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://gagalab.tech/" title="https:&#x2F;&#x2F;gagalab.tech&#x2F;" rel="noopener" target="_blank">嘎嘎研究所</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://qibinaoe.top/2020/11/01/leetcode%E2%80%94%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me_avatar.png">
      <meta itemprop="name" content="ZQB">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qibin's Blog">
      <meta itemprop="description" content="Better Me">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="leetcode—链表 | Qibin's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          leetcode—链表
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-01 09:07:14" itemprop="dateCreated datePublished" datetime="2020-11-01T09:07:14+08:00">2020-11-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-08 12:59:36" itemprop="dateModified" datetime="2022-06-08T12:59:36+08:00">2022-06-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>70k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:56</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="leetcode——链表TAG"><a class="header-anchor" href="#leetcode——链表TAG"> </a>leetcode——链表TAG</h1>
<!-- more -->
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/tag/linked-list/">来源leetcode链表专题</a></p>
<blockquote>
<p>一杯茶，一包烟，一道链表做一天</p>
</blockquote>
<h2 id="leetcode21——合并两个有序链表"><a class="header-anchor" href="#leetcode21——合并两个有序链表"> </a>leetcode21——合并两个有序链表</h2>
<h3 id="题目-v71"><a class="header-anchor" href="#题目-v71"> </a>题目</h3>
<pre><code>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
</code></pre>
<h3 id="示例"><a class="header-anchor" href="#示例"> </a>示例</h3>
<blockquote>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</p>
</blockquote>
<blockquote>
<p>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
</blockquote>
<hr>
<h3 id="C-代码"><a class="header-anchor" href="#C-代码"> </a>C++代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//迭代的方式</span></span><br><span class="line">        <span class="comment">//哨兵结点，方便结果返回</span></span><br><span class="line">        ListNode *prehead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *cur = prehead;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span> &amp;&amp; l2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                <span class="comment">//l1值小，可以插入新表</span></span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cur-&gt;next = l1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prehead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="解题感悟"><a class="header-anchor" href="#解题感悟"> </a>解题感悟</h3>
<ol>
<li>这题使用了一个哨兵结点<code>prehead</code>记录链表头，便于最后返回合并后的链表。但是<strong>注意</strong>：开始第一次的时候，prehead不应该储存记录，即不能这样<code>cur = l1</code>，因为会把<code>preahead</code>指向的链表头给覆盖，导致丢掉。因此应该在<code>cur-&gt;next = l1</code>进行赋值。</li>
<li>由于两个链表都是有序的，因此当一个链表为空的时候，另外一个链表也是有序的，只需要将它接在合并后的链表末尾就可以了。</li>
</ol>
<hr>
<h2 id="leetcode83——删除排序链表中的重复元素"><a class="header-anchor" href="#leetcode83——删除排序链表中的重复元素"> </a>leetcode83——删除排序链表中的重复元素</h2>
<h3 id="题目-v72"><a class="header-anchor" href="#题目-v72"> </a>题目</h3>
<p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<h3 id="示例1"><a class="header-anchor" href="#示例1"> </a>示例1</h3>
<blockquote>
<p>输入: 1-&gt;1-&gt;2</p>
</blockquote>
<blockquote>
<p>输出: 1-&gt;2</p>
</blockquote>
<h3 id="示例2"><a class="header-anchor" href="#示例2"> </a>示例2</h3>
<blockquote>
<p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3</p>
</blockquote>
<blockquote>
<p>输出: 1-&gt;2-&gt;3</p>
</blockquote>
<h3 id="C-代码-v2"><a class="header-anchor" href="#C-代码-v2"> </a>C++代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断下一个结点与当前结点储存的值是否相等</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* nextNode = head-&gt;next;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nextNode != <span class="literal">nullptr</span> &amp;&amp; nextNode-&gt;val == cur-&gt;val)&#123;</span><br><span class="line">                nextNode = nextNode-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur-&gt;next = nextNode;  </span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题感悟-v2"><a class="header-anchor" href="#解题感悟-v2"> </a>解题感悟</h3>
<ol>
<li>这种要遍历整个链表并且返回整个链表的题目，应该先声明一个指针，例如<code>cur</code>指向该链表头，再进行遍历。在最后的结果就可以直接返回<code>head</code>。</li>
</ol>
<hr>
<h2 id="leetcode141——环形链表"><a class="header-anchor" href="#leetcode141——环形链表"> </a>leetcode141——环形链表</h2>
<h3 id="题目-v73"><a class="header-anchor" href="#题目-v73"> </a>题目</h3>
<p>给定一个链表，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
<p></p>
<p>进阶：</p>
<p>你能用 O(1)（即，常量）内存解决此问题吗？</p>
<h3 id="示例1-v2"><a class="header-anchor" href="#示例1-v2"> </a>示例1</h3>
<p><img src="http://algorithm-image.qibinaoe.top/%E7%A4%BA%E4%BE%8B1.png" alt="示例图1"></p>
<blockquote>
<p>输入：head = [3,2,0,-4], pos = 1</p>
</blockquote>
<blockquote>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>解释：链表中有一个环，其尾部连接到第二个节点。</p>
</blockquote>
<h3 id="示例2-v2"><a class="header-anchor" href="#示例2-v2"> </a>示例2</h3>
<p><img src="http://algorithm-image.qibinaoe.top/%E7%A4%BA%E4%BE%8B2.png" alt="示例图2"></p>
<blockquote>
<p>输入：head = [1,2], pos = 0</p>
</blockquote>
<blockquote>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>解释：链表中有一个环，其尾部连接到第一个节点。</p>
</blockquote>
<h3 id="示例3"><a class="header-anchor" href="#示例3"> </a>示例3</h3>
<p><img src="http://algorithm-image.qibinaoe.top/%E7%A4%BA%E4%BE%8B3.png" alt="示例图3"></p>
<blockquote>
<p>输入：head = [1], pos = -1</p>
</blockquote>
<blockquote>
<p>输出：false</p>
</blockquote>
<blockquote>
<p>解释：链表中没有环。</p>
</blockquote>
<p>解释：链表中没有环。</p>
<p>提示：</p>
<ul>
<li>链表中节点的数目范围是 [0, 10<sup>4</sup>]</li>
<li>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></li>
<li>pos 为 -1 或者链表中的一个 有效索引.</li>
</ul>
<h3 id="解法一"><a class="header-anchor" href="#解法一"> </a>解法一</h3>
<p>时间复杂度O(n)，空间复杂度O(n)</p>
<p>通过集合set可以很容易判断set中是否已经存在某个元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode*&gt; seen;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(seen.<span class="built_in">count</span>(head))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                seen.<span class="built_in">insert</span>(head);</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解法二"><a class="header-anchor" href="#解法二"> </a>解法二</h3>
<h4 id="Floyd-判圈算法-Floyd-cycle-detection"><a class="header-anchor" href="#Floyd-判圈算法-Floyd-cycle-detection"> </a>Floyd 判圈算法(Floyd cycle detection)</h4>
<p>Floyd判圈算法又称龟兔赛跑算法</p>
<p>对于一个有环链表，floyd判圈算法能做到三件事</p>
<ul>
<li>判断链表是否有环</li>
<li>计算环的长度</li>
<li>寻找环的起点</li>
</ul>
<ol>
<li>
<p>判断链表是否有环</p>
<p>假设有两个指针它们移动速度不同。一个指针每一次走两步，称为快指针fast(也叫兔子hare)。另一个指针每一次走一步，称为慢指针slow(也叫乌龟tortoise)。它们同时从起点出发，会发生两种情况。</p>
<ul>
<li>快指针fast到达了链表的尾部，这说明该链表没有环</li>
<li>快指针fast和慢指针slow相遇，说明链表存在环</li>
</ul>
<p>当链表存在环的时候，fast走过的路程比slow走的路程，多走了k个环的长度,即kC。其中C为环的长度</p>
</li>
</ol>
<h4 id="代码实现"><a class="header-anchor" href="#代码实现"> </a>代码实现</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//同时在跑道开头 </span></span><br><span class="line">	ListNode* fast = head;</span><br><span class="line">	ListNode* slow = head;</span><br><span class="line">	<span class="keyword">while</span>(fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">		fast = fast-&gt;next-&gt;next;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		<span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">			<span class="comment">//相遇</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>计算环的长度</p>
<p>由于快指针和慢指针相遇的地方一定是环中的某一点，这时候快指针停下来，让慢指针继续走。当快慢指针再次相遇的时候，慢指针所走过的步长即为环的长度。</p>
</li>
</ol>
<h4 id="代码实现-v2"><a class="header-anchor" href="#代码实现-v2"> </a>代码实现</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cycleLength</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* fast = head;</span><br><span class="line">	ListNode* slow = head;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">		fast = fast-&gt;next-&gt;next;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		<span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">			<span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">do</span>&#123;</span><br><span class="line">				slow = slow-&gt;next;</span><br><span class="line">				length++;</span><br><span class="line">			&#125;<span class="keyword">while</span>(fast != slow);</span><br><span class="line">			<span class="keyword">return</span> length;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/floyd_route.jpg" alt="floyd_route.jpg"></p>
<ol>
<li>
<p>环的起点<br>
注意，快指针每次走2步，慢指针每次走1步，因此当它们相遇的时候，快指针走的路程是慢指针的两倍。不妨设慢指针走的路程为S<sub>1</sub>,则快指针走的路程为2*S<sub>1</sub>。因此可以推导如下公式,k<sub>1</sub>为慢指针走的圈数，k<sub>2</sub>为快指针走的圈数</p>
<p>S<sub>1</sub> = d<sub>1</sub>+d<sub>2</sub>+k<sub>1</sub>*C</p>
<p>2*S<sub>1</sub> = d<sub>1</sub>+d<sub>2</sub>+k<sub>2</sub>*C</p>
<p>所以</p>
<p>S<sub>1</sub> = (k<sub>2</sub>-k<sub>1</sub>)*C =  d<sub>1</sub>+d<sub>2</sub>+k<sub>1</sub>*C</p>
<p>可以推出</p>
<p>d<sub>1</sub>+d<sub>2</sub> = (k<sub>2</sub>-2*k<sub>1</sub>)*C 该公式说明d<sub>1</sub>+d<sub>2</sub>为圈的整数倍</p>
<p>这里不妨让快指针在相遇后回到起点，慢指针留在原地M，然后步长为1同时开始移动。那么当快指针走了d<sub>1</sub>来到P(环的起点)的时候，慢指针走的路程也为d<sub>1</sub>，又我们前面知道d<sub>1</sub>+d<sub>2</sub>为圈的整数倍，而慢指针开始在M点，相当于已经走了d<sub>2</sub>,这时候再走d<sub>1</sub>长度，加起来圈的整数倍。即环的起点。</p>
<p><strong>这里有点绕，困了我很久</strong>，我们可以这么理解，当快指针和慢指针在M相遇的时候，我们把慢指针放在圈的起点P，快指针放在整个道路的起点S。这时让慢指针先走了d<sub>2</sub>的长度时，快指针才开始移动，移动的速度和慢指针一样都是1步，那么当快指针走到P点的时候，慢指针对于圈的起点P走了d<sub>1</sub>+d<sub>2</sub>的长度，为圈的整数倍，即又回到圈的起点</p>
</li>
</ol>
<h4 id="代码实现-v3"><a class="header-anchor" href="#代码实现-v3"> </a>代码实现</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ListNode* findCircleHead(ListNode* head)</span><br><span class="line">&#123;</span><br><span class="line">	if(head == nullptr || head-&gt;next == nullptr)&#123;</span><br><span class="line">		return nullptr;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* fast = head;</span><br><span class="line">	ListNode* slow = head;</span><br><span class="line">	</span><br><span class="line">	while(fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr)&#123;</span><br><span class="line">		fast = fast-&gt;next-&gt;next;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		if(fast == slow)&#123;</span><br><span class="line">			fast = head;</span><br><span class="line">			while(fast != slow)&#123;</span><br><span class="line">				fast = fast-&gt;next;</span><br><span class="line">				slow = slow-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			return slow;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过快慢指针的方法，时间复杂度为O(N),空间复杂度为O(1)</p>
<h4 id="解法三"><a class="header-anchor" href="#解法三"> </a>解法三</h4>
<p>逐个删除法，即遍历过的结点让其next指向自己。如果遇到一个结点其结点已经指向自己了，说明其存在环</p>
<h4 id="实现代码"><a class="header-anchor" href="#实现代码"> </a>实现代码</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//逐个删除法</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* prev;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;next == head)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = head;</span><br><span class="line">            <span class="comment">//删除该结点</span></span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            prev-&gt;next = prev;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="leetcode160——相交链表"><a class="header-anchor" href="#leetcode160——相交链表"> </a>leetcode160——相交链表</h2>
<h3 id="题目-v74"><a class="header-anchor" href="#题目-v74"> </a>题目</h3>
<h4 id="示例1-v3"><a class="header-anchor" href="#示例1-v3"> </a>示例1</h4>
<blockquote>
<p>编写一个程序，找到两个单链表相交的起始节点。<br>
如下面的两个链表：</p>
</blockquote>
<p><img src="http://algorithm-image.qibinaoe.top/160_%E7%A4%BA%E4%BE%8B1.png" alt="160_示例1.png"></p>
<blockquote>
<p>在节点 c1 开始相交。</p>
</blockquote>
<h4 id="示例2-v3"><a class="header-anchor" href="#示例2-v3"> </a>示例2</h4>
<p><img src="http://algorithm-image.qibinaoe.top/160_%E7%A4%BA%E4%BE%8B2.png" alt="160_示例2.png"></p>
<blockquote>
<p>不相交，返回<code>null</code></p>
</blockquote>
<h4 id="注意："><a class="header-anchor" href="#注意："> </a>注意：</h4>
<ul>
<li>如果两个链表没有交点，返回 null.</li>
<li>在返回结果后，两个链表仍须保持原有的结构。</li>
<li>可假定整个链表结构中没有循环。</li>
<li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li>
</ul>
<h3 id="解法一-v2"><a class="header-anchor" href="#解法一-v2"> </a>解法一</h3>
<p>通过集合set，两个链表同时向后移动，每移动一个结点就放入set中，如果要放入的结点已经存在，则该结点为相交点，当两个链表都遍历完后，仍没有重复结点，则不相交</p>
<p>空间复杂度O(N+M)  时间复杂度O(N)或O(M)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        set&lt;ListNode*&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="literal">nullptr</span> || headB == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(headA||headB)&#123;</span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span>(headA)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.<span class="built_in">count</span>(headA))&#123;</span><br><span class="line">                    <span class="keyword">return</span> headA;</span><br><span class="line">                &#125;</span><br><span class="line">                s.<span class="built_in">insert</span>(headA);</span><br><span class="line">                headA = headA-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(headB)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.<span class="built_in">count</span>(headB))&#123;</span><br><span class="line">                    <span class="keyword">return</span> headB;</span><br><span class="line">                &#125;</span><br><span class="line">                s.<span class="built_in">insert</span>(headB);</span><br><span class="line">                headB = headB-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解法二-v2"><a class="header-anchor" href="#解法二-v2"> </a>解法二</h3>
<p>双指针法，双指针的根本原理就是消除两个链表的长度差。然后同时判断指向的结点是否同一个。</p>
<p>基本做法就声明两个指针<em>p</em>A和<em>p</em>B，让它们分别指向链表A和链表B，然后同时移动，当一个指针例如<em>p</em>A遍历完链表A后，将它指向链表B并继续前进遍历。当<em>p</em>B遍历完链表B后，将它指向链表A并继续遍历。这样做，当<em>p</em>A和<em>p</em>B都遍历了两条链都遍历了链表A和链表B不同的部分，和一遍相同的部分，然后回同时达到相同的部分(如果存在相交)。如果指针遍历完第二次链表完都没有相同结点，则不相交</p>
<p>时间复杂度O(M+N)  空间复杂度O(1)</p>
<h3 id="代码实现-v4"><a class="header-anchor" href="#代码实现-v4"> </a>代码实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="literal">nullptr</span> || headB == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* pA = headA;</span><br><span class="line">        ListNode* pB = headB;</span><br><span class="line">        <span class="keyword">while</span>(pA != <span class="literal">nullptr</span> || pB != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pA == pB)&#123;</span><br><span class="line">                <span class="keyword">return</span> pA;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pA == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                pA = headB;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pA = pA-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pB == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                pB = headA;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pB = pB-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="代码说明"><a class="header-anchor" href="#代码说明"> </a>代码说明</h4>
<p><code> while(pA != nullptr || pB != nullptr)</code>.如果链表A和链表B等长度并且有交点，那么第一次遍历的时候就会相交，如果不相交，则两个指针同时为空。</p>
<hr>
<h2 id="leetcode203——移除链表元素"><a class="header-anchor" href="#leetcode203——移除链表元素"> </a>leetcode203——移除链表元素</h2>
<h3 id="题目-v75"><a class="header-anchor" href="#题目-v75"> </a>题目</h3>
<p>删除链表中等于给定值 val 的所有节点。</p>
<h3 id="示例-v2"><a class="header-anchor" href="#示例-v2"> </a>示例</h3>
<blockquote>
<p>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6</p>
<p>输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
</blockquote>
<h3 id="解题思路-v58"><a class="header-anchor" href="#解题思路-v58"> </a>解题思路</h3>
<p>对于该题，如果只是删除链表中间的结点，是十分简单，只需要将<code>prev-&gt;next = cur-&gt;next</code>即可</p>
<p>但是由于该链表没有特殊的头结点，因此删除头结点会显得异常麻烦，因此这里可以引入哨兵结点的方法去解决该问题，既然题目没有特殊头结点，那我们自己给它生成一个就可以了。</p>
<p>我自己做的时候不懂哨兵结点的方法，所以我采用的方法是首先对链表的头结点进行&quot;特殊对待&quot;,一直遍历头结点，直到它为空或者不需要删除位置。</p>
<h3 id="实现代码1"><a class="header-anchor" href="#实现代码1"> </a>实现代码1</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//确保头结点不是要删除的结点</span></span><br><span class="line">        <span class="keyword">while</span>(head &amp;&amp; head-&gt;val == val)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* prev = head;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val == val)&#123;</span><br><span class="line">                prev-&gt;next = cur-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prev = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="哨兵结点做法"><a class="header-anchor" href="#哨兵结点做法"> </a>哨兵结点做法</h4>
<blockquote>
<p>哨兵节点广泛应用于树和链表中，如伪头、伪尾、标记等，它们是纯功能的，通常不保存任何数据，其主要目的是使链表标准化，如使链表永不为空、永不无头、简化插入和删除。  –<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-linked-list-elements/solution/yi-chu-lian-biao-yuan-su-by-leetcode/">leetcode官方解法</a></p>
</blockquote>
<p>这里我们可以初始化一个哨兵结点，让哨兵结点的<code>next</code>指向<code>head</code></p>
<h3 id="实现代码2"><a class="header-anchor" href="#实现代码2"> </a>实现代码2</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* sentinel = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        sentinel-&gt;next = head;</span><br><span class="line">        ListNode* prev = sentinel;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* toDelete = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val == val)&#123;</span><br><span class="line">                prev-&gt;next = cur-&gt;next;</span><br><span class="line">                toDelete = cur;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prev = prev-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(toDelete)&#123;</span><br><span class="line">                <span class="keyword">delete</span> toDelete;</span><br><span class="line">                toDelete = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* res = sentinel-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> sentinel;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="leetcode206——反转链表"><a class="header-anchor" href="#leetcode206——反转链表"> </a>leetcode206——反转链表</h2>
<h3 id="题目-v76"><a class="header-anchor" href="#题目-v76"> </a>题目</h3>
<p>反转一个单链表。</p>
<p>示例:</p>
<blockquote>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
</blockquote>
<h3 id="解题思路-v59"><a class="header-anchor" href="#解题思路-v59"> </a>解题思路</h3>
<p>对于迭代的方法，主要需要考虑在将当前结点指向前一个节点时，需要保存下一个结点。</p>
<p>对于递归实现的代码，主要思路是依次改变当前结点的下一个结点指向当前指针</p>
<h3 id="迭代实现代码"><a class="header-anchor" href="#迭代实现代码"> </a>迭代实现代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        ListNode* temp;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            temp = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = pre;</span><br><span class="line">            pre = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="递归实现代码——效率低下版"><a class="header-anchor" href="#递归实现代码——效率低下版"> </a>递归实现代码——效率低下版</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* cur = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        ListNode* temp = cur;</span><br><span class="line">        <span class="keyword">while</span>(temp-&gt;next !=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="递归实现代码——改进版"><a class="header-anchor" href="#递归实现代码——改进版"> </a>递归实现代码——改进版</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* p = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="leetcode234——回文链表"><a class="header-anchor" href="#leetcode234——回文链表"> </a>leetcode234——回文链表</h2>
<h3 id="题目-v77"><a class="header-anchor" href="#题目-v77"> </a>题目</h3>
<p>请判断一个链表是否为回文链表。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: 1-&gt;2<br>
输出: false</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: 1-&gt;2-&gt;2-&gt;1<br>
输出: true</p>
</blockquote>
<h3 id="解题思路-v60"><a class="header-anchor" href="#解题思路-v60"> </a>解题思路</h3>
<p>判断回文的一个思路是两个指针，一头一尾向中间边移动边比较，但是对于链表去正向访问和反向访问都挺麻烦的，有一个办法是将链表遍历一遍，储存到数组中，再进行双指针遍历。这种思路时间复杂度是O(N),空间复杂度也是O(N)</p>
<p>另一种思路是将链表分成两半，这通过快慢指针实现，再将后半部分的链表反转，再两边同时遍历；这样实现的空间复杂度为O(1),时间复杂度为O(N)</p>
<h3 id="双指针解题代码"><a class="header-anchor" href="#双指针解题代码"> </a>双指针解题代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">       vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">       <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">           v.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">           head = head-&gt;next;</span><br><span class="line">           size++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size/<span class="number">2</span>; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(v[i] != v[size<span class="number">-1</span>-i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="快慢指针-反转链表解题代码"><a class="header-anchor" href="#快慢指针-反转链表解题代码"> </a>快慢指针+反转链表解题代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="comment">//先将链表分成两部分</span></span><br><span class="line">       ListNode* endOfFirst = <span class="built_in">endOfFirstPart</span>(head);</span><br><span class="line">       <span class="comment">//将后半部分反转</span></span><br><span class="line">       ListNode* p1 = head;</span><br><span class="line">       ListNode* p2 = <span class="built_in">reverseList</span>(endOfFirst-&gt;next);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//比较回文, p1的长度 &gt;= p2的长度</span></span><br><span class="line">       <span class="keyword">while</span>(p2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(p1-&gt;val != p2-&gt;val)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           p1 = p1-&gt;next;</span><br><span class="line">           p2 = p2-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">endOfFirstPart</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* temp;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            temp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="237-删除链表中的节点"><a class="header-anchor" href="#237-删除链表中的节点"> </a>237. 删除链表中的节点</h2>
<h3 id="题目-v78"><a class="header-anchor" href="#题目-v78"> </a>题目</h3>
<p>请编写一个函数，使其可以删除某个链表中给定的**（非末尾）<strong>节点。传入函数的</strong>唯一参数**为 要被删除的节点。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：head = [4,5,1,9], node = 5<br>
输出：[4,1,9]<br>
解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：head = [4,5,1,9], node = 1<br>
输出：[4,5,9]<br>
解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p>
</blockquote>
<h3 id="解题思路-v61"><a class="header-anchor" href="#解题思路-v61"> </a>解题思路</h3>
<p>常规方法就是修改上一个next为当前结点的下一个结点，但是只传进来的当前结点，此方法行不通。因此可以将后面的结点覆盖到当前结点，这里只需修改当前结点的值和next与下一个结点的next一致就可以了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//由于不知道上一个节点，所以不能简单的取出该结点，因此可以将后面的结点补上</span></span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="876-链表的中间结点"><a class="header-anchor" href="#876-链表的中间结点"> </a>876. 链表的中间结点</h2>
<h3 id="题目-v79"><a class="header-anchor" href="#题目-v79"> </a>题目</h3>
<p>给定一个头结点为 head 的非空单链表，返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<p>输入：[1,2,3,4,5]<br>
输出：3</p>
<p>输入：[1,2,3,4,5,6]<br>
输出：4</p>
<h3 id="解题思路-v62"><a class="header-anchor" href="#解题思路-v62"> </a>解题思路</h3>
<p>这题显然用快慢指针，快指针走到末尾的时候，慢指针到中间位置，但是细节的地方具体是如何处理返回哪个结点需要注意一下</p>
<p>我们开始的时候，快慢指针都指向头指针，即第一个结点。</p>
<p>快指针走的位置为奇数位，即1，3，5，7…</p>
<p>可以通过画图发现，如果链表长度为奇数，那么快指针走到末尾的时候，下一个指针为空，此时慢指针刚好指向中间</p>
<p>如果链表长度为偶数，那么快指针走到末尾时，下一个结点还是存在的，最后一个偶数结点，因此需要<code>fast-&gt;next-&gt;next</code>才为空，而此时，慢指针走的位置其实和奇数链表长度的情况是一致的，但是题目要求返回中间的第二个节点，因此就返回<code>slow-&gt;next</code></p>
<h3 id="解题代码-v53"><a class="header-anchor" href="#解题代码-v53"> </a>解题代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="再次优化"><a class="header-anchor" href="#再次优化"> </a>再次优化</h3>
<p>这里对于快指针的判断，如果改成对当前fast指针和fast-&gt;next的结点两个判不为空进行循环，可以省去上面那种方法的条件判断</p>
<h3 id="代码实现-v5"><a class="header-anchor" href="#代码实现-v5"> </a>代码实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1290-二进制链表转整数"><a class="header-anchor" href="#1290-二进制链表转整数"> </a>1290. 二进制链表转整数</h2>
<h3 id="题目-v80"><a class="header-anchor" href="#题目-v80"> </a>题目</h3>
<p>给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。</p>
<p>请你返回该链表所表示数字的 十进制值 。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：head = [1,0,1]<br>
输出：5<br>
解释：二进制数 (101) 转化为十进制数 (5)</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：head = [0]<br>
输出：0</p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入：head = [1]<br>
输出：1</p>
</blockquote>
<p>示例 4：</p>
<blockquote>
<p>输入：head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]<br>
输出：18880</p>
</blockquote>
<p>示例 5：</p>
<blockquote>
<p>输入：head = [0,0]<br>
输出：0</p>
</blockquote>
<h3 id="解题思路-v63"><a class="header-anchor" href="#解题思路-v63"> </a>解题思路</h3>
<p>这题就是位运算和遍历链表</p>
<h3 id="解题代码-v54"><a class="header-anchor" href="#解题代码-v54"> </a>解题代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDecimalValue</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            result &lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            result+= head-&gt;val;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-06-从尾到头打印链表"><a class="header-anchor" href="#剑指-Offer-06-从尾到头打印链表"> </a>剑指 Offer 06. 从尾到头打印链表</h2>
<h3 id="题目-v81"><a class="header-anchor" href="#题目-v81"> </a>题目</h3>
<p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：head = [1,3,2]<br>
输出：[2,3,1]</p>
</blockquote>
<h3 id="解题思路-v64"><a class="header-anchor" href="#解题思路-v64"> </a>解题思路</h3>
<p>这题它要逆序导入到数组当中去，最先想到用递归的方法；然后又想到用栈的方法（时间复杂度为O(N),空间复杂度为O(N)）；然后又想到先把链表反转过来，时间复杂度需要O(N)，空间复杂度需要O(1)，然后再遍历一遍导入到数组中去，时间复杂度为O(N)，空间复杂度为O(1)</p>
<h3 id="栈实现代码"><a class="header-anchor" href="#栈实现代码"> </a>栈实现代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;s;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(s.<span class="built_in">top</span>());</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="反转链表实现"><a class="header-anchor" href="#反转链表实现"> </a>反转链表实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        head = <span class="built_in">reverseList</span>(head);</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* temp;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            temp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-18-删除链表的节点"><a class="header-anchor" href="#剑指-Offer-18-删除链表的节点"> </a>剑指 Offer 18. 删除链表的节点</h2>
<h3 id="题目-v82"><a class="header-anchor" href="#题目-v82"> </a>题目</h3>
<p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: head = [4,5,1,9], val = 5<br>
输出: [4,1,9]<br>
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: head = [4,5,1,9], val = 1<br>
输出: [4,5,9]<br>
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p>
</blockquote>
<h3 id="解题思路-v65"><a class="header-anchor" href="#解题思路-v65"> </a>解题思路</h3>
<p>这题添加一个头结点，就变成了正常删除链表结点</p>
<h3 id="解题代码-v55"><a class="header-anchor" href="#解题代码-v55"> </a>解题代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode* ahead = prev;</span><br><span class="line">        prev-&gt;next = head;</span><br><span class="line">        <span class="keyword">while</span>(prev-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prev-&gt;next-&gt;val == val)&#123;</span><br><span class="line">                <span class="comment">//删除</span></span><br><span class="line">                prev-&gt;next = prev-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">return</span> ahead-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ahead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-22-链表中倒数第k个节点"><a class="header-anchor" href="#剑指-Offer-22-链表中倒数第k个节点"> </a>剑指 Offer 22. 链表中倒数第k个节点</h2>
<h3 id="题目-v83"><a class="header-anchor" href="#题目-v83"> </a>题目</h3>
<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<blockquote>
<p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.<br>
返回链表 4-&gt;5.</p>
</blockquote>
<h3 id="解题思路-v66"><a class="header-anchor" href="#解题思路-v66"> </a>解题思路</h3>
<p>最直接的想法就是先遍历一遍获得链表的长度，再根据数学关系推出第(n-k)个位所求结点</p>
<p>另一种思路是通过双指针，一个指针先走k个结点，拉开距离k，再同时向前前进1步，当前头的指针到达末尾时，后头的指针到达倒数第k个</p>
<h3 id="遍历法解题代码"><a class="header-anchor" href="#遍历法解题代码"> </a>遍历法解题代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">        ListNode* dum = head;</span><br><span class="line">        <span class="keyword">while</span>(dum != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            size++;</span><br><span class="line">            dum = dum-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> pos = size - k;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        dum = head;</span><br><span class="line">        <span class="keyword">while</span>(count != pos)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            dum = dum-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="双指针做法"><a class="header-anchor" href="#双指针做法"> </a>双指针做法</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* front = head;</span><br><span class="line">        ListNode* back = head;</span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">            front = front-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(front != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            front = front-&gt;next;</span><br><span class="line">            back = back-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> back;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="学习借鉴"><a class="header-anchor" href="#学习借鉴"> </a>学习借鉴</h3>
<p>在看题解的时候，发现有篇归纳链表说得不错,<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/solution/yi-wen-gao-ding-chang-jian-de-lian-biao-wen-ti-h-3/">链表总结 作者Time-Limit</a></p>
<p>其中有一句话指出了链表的缺点劣势</p>
<blockquote>
<p>无法高效获取长度，无法根据偏移快速访问元素，是链表的两个劣势。</p>
</blockquote>
<blockquote>
<p>双指针并不是固定的公式，而是一种思维方式</p>
</blockquote>
<blockquote>
<p>双指针可解决的问题:<br>
获取倒数第k个元素，获取中间位置的元素，判断链表是否存在环，判断环的长度等和长度与位置有关的问题。</p>
</blockquote>
<p>我觉得这两句话总结不错，故此引用</p>
<h2 id="剑指-Offer-52-两个链表的第一个公共节点"><a class="header-anchor" href="#剑指-Offer-52-两个链表的第一个公共节点"> </a>剑指 Offer 52. 两个链表的第一个公共节点</h2>
<h3 id="题目-v84"><a class="header-anchor" href="#题目-v84"> </a>题目</h3>
<p>该题与 leetcode160——相交链表一样</p>
<h3 id="解题思路-v67"><a class="header-anchor" href="#解题思路-v67"> </a>解题思路</h3>
<p>采用双指针方法，leetcode有人代码写得简洁，因此改写了一下</p>
<h3 id="解题代码-v56"><a class="header-anchor" href="#解题代码-v56"> </a>解题代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* node1 = headA;</span><br><span class="line">        ListNode* node2 = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(node1 != node2)&#123;</span><br><span class="line">            node1 = node1==<span class="literal">nullptr</span>?headB:node1-&gt;next;</span><br><span class="line">            node2 = node2==<span class="literal">nullptr</span>?headA:node2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="面试题-02-01-移除重复节点"><a class="header-anchor" href="#面试题-02-01-移除重复节点"> </a>面试题 02.01. 移除重复节点</h2>
<h3 id="题目-v85"><a class="header-anchor" href="#题目-v85"> </a>题目</h3>
<p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p>
<p>示例1:</p>
<blockquote>
<p>输入：[1, 2, 3, 3, 2, 1]<br>
输出：[1, 2, 3]</p>
</blockquote>
<p>示例2:</p>
<blockquote>
<p>输入：[1, 1, 1, 1, 2]<br>
输出：[1, 2]</p>
</blockquote>
<h3 id="解题思路-v68"><a class="header-anchor" href="#解题思路-v68"> </a>解题思路</h3>
<p>这题可以使用集合(set)来判断是否有重复出现的元素，注意边界条件，这种解法时间复杂度为O(N)，空间复杂度为O(N)</p>
<h3 id="集合解法"><a class="header-anchor" href="#集合解法"> </a>集合解法</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeDuplicateNodes</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        ListNode* prev = head;</span><br><span class="line">        ListNode* cur;</span><br><span class="line">        <span class="keyword">if</span>(head)&#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(head-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(prev != <span class="literal">nullptr</span> &amp;&amp; prev-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cur = prev-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">find</span>(cur-&gt;val) == s.<span class="built_in">end</span>())&#123;</span><br><span class="line">                s.<span class="built_in">insert</span>(cur-&gt;val);</span><br><span class="line">                prev = prev-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prev-&gt;next = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="面试题-02-02-返回倒数第-k-个节点"><a class="header-anchor" href="#面试题-02-02-返回倒数第-k-个节点"> </a>面试题 02.02. 返回倒数第 k 个节点</h2>
<h3 id="题目-v86"><a class="header-anchor" href="#题目-v86"> </a>题目</h3>
<p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</p>
<p>注意：本题相对原题稍作改动</p>
<p>示例：</p>
<blockquote>
<p>输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k = 2<br>
输出： 4</p>
</blockquote>
<p>说明：<br>
给定的 k 保证是有效的。</p>
<h3 id="解题思路-v69"><a class="header-anchor" href="#解题思路-v69"> </a>解题思路</h3>
<p>同剑指 Offer 22. 链表中倒数第k个节点</p>
<h3 id="解题代码-v57"><a class="header-anchor" href="#解题代码-v57"> </a>解题代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthToLast</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* front = head;</span><br><span class="line">        ListNode* back = head;</span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">            front = front-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(front != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            back = back-&gt;next;</span><br><span class="line">            front = front-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> back-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="面试题-02-03-删除中间节点"><a class="header-anchor" href="#面试题-02-03-删除中间节点"> </a>面试题 02.03. 删除中间节点</h2>
<h3 id="题目-v87"><a class="header-anchor" href="#题目-v87"> </a>题目</h3>
<p>实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。</p>
<p>示例：</p>
<blockquote>
<p>输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c<br>
结果：不返回任何数据，但该链表变为a-&gt;b-&gt;d-&gt;e-&gt;f</p>
</blockquote>
<h3 id="解题思路-v70"><a class="header-anchor" href="#解题思路-v70"> </a>解题思路</h3>
<p>同237. 删除链表中的节点</p>
<h2 id="面试题-02-06-回文链表"><a class="header-anchor" href="#面试题-02-06-回文链表"> </a>面试题 02.06. 回文链表</h2>
<h3 id="解题思路-v71"><a class="header-anchor" href="#解题思路-v71"> </a>解题思路</h3>
<p>同 leetcode234——回文链表</p>
<h3 id="快慢指针寻找中间节点学习总结"><a class="header-anchor" href="#快慢指针寻找中间节点学习总结"> </a>快慢指针寻找中间节点学习总结</h3>
<p>在不同的题目中，我发现通过快慢指针来寻找一个链表的中间结点位置。初始情况是相同的，即快慢指针都指向头结点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListNode* fast = head;</span><br><span class="line">ListNode* slow = head;</span><br></pre></td></tr></table></figure>
<p>但是到达慢指针到达中点的位置，随着对于快指针(<code>fast</code>)判断条件不同而不同</p>
<p>例如在leetcode234——回文链表中，通过判断快指针的下一个和下一个的下一个不为空</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    slow = slow-&gt;next;</span><br><span class="line">    fast = fast-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在876. 链表的中间结点中，通过判断快指针本身和快指针下一个不为空来确定中间位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    fast = fast-&gt;next-&gt;next;</span><br><span class="line">    slow = slow-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两种判断条件最终导致慢指针的位置有什么不同呢？</p>
<p>通过画个图发现</p>
<p><a href="%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8.jpg">快慢指针奇偶链表</a></p>
<p>两种方法对于链表长度为奇数的时候，慢指针都指向中间结点位置</p>
<p>而对于链表长度为偶数时候，慢指针位置不同。这是由于偶数长度时候，中间结点有两个。</p>
<p>因此可以这样记，由于<code>fast != nullptr &amp;&amp; fast-&gt;next != nullptr</code>条件较弱，所以慢指针可以多走，指向靠右边的结点。由于<code>fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr</code>条件较强，因此慢指针少走，所以指向靠左边的位置。</p>
<p>当然，其实两种方法都可以转换，比如876. 链表的中间结点写的两种写法，虽然题目要求是返回靠右的结点，但是我第一次解题的时候，判断条件为<code>fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr</code>，导致慢结点对于奇数和偶数情况不统一。这时候可以通过判断<code>fast</code>对于<code>null</code>的距离来确定是奇数情况还是偶数情况</p>
<p>还存在一种写法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(fast-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    fast = fast-&gt;next;</span><br><span class="line">    slow = slow-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(fast-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法又和上面两种有什么区别呢？可以看到<code>fast</code>能走就走，<code>slow</code>也是能走就走。因此可以想到，<code>slow</code>如果在奇数长度链表中，处于中间位置；而在偶数长度链表中，处于中间靠右的位置。这种写法和<code>fast != nullptr &amp;&amp; fast-&gt;next != nullptr</code>的结果区别在于快指针最终的位置。</p>
<p>在分两步while语句中嵌套一个if语句这种方法，能够保证fast在最后指向的是最后一个结点，而不是空。</p>
<p>在while语句中直接把fast的当前位置和下一个位置判断不为空了，但是没有考虑fast将要移动到的那个位置是否为空，因此fast最终是空。</p>
<h2 id="面试题-02-07-链表相交"><a class="header-anchor" href="#面试题-02-07-链表相交"> </a>面试题 02.07. 链表相交</h2>
<h3 id="题目-v88"><a class="header-anchor" href="#题目-v88"> </a>题目</h3>
<p>同leetcode160——相交链表和剑指 Offer 52. 两个链表的第一个公共节点</p>
<hr>
<h2 id="2-两数相加"><a class="header-anchor" href="#2-两数相加"> </a>2. 两数相加</h2>
<h3 id="题目-v89"><a class="header-anchor" href="#题目-v89"> </a>题目</h3>
<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例：</p>
<blockquote>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>
输出：7 -&gt; 0 -&gt; 8<br>
原因：342 + 465 = 807</p>
</blockquote>
<h3 id="解题思路-v72"><a class="header-anchor" href="#解题思路-v72"> </a>解题思路</h3>
<p>开始的时候的思路是分别遍历两遍，读取每个链表的数字，再加起来，然后再生成一条新的链表返回，但是这种做法无论是<code>int</code>还是<code>long long</code>都装不下大数字。</p>
<p>后来想到直接按顺序遍历链表，只需要记录每一位是否进位，同时要注意如果最后有进位但是两个链表都为空的情况需要考虑下去</p>
<h4 id="错误解题"><a class="header-anchor" href="#错误解题"> </a>错误解题</h4>
<p>Line 48: Char 20: runtime error: signed integer overflow: 1000000000000000000 * 10 cannot be represented in type ‘long long’ (solution.cpp)</p>
<p>SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:57:20</p>
<p>最后执行的输入：</p>
<p>[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]</p>
<p>[5,6,4]</p>
<p>可以看到溢出了</p>
<p>错误实现思路代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先依次遍历两个链表取出数字</span></span><br><span class="line">        <span class="comment">//相加后生成新的链表</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> num1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            num1 += (l1-&gt;val) * <span class="built_in">pow</span>(<span class="number">10</span>,count);</span><br><span class="line">            count++;</span><br><span class="line">            l1 = l1-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            num2 += (l2-&gt;val) * <span class="built_in">pow</span>(<span class="number">10</span>,count);</span><br><span class="line">            count++;</span><br><span class="line">            l2 = l2-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> result = num1+num2;</span><br><span class="line">        ListNode* res = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode* cur = res;</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="number">0</span>)&#123;</span><br><span class="line">            res-&gt;val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(result)&#123;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">            cur-&gt;next-&gt;val = result%<span class="number">10</span>;</span><br><span class="line">            result/=<span class="number">10</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">pow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> base, <span class="type">long</span> <span class="type">long</span> index)</span></span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>; i&lt;index; i++)&#123;</span><br><span class="line">            result *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="正确解法"><a class="header-anchor" href="#正确解法"> </a>正确解法</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//边遍历边添加，直到两个都为空</span></span><br><span class="line">        ListNode* res = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode* cur = res;</span><br><span class="line">        <span class="type">int</span> num1,num2;</span><br><span class="line">        <span class="type">bool</span> overflow = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> asum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 || l2)&#123;</span><br><span class="line">            num1 = l1==<span class="literal">nullptr</span>?<span class="number">0</span>:l1-&gt;val;</span><br><span class="line">            num2 = l2==<span class="literal">nullptr</span>?<span class="number">0</span>:l2-&gt;val;</span><br><span class="line">            asum = overflow?num1+num2+<span class="number">1</span>:num1+num2;</span><br><span class="line">            <span class="keyword">if</span>(asum&gt;<span class="number">9</span>)&#123;</span><br><span class="line">                asum %= <span class="number">10</span>;</span><br><span class="line">                overflow = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                overflow = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">            cur-&gt;next-&gt;val = asum;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l1) l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2) l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(overflow)&#123;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">            cur-&gt;next-&gt;val = <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="19-删除链表的倒数第N个节点"><a class="header-anchor" href="#19-删除链表的倒数第N个节点"> </a>19. 删除链表的倒数第N个节点</h2>
<h3 id="题目-v90"><a class="header-anchor" href="#题目-v90"> </a>题目</h3>
<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<p>示例：</p>
<blockquote>
<p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>
当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p>
</blockquote>
<p>说明：</p>
<p>给定的 n 保证是有效的。</p>
<p>进阶：</p>
<p>你能尝试使用一趟扫描实现吗？</p>
<h3 id="解题思路-v73"><a class="header-anchor" href="#解题思路-v73"> </a>解题思路</h3>
<p>这题的做法就是将leetcode203——移除链表元素和剑指 Offer 22. 链表中倒数第k个节点两道题结合在一起，声明一个哨兵节点放在头结点<code>head</code>之前，然后将两个指针拉开距离<code>n</code>，记住最后是返回最初哨兵节点的下一给节点<code>dum-&gt;next</code>，而不是直接返回<code>head</code>.因为如果倒数第n个节点是head话，会出错。因此需要声明一个<code>dum</code>去记录开始定义的哨兵节点的地址</p>
<blockquote>
<p>在对链表进行操作时，一种常用的技巧是添加一个哑节点（dummy node），它的<code>next</code>指针指向链表的头节点。</p>
</blockquote>
<p>在第一种解法时，prevHead的作用和back的作用重复了，如果将prevHead去掉，将back指向dummy节点，可以简化代码</p>
<h3 id="解题代码1-v9"><a class="header-anchor" href="#解题代码1-v9"> </a>解题代码1</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* front = head;</span><br><span class="line">        ListNode* back = head;</span><br><span class="line">        ListNode* prevHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        prevHead-&gt;next = head;</span><br><span class="line">        ListNode* dum = prevHead;</span><br><span class="line">        <span class="comment">//先走n个节点</span></span><br><span class="line">        <span class="keyword">while</span>(n--) front=front-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(front != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            front = front-&gt;next;</span><br><span class="line">            back = back-&gt;next;</span><br><span class="line">            prevHead = prevHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        prevHead-&gt;next = back-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dum-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="优化代码"><a class="header-anchor" href="#优化代码"> </a>优化代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* front = head;</span><br><span class="line">        ListNode* back = dummy;</span><br><span class="line">        <span class="comment">//先走n个节点</span></span><br><span class="line">        <span class="keyword">while</span>(n--) front=front-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(front != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            front = front-&gt;next;</span><br><span class="line">            back = back-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        back-&gt;next = back-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="24-两两交换链表中的节点"><a class="header-anchor" href="#24-两两交换链表中的节点"> </a>24. 两两交换链表中的节点</h2>
<h3 id="题目-v91"><a class="header-anchor" href="#题目-v91"> </a>题目</h3>
<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：head = [1,2,3,4]<br>
输出：[2,1,4,3]</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：head = []<br>
输出：[]</p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入：head = [1]<br>
输出：[1]</p>
</blockquote>
<p>提示：</p>
<p>链表中节点的数目在范围 [0, 100] 内</p>
<p>0 &lt;= Node.val &lt;= 100</p>
<h3 id="解题思路1-v10"><a class="header-anchor" href="#解题思路1-v10"> </a>解题思路1</h3>
<p>仔细观察可以发现，如果有四个节点存在，则在两两交换后，第一个节点指向第四个结点，因此不能只两个两个看，得四个四个看。根据这个发现，进行分类讨论，即有四个结点、剩下三个结点、剩下两个结点的三种情况。</p>
<p>对于有大于四个结点的情况，只需要将第二个结点指向第一个，第一个结点指向第四个，就完成了前两个的交换，然后向后偏移两位。</p>
<p>对于三个结点情况，交换前两个的同时，将第一个结点指向链表末尾，即第三个结点，即可完成操作</p>
<p>对于两个结点情况，只需要交换前两个结点，并将第一个结点指向空结点即可。</p>
<h3 id="解题代码1-v10"><a class="header-anchor" href="#解题代码1-v10"> </a>解题代码1</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next ==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* privot = head-&gt;next;</span><br><span class="line">        ListNode* first = head;</span><br><span class="line">        ListNode* second = head-&gt;next;</span><br><span class="line">        ListNode* third;</span><br><span class="line">        ListNode* fourth;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(second != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(second-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                third = second-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(third != <span class="literal">nullptr</span> &amp;&amp; third-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                fourth = third-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进行交换</span></span><br><span class="line">            <span class="keyword">if</span>(fourth != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                second-&gt;next  = first;</span><br><span class="line">                first-&gt;next = fourth;</span><br><span class="line">                first = third;</span><br><span class="line">                second = fourth;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(third != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                second-&gt;next = first;</span><br><span class="line">                first-&gt;next = third;</span><br><span class="line">                third-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                first = <span class="literal">nullptr</span>;</span><br><span class="line">                second = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                second-&gt;next = first;</span><br><span class="line">                first-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                first = <span class="literal">nullptr</span>;</span><br><span class="line">                second = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            third = <span class="literal">nullptr</span>;</span><br><span class="line">            fourth = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> privot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v24"><a class="header-anchor" href="#解题思路2-v24"> </a>解题思路2</h3>
<p>利用递归的思想，递归返回的都是已经两两反转后的链表头，而基线是传进来的结点是空结点或者是单个节点。同时注意交换结点的位置以及与已经交换好的链表之间连接的关系</p>
<h3 id="解题代码2-v23"><a class="header-anchor" href="#解题代码2-v23"> </a>解题代码2</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next ==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换两个</span></span><br><span class="line">        ListNode* h = <span class="built_in">swapPairs</span>(head-&gt;next-&gt;next);</span><br><span class="line">        ListNode* hnext = head-&gt;next;</span><br><span class="line">        hnext-&gt;next =head;</span><br><span class="line">        head-&gt;next = h;</span><br><span class="line">        <span class="keyword">return</span> hnext;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路3-v5"><a class="header-anchor" href="#解题思路3-v5"> </a>解题思路3</h3>
<p>通过引入一个哑结点(dummy)，初始化<code>dummy-&gt;next = head</code>。然后通过三个结点之间的交换，达到temp-&gt;node1-&gt;node2  ===&gt; temp-&gt;node2-&gt;node1的效果，而下一轮temp就在node1的位置，即node1-&gt;node3-&gt;node4 ==&gt; node1-&gt;node4-&gt;node3 这样一来就保证了两两之间的交换且能保证与下一对能够正确指向。对于最终条件即<code>temp-&gt;next</code>或<code>temp-&gt;next-&gt;next</code>为空时，遍历结束</p>
<h3 id="解题代码3-v9"><a class="header-anchor" href="#解题代码3-v9"> </a>解题代码3</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* temp = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(temp-&gt;next != <span class="literal">nullptr</span> &amp;&amp; temp-&gt;next-&gt;next !=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">//这里的temp不要想象成一个空结点</span></span><br><span class="line">            <span class="comment">//而是要想象成要交换的两个结点的上一个结点</span></span><br><span class="line">            <span class="comment">//然后保证temp结点与两个结点能够正确交换位置</span></span><br><span class="line">            ListNode* node1 = temp-&gt;next;</span><br><span class="line">            ListNode* node2 = temp-&gt;next-&gt;next;</span><br><span class="line">            temp-&gt;next = node2;</span><br><span class="line">            node1-&gt;next = node2-&gt;next;</span><br><span class="line">            node2-&gt;next = node1;</span><br><span class="line">            temp = node1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="61-旋转链表"><a class="header-anchor" href="#61-旋转链表"> </a>61. 旋转链表</h2>
<h3 id="题目-v92"><a class="header-anchor" href="#题目-v92"> </a>题目</h3>
<p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br>
输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>
解释:<br>
向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>
向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4<br>
输出: 2-&gt;0-&gt;1-&gt;NULL<br>
解释:<br>
向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL<br>
向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL<br>
向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL<br>
向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</p>
</blockquote>
<h3 id="解题思路-v74"><a class="header-anchor" href="#解题思路-v74"> </a>解题思路</h3>
<p>一种解法是遍历两遍链表。第一次遍历获得链表长度，已经到达链表末尾的位置，将末尾结点指向头结点，构成环。第二次遍历找到新链表头的前一个结点位置，保存新链表头，并生成新链表尾。</p>
<h3 id="解题代码-v58"><a class="header-anchor" href="#解题代码-v58"> </a>解题代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先遍历一遍，找得到链表尾部，将其接到头部，并计算链表长度</span></span><br><span class="line">        <span class="comment">//要预测下一个，所以基准情况要先排除掉</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">int</span> length = <span class="number">1</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = head;</span><br><span class="line">        <span class="comment">//找出倒数第k的位置，注意k&gt;=length情况</span></span><br><span class="line">        <span class="type">int</span> pos = length - (k % length);</span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(count != pos)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* newHead = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="82-删除排序链表中的重复元素-II"><a class="header-anchor" href="#82-删除排序链表中的重复元素-II"> </a>82. 删除排序链表中的重复元素 II</h2>
<h3 id="题目-v93"><a class="header-anchor" href="#题目-v93"> </a>题目</h3>
<p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br>
输出: 1-&gt;2-&gt;5</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: 1-&gt;1-&gt;1-&gt;2-&gt;3<br>
输出: 2-&gt;3</p>
</blockquote>
<h3 id="解题思路-v75"><a class="header-anchor" href="#解题思路-v75"> </a>解题思路</h3>
<p>这题与leetcode83——删除排序链表中的重复元素不同在于，这题删除结点有可能需要删除头结点，因此需要定义一个哑结点方便操作。同时当判断当前结点与下一个结点不同，但是当前结点与之前被删除的结点是相同的情况下，因此需要定义一个变量来判断当前结点是否应该被删除</p>
<h3 id="解题代码-v59"><a class="header-anchor" href="#解题代码-v59"> </a>解题代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        prev-&gt;next =head;</span><br><span class="line">        ListNode* dummy = prev;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="type">bool</span> shouldDelete = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val == cur-&gt;next-&gt;val)&#123;</span><br><span class="line">                shouldDelete = <span class="literal">true</span>;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(shouldDelete)&#123;</span><br><span class="line">                    prev-&gt;next = cur-&gt;next;</span><br><span class="line">                    cur = prev-&gt;next;</span><br><span class="line">                    shouldDelete = <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cur = cur-&gt;next;</span><br><span class="line">                    prev = prev-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(shouldDelete)&#123;</span><br><span class="line">            prev-&gt;next = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="86-分隔链表"><a class="header-anchor" href="#86-分隔链表"> </a>86. 分隔链表</h2>
<h3 id="题目-v94"><a class="header-anchor" href="#题目-v94"> </a>题目</h3>
<p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</p>
<p>你应当保留两个分区中每个节点的初始相对位置。</p>
<p>示例:</p>
<blockquote>
<p>输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>
输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p>
</blockquote>
<h3 id="解题思路1-v11"><a class="header-anchor" href="#解题思路1-v11"> </a>解题思路1</h3>
<p>这题开始没有看懂，后来看了题解才大概明白。这里借用官方题解的图片</p>
<p><a href="%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8%E6%84%8F%E6%80%9D.png">分割链表意思</a></p>
<p>这题的意思就是将链表分成<strong>两部分</strong>(例如图中JOINT点)，第一部分是所有结点都小于<code>x</code>的值，第二部分的所有结点的值都是大于等于<code>x</code>的值。题目不要求整个链表是排序的，也不要求这两部分各自内部是排序的，因此只要将大小关系分开，同时保证原先链表的相对位置就行。</p>
<p>按照这个思路，有一种简单做法就是声明两个链表，一个存放小于<code>x</code>值的，一个存放大于等于<code>x</code>的值，同时遍历原先链表。最终将两个链表拼接起来即可</p>
<h3 id="解题代码1-v11"><a class="header-anchor" href="#解题代码1-v11"> </a>解题代码1</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode* little = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode* bigger = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line"></span><br><span class="line">        ListNode* lnode = little;</span><br><span class="line">        ListNode* bnode = bigger;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val &lt; x)&#123;</span><br><span class="line">                lnode-&gt;next = head;</span><br><span class="line">                lnode = lnode-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                bnode-&gt;next = head;</span><br><span class="line">                bnode = bnode-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        lnode-&gt;next = bigger-&gt;next;</span><br><span class="line">        bnode-&gt;next =<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> little-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v25"><a class="header-anchor" href="#解题思路2-v25"> </a>解题思路2</h3>
<p>如果不用哑结点的话，也可以操作。但是思想一致的，即找到大于等于<code>x</code>的头结点和找到小于<code>x</code>的头结点，并在最后进行拼接操作</p>
<h3 id="解题代码2-v24"><a class="header-anchor" href="#解题代码2-v24"> </a>解题代码2</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不用哑结点做法</span></span><br><span class="line">        ListNode* biggerHead = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* littleHead = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* bnode = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* lnode = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val &lt; x)&#123;</span><br><span class="line">                <span class="keyword">if</span>(littleHead == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    littleHead = head;</span><br><span class="line">                    lnode = littleHead;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    lnode-&gt;next = head;</span><br><span class="line">                    lnode = lnode-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(biggerHead == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    biggerHead = head;</span><br><span class="line">                    bnode = biggerHead;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    bnode-&gt;next = head;</span><br><span class="line">                    bnode = bnode-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拼接</span></span><br><span class="line">        <span class="keyword">if</span>(littleHead== <span class="literal">nullptr</span>) <span class="keyword">return</span> biggerHead;</span><br><span class="line">        <span class="keyword">if</span>(biggerHead == <span class="literal">nullptr</span>) <span class="keyword">return</span> littleHead;</span><br><span class="line">        lnode-&gt;next = biggerHead;</span><br><span class="line">        bnode-&gt;next =<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> littleHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="92-反转链表-II"><a class="header-anchor" href="#92-反转链表-II"> </a>92. 反转链表 II</h2>
<h3 id="题目-v95"><a class="header-anchor" href="#题目-v95"> </a>题目</h3>
<p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>
<p>说明:<br>
1 ≤ m ≤ n ≤ 链表长度。</p>
<p>示例:</p>
<blockquote>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4<br>
输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p>
</blockquote>
<h3 id="解题思路-v76"><a class="header-anchor" href="#解题思路-v76"> </a>解题思路</h3>
<p>这题做题思路是在<em>leetcode206——反转链表</em>中迭代做法的思路上进行修改。同时在看题解的时候也发现有两种不同的解法。另一种迭代思想是<em>24. 两两交换链表</em>中的<em>解题思路3</em>的思想，即四个点为一组，只在这四个点内进行中间的两个交换顺序，不会影响到第一个结点和第四个结点的关系。</p>
<p>同时注意，对于第一种解法，需要记录反转链表之前的最后一个结点，以及反转后的子链表的尾部（即第一个被改变的结点），以便内部反转后，能够与原整条链的相应位置对上</p>
<p>对于第二种解法，与两两交换不同的是，<code>prev</code>位置的改变，因为两两交换，交换一次，跳一个结点，因此<code>prev</code>指向<code>node1</code>，即翻转后的子链表的尾结点；而对于本题，<code>prev</code>不会进行移动，一直位于要反转的子链表的上一个结点，因为在两两交换的过程中，后面一个节点并不是简单的移动到相邻结点的上一个，而是要移动到整个子链表的头部。</p>
<h3 id="解题代码1-v12"><a class="header-anchor" href="#解题代码1-v12"> </a>解题代码1</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* temp;</span><br><span class="line">        ListNode* littleTail;</span><br><span class="line">        ListNode* prevLittleHead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将指针cur移到m的位置</span></span><br><span class="line">        <span class="keyword">while</span>(m&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            m--;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        prevLittleHead = prev;</span><br><span class="line">        littleTail = cur;</span><br><span class="line">        <span class="keyword">while</span>(n--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           temp = cur-&gt;next;</span><br><span class="line">           cur-&gt;next = prev;</span><br><span class="line">           prev = cur;</span><br><span class="line">           cur = temp; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拼接</span></span><br><span class="line">        <span class="comment">//如果m=1，那么prevLittleHead为空</span></span><br><span class="line">        <span class="keyword">if</span>(prevLittleHead != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            prevLittleHead-&gt;next = prev;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head = prev;</span><br><span class="line">        &#125;</span><br><span class="line">        littleTail-&gt;next = cur;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码2-v25"><a class="header-anchor" href="#解题代码2-v25"> </a>解题代码2</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* prev = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//要翻转的子链表的开头</span></span><br><span class="line">        ListNode* node1 = prev-&gt;next;</span><br><span class="line">        ListNode* node2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n-m; i++)&#123;</span><br><span class="line">            node2 = node1-&gt;next; </span><br><span class="line">            node1-&gt;next = node2-&gt;next;</span><br><span class="line">            node2-&gt;next = prev-&gt;next;</span><br><span class="line">            prev-&gt;next = node2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="109-有序链表转换二叉搜索树"><a class="header-anchor" href="#109-有序链表转换二叉搜索树"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a></h2>
<h3 id="题目-v96"><a class="header-anchor" href="#题目-v96"> </a>题目</h3>
<p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<p>示例:</p>
<p>给定的有序链表： [-10, -3, 0, 5, 9],</p>
<p>一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</p>
<pre><code>       0
      / \
    -3   9
   /   /
 -10  5
</code></pre>
<h3 id="解题思路1-v12"><a class="header-anchor" href="#解题思路1-v12"> </a>解题思路1</h3>
<p>这题要求高度平衡二叉树，即左右两个子树高度差不超过1，那么将这个链表中间的位置作为根节点就可以实现这种需求。</p>
<p>对于奇数个结点的链表来说，中间结点为根节点；对于偶数个结点的链表，中间的两个任意一个作为根节点都可以。</p>
<p>根据这个思路，最简单的是利用分治递归的思想，类似二分法的思想去实现这种。由于链表不能像数组一样方便获取某个位置的元素，所以就先遍历一遍链表，保存到数组中去。</p>
<h3 id="解题代码1-v13"><a class="header-anchor" href="#解题代码1-v13"> </a>解题代码1</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将链表转换成数组</span></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            vals.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">generateBST</span>(<span class="number">0</span>,vals.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">generateBST</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//这里左闭右开</span></span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(right - left == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(vals[left]);</span><br><span class="line">        <span class="type">int</span> middle = (left+right)/<span class="number">2</span>;</span><br><span class="line">        TreeNode* t = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(vals[middle]);</span><br><span class="line">        t-&gt;left = <span class="built_in">generateBST</span>(left,middle);</span><br><span class="line">        t-&gt;right = <span class="built_in">generateBST</span>(middle+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v26"><a class="header-anchor" href="#解题思路2-v26"> </a>解题思路2</h3>
<p>在解题思路1中，用到了数组来储存，耗费了空间O(N)，所以我们也可以利用快慢结点来获取中间结点。</p>
<p>其中对于中间结点的获取，我认为<code>while(fast != right &amp;&amp; fast-&gt;next != right)&#123;...&#125;</code>和<code>while(fast-&gt;next != right &amp;&amp; fast-&gt;next-&gt;next != right)&#123;...&#125;</code>都是可以的</p>
<p>空间复杂度为O(logn)，为递归过程中栈的空间。</p>
<p>时间复杂度为O(nlogn)</p>
<h3 id="解题代码2-v26"><a class="header-anchor" href="#解题代码2-v26"> </a>解题代码2</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildTree</span>(head,<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(ListNode* left, ListNode* right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == right) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* mid = <span class="built_in">getMiddle</span>(left,right);</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(mid-&gt;val);</span><br><span class="line">        root-&gt;left = <span class="built_in">buildTree</span>(left,mid);</span><br><span class="line">        root-&gt;right = <span class="built_in">buildTree</span>(mid-&gt;next,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">getMiddle</span><span class="params">(ListNode* left, ListNode* right)</span></span>&#123;</span><br><span class="line">        ListNode* fast = left;</span><br><span class="line">        ListNode* slow = left;</span><br><span class="line">        <span class="keyword">while</span>(fast != right &amp;&amp; fast-&gt;next != right)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="138-复制带随机指针的链表"><a class="header-anchor" href="#138-复制带随机指针的链表"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">138. 复制带随机指针的链表</a></h2>
<h3 id="题目-v97"><a class="header-anchor" href="#题目-v97"> </a>题目</h3>
<p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p>
<p>要求返回这个链表的 <strong>深拷贝</strong>。</p>
<p>我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p>
<ul>
<li>val：一个表示 Node.val 的整数。</li>
<li>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。</li>
</ul>
<p>示例 1：</p>
<blockquote>
<p>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]<br>
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</p>
<p><img src="http://algorithm-image.qibinaoe.top/e1.png" alt="复制带随机指针的链表示例1"></p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：head = []<br>
输出：[]<br>
解释：给定的链表为空（空指针），因此返回 null。</p>
</blockquote>
<h3 id="解题思路1-v13"><a class="header-anchor" href="#解题思路1-v13"> </a><strong>解题思路</strong>1</h3>
<p>开始思考能不能遍历一次就生成整个完整链表呢？由于可能存在当前遍历的结点的random变量还未创建出来，因而不能指向。所以我想到通过先遍历一遍原链表，同时生成一个新链表。在遍历的同时，通过两个hash表来储存每个结点对应的位置，从而在第二次遍历的时候能够快速的连接上</p>
<h3 id="解题代码1-v14"><a class="header-anchor" href="#解题代码1-v14"> </a>解题代码1</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        map&lt;Node*,<span class="type">int</span>&gt; oldlocations;</span><br><span class="line">        map&lt;<span class="type">int</span>,Node*&gt; newlocations;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        Node* dummy = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>);</span><br><span class="line">        Node* cur1 = head;</span><br><span class="line">        Node* cur2 = dummy;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cur2-&gt;next = <span class="keyword">new</span> <span class="built_in">Node</span>(cur1-&gt;val);</span><br><span class="line">            oldlocations[cur1] = count;</span><br><span class="line">            newlocations[count] = cur2-&gt;next;</span><br><span class="line"></span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">            cur2 = cur2-&gt;next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = head;</span><br><span class="line">        cur2 = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* temp = cur1-&gt;random;</span><br><span class="line">            cur2-&gt;random = temp == <span class="literal">nullptr</span>?cur2-&gt;random = <span class="literal">nullptr</span>:cur2-&gt;random = newlocations[oldlocations[temp]];</span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">            cur2 = cur2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v27"><a class="header-anchor" href="#解题思路2-v27"> </a>解题思路2</h3>
<p>根据官方的题解的方法。回溯算法的思想大致为：能进则进，不进则退。我们可以将这个链表看做是一张图，其中<code>node-&gt;next</code>是一条道路，而<code>node-&gt;random</code>又是另一条道路。我们可以同时对这两条道路进行递归，从而遍历整张图。</p>
<p>在本题中，不进则退的<strong>退</strong>：体现在当前结点是空结点，不能够再前进。而整个函数结束递归的条件即为<code>node-&gt;next</code>是空了，已经走不下去了，<code>node-&gt;random</code>要么为空要么已经走过了不必要再遍历了。</p>
<h3 id="解题代码2-v27"><a class="header-anchor" href="#解题代码2-v27"> </a>解题代码2</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;Node*, Node*&gt; visitedHash;</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//传入参数 : 旧链表上的结点</span></span><br><span class="line">        <span class="comment">//返回参数 : 新链表上对应旧结点位置的点</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果新链表已经存在该点了，直接返回新链表的该点就可以了</span></span><br><span class="line">        <span class="keyword">if</span>(visitedHash.<span class="built_in">find</span>(head) != visitedHash.<span class="built_in">end</span>()) <span class="keyword">return</span> visitedHash[head];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有新链表还没生成该节点</span></span><br><span class="line">        Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(head-&gt;val);</span><br><span class="line">        <span class="comment">//存入哈希表中</span></span><br><span class="line">        visitedHash[head] = newNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为新的结点设置下一个结点和随机结点</span></span><br><span class="line">        newNode-&gt;next = <span class="built_in">copyRandomList</span>(head-&gt;next);</span><br><span class="line">        newNode-&gt;random = <span class="built_in">copyRandomList</span>(head-&gt;random);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回新节点</span></span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="142-环形链表-II"><a class="header-anchor" href="#142-环形链表-II"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h2>
<h3 id="题目-v98"><a class="header-anchor" href="#题目-v98"> </a>题目</h3>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p>
<p>说明：不允许修改给定的链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="http://algorithm-image.qibinaoe.top/circularlinkedlist.png" alt="img"></p>
<blockquote>
<p>输入：head = [3,2,0,-4], pos = 1<br>
输出：返回索引为 1 的链表节点<br>
解释：链表中有一个环，其尾部连接到第二个节点。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<p><img src="http://algorithm-image.qibinaoe.top/circularlinkedlist_test3.png" alt="img"></p>
<blockquote>
<p>输入：head = [1], pos = -1<br>
输出：返回 null<br>
解释：链表中没有环。</p>
</blockquote>
<h3 id="解题思路-v77"><a class="header-anchor" href="#解题思路-v77"> </a>解题思路</h3>
<p>这道题有两种解法，第一种是之前做的采用floyd判断法，通过快慢指针找到相遇点，然后将其中一个指针放在起点，两个指针同时步长为1前进，直到第一次相遇，即为环的入口。详细看上面的leetcode141——环形链表的解题思路</p>
<p>第二种解法即用一个hash表，如果判断当前结点已经存在表中，同时是第一次判断有存在，返回就可以了，时间复杂度为O(N)，空间复杂度为O(N)</p>
<h3 id="解题代码-v60"><a class="header-anchor" href="#解题代码-v60"> </a>解题代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                fast = head;</span><br><span class="line">                <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="143-重排链表"><a class="header-anchor" href="#143-重排链表"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reorder-list/">143. 重排链表</a></h2>
<h3 id="题目-v99"><a class="header-anchor" href="#题目-v99"> </a>题目</h3>
<p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>
将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>示例 1:</p>
<blockquote>
<p>给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</p>
</blockquote>
<h3 id="解题思路-v78"><a class="header-anchor" href="#解题思路-v78"> </a>解题思路</h3>
<p>比较直接的思想就是把链表中所有的结点都存起来，然后通过下标的关系，来到达前面一个、后面一个的遍历关系。同时注意到，在整个循环遍历后，还需要处理一下链表尾部的关系。</p>
<p>在链表长度为奇数的情况下，中间的结点不会被遍历到，所以要自己加上去。</p>
<p>在链表长度为偶数的情况下，虽然每个链表都已经正确的前后前后的关系连上去，但是新生成的链表尾部不是指向空，所以得处理一下。</p>
<p>在方法的开头，已经将链表长度为0和为1的情况排除了，所以<code>front</code>和<code>back</code>都可以在最后处理的时候，保证不为空。</p>
<h3 id="解题代码-v61"><a class="header-anchor" href="#解题代码-v61"> </a>解题代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        vector&lt;ListNode*&gt; v;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* front = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* back = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>()/<span class="number">2</span>; i++)&#123;</span><br><span class="line">            front = v[i];</span><br><span class="line">            <span class="keyword">if</span>(back != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                back-&gt;next = front;</span><br><span class="line">            &#125;</span><br><span class="line">            back = v[v.<span class="built_in">size</span>()-i<span class="number">-1</span>];</span><br><span class="line">            front-&gt;next = back;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理尾部情况</span></span><br><span class="line">        <span class="keyword">if</span>(v.<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            ListNode* middle = v[v.<span class="built_in">size</span>()/<span class="number">2</span>];</span><br><span class="line">            back-&gt;next = middle;</span><br><span class="line">            middle-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            back-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v28"><a class="header-anchor" href="#解题思路2-v28"> </a>解题思路2</h3>
<p>可以把结尾的方法统一一下</p>
<h3 id="解题代码2-v28"><a class="header-anchor" href="#解题代码2-v28"> </a>解题代码2</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> ) <span class="keyword">return</span>;</span><br><span class="line">        vector&lt;ListNode*&gt; v;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = v.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            v[i]-&gt;next = v[j];</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">                <span class="comment">//考虑到偶数长度情况</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            v[j]-&gt;next = v[i];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        v[i]-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路3-v6"><a class="header-anchor" href="#解题思路3-v6"> </a>解题思路3</h3>
<p>由于新生成的链表是一前一后的取，因此我们可以把链表看成两部分，将后半部分的链表反转过来，再同时正向遍历合并起来，即可。这样空间复杂度为O(1)</p>
<h3 id="解题代码3-v10"><a class="header-anchor" href="#解题代码3-v10"> </a>解题代码3</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先找到中间结点</span></span><br><span class="line">        <span class="comment">//再翻转右半部链表</span></span><br><span class="line">        <span class="comment">//两个链表合并</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        ListNode* mid = <span class="built_in">findMiddle</span>(head);</span><br><span class="line">        ListNode* secondHead = <span class="built_in">reverseList</span>(mid-&gt;next);</span><br><span class="line">        mid-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* firstHead = head;</span><br><span class="line">        <span class="built_in">mergeList</span>(firstHead,secondHead);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">findMiddle</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* temp;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            temp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mergeList</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        ListNode* temp1;</span><br><span class="line">        ListNode* temp2;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            temp1 = l1-&gt;next;</span><br><span class="line">            temp2 = l2-&gt;next;</span><br><span class="line">            l1-&gt;next = l2;</span><br><span class="line">            l1 = temp1;</span><br><span class="line">            l2-&gt;next = l1;</span><br><span class="line">            l2 = temp2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="147-对链表进行插入排序"><a class="header-anchor" href="#147-对链表进行插入排序"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insertion-sort-list/">147. 对链表进行插入排序</a></h2>
<h3 id="题目-v100"><a class="header-anchor" href="#题目-v100"> </a>题目</h3>
<p>对链表进行插入排序。</p>
<p>插入排序算法：</p>
<p>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。<br>
每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。<br>
重复直到所有输入数据插入完为止。</p>
<h3 id="解题思路-v79"><a class="header-anchor" href="#解题思路-v79"> </a>解题思路</h3>
<p>由于链表与数组不同，对于已排序的前部分，不能逆序比较，随意从第一个元素开始比较。有注意到可能会操作到头结点，因此要设置一个哑结点来保存头节点的上一个。</p>
<p>对于当前要比较的结点，有两种可能。</p>
<p>第一种是该结点不需要移动，那么只需要已排序的部分向后移动一位即可。</p>
<p>第二种情况是该结点需要插入已排序的中间，那么就从头开始遍历查找。同时注意将已排序的最后一个结点的<code>next</code>要先指向<code>cur-&gt;next</code></p>
<h3 id="解题代码-v62"><a class="header-anchor" href="#解题代码-v62"> </a>解题代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> ) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* prev;</span><br><span class="line">        ListNode* cur = head-&gt;next;</span><br><span class="line">        ListNode* lastSorted = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">//寻找该点的应该的位置</span></span><br><span class="line">            <span class="keyword">if</span>(lastSorted-&gt;val &lt;= cur-&gt;val)&#123;</span><br><span class="line">                <span class="comment">//cur不需要移动</span></span><br><span class="line">                lastSorted = lastSorted-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prev = dummy;</span><br><span class="line">                <span class="keyword">while</span>(prev-&gt;next-&gt;val &lt;= cur-&gt;val)&#123;</span><br><span class="line">                    prev = prev-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                lastSorted-&gt;next = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = prev-&gt;next;</span><br><span class="line">                prev-&gt;next = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = lastSorted-&gt;next;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="148-排序链表"><a class="header-anchor" href="#148-排序链表"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a></h2>
<p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p>
<blockquote>
<p>进阶：<br>
你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p>
</blockquote>
<h3 id="解题思路-v80"><a class="header-anchor" href="#解题思路-v80"> </a>解题思路</h3>
<p>这里借鉴官方题解。</p>
<p>插入排序的时间复杂度为O(N<sup>2</sup>)</p>
<p>时间复杂度为O(nlogn)排序算法有归并排序、推排序和快速排序</p>
<p>其中最适合链表排序的算法是归并排序</p>
<p>实现归并排序有两种思路。第一种是自顶向下的递归实现，在递归调用中使用的栈空间的空间复杂度为O(logn)。第二种是自底向上的实现方式,空间复杂度为O(1)</p>
<h3 id="自顶向下代码实现"><a class="header-anchor" href="#自顶向下代码实现"> </a>自顶向下代码实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sortList</span>(head,<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head, ListNode* tail)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next == tail)&#123;</span><br><span class="line">            head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//寻找中点</span></span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != tail &amp;&amp; fast-&gt;next != tail)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分治</span></span><br><span class="line">        ListNode* mid = slow;</span><br><span class="line">        ListNode* l1 = <span class="built_in">sortList</span>(head,mid);</span><br><span class="line">        ListNode* l2 = <span class="built_in">sortList</span>(mid,tail);</span><br><span class="line">        <span class="comment">//合并</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeList</span>(l1,l2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeList</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt;= l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cur-&gt;next = l1;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cur-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="自底向上代码实现"><a class="header-anchor" href="#自底向上代码实现"> </a>自底向上代码实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//归并排序自底向上</span></span><br><span class="line">        <span class="comment">//先局部有序，1 2 4 8 的顺序</span></span><br><span class="line">        <span class="comment">//局部有序的长度等于或大于链表长度时，即整体有序</span></span><br><span class="line">        <span class="comment">//在某个实现局部有序时</span></span><br><span class="line">        <span class="comment">//需要先找到两条链表，分割出来，同时保留这两条链表后的链表</span></span><br><span class="line">        <span class="comment">//将两条链表合并</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取链表长度</span></span><br><span class="line">        <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">        ListNode* node = head;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> subLength = <span class="number">1</span>; subLength &lt; size;subLength &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            ListNode* prev = dummy;</span><br><span class="line">            ListNode* cur = dummy-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="comment">//获取第一条链  cur的当前的定义是第一条链的最后一个结点</span></span><br><span class="line">                ListNode* head1 = cur;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; subLength &amp;&amp; cur-&gt;next != <span class="literal">nullptr</span>; i++)&#123;</span><br><span class="line">                    cur = cur-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode* head2 = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                cur = head2;</span><br><span class="line">                <span class="comment">// 获取第二条链 cur的当前定义是第二条链的最后一个结点</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; subLength &amp;&amp; cur != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next != <span class="literal">nullptr</span>; i++)&#123;</span><br><span class="line">                    cur = cur-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode* next = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="comment">//判断是否有第二条链</span></span><br><span class="line">                <span class="keyword">if</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    next = cur-&gt;next;</span><br><span class="line">                    cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev-&gt;next = <span class="built_in">mergeList</span>(head1,head2);</span><br><span class="line">                <span class="keyword">while</span>(prev-&gt;next !=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    prev = prev-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeList</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt;= l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cur-&gt;next = l1;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cur-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="328-奇偶链表"><a class="header-anchor" href="#328-奇偶链表"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/odd-even-linked-list/">328. 奇偶链表</a></h2>
<h3 id="题目-v101"><a class="header-anchor" href="#题目-v101"> </a>题目</h3>
<p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p>
<p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p>
<blockquote>
<p>示例 1:<br>
输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>
输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL<br>
输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</p>
</blockquote>
<p>说明:</p>
<p>应当保持奇数节点和偶数节点的相对顺序。<br>
链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</p>
<h3 id="解题思路-v81"><a class="header-anchor" href="#解题思路-v81"> </a>解题思路</h3>
<p>题目要求时间复杂度为O(N)，空间复杂度O(1)，所以想到的是迭代的方式。一个比较直接的思路就是遍历的同时生成奇数链表和偶数链表，在两个遍历完成后，同时两个链表的结尾都正确设置为空后，将偶数链表接在奇数链表后就可以了。</p>
<h3 id="解题代码-v63"><a class="header-anchor" href="#解题代码-v63"> </a>解题代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* oddHead = head;</span><br><span class="line">        ListNode* evenHead = head-&gt;next;</span><br><span class="line">        ListNode* oddptr = oddHead;</span><br><span class="line">        ListNode* evenptr = evenHead;</span><br><span class="line">        ListNode* node;</span><br><span class="line">        <span class="keyword">while</span>(evenptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            node = evenptr-&gt;next;</span><br><span class="line">            oddptr-&gt;next = node;</span><br><span class="line">            <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">break</span>;</span><br><span class="line">            evenptr-&gt;next = node-&gt;next;</span><br><span class="line">            oddptr = node;</span><br><span class="line">            evenptr = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拼接在一起</span></span><br><span class="line">        oddptr-&gt;next = evenHead;</span><br><span class="line">        <span class="keyword">return</span> oddHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v29"><a class="header-anchor" href="#解题思路2-v29"> </a>解题思路2</h3>
<p>代码还能够进一步变得简洁。可以想到，当遍历到末尾的时候，不要求奇数结点后面指向空，指向最后一个偶数结点也是可以的。因为最后还是需要改变<code>oddptr-&gt;next = evenHead</code></p>
<h3 id="解题代码2-v29"><a class="header-anchor" href="#解题代码2-v29"> </a>解题代码2</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* evenHead = head-&gt;next;</span><br><span class="line">        ListNode* oddptr = head;</span><br><span class="line">        ListNode* evenptr = evenHead;</span><br><span class="line">        <span class="keyword">while</span>(evenptr != <span class="literal">nullptr</span> &amp;&amp; evenptr-&gt;next !=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            oddptr-&gt;next = evenptr-&gt;next;</span><br><span class="line">            oddptr = oddptr-&gt;next;</span><br><span class="line">            evenptr-&gt;next = oddptr-&gt;next;</span><br><span class="line">            evenptr = evenptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拼接在一起</span></span><br><span class="line">        oddptr-&gt;next = evenHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="430-扁平化多级双向链表"><a class="header-anchor" href="#430-扁平化多级双向链表"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/">430. 扁平化多级双向链表</a></h2>
<h3 id="题目-v102"><a class="header-anchor" href="#题目-v102"> </a>题目</h3>
<p>多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</p>
<p>给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。</p>
<p><img src="http://algorithm-image.qibinaoe.top/multilevellinkedlist.png" alt="img"></p>
<p><img src="http://algorithm-image.qibinaoe.top/multilevellinkedlistflattened.png" alt="img"></p>
<h3 id="解题思路-v82"><a class="header-anchor" href="#解题思路-v82"> </a>解题思路</h3>
<p>题目的想表达的意思是，这个链表有很多分支，它只想要一条从头贯穿到底的链表。而我们要做的是将每个结点如果有存在child结点，则把它们移动到主链表中去。此时每个结点只有<code>next</code>和<code>prev</code>是有用的。所有的<code>child</code>都要置为空。而按照<code>child</code>紧放在父节点的后面的顺序。</p>
<p>对于如何实现这道题。考虑到这道题有种递归的味道。即一个问题可以分解成多个相同的小问题：一个结点的next需要扁平化(flatten)，它的child也需要扁平化。根据这个思路，去实现递归。而对于递归的baseline显然是当前结点为空。</p>
<h3 id="解题代码-v64"><a class="header-anchor" href="#解题代码-v64"> </a>解题代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        Node* temp = head-&gt;next;</span><br><span class="line">        Node* result = <span class="built_in">flatten</span>(head-&gt;child);</span><br><span class="line">        head-&gt;child = <span class="literal">nullptr</span>;</span><br><span class="line">        Node* result2;</span><br><span class="line">        <span class="keyword">if</span>(result != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            head-&gt;next = result;</span><br><span class="line">            result-&gt;prev= head;</span><br><span class="line">            <span class="keyword">while</span>(result-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                result = result-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            result2 = <span class="built_in">flatten</span>(temp);</span><br><span class="line">            <span class="keyword">if</span>(result2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                result-&gt;next = result2;</span><br><span class="line">                result2-&gt;prev = result;     </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result2 = <span class="built_in">flatten</span>(temp);</span><br><span class="line">            <span class="keyword">if</span>(result2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                head-&gt;next = result2;</span><br><span class="line">                result2-&gt;prev = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v30"><a class="header-anchor" href="#解题思路2-v30"> </a>解题思路2</h3>
<p>参考官方题解</p>
<p>可以将多级双向链表看成一颗二叉树，即左结点为<code>child</code>，右节点为<code>next</code>。而扁平化操作是对这二叉树进行先序遍历（深度优先）。因此存在递归和迭代两种做法。</p>
<p>对于递归思路</p>
<h3 id="递归解题代码"><a class="header-anchor" href="#递归解题代码"> </a>递归解题代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        Node* dummy = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="built_in">flattenDFS</span>(dummy,head);</span><br><span class="line">        Node* result = dummy-&gt;next;</span><br><span class="line">        dummy-&gt;next-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node* <span class="title">flattenDFS</span><span class="params">(Node* prev, Node* cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span> prev;</span><br><span class="line">        <span class="comment">//将上一个结点和当前结点建立关系</span></span><br><span class="line">        <span class="comment">//这里相当于先序遍历中，访问根节点</span></span><br><span class="line">        <span class="comment">//因为我们把根节点加到的主链表上</span></span><br><span class="line">        prev-&gt;next = cur;</span><br><span class="line">        cur-&gt;prev = prev;</span><br><span class="line">        <span class="comment">//保存右节点，因为如果左节点存在，则右节点会丢掉，所以要先存起来</span></span><br><span class="line">        Node* nextTemp = cur-&gt;next;</span><br><span class="line">        <span class="comment">//访问左子结点,这里访问后，会把左子结点加到了主链表上，同时返回了最后一个结点</span></span><br><span class="line">        Node* tail = <span class="built_in">flattenDFS</span>(cur,cur-&gt;child);</span><br><span class="line">        cur-&gt;child = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//访问右子节点，将它加在tail后</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">flattenDFS</span>(tail,nextTemp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路3-v7"><a class="header-anchor" href="#解题思路3-v7"> </a>解题思路3</h3>
<p>通过迭代的方式完成先序遍历，借助栈</p>
<h3 id="解题代码3-v11"><a class="header-anchor" href="#解题代码3-v11"> </a>解题代码3</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        Node* dummy = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        Node* prev = dummy;</span><br><span class="line">        Node* cur;</span><br><span class="line">        stack&lt;Node*&gt; s;</span><br><span class="line">        s.<span class="built_in">push</span>(head);</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            cur = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//当前根节点加入链表中</span></span><br><span class="line">            prev-&gt;next = cur;</span><br><span class="line">            cur-&gt;prev = prev;</span><br><span class="line">            <span class="comment">//将右节点压栈</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                s.<span class="built_in">push</span>(cur-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将左节点压栈</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;child != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                s.<span class="built_in">push</span>(cur-&gt;child);</span><br><span class="line">                cur-&gt;child = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        Node* result = dummy-&gt;next;</span><br><span class="line">        dummy-&gt;next-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路4-v2"><a class="header-anchor" href="#解题思路4-v2"> </a>解题思路4</h3>
<p>最后还有直接迭代的方法。基本思路就是将一个结点的child结点的那一串接在当前结点，和当前结点的下一个结点之间。这样该结点就完成了它的使命，可以进行下一个结点的遍历</p>
<h3 id="解题代码4-v3"><a class="header-anchor" href="#解题代码4-v3"> </a>解题代码4</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        Node* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            Node* nxt = cur-&gt;next; <span class="comment">//保存下一个结点</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;child != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="comment">//将child结点放在主链表中</span></span><br><span class="line">                Node* curChild = cur-&gt;child;</span><br><span class="line">                cur-&gt;child = <span class="literal">nullptr</span>;</span><br><span class="line">                cur-&gt;next = curChild;</span><br><span class="line">                curChild-&gt;prev = cur;</span><br><span class="line">                <span class="comment">//将这一串child链和原来的nxt拼起来</span></span><br><span class="line">                <span class="keyword">while</span>(curChild != <span class="literal">nullptr</span> &amp;&amp; curChild-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    curChild = curChild-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nxt != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    curChild-&gt;next = nxt;</span><br><span class="line">                    nxt-&gt;prev = curChild;            </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="445-两数相加-II"><a class="header-anchor" href="#445-两数相加-II"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers-ii/">445. 两数相加 II</a></h2>
<h3 id="题目-v103"><a class="header-anchor" href="#题目-v103"> </a>题目</h3>
<p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<blockquote>
<p>进阶：<br>
如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p>
</blockquote>
<blockquote>
<p>示例：<br>
输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>
输出：7 -&gt; 8 -&gt; 0 -&gt; 7</p>
</blockquote>
<h3 id="解题思路1-v14"><a class="header-anchor" href="#解题思路1-v14"> </a>解题思路1</h3>
<p>这题可以和“<strong>2. 两数相加</strong>”相比较，其中一种实现思路就是，将两个链表都反转过来然后用“<strong>2. 两数相加</strong>”的方法去相加，注意最后结果还要再返回来一次</p>
<h3 id="解题代码1-v15"><a class="header-anchor" href="#解题代码1-v15"> </a>解题代码1</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        l1 = <span class="built_in">reverseList</span>(l1);</span><br><span class="line">        l2 = <span class="built_in">reverseList</span>(l2);</span><br><span class="line">        <span class="type">bool</span> overflow = <span class="literal">false</span>;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode* prev = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode* curNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">            <span class="type">int</span> value = overflow?l1-&gt;val + l2-&gt;val + <span class="number">1</span> : l1-&gt;val + l2-&gt;val;</span><br><span class="line">            overflow = value&gt;=<span class="number">10</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">            curNode-&gt;val = value%<span class="number">10</span>;</span><br><span class="line">            prev-&gt;next = curNode;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后拼接较长的链，同时注意进位</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            prev-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">            <span class="type">int</span> value = overflow?l1-&gt;val+<span class="number">1</span> : l1-&gt;val;</span><br><span class="line">            overflow = value &gt;= <span class="number">10</span>? <span class="literal">true</span>: <span class="literal">false</span>;</span><br><span class="line">            prev-&gt;next-&gt;val = value % <span class="number">10</span>;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            prev-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">            <span class="type">int</span> value = overflow?l2-&gt;val+<span class="number">1</span> : l2-&gt;val;</span><br><span class="line">            overflow = value &gt;= <span class="number">10</span>? <span class="literal">true</span>: <span class="literal">false</span>;</span><br><span class="line">            prev-&gt;next-&gt;val = value % <span class="number">10</span>;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(overflow)&#123;</span><br><span class="line">            prev-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">            prev-&gt;next-&gt;val = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverseList</span>(dummy-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* temp;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            temp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v31"><a class="header-anchor" href="#解题思路2-v31"> </a>解题思路2</h3>
<p>如果要完成进阶的，不反转链表的方式，可以使用栈的结构就能达到逆序。</p>
<h3 id="解题代码2-v30"><a class="header-anchor" href="#解题代码2-v30"> </a>解题代码2</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            s1.<span class="built_in">push</span>(l1-&gt;val);</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            s2.<span class="built_in">push</span>(l2-&gt;val);</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="type">bool</span> carry = <span class="literal">false</span>;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>() || !s2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!s1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                num1 = s1.<span class="built_in">top</span>();</span><br><span class="line">                s1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num1 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                num2 = s2.<span class="built_in">top</span>();</span><br><span class="line">                s2.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num2 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            value = carry?num1+num2+<span class="number">1</span>:num1+num2;</span><br><span class="line">            carry = value&gt;<span class="number">9</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">            ListNode* newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">            newNode-&gt;val = value%<span class="number">10</span>;</span><br><span class="line">            newNode-&gt;next = dummy-&gt;next;</span><br><span class="line">            dummy-&gt;next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry)&#123;</span><br><span class="line">            ListNode* newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">            newNode-&gt;val = <span class="number">1</span>;</span><br><span class="line">            newNode-&gt;next = dummy-&gt;next;</span><br><span class="line">            dummy-&gt;next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="707-设计链表"><a class="header-anchor" href="#707-设计链表"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/design-linked-list/">707. 设计链表</a></h2>
<h3 id="题目-v104"><a class="header-anchor" href="#题目-v104"> </a>题目</h3>
<p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p>
<p>在链表类中实现这些功能：</p>
<p>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。<br>
addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。<br>
addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。<br>
addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。<br>
deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</p>
<blockquote>
<p>示例：<br>
MyLinkedList linkedList = new MyLinkedList();<br>
linkedList.addAtHead(1);<br>
linkedList.addAtTail(3);<br>
linkedList.addAtIndex(1,2);   //链表变为1-&gt; 2-&gt; 3<br>
linkedList.get(1);            //返回2<br>
linkedList.deleteAtIndex(1);  //现在链表是1-&gt; 3<br>
linkedList.get(1);            //返回3</p>
</blockquote>
<h3 id="解题思路-v83"><a class="header-anchor" href="#解题思路-v83"> </a>解题思路</h3>
<p>引用官解一句话</p>
<blockquote>
<p>单链表是最简单的一种，双链表是最常用的一种</p>
</blockquote>
<p>对于双向链表的话，定义一个伪头，定义一个伪尾能够简化操作</p>
<h3 id="单向链表代码"><a class="header-anchor" href="#单向链表代码"> </a>单向链表代码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node dummy;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化一个头节点</span></span><br><span class="line">        dummy = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= size || index&lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node cur = dummy;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count != index)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.next.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">addAtIndex</span>(<span class="number">0</span>,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">addAtIndex</span>(<span class="keyword">this</span>.size,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;size) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>) index = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        Node cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(count != index)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(val,cur.next);</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        <span class="keyword">this</span>.size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        Node cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(count != index)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        <span class="keyword">this</span>.size -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> val;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="type">int</span> val, Node next)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>.next = null;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">setVal</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">setNext</span><span class="params">(Node next)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">getVal</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Node <span class="title">getNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双向链表代码"><a class="header-anchor" href="#双向链表代码"> </a>双向链表代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> Node tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//初始化一个头节点</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= size || index&lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span>(index+<span class="number">1</span> &lt; size-index)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;index+<span class="number">1</span>; i++) cur = cur.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = tail;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size-index; i++) cur = cur.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(<span class="number">0</span>,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(<span class="built_in">this</span>.size,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;size) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>) index = <span class="number">0</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span>(index+<span class="number">1</span> &lt; size-index)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;index+<span class="number">1</span>; i++) cur = cur.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = tail;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size-index; i++) cur = cur.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">        cur.prev.next = newNode;</span><br><span class="line">        newNode.prev = cur.prev;</span><br><span class="line">        newNode.next = cur;</span><br><span class="line">        cur.prev = newNode;</span><br><span class="line">        <span class="built_in">this</span>.size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span>(index+<span class="number">1</span> &lt; size-index)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;index+<span class="number">1</span>; i++) cur = cur.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = tail;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size-index; i++) cur = cur.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur.prev.next = cur.next;</span><br><span class="line">        cur.next.prev = cur.prev;</span><br><span class="line">        <span class="built_in">this</span>.size -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line">        <span class="keyword">public</span> Node prev;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val, Node next, Node prev)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="725-分隔链表"><a class="header-anchor" href="#725-分隔链表"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/split-linked-list-in-parts/">725. 分隔链表</a></h2>
<h3 id="题目-v105"><a class="header-anchor" href="#题目-v105"> </a>题目</h3>
<p>给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。</p>
<p>每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。</p>
<p>这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。</p>
<p>返回一个符合上述规则的链表的列表。</p>
<p>举例： 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 结果 [ [1], [2], [3], [4], null ]</p>
<blockquote>
<p>示例 1：<br>
输入:<br>
root = [1, 2, 3], k = 5<br>
输出: [[1],[2],[3],[],[]]<br>
解释:<br>
输入输出各部分都应该是链表，而不是数组。<br>
例如, 输入的结点 root 的 val= 1, root.next.val = 2, \root.next.next.val = 3, 且 root.next.next.next = null。<br>
第一个输出 output[0] 是 output[0].val = 1, output[0].next = null。<br>
最后一个元素 output[4] 为 null, 它代表了最后一个部分为空链表。</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入:<br>
root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3<br>
输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]<br>
解释:<br>
输入被分成了几个连续的部分，并且每部分的长度相差不超过1.前面部分的长度大于等于后面部分的长度。</p>
</blockquote>
<h3 id="解题思路-v84"><a class="header-anchor" href="#解题思路-v84"> </a>解题思路</h3>
<p>要解决这道题首先要搞清楚一下几个变量的数值</p>
<ul>
<li>数组的长度</li>
<li>要分成多少个区间</li>
<li>每个区间的长度是多少</li>
<li>对于长度不同的区间，分别又是多少个</li>
</ul>
<p>对于数组的长度，可以通过遍历一遍链表知道</p>
<p>对于分成多少个区间，方法已经传进来了</p>
<p>每个区间的长度是多少，可以观察到，如果链表长度是要分成的区间个数的整数倍。则</p>
<blockquote>
<p>区间长度 = 链表长度/区间个数</p>
</blockquote>
<p>但是当不是整数倍的时候，可以观察到，区间长度只有两个值，即<code>ceil(链表长度/区间个数)</code>与<code>ceil(链表长度/区间个数)-1</code>两个值</p>
<p>对于不同区间分别又是多少个呢？可以发现，假设所有区间长度我们都设定为<code>ceil(链表长度/区间个数)</code>,那么<code>ceil(链表长度/区间个数) * 区间个数 - 链表长度</code>的话，就可以得出<strong>区间长度较短的那个区间个数</strong>，因为长区间长度比短区间长度多一，因此我们可以这个式子获得短区间的个数</p>
<p>同时<code>for(int j = 0; j &lt; sectionLengthBig-1;j++)</code>这里<code>-1</code>是为了控制 <code>cur</code>移动的位置，如果没有减一，则跑到下一个区间中，我们需要把当前区间的末尾置为空</p>
<h3 id="解题代码-v65"><a class="header-anchor" href="#解题代码-v65"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode[] splitListToParts(ListNode root, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 先获得链表长度</span></span><br><span class="line">        <span class="comment">// 获取区间长度的范围 向上取整 (n-1)/k+1</span></span><br><span class="line">        <span class="comment">// 生成结果 </span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        ListNode[] result = <span class="keyword">new</span> <span class="title class_">ListNode</span>[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            size++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = root;</span><br><span class="line">        <span class="keyword">if</span>(size &lt; k)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">                cur.next = <span class="literal">null</span>;</span><br><span class="line">                result[i] = cur;</span><br><span class="line">                cur = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size; i &lt; k; i++)&#123;</span><br><span class="line">                result[i] = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sectionLengthBig</span> <span class="operator">=</span> (<span class="type">int</span>)Math.ceil((<span class="type">double</span>)size/(<span class="type">double</span>)k);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sectionLengthSmall</span> <span class="operator">=</span> size%k == <span class="number">0</span> ? sectionLengthBig : sectionLengthBig-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sectionLengthSmallNum</span> <span class="operator">=</span> sectionLengthBig*k-size;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sectionLengthBigNum</span> <span class="operator">=</span> k - sectionLengthSmallNum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sectionLengthBigNum; i++)&#123;</span><br><span class="line">            result[i] = cur;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; sectionLengthBig-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = <span class="literal">null</span>;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sectionLengthBigNum; i &lt; k; i++)&#123;</span><br><span class="line">            result[i] = cur;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; sectionLengthSmall-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = <span class="literal">null</span>;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v32"><a class="header-anchor" href="#解题思路2-v32"> </a>解题思路2</h3>
<p>上面这种我自己想的思路想得有点复杂了，官方题解的代码比较简明，但是思想是一致的。</p>
<h3 id="解题代码2-v31"><a class="header-anchor" href="#解题代码2-v31"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode[] splitListToParts(ListNode root, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            size++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = root;</span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> size/k;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rem</span> <span class="operator">=</span> size % k;</span><br><span class="line">        ListNode[] results = <span class="keyword">new</span> <span class="title class_">ListNode</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> cur;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; (width + (i &lt; rem ? <span class="number">1</span> : <span class="number">0</span>))-<span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur != <span class="literal">null</span>) cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//这里加判断是k&gt;size的情况</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> cur;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                prev.next = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            results[i] = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="817-链表组件"><a class="header-anchor" href="#817-链表组件"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-components/">817. 链表组件</a></h2>
<h3 id="题目-v106"><a class="header-anchor" href="#题目-v106"> </a>题目</h3>
<p>给定链表头结点 head，该链表上的每个结点都有一个 唯一的整型值 。</p>
<p>同时给定列表 G，该列表是上述链表中整型值的一个子集。</p>
<p>返回列表 G 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 G 中）构成的集合。</p>
<blockquote>
<p>示例 1：<br>
输入:<br>
head: 0-&gt;1-&gt;2-&gt;3<br>
G = [0, 1, 3]<br>
输出: 2<br>
解释:<br>
链表中,0 和 1 是相连接的，且 G 中不包含 2，所以 [0, 1] 是 G 的一个组件，同理 [3] 也是一个组件，故返回 2。</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入:<br>
head: 0-&gt;1-&gt;2-&gt;3-&gt;4<br>
G = [0, 3, 1, 4]<br>
输出: 2<br>
解释:<br>
链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。</p>
</blockquote>
<h3 id="解题思路1-v15"><a class="header-anchor" href="#解题思路1-v15"> </a>解题思路1</h3>
<p>我的解法是判断遍历每个结点，对于每个结点再遍历一次数组G，来判断该结点是否在G中，并结合结点是否属于一个组件中，来计算值。当然也可以引入Set来以空间换时间</p>
<h3 id="解题代码1-v16"><a class="header-anchor" href="#解题代码1-v16"> </a>解题代码1</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numComponents</span><span class="params">(ListNode head, <span class="type">int</span>[] G)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">inComponent</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">inG</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> cur.val;</span><br><span class="line">            inG = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v : G)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v == value)&#123;</span><br><span class="line">                    <span class="comment">//判断是组件头</span></span><br><span class="line">                    <span class="keyword">if</span>(!inComponent)&#123;</span><br><span class="line">                        count++; <span class="comment">//新头</span></span><br><span class="line">                        inComponent =  <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    inG = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!inG &amp;&amp; inComponent) inComponent = <span class="literal">false</span>;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v33"><a class="header-anchor" href="#解题思路2-v33"> </a>解题思路2</h3>
<p>引入HashSet来判断重复元素，同时对于一个组件的判断，可以通过判断组件末尾来计算个数</p>
<h3 id="解题代码2-v32"><a class="header-anchor" href="#解题代码2-v32"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numComponents</span><span class="params">(ListNode head, <span class="type">int</span>[] G)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; g = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v : G) g.add(v);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g.contains(cur.val) &amp;&amp; (cur.next == <span class="literal">null</span> || !g.contains(cur.next.val))) count++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1019-链表中的下一个更大节点"><a class="header-anchor" href="#1019-链表中的下一个更大节点"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/next-greater-node-in-linked-list/">1019. 链表中的下一个更大节点</a></h2>
<h3 id="题目-v107"><a class="header-anchor" href="#题目-v107"> </a>题目</h3>
<p>给出一个以头节点 head 作为第一个节点的链表。链表中的节点分别编号为：node_1, node_2, node_3, … 。</p>
<p>每个节点都可能有下一个更大值（next larger value）：对于 node_i，如果其 next_larger(node_i) 是 node_j.val，那么就有 j &gt; i 且  node_j.val &gt; node_i.val，而 j 是可能的选项中最小的那个。如果不存在这样的 j，那么下一个更大值为 0 。</p>
<p>返回整数答案数组 answer，其中 answer[i] = next_larger(node_{i+1}) 。</p>
<p>注意：在下面的示例中，诸如 [2,1,5] 这样的输入（不是输出）是链表的序列化表示，其头节点的值为 2，第二个节点值为 1，第三个节点值为 5 。</p>
<blockquote>
<p>示例 1：<br>
输入：[2,1,5]<br>
输出：[5,5,0]</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：[2,7,4,3,5]<br>
输出：[7,0,5,5,0]</p>
</blockquote>
<blockquote>
<p>示例 3：<br>
输入：[1,7,5,1,9,2,5,1]<br>
输出：[7,9,9,9,0,5,0,0]</p>
</blockquote>
<h3 id="解题思路1-v16"><a class="header-anchor" href="#解题思路1-v16"> </a>解题思路1</h3>
<p>时间复杂度O(N<sup>2</sup>)的方法</p>
<h3 id="解题代码1-v17"><a class="header-anchor" href="#解题代码1-v17"> </a>解题代码1</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextLargerNodes(ListNode head) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        ListNode after;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] answer = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            after = cur.next;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">hasbigger</span> <span class="operator">=</span> <span class="literal">false</span>; </span><br><span class="line">            <span class="keyword">while</span>(after!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(after.val &gt; cur.val)&#123;</span><br><span class="line">                    hasbigger = <span class="literal">true</span>;</span><br><span class="line">                    answer[index]= after.val;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                after = after.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!hasbigger) answer[index] = <span class="number">0</span>;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v34"><a class="header-anchor" href="#解题思路2-v34"> </a>解题思路2</h3>
<p>解题思路1的方法太土了，效率太低了，有种叫做单调栈的东西。</p>
<h3 id="解题代码2-v33"><a class="header-anchor" href="#解题代码2-v33"> </a>解题代码2</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextLargerNodes</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; answers; <span class="comment">//答案输出，注意这个答案数组会随着遍历过程改变</span></span><br><span class="line">        stack&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; stack; <span class="comment">// 存放链表中暂未找到bigger的元素，其中first未元素的值，second为元素的位置</span></span><br><span class="line">        <span class="comment">//基本思路就是遍历过程中，判断栈中未找到bigger的元素是否大于现在遍历到的结点，如果是bigger的弹出栈，同时判断栈下一个元素</span></span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            answers.<span class="built_in">push_back</span>(<span class="number">0</span>); <span class="comment">// 填充0的意义在于目前并不知道这个结点是否有bigger，在后面如果找到bigger的话会修改</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.<span class="built_in">empty</span>() &amp;&amp; head-&gt;val &gt; stack.<span class="built_in">top</span>().first)&#123;</span><br><span class="line">                <span class="comment">//当前遍历的元素是栈顶元素的bigger</span></span><br><span class="line">                answers[stack.<span class="built_in">top</span>().second] = head-&gt;val;</span><br><span class="line">                stack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前的结点也没找到bigger，先压栈</span></span><br><span class="line">            stack.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(head-&gt;val,index++));</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1171-从链表中删去总和值为零的连续节点"><a class="header-anchor" href="#1171-从链表中删去总和值为零的连续节点"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/">1171. 从链表中删去总和值为零的连续节点</a></h2>
<h3 id="题目-v108"><a class="header-anchor" href="#题目-v108"> </a>题目</h3>
<p>给你一个链表的头节点 head，请你编写代码，反复删去链表中由 总和 值为 0 的连续节点组成的序列，直到不存在这样的序列为止。</p>
<p>删除完毕后，请你返回最终结果链表的头节点。</p>
<p>你可以返回任何满足题目要求的答案。</p>
<p>（注意，下面示例中的所有序列，都是对 ListNode 对象序列化的表示。）</p>
<blockquote>
<p>示例 1：<br>
输入：head = [1,2,-3,3,1]<br>
输出：[3,1]<br>
提示：答案 [1,2,1] 也是正确的。</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：head = [1,2,3,-3,4]<br>
输出：[1,2,4]</p>
</blockquote>
<blockquote>
<p>示例 3：<br>
输入：head = [1,2,3,-3,-2]<br>
输出：[1]</p>
</blockquote>
<h3 id="解题思路-v85"><a class="header-anchor" href="#解题思路-v85"> </a>解题思路</h3>
<p>解决这道题的关键是如何去定义 <strong>总和值为 <code>0</code> 的连续节点</strong>这句话。</p>
<p>而我们通过将链表值累加能够发现，在<strong>总和值为0</strong>的链表区间中，累加值<code>sum</code>会先升后降。达到与升起来之前相等的值。</p>
<p>根据这个我们可以声明一个散列表，来保存上一个达到累加值的结点。如果在遍历中发现累加值已经存在，说明在这个结点之前到这个结点的位置，为总和值为0的部分，需要将上一个出现该累加值的结点指向现在遍历到的这个结点的<code>next</code>结点。同时需要将散列表中该区间的累加值和相应的结点给删除。</p>
<h3 id="解题代码-v66"><a class="header-anchor" href="#解题代码-v66"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeZeroSumSublists</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 解题思路</span></span><br><span class="line">        <span class="comment">// 如何判断中间部分总和为0？</span></span><br><span class="line">        <span class="comment">// 如果一系列数累加上去又降下了，说明这部分存在抵消部分</span></span><br><span class="line">        <span class="comment">// 因此判断在同一水平位置的升降，即可知道中间部分是涨，水平位置右侧的值是抵消的最后一个值</span></span><br><span class="line">        <span class="comment">// 因此将水平位置左侧的结点指向水平位置右侧的next即可</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//存在头节点被删的可能，因此定义哑结点，同时值为0</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//散列表存的键是一系列累加的值，值存的是加成这个值的结点</span></span><br><span class="line">        HashMap&lt;Integer,ListNode&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>,dummy);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            sum += cur.val;</span><br><span class="line">            <span class="keyword">if</span>(map.get(sum) != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//说明已经涨落</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">before</span> <span class="operator">=</span> map.get(sum);</span><br><span class="line">                <span class="comment">//中间的值也需要删</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> before.next;</span><br><span class="line">                <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> sum;</span><br><span class="line">                <span class="keyword">while</span>(temp != cur)&#123;</span><br><span class="line">                    curSum += temp.val;</span><br><span class="line">                    map.remove(curSum);</span><br><span class="line">                    temp = temp.next;</span><br><span class="line">                &#125;</span><br><span class="line">                before.next = cur.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(sum,cur);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1367-二叉树中的列表"><a class="header-anchor" href="#1367-二叉树中的列表"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-in-binary-tree/">1367. 二叉树中的列表</a></h2>
<h3 id="题目-v109"><a class="header-anchor" href="#题目-v109"> </a>题目</h3>
<p>给你一棵以 root 为根的二叉树和一个 head 为第一个节点的链表。</p>
<p>如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 head 为首的链表中每个节点的值，那么请你返回 True ，否则返回 False 。</p>
<p>一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。</p>
<blockquote>
<p>示例 1：<br>
输入：head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]<br>
输出：true<br>
解释：树中蓝色的节点构成了与链表对应的子路径。</p>
</blockquote>
<p><img src="http://algorithm-image.qibinaoe.top/sample_1_1720.png" alt="img"></p>
<p>示例 2:<br>
输入：head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]<br>
输出：true</p>
<p>示例 3：<br>
输入：head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]<br>
输出：false<br>
解释：二叉树中不存在一一对应链表的路径。</p>
<p><img src="http://algorithm-image.qibinaoe.top/sample_2_1720.png" alt="img"></p>
<h3 id="解题思路-v86"><a class="header-anchor" href="#解题思路-v86"> </a>解题思路</h3>
<p>这题显然是一道深度优先搜索的题目。</p>
<p>通过递归判断当前节点是否与树上当前节点相等。如果相等，则继续判断链表下一个节点与书上的左右两子树。这个即方法<code>dfs</code>的作用。</p>
<p>当然也可能存在当前链表的结点与树上的结点相等，但接下来链表下一个结点就不相等了，这并不意味着不匹配，有可能这匹配的串在树的更底层。所以要或上<code>isSubPath(head,root.left) || isSubPath(head,root.right)</code></p>
<h4 id="解题代码-v67"><a class="header-anchor" href="#解题代码-v67"> </a>解题代码</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubPath</span><span class="params">(ListNode head, TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//DFS的题目</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//有可能存在head.val在树上存在两个都相等的结点，所以两个位置的结点都得判断</span></span><br><span class="line">        <span class="keyword">return</span> dfs(head,root) || isSubPath(head,root.left) || isSubPath(head,root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(ListNode head, TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.val == node.val) <span class="keyword">return</span> dfs(head.next,node.left) || dfs(head.next, node.right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1669-合并两个链表"><a class="header-anchor" href="#1669-合并两个链表"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-in-between-linked-lists/">1669. 合并两个链表</a></h2>
<h3 id="题目-v110"><a class="header-anchor" href="#题目-v110"> </a>题目</h3>
<p>给你两个链表 list1 和 list2 ，它们包含的元素分别为 n 个和 m 个。</p>
<p>请你将 list1 中第 a 个节点到第 b 个节点删除，并将list2 接在被删除节点的位置。</p>
<p>下图中蓝色边和节点展示了操作后的结果：</p>
<p><img src="http://algorithm-image.qibinaoe.top/fig1.png" alt="img"></p>
<blockquote>
<p>示例 1：<br>
输入：list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]<br>
输出：[0,1,2,1000000,1000001,1000002,5]<br>
解释：我们删除 list1 中第三和第四个节点，并将 list2 接在该位置。上图中蓝色的边和节点为答案链表。</p>
</blockquote>
<p><img src="http://algorithm-image.qibinaoe.top/merge_linked_list_ex1.png" alt="img"></p>
<h3 id="解题思路-v87"><a class="header-anchor" href="#解题思路-v87"> </a>解题思路</h3>
<p>这题主要是两个指针移动b-a+1个距离，然后操作链表的题目</p>
<p>一种做法是一个指针移动<code>b-a+1</code>的距离，另一个指针从头开始，同步移动a-1个距离。</p>
<p>另一种做法是一个指针移动a-1个距离，另一个指针在第一个指针的基础上移动b-a+1个距离</p>
<h3 id="解题代码-v68"><a class="header-anchor" href="#解题代码-v68"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeInBetween</span><span class="params">(ListNode list1, <span class="type">int</span> a, <span class="type">int</span> b, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="comment">// 关键是找到第a-1个结点和b的结点</span></span><br><span class="line">        <span class="comment">// 找长度显然用快慢指针</span></span><br><span class="line">        <span class="comment">// 根据题目的条件，不会删除头结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">before</span> <span class="operator">=</span> list1;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">after</span> <span class="operator">=</span> list1;</span><br><span class="line">        <span class="comment">//偏移b-a+1个位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> b - a + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            after = after.next;</span><br><span class="line">            pos--;</span><br><span class="line">        &#125;</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将这段指针同步移动到before的位置在a的位置</span></span><br><span class="line">        a--;</span><br><span class="line">        <span class="keyword">while</span>(a&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            after = after.next;</span><br><span class="line">            before = before.next;</span><br><span class="line">            a--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拼接</span></span><br><span class="line">        before.next = list2;</span><br><span class="line">        <span class="keyword">while</span>(list2.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        list2.next = after.next;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1670-设计前中后队列"><a class="header-anchor" href="#1670-设计前中后队列"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/design-front-middle-back-queue/">1670. 设计前中后队列</a></h2>
<h3 id="题目-v111"><a class="header-anchor" href="#题目-v111"> </a>题目</h3>
<p>请你设计一个队列，支持在前，中，后三个位置的 push 和 pop 操作。</p>
<p>请你完成 FrontMiddleBack 类：</p>
<blockquote>
<p>FrontMiddleBack() 初始化队列。<br>
void pushFront(int val) 将 val 添加到队列的 最前面 。<br>
void pushMiddle(int val) 将 val 添加到队列的 正中间 。<br>
void pushBack(int val) 将 val 添加到队里的 最后面 。<br>
int popFront() 将 最前面 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。<br>
int popMiddle() 将 正中间 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。<br>
int popBack() 将 最后面 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。<br>
请注意当有 两个 中间位置的时候，选择靠前面的位置进行操作。比方说：</p>
</blockquote>
<blockquote>
<p>将 6 添加到 [1, 2, 3, 4, 5] 的中间位置，结果数组为 [1, 2, 6, 3, 4, 5] 。<br>
从 [1, 2, 3, 4, 5, 6] 的中间位置弹出元素，返回 3 ，数组变为 [1, 2, 4, 5, 6] 。</p>
</blockquote>
<h3 id="解题思路-v88"><a class="header-anchor" href="#解题思路-v88"> </a>解题思路</h3>
<p>这题可以用单向链表实现，也可以用双向链表实现。</p>
<p>如果用双向链表实现的话，还可以定义一个记录中间节点变量。这样能够提高效率。</p>
<h3 id="解题代码单向链表"><a class="header-anchor" href="#解题代码单向链表"> </a>解题代码单向链表</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FrontMiddleBackQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node dummy;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FrontMiddleBackQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个哑结点</span></span><br><span class="line">        dummy = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushFront</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val,dummy.next);</span><br><span class="line">        dummy.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMiddle</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//找到中间位置</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">fast</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">slow</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val,slow.next);</span><br><span class="line">        slow.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushBack</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">popFront</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">result</span> <span class="operator">=</span> dummy.next;</span><br><span class="line">        dummy.next = dummy.next.next;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> result.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">popMiddle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">fast</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">slow</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span> &amp;&amp; fast.next.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">result</span> <span class="operator">=</span> slow.next;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> result.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">popBack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(cur.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">result</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> result.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val,Node next)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FrontMiddleBackQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FrontMiddleBackQueue obj = new FrontMiddleBackQueue();</span></span><br><span class="line"><span class="comment"> * obj.pushFront(val);</span></span><br><span class="line"><span class="comment"> * obj.pushMiddle(val);</span></span><br><span class="line"><span class="comment"> * obj.pushBack(val);</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.popFront();</span></span><br><span class="line"><span class="comment"> * int param_5 = obj.popMiddle();</span></span><br><span class="line"><span class="comment"> * int param_6 = obj.popBack();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-35-复杂链表的复制"><a class="header-anchor" href="#剑指-Offer-35-复杂链表的复制"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指 Offer 35. 复杂链表的复制</a></h2>
<h3 id="题目-v112"><a class="header-anchor" href="#题目-v112"> </a>题目</h3>
<p>同“138. 复制带随机指针的链表”</p>
<h3 id="解题代码-v69"><a class="header-anchor" href="#解题代码-v69"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        HashMap&lt;Node,Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//键是原链表 值是新链表</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">newhead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(head.val);</span><br><span class="line">        map.put(head,newhead);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">oldNode</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> newhead;</span><br><span class="line">        <span class="keyword">while</span>(oldNode.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(oldNode.next.val);</span><br><span class="line">            newNode.next = temp;</span><br><span class="line">            map.put(oldNode.next,temp);</span><br><span class="line">            oldNode = oldNode.next;</span><br><span class="line">            newNode = newNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        oldNode = head;</span><br><span class="line">        newNode = newhead;</span><br><span class="line">        <span class="keyword">while</span>(oldNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newRandom</span> <span class="operator">=</span> map.get(oldNode.random);</span><br><span class="line">            newNode.random = newRandom;</span><br><span class="line">            oldNode = oldNode.next;</span><br><span class="line">            newNode = newNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题-02-04-分割链表"><a class="header-anchor" href="#面试题-02-04-分割链表"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-list-lcci/">面试题 02.04. 分割链表</a></h2>
<p>题目同“86. 分隔链表”</p>
<h2 id="面试题-02-05-链表求和"><a class="header-anchor" href="#面试题-02-05-链表求和"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-lists-lcci/">面试题 02.05. 链表求和</a></h2>
<p>题目同“2. 两数相加”</p>
<h3 id="解题代码-v70"><a class="header-anchor" href="#解题代码-v70"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> l1==<span class="literal">null</span>?<span class="number">0</span>:l1.val;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> l2==<span class="literal">null</span>?<span class="number">0</span>:l2.val;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>((num1+num2+(carry==<span class="number">0</span>?<span class="number">0</span>:<span class="number">1</span>))%<span class="number">10</span>);</span><br><span class="line">            carry = num1+num2+carry&gt;<span class="number">9</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            cur.next = newNode;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            l1 = l1==<span class="literal">null</span>?<span class="literal">null</span>:l1.next;</span><br><span class="line">            l2 = l2==<span class="literal">null</span>?<span class="literal">null</span>:l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">            cur.next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题-02-08-环路检测"><a class="header-anchor" href="#面试题-02-08-环路检测"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-lcci/">面试题 02.08. 环路检测</a></h2>
<p>题目同“<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a>”</p>
<h2 id="23-合并K个升序链表"><a class="header-anchor" href="#23-合并K个升序链表"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></h2>
<h3 id="题目-v113"><a class="header-anchor" href="#题目-v113"> </a>题目</h3>
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<blockquote>
<p>示例 1：<br>
输入：lists = [[1,4,5],[1,3,4],[2,6]]<br>
输出：[1,1,2,3,4,4,5,6]<br>
解释：链表数组如下：<br>
[<br>
1-&gt;4-&gt;5,<br>
1-&gt;3-&gt;4,<br>
2-&gt;6<br>
]<br>
将它们合并到一个有序链表中得到。<br>
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：lists = []<br>
输出：[]</p>
</blockquote>
<blockquote>
<p>示例 3：<br>
输入：lists = [[]]<br>
输出：[]</p>
</blockquote>
<blockquote>
<p>提示：<br>
k == lists.length<br>
0 &lt;= k &lt;= 10^4<br>
0 &lt;= lists[i].length &lt;= 500<br>
-10^4 &lt;= lists[i][j] &lt;= 10^4<br>
lists[i] 按 升序 排列<br>
lists[i].length 的总和不超过 10^4</p>
</blockquote>
<h3 id="解题思路1-v17"><a class="header-anchor" href="#解题思路1-v17"> </a>解题思路1</h3>
<p>最开始的想法是不断的从数组中找到最小的值，接到新链表中。这就通过循环找最小值即可</p>
<h3 id="解题代码1-v18"><a class="header-anchor" href="#解题代码1-v18"> </a>解题代码1</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个新链表</span></span><br><span class="line">        <span class="comment">//遍历每个lists的头取最小加入新链表</span></span><br><span class="line">        <span class="keyword">if</span>(lists == <span class="literal">null</span> || lists.length == <span class="number">0</span> || (lists.length == <span class="number">1</span> &amp;&amp; lists[<span class="number">0</span>]==<span class="literal">null</span>)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> ans;</span><br><span class="line">        <span class="type">boolean</span> flag;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">minNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lists.length; i++)&#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> lists[i];</span><br><span class="line">                <span class="keyword">if</span>(temp != <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(temp.val &lt; min)&#123;</span><br><span class="line">                        min = temp.val;</span><br><span class="line">                        minNode = temp;</span><br><span class="line">                        index = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                cur.next =<span class="keyword">new</span> <span class="title class_">ListNode</span>(min);</span><br><span class="line">                lists[index] = minNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;<span class="keyword">while</span>(flag);</span><br><span class="line">        <span class="keyword">return</span> ans.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v35"><a class="header-anchor" href="#解题思路2-v35"> </a>解题思路2</h3>
<p>题目要求合并K个，那么我们可以直接2个2个合并就完事了</p>
<h3 id="解题代码2-v34"><a class="header-anchor" href="#解题代码2-v34"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lists == <span class="literal">null</span> || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;lists.length; i++)&#123;</span><br><span class="line">           ans = mergeTwoLists(ans,lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">null</span> || l2 == <span class="literal">null</span>) <span class="keyword">return</span> l1==<span class="literal">null</span>?l2:l1;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = l1==<span class="literal">null</span>?l2:l1;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路3-v8"><a class="header-anchor" href="#解题思路3-v8"> </a>解题思路3</h3>
<p>可以通过归并排序，优化直接按顺序合并的速度</p>
<h3 id="解题代码3-v12"><a class="header-anchor" href="#解题代码3-v12"> </a>解题代码3</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lists == <span class="literal">null</span> || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> merge(lists,<span class="number">0</span>,lists.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode lists[], <span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> lists[l];</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(merge(lists,l,mid),merge(lists,mid+<span class="number">1</span>,r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">null</span> || l2 == <span class="literal">null</span>) <span class="keyword">return</span> l1==<span class="literal">null</span>?l2:l1;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = l1==<span class="literal">null</span>?l2:l1;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路4-v3"><a class="header-anchor" href="#解题思路4-v3"> </a>解题思路4</h3>
<p>可以利用优先队列，每次都能够取出最小值的特点</p>
<h3 id="解题代码4-v4"><a class="header-anchor" href="#解题代码4-v4"> </a>解题代码4</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lists == <span class="literal">null</span> || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((ListNode n1, ListNode n2)-&gt;&#123;<span class="keyword">return</span> n1.val-n2.val;&#125;);</span><br><span class="line">        <span class="keyword">for</span>(ListNode n : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n != <span class="literal">null</span>) queue.offer(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> ans;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">min</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            cur.next = min;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            min = min.next;</span><br><span class="line">            <span class="keyword">if</span>(min != <span class="literal">null</span>) queue.offer(min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="25-K-个一组翻转链表"><a class="header-anchor" href="#25-K-个一组翻转链表"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h2>
<h3 id="题目-v114"><a class="header-anchor" href="#题目-v114"> </a>题目</h3>
<p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<blockquote>
<p>示例：<br>
给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5<br>
当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5<br>
当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
</blockquote>
<blockquote>
<p>说明：<br>
你的算法只能使用常数的额外空间。<br>
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
</blockquote>
<h3 id="解题思路-v89"><a class="header-anchor" href="#解题思路-v89"> </a>解题思路</h3>
<p>既然是k个结点进行翻转，那本质是“leetcode206——反转链表”这道题。</p>
<p>接下来思考要翻转多少次?可以先获取链表的长度，再除以k，即可得到次数。</p>
<p>接下来比较麻烦的就是处理翻转的位置首尾的连接。</p>
<h3 id="解题代码-v71"><a class="header-anchor" href="#解题代码-v71"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> size/k;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummy;</span><br><span class="line">        cur = head;</span><br><span class="line">        ListNode after;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">            after = cur;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j&lt; k; j++)&#123;</span><br><span class="line">                after = after.next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev.next = reverseList(cur,after);</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = after;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head, ListNode end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> end;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        ListNode temp;</span><br><span class="line">        <span class="keyword">while</span>(cur != end)&#123;</span><br><span class="line">            temp = cur.next;</span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"><i class="fa fa-tag"></i> 算法</a>
              <a href="/tags/leetcode/" rel="tag"><i class="fa fa-tag"></i> leetcode</a>
              <a href="/tags/%E9%93%BE%E8%A1%A8/" rel="tag"><i class="fa fa-tag"></i> 链表</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/10/31/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12%E2%80%94%E5%8D%A1%E8%BD%A6%E8%A3%85%E8%B4%A7Allocation/" rel="prev" title="挑战程序设计2—卡车装货Allocation">
                  <i class="fa fa-chevron-left"></i> 挑战程序设计2—卡车装货Allocation
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/11/02/git%E5%AD%A6%E4%B9%A0/" rel="next" title="git学习">
                  git学习 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">闽ICP备2021001502号 </a>
      <img src="/images/%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" alt=""><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=35058202000501" rel="noopener" target="_blank">闽公网安备 35058202000501号 </a>
  </div>

<div class="copyright">
  &copy; 2020 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-seedling"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZQB</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">602k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">16:43</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/comments.js"></script><script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/utils.js"></script><script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/motion.js"></script><script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/next-boot.js"></script><script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/bookmark.js"></script>

  
<script src="https://unpkg.com/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/third-party/search/local-search.js"></script>



  <script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/third-party/fancybox.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://unpkg.com/mathjax@3.2.1/es5/tex-mml-chtml.js","integrity":"sha256-hlC2uSQYTmPsrzGZTEQEg9PZ1a/+SV6VBCTclohf2og="}}</script>
<script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://unpkg.com/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"qibinaoe","repo":"blog-comments","client_id":"157704bd238da130367f","client_secret":"b0bc6368a8d8c75ba5562dabf654a38242c9600f","admin_user":"qibinaoe","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://unpkg.com/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"1f548a991bd99ec27237508f8fd85e63"}</script>
<script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/third-party/comments/gitalk.js"></script>

</body>
</html>
