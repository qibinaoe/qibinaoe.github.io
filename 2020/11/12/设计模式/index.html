<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#f3a683"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-bin.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-bin.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-bin.png">
  <link rel="mask-icon" href="/images/logo-bin.svg" color="#f3a683">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"qibinaoe.top","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":true,"color":"#FF8B8B","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/config.js"></script>

    <meta name="description" content="本篇是《设计模式的艺术》的相关知识记录摘抄">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式">
<meta property="og:url" content="http://qibinaoe.top/2020/11/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="Qibin&#39;s Blog">
<meta property="og:description" content="本篇是《设计模式的艺术》的相关知识记录摘抄">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20201210141048317.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20201210141132832.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20201210142755472.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20201210145448230.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20201210150154346.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20201210151227012.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20201210152632642.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20201210160525640.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20201210160601204.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20201210173445512.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20201210174414414.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20201210182814754.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20201210182840381.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20201210185435843.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20201210185446564.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20201211204406607.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20201211204422063.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20201216163723612.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20201216183951684.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20201224175352126.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20201224201619925.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20210312090446928.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20210508141710004.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20210508150529509.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20210512140621752.png">
<meta property="article:published_time" content="2020-11-12T03:20:54.000Z">
<meta property="article:modified_time" content="2022-06-08T05:06:35.542Z">
<meta property="article:author" content="ZQB">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://algorithm-image.qibinaoe.top/image-20201210141048317.png">


<link rel="canonical" href="http://qibinaoe.top/2020/11/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://qibinaoe.top/2020/11/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","path":"2020/11/12/设计模式/","title":"设计模式"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>设计模式 | Qibin's Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Qibin's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">better and better</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook/" rel="section"><i class="fa fa-book fa-fw"></i>留言板</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0"><span class="nav-number">1.</span> <span class="nav-text">设计模式读书笔记</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E5%BF%B5"><span class="nav-number">2.</span> <span class="nav-text">设计模式概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">2.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E8%A6%81%E7%B4%A0"><span class="nav-number">2.2.</span> <span class="nav-text">关键要素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E5%85%B3%E9%94%AE"><span class="nav-number">2.3.</span> <span class="nav-text">学习关键</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UML"><span class="nav-number">3.</span> <span class="nav-text">UML</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB-Association"><span class="nav-number">3.1.</span> <span class="nav-text">关联关系 Association</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E5%85%B3%E8%81%94"><span class="nav-number">3.2.</span> <span class="nav-text">双向关联</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E5%90%91%E5%85%B3%E8%81%94"><span class="nav-number">3.3.</span> <span class="nav-text">单向关联</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%85%B3%E8%81%94"><span class="nav-number">3.4.</span> <span class="nav-text">自关联</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E6%80%A7%E5%85%B3%E8%81%94"><span class="nav-number">3.5.</span> <span class="nav-text">多重性关联</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB-Aggregation"><span class="nav-number">3.6.</span> <span class="nav-text">聚合关系 Aggregation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB-Composition"><span class="nav-number">3.7.</span> <span class="nav-text">组合关系 Composition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB-Dependency"><span class="nav-number">3.8.</span> <span class="nav-text">依赖关系 Dependency</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB-Generalization"><span class="nav-number">3.9.</span> <span class="nav-text">泛化关系 Generalization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB"><span class="nav-number">3.10.</span> <span class="nav-text">接口与实现关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">4.</span> <span class="nav-text">面向对象设计原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87"><span class="nav-number">4.1.</span> <span class="nav-text">目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%EF%BC%88Single-Responsibility-Principle-SRP%EF%BC%89"><span class="nav-number">4.2.</span> <span class="nav-text">单一职责原则（Single Responsibility Principle,SRP）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-v2"><span class="nav-number">4.2.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E8%A6%81%E6%B1%82"><span class="nav-number">4.2.2.</span> <span class="nav-text">作用要求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.2.3.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8D%E4%BE%8B"><span class="nav-number">4.2.3.1.</span> <span class="nav-text">反例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%EF%BC%88Open-Closed-Principle-OCP%EF%BC%89"><span class="nav-number">4.3.</span> <span class="nav-text">开闭原则（Open-Closed Principle, OCP）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-v3"><span class="nav-number">4.3.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E8%A6%81%E6%B1%82-v2"><span class="nav-number">4.3.2.</span> <span class="nav-text">作用要求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-v2"><span class="nav-number">4.3.3.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99%EF%BC%88Liskov-Substitution-Principle-LSP%EF%BC%89"><span class="nav-number">4.4.</span> <span class="nav-text">里氏代换原则（Liskov Substitution Principle,LSP）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-v4"><span class="nav-number">4.4.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E8%A6%81%E6%B1%82-v3"><span class="nav-number">4.4.2.</span> <span class="nav-text">作用要求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-v3"><span class="nav-number">4.4.3.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99%EF%BC%88Dependence-Inversion-Principle-DIP%EF%BC%89"><span class="nav-number">4.5.</span> <span class="nav-text">依赖倒转原则（Dependence Inversion Principle,DIP）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-v5"><span class="nav-number">4.5.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E8%A6%81%E6%B1%82-v4"><span class="nav-number">4.5.2.</span> <span class="nav-text">作用要求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-v4"><span class="nav-number">4.5.3.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8D%E4%BE%8B-v2"><span class="nav-number">4.5.3.1.</span> <span class="nav-text">反例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E5%90%8E"><span class="nav-number">4.5.3.2.</span> <span class="nav-text">修改后</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%EF%BC%88Interface-Segregation-Principle-ISP%EF%BC%89"><span class="nav-number">4.6.</span> <span class="nav-text">接口隔离原则（Interface Segregation Principle,ISP）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-v6"><span class="nav-number">4.6.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E8%A6%81%E6%B1%82-v5"><span class="nav-number">4.6.2.</span> <span class="nav-text">作用要求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="nav-number">4.6.3.</span> <span class="nav-text">解决问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E4%BE%8B-v3"><span class="nav-number">4.6.4.</span> <span class="nav-text">反例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99%EF%BC%88Composite-Reuse-Principle-CRP%EF%BC%89"><span class="nav-number">4.7.</span> <span class="nav-text">合成复用原则（Composite Reuse Principle,CRP）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-v7"><span class="nav-number">4.7.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A6%81%E6%B1%82%E4%BD%9C%E7%94%A8"><span class="nav-number">4.7.2.</span> <span class="nav-text">要求作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BC%98%E7%82%B9"><span class="nav-number">4.7.3.</span> <span class="nav-text">使用优点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99-%EF%BC%88Law-of-Demeter-LoD%EF%BC%89"><span class="nav-number">4.8.</span> <span class="nav-text">迪米特法则 （Law of Demeter,LoD）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-v8"><span class="nav-number">4.9.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A6%81%E6%B1%82%E4%BD%9C%E7%94%A8-v2"><span class="nav-number">4.10.</span> <span class="nav-text">要求作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E4%BE%8B-v4"><span class="nav-number">4.11.</span> <span class="nav-text">反例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-Creational-Pattern"><span class="nav-number">5.</span> <span class="nav-text">创建型模式 Creational Pattern</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-Singleton-Pattern"><span class="nav-number">5.1.</span> <span class="nav-text">单例模式 Singleton Pattern</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-v9"><span class="nav-number">5.1.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AE%B9"><span class="nav-number">5.1.2.</span> <span class="nav-text">内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="nav-number">5.1.3.</span> <span class="nav-text">单例模式创建过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">5.1.4.</span> <span class="nav-text">懒汉式单例存在的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E7%B1%BB"><span class="nav-number">5.1.5.</span> <span class="nav-text">饿汉式单例类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="nav-number">5.1.5.1.</span> <span class="nav-text">实现方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-v3"><span class="nav-number">5.1.5.2.</span> <span class="nav-text">实现代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E7%B1%BB"><span class="nav-number">5.1.6.</span> <span class="nav-text">懒汉式单例类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E7%B1%BB%E5%92%8C%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E7%B1%BB%E6%AF%94%E8%BE%83"><span class="nav-number">5.1.7.</span> <span class="nav-text">饿汉式单例类和懒汉式单例类比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Initialization-on-Demand-Holder-%EF%BC%88IoDH%EF%BC%89"><span class="nav-number">5.1.8.</span> <span class="nav-text">Initialization on Demand Holder （IoDH）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-number">5.1.9.</span> <span class="nav-text">单例模式总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-Simple-Factory-Pattern"><span class="nav-number">5.2.</span> <span class="nav-text">简单工厂模式 Simple Factory Pattern</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-v10"><span class="nav-number">5.2.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AE%B9-v2"><span class="nav-number">5.2.2.</span> <span class="nav-text">内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E"><span class="nav-number">5.2.3.</span> <span class="nav-text">说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-v20"><span class="nav-number">5.2.4.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%92%8C%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.2.5.</span> <span class="nav-text">创建对象和使用对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%AE%80%E5%8C%96"><span class="nav-number">5.2.6.</span> <span class="nav-text">简单工厂模式的简化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E7%B1%BB%E6%80%BB%E7%BB%93"><span class="nav-number">5.2.7.</span> <span class="nav-text">简单工厂类总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-Factory-Method-Pattern"><span class="nav-number">5.3.</span> <span class="nav-text">工厂方法模式 Factory Method Pattern</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-v11"><span class="nav-number">5.3.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">5.3.2.</span> <span class="nav-text">简单工厂模式存在的缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AE%B9-v3"><span class="nav-number">5.3.3.</span> <span class="nav-text">内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-v21"><span class="nav-number">5.3.4.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%82%B9"><span class="nav-number">5.3.5.</span> <span class="nav-text">工厂方法模式优点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-Abstract-Factory-Pattern"><span class="nav-number">5.4.</span> <span class="nav-text">抽象工厂模式 Abstract Factory Pattern</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-v12"><span class="nav-number">5.4.1.</span> <span class="nav-text">定义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-Prototype-Pattern"><span class="nav-number">5.5.</span> <span class="nav-text">原型模式 Prototype Pattern</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-v13"><span class="nav-number">5.5.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%88%E6%B5%85%E5%85%8B%E9%9A%86%EF%BC%89"><span class="nav-number">5.5.2.</span> <span class="nav-text">浅拷贝（浅克隆）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%88%E6%B7%B1%E5%85%8B%E9%9A%86%EF%BC%89"><span class="nav-number">5.5.3.</span> <span class="nav-text">深拷贝（深克隆）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-Builder-Pattern"><span class="nav-number">5.6.</span> <span class="nav-text">建造者模式 Builder Pattern</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-v14"><span class="nav-number">5.6.1.</span> <span class="nav-text">定义</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-Structural-Pattern"><span class="nav-number">6.</span> <span class="nav-text">结构型模式 Structural Pattern</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-Adapter-Pattern"><span class="nav-number">6.1.</span> <span class="nav-text">适配器模式 Adapter Pattern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F-Bridge-Pattern"><span class="nav-number">6.2.</span> <span class="nav-text">桥接模式 Bridge Pattern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F-Composite-Pattern"><span class="nav-number">6.3.</span> <span class="nav-text">组合模式 Composite Pattern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F-Decorator-Pattern"><span class="nav-number">6.4.</span> <span class="nav-text">装饰模式 Decorator Pattern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F-Facade-Pattern"><span class="nav-number">6.5.</span> <span class="nav-text">外观模式 Facade Pattern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F-Flyweight-Pattern"><span class="nav-number">6.6.</span> <span class="nav-text">享元模式 Flyweight Pattern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-Proxy-Pattern"><span class="nav-number">6.7.</span> <span class="nav-text">代理模式 Proxy Pattern</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-Behavioral-Pattern"><span class="nav-number">7.</span> <span class="nav-text">行为型模式 Behavioral Pattern</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F-Chain-of-Responsibility-Pattern"><span class="nav-number">7.1.</span> <span class="nav-text">职责链模式 Chain of Responsibility Pattern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-Command-Pattern"><span class="nav-number">7.2.</span> <span class="nav-text">命令模式 Command Pattern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F-Interpreter-Pattern"><span class="nav-number">7.3.</span> <span class="nav-text">解释器模式 Interpreter Pattern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F-Iterator-Pattern"><span class="nav-number">7.4.</span> <span class="nav-text">迭代器模式 Iterator Pattern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F-Mediator-Pattern"><span class="nav-number">7.5.</span> <span class="nav-text">中介者模式 Mediator Pattern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F-Memento-Pattern"><span class="nav-number">7.6.</span> <span class="nav-text">备忘录模式 Memento Pattern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F-Observer-Pattern"><span class="nav-number">7.7.</span> <span class="nav-text">观察者模式 Observer Pattern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F-State-Pattern"><span class="nav-number">7.8.</span> <span class="nav-text">状态模式 State Pattern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-Strategy-Pattern"><span class="nav-number">7.9.</span> <span class="nav-text">策略模式 Strategy Pattern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-Template-Method-Pattern"><span class="nav-number">7.10.</span> <span class="nav-text">模板方法模式 Template Method Pattern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F-Visitor-Pattern"><span class="nav-number">7.11.</span> <span class="nav-text">访问者模式 Visitor Pattern</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZQB"
      src="/images/me_avatar.png">
  <p class="site-author-name" itemprop="name">ZQB</p>
  <div class="site-description" itemprop="description">Better Me</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/qibinaoe" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;qibinaoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:780891896@qq.com" title="E-Mail → mailto:780891896@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://gagalab.tech/" title="https:&#x2F;&#x2F;gagalab.tech&#x2F;" rel="noopener" target="_blank">嘎嘎研究所</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://qibinaoe.top/2020/11/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me_avatar.png">
      <meta itemprop="name" content="ZQB">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qibin's Blog">
      <meta itemprop="description" content="Better Me">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="设计模式 | Qibin's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          设计模式
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-12 11:20:54" itemprop="dateCreated datePublished" datetime="2020-11-12T11:20:54+08:00">2020-11-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-08 13:06:35" itemprop="dateModified" datetime="2022-06-08T13:06:35+08:00">2022-06-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>17k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>29 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="设计模式读书笔记"><a class="header-anchor" href="#设计模式读书笔记"> </a>设计模式读书笔记</h2>
<p>设计模式的学习书籍我看的是刘伟老师的《设计模式的艺术》</p>
<p>图片来源于《设计模式的艺术》</p>
<!-- more -->
<h2 id="设计模式概念"><a class="header-anchor" href="#设计模式概念"> </a>设计模式概念</h2>
<h3 id="定义"><a class="header-anchor" href="#定义"> </a>定义</h3>
<p>设计模式是一套被<strong>反复使用</strong>的、多数人知晓的、经过分类的、<strong>代码设计经验</strong>的<strong>总结</strong>。</p>
<p>使用设计模式是为了<strong>重用代码</strong>、让代码更容易被他人理解并且保证代码的<strong>可靠性</strong></p>
<h3 id="关键要素"><a class="header-anchor" href="#关键要素"> </a>关键要素</h3>
<p>模式名称、问题、解决方案和效果</p>
<h3 id="学习关键"><a class="header-anchor" href="#学习关键"> </a>学习关键</h3>
<ul>
<li>这个设计模式的意图是什么</li>
<li>解决一个什么样的问题</li>
<li>什么时候可以使用它</li>
<li>如果解决问题</li>
<li>掌握结构图</li>
<li>关键代码</li>
<li>应用实例
<ul>
<li>生活上</li>
<li>软件上</li>
</ul>
</li>
<li>模式的优点</li>
<li>模式的缺点</li>
<li>使用时应该注意什么</li>
</ul>
<h2 id="UML"><a class="header-anchor" href="#UML"> </a>UML</h2>
<h3 id="关联关系-Association"><a class="header-anchor" href="#关联关系-Association"> </a>关联关系 Association</h3>
<p>关联关系是一种<strong>结构化关系</strong></p>
<p>关联关系用来表示一类对象对另一类对象之间<strong>有联系</strong>。</p>
<p>通常将一个类的对象作为另一个类的成员变量</p>
<h3 id="双向关联"><a class="header-anchor" href="#双向关联"> </a>双向关联</h3>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210141048317.png" alt="image-20201210141048317"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Product[] products;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Customer[] customers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单向关联"><a class="header-anchor" href="#单向关联"> </a>单向关联</h3>
<p>单向关联用<strong>带箭头的实线</strong>表示</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210141132832.png" alt="image-20201210141132832"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Customer &#123;</span><br><span class="line">    private Address address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自关联"><a class="header-anchor" href="#自关联"> </a>自关联</h3>
<p>自关联表示类的属性中<strong>存在该类本身</strong>。</p>
<p>例如链表中的结点都包含自身<code>Node next</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多重性关联"><a class="header-anchor" href="#多重性关联"> </a>多重性关联</h3>
<p>多重性关联关系又称为重数性（multiplicity）关联关系，表示<strong>两个关联对象</strong>在<strong>数量上</strong>的对应关系。UML中多重性在关联直线上用数字或数字范围来表示</p>
<table>
<thead>
<tr>
<th style="text-align:center">表示方式</th>
<th style="text-align:center">多重性说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1…1</td>
<td style="text-align:center">表示<strong>另一个类</strong>的<strong>一个对象</strong>只与<strong>该类</strong>的<strong>一个对象</strong>有关系</td>
</tr>
<tr>
<td style="text-align:center">0…*</td>
<td style="text-align:center">表示<strong>另一个类</strong>的<strong>一个对象</strong>与<strong>该类</strong>的<strong>零个或多个对象</strong>有关系</td>
</tr>
<tr>
<td style="text-align:center">1…*</td>
<td style="text-align:center">表示<strong>另一个类</strong>的<strong>一个对象</strong>与<strong>该类</strong>的<strong>一个或多个对象</strong>有关系</td>
</tr>
<tr>
<td style="text-align:center">0…1</td>
<td style="text-align:center">表示<strong>另一个类</strong>的<strong>一个对象</strong>与<strong>该类没有关系</strong>或只与<strong>一个对象</strong>有关系</td>
</tr>
<tr>
<td style="text-align:center">m…n</td>
<td style="text-align:center">表示<strong>另一个类</strong>的<strong>一个对象</strong>与<strong>该类最少有m个，最多n个对象</strong>有关系 （其中m &lt;= n）</td>
</tr>
</tbody>
</table>
<p>注意：这里的<strong>数字范围靠近</strong>的<strong>那个类</strong>，指的是上面”多重性说明“中的<strong>该类</strong>，而离<strong>数字范围远</strong>的那个类指代的是<strong>另一个类</strong></p>
<p>下面例子表示：**0…***靠近Button端，远离Form端。说明，Form的一个对象有Button类的零个或多个对象。</p>
<p>说人话：一个Form界面拥有零个或多个Button按钮。而一个按钮Button只属于一个Form界面</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210142755472.png" alt="image-20201210142755472"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Form</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Button[] buttons;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="聚合关系-Aggregation"><a class="header-anchor" href="#聚合关系-Aggregation"> </a>聚合关系 Aggregation</h3>
<p>聚合关系表示<strong>整体</strong>和<strong>部分</strong>的关系。<strong>成员对象</strong>是<strong>整体对象</strong>的一部分，但是成员对象<strong>可以脱离</strong>整体对象独立存在。</p>
<p>UML中，聚合关系用带<strong>空心菱形</strong>的直线表示。（空心菱形一端指向整体对象）。</p>
<p>汽车发动机可以脱离汽车独立存在</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210145448230.png" alt="image-20201210145448230"></p>
<p>代码实现聚合关系时，成员对象通常通过<strong>构造方法</strong>、Setter方法或业务方法的参数注入到整体对象中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Engine engine;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(Engine engine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEngine</span><span class="params">(Engine engine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组合关系-Composition"><a class="header-anchor" href="#组合关系-Composition"> </a>组合关系 Composition</h3>
<p>组合关系也表示类之间整体和部分的关系。</p>
<p>与<strong>聚合关系</strong>的区别在于，组合关系中的整体对象能够控制成员对象的声明周期。一旦整体对象不存在，成员对象也将不存在。</p>
<p>总而言之，聚合关系中的成员对象可以活着离开整体对象。组合关系中的成员对象不能离开整体对象。</p>
<p>UML中，组合关系用带<strong>实心菱形</strong>的直线表示</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210150154346.png" alt="image-20201210150154346"></p>
<p>在代码实现组合关系时，通常在<strong>整体类</strong>的<strong>构造方法</strong>中直接<strong>实例化</strong>成员类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Head</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Mouth mouth;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Head</span><span class="params">()</span>&#123;</span><br><span class="line">        mouth = <span class="keyword">new</span> <span class="title class_">Mouth</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="依赖关系-Dependency"><a class="header-anchor" href="#依赖关系-Dependency"> </a>依赖关系 Dependency</h3>
<p>依赖关系是一种<strong>使用关系</strong>。</p>
<p>在依赖关系中，某个事物如果发生了改变，则可能会影响到<strong>使用</strong>该事物的<strong>其他事物</strong></p>
<p>在需要表示<strong>一个事物使用另一个事物</strong>时，使用依赖关系</p>
<p>UML中，依赖关系使用<strong>带箭头的虚线</strong>表示，由<strong>依赖</strong>一方<strong>指向被依赖</strong>的一方。（使用的一方指向被使用的一方）</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210151227012.png" alt="image-20201210151227012"></p>
<p>Driver类中<code>drive(Car car)</code>方法中，需要<code>Car</code>类型的对象作为<strong>参数传入</strong>，并且在该方法中调用<code>Car.move</code>的方法。即<code>drive()</code>方法依赖<code>move()</code>方法，所以<code>Driver</code>依赖<code>Car</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">(Car car)</span>&#123;</span><br><span class="line">        car.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码实现时，依赖关系通常通过以下3中方法实现</p>
<ol>
<li>将一个类（被依赖）的<strong>对象</strong>作为另一个类（依赖）中的<strong>方法的参数</strong></li>
<li>在一个类（依赖）的方法中，将另一个类（被依赖）的对象作为其<strong>局部变量</strong></li>
<li>在一个类（依赖）的方法中调用另一个类（被依赖）的<strong>静态方法</strong></li>
</ol>
<h3 id="泛化关系-Generalization"><a class="header-anchor" href="#泛化关系-Generalization"> </a>泛化关系 Generalization</h3>
<p>泛化关系即<strong>继承</strong>关系。用于描述<strong>父类与子类</strong>之间的关系</p>
<p>在UML中，泛化关系用<strong>带空心三角形</strong>的直线表示。（由子类指向父类，即空心三角形位于父类一端）</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210152632642.png" alt="image-20201210152632642"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String studentNo;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String teacherNo;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口与实现关系"><a class="header-anchor" href="#接口与实现关系"> </a>接口与实现关系</h3>
<p>接口通常<strong>只有操作的声明</strong>，没有操作的实现</p>
<p>接口之间也存在<strong>继承</strong>关系和<strong>依赖</strong>关系</p>
<p>接口和<strong>类</strong>之间存在**实现（Realization）**关系</p>
<ul>
<li>类实现了接口</li>
<li>类中的操作实现了接口中所声明的操作</li>
</ul>
<p>在UML中，类与接口之间的<strong>实现关系</strong>用带<strong>空心三角形</strong>的虚线来表示</p>
<p><strong>接口interface</strong>的UML表示</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210160525640.png" alt="image-20201210160525640"></p>
<p>实现关系</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210160601204.png" alt="image-20201210160601204"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Vehicle</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面向对象设计原则"><a class="header-anchor" href="#面向对象设计原则"> </a>面向对象设计原则</h2>
<h3 id="目标"><a class="header-anchor" href="#目标"> </a>目标</h3>
<p><strong>可维护性复用</strong></p>
<ul>
<li>实现设计方案或源代码的<strong>重用</strong></li>
<li>确保系统易于<strong>扩展和维护</strong>，具有灵活性</li>
</ul>
<h3 id="单一职责原则（Single-Responsibility-Principle-SRP）"><a class="header-anchor" href="#单一职责原则（Single-Responsibility-Principle-SRP）"> </a>单一职责原则（Single Responsibility Principle,SRP）</h3>
<h4 id="定义-v2"><a class="header-anchor" href="#定义-v2"> </a>定义</h4>
<p>一个类<strong>只</strong>负责<strong>一个功能领域</strong>中的相应职责。或者说，就一个类而言，应该<strong>只有一个</strong>引起它<strong>变化的原因</strong></p>
<h4 id="作用要求"><a class="header-anchor" href="#作用要求"> </a>作用要求</h4>
<p>控制类的<strong>粒度大小</strong></p>
<ul>
<li>一个类承担的职责越多，它被复用的可能性就越小</li>
<li>一个类程度的职责过多，则职责耦合在一起。其中一个职责变化可能会影响到其他职责运作</li>
<li>应该将不同的职责封装在不同的类，即不同的变化原因封装在不同的类</li>
<li>如果多个职责总是同时发生改变则可以将它们封装在一个类中</li>
</ul>
<blockquote>
<p>单一职责原则是实现高内聚、低耦合的指导方针</p>
</blockquote>
<h4 id="实现"><a class="header-anchor" href="#实现"> </a>实现</h4>
<p>要判断一个类是否符合单一职责原则，可以考虑该类是否有不止一个引起它变化的原因，从而进行拆分。同时也要考虑到其他的类是否需要使用到当前类的方法。</p>
<h5 id="反例"><a class="header-anchor" href="#反例"> </a>反例</h5>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210173445512.png" alt="image-20201210173445512"></p>
<p><strong>修改后</strong></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210174414414.png" alt="image-20201210174414414"></p>
<h3 id="开闭原则（Open-Closed-Principle-OCP）"><a class="header-anchor" href="#开闭原则（Open-Closed-Principle-OCP）"> </a>开闭原则（Open-Closed Principle, OCP）</h3>
<h4 id="定义-v3"><a class="header-anchor" href="#定义-v3"> </a>定义</h4>
<p>软件实体应对<strong>扩展开放</strong>，而对<strong>修改关闭</strong>。即软件实体应尽量在不修改原有代码的情况下进行扩展</p>
<ul>
<li>这里的软件实体指<strong>一个软件模块</strong>、一个有多个类组成的<strong>局部结构</strong>或一个<strong>独立的类</strong></li>
</ul>
<h4 id="作用要求-v2"><a class="header-anchor" href="#作用要求-v2"> </a>作用要求</h4>
<p>开闭原则是面向对象的<strong>可复用设计</strong>的基石。</p>
<p>软件系统面临新的需求时，应该尽量保证系统的设计框架是稳定的。</p>
<ul>
<li>方便对系统进行扩展，且扩展时无须修改现有代码</li>
<li>使得软件系统在拥有<strong>适应性</strong>和<strong>灵活性</strong>的同时具备较好的<strong>稳定性</strong>和<strong>延续性</strong></li>
</ul>
<h4 id="实现-v2"><a class="header-anchor" href="#实现-v2"> </a>实现</h4>
<p><strong>抽象化</strong>是开闭原则的关键</p>
<p>需要对系统进行抽象化设计</p>
<ul>
<li>可以为系统定义相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成</li>
<li>例如接口定义抽象层，再由具体类进行扩展。而只需增加新的具体类来实现新的业务功能即可</li>
</ul>
<h3 id="里氏代换原则（Liskov-Substitution-Principle-LSP）"><a class="header-anchor" href="#里氏代换原则（Liskov-Substitution-Principle-LSP）"> </a>里氏代换原则（Liskov Substitution Principle,LSP）</h3>
<h4 id="定义-v4"><a class="header-anchor" href="#定义-v4"> </a>定义</h4>
<p>所有<strong>引用父类</strong>对象的地方能够透明地<strong>使用其子类</strong>的对象</p>
<blockquote>
<p>在软件中，将一个基类（父类）对象替换成它的子类对象，程序不会产生任何错误和异常，但反之不成立。</p>
</blockquote>
<h4 id="作用要求-v3"><a class="header-anchor" href="#作用要求-v3"> </a>作用要求</h4>
<p>里氏代换原则是实现开闭原则的重要方式之一。</p>
<ul>
<li>在程序中尽量使用<strong>基类类型</strong>来对对象进行<strong>定义</strong>，而在<strong>运行时</strong>，再确定其<strong>子类类型</strong>，用子类来替换父类对象</li>
<li>父类设计为抽象类或接口，让子类继承父类或实现父类接口，并实现在父类声明的方法。运行时子类实例替换父类实例，可以扩展系统的功能，无须修改原子类的代码</li>
</ul>
<h4 id="实现-v3"><a class="header-anchor" href="#实现-v3"> </a>实现</h4>
<p>在Java实现多态的时候，有着里氏代换原则的味道</p>
<h3 id="依赖倒转原则（Dependence-Inversion-Principle-DIP）"><a class="header-anchor" href="#依赖倒转原则（Dependence-Inversion-Principle-DIP）"> </a>依赖倒转原则（Dependence Inversion Principle,DIP）</h3>
<h4 id="定义-v5"><a class="header-anchor" href="#定义-v5"> </a>定义</h4>
<p>抽象<strong>不应该</strong>依赖于细节，细节应该依赖于抽象</p>
<p>要针对<strong>接口编程</strong>，而不是针对实现编程</p>
<h4 id="作用要求-v4"><a class="header-anchor" href="#作用要求-v4"> </a>作用要求</h4>
<p>依赖倒转原则是面向对象设计的主要实现机制之一，是<strong>系统抽象化</strong>的具体实现</p>
<p>依赖倒转原则要求在程序代码中，<strong>传递参数</strong>时或在<strong>关联关系</strong>中，尽量引用层次高的<strong>抽象层</strong>。即使用<strong>接口</strong>和<strong>抽象类</strong>进行<strong>变量类型声明</strong>、<strong>参数类型声明</strong>、<strong>方法返回类型声明</strong>以及<strong>数据类型的转换</strong>等，而不要用具体类做这些事。</p>
<p>一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法</p>
<p>在实现依赖倒置时，需要针对<strong>抽象层编程</strong>，而将<strong>具体的类对象</strong>通过**依赖注入（Dependency Injection，DI）**的方式，注入到其他对象中去。</p>
<p><strong>依赖注入</strong>：一个对象要与其他对象发生<strong>依赖关系</strong>时，通过<strong>抽象</strong>来注入所依赖的<strong>对象</strong></p>
<ul>
<li>构造注入
<ul>
<li>通过构造函数传入具体类的对象</li>
</ul>
</li>
<li>设值注入（Setter注入）
<ul>
<li>通过Setter方法来传入具体类的对象</li>
</ul>
</li>
<li>接口注入
<ul>
<li>通过实现在接口中声明的业务方法来传入具体类的对象</li>
</ul>
</li>
</ul>
<p>这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。</p>
<h4 id="实现-v4"><a class="header-anchor" href="#实现-v4"> </a>实现</h4>
<h5 id="反例-v2"><a class="header-anchor" href="#反例-v2"> </a>反例</h5>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210182814754.png" alt="image-20201210182814754"></p>
<h5 id="修改后"><a class="header-anchor" href="#修改后"> </a>修改后</h5>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210182840381.png" alt="image-20201210182840381"></p>
<ul>
<li>开闭原则是目标</li>
<li>里氏代换原则是基础</li>
<li>依赖倒转是手段</li>
</ul>
<h3 id="接口隔离原则（Interface-Segregation-Principle-ISP）"><a class="header-anchor" href="#接口隔离原则（Interface-Segregation-Principle-ISP）"> </a>接口隔离原则（Interface Segregation Principle,ISP）</h3>
<h4 id="定义-v6"><a class="header-anchor" href="#定义-v6"> </a>定义</h4>
<p>使用多个<strong>专门的接口</strong>，而<strong>不使用</strong>单一的<strong>总接口</strong>。</p>
<p>即客户端<strong>不应该依赖</strong>那些它<strong>不需要的接口</strong></p>
<p><strong>接口含义</strong></p>
<ol>
<li><strong>逻辑上</strong>的抽象：一个<strong>类型</strong>所具有的<strong>方法特征的集合</strong>
<ul>
<li>接口的划分带来<strong>类型</strong>的划分。一个接口只能代表一个角色，每个角色都有它特定的接口</li>
</ul>
</li>
<li>某种语言<strong>具体的“接口 ”定义</strong>，有严格的定义和结构
<ul>
<li>仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来</li>
</ul>
</li>
</ol>
<h4 id="作用要求-v5"><a class="header-anchor" href="#作用要求-v5"> </a>作用要求</h4>
<p>当一个接口<strong>太大时</strong>，需要将它<strong>分割</strong>成一些<strong>更细小的接口</strong>，使用该接口的客户端<strong>仅需知道</strong>与之相关的方法即可。</p>
<p>每一个接口应该承担<strong>一种相对独立</strong>的角色。</p>
<p>需要控制接口的粒度</p>
<ul>
<li>接口太小会导致接口泛滥，不利维护</li>
<li>接口太大会违背接口割离原则，灵活性差，使用不方便</li>
</ul>
<h4 id="解决问题"><a class="header-anchor" href="#解决问题"> </a>解决问题</h4>
<p>如果接口承担太多职责</p>
<ul>
<li>导致接口实现类庞大，需要实现接口中定义的所有方法</li>
<li>灵活性差，出现大量的空方法，导致系统产生大量的无用代码，影响代码质量</li>
<li>破坏程序的封装性</li>
</ul>
<h4 id="反例-v3"><a class="header-anchor" href="#反例-v3"> </a>反例</h4>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210185435843.png" alt="image-20201210185435843"></p>
<p><strong>解决后</strong></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210185446564.png" alt="image-20201210185446564"></p>
<h3 id="合成复用原则（Composite-Reuse-Principle-CRP）"><a class="header-anchor" href="#合成复用原则（Composite-Reuse-Principle-CRP）"> </a>合成复用原则（Composite Reuse Principle,CRP）</h3>
<h4 id="定义-v7"><a class="header-anchor" href="#定义-v7"> </a>定义</h4>
<p>合成复用原则又称**“组合/聚合复用原则（Composition/Aggregation Reuse Principle）&quot;**</p>
<p>尽量使用<strong>对象组合</strong>，而不是继承来达到复用的目的</p>
<h4 id="要求作用"><a class="header-anchor" href="#要求作用"> </a>要求作用</h4>
<p>合成复用原则是在一个新的对象里，通过<strong>关联关系（包括组合关系和聚合关系）<strong>来使用一些已有的对象，使之成为新对象的</strong>一部分</strong>。</p>
<p>新对象通过委派调用已有对象的方法来达到复用功能的目的。</p>
<blockquote>
<p>复用时，尽量使用组合/聚合关系（关联关系），少用继承</p>
</blockquote>
<h4 id="使用优点"><a class="header-anchor" href="#使用优点"> </a>使用优点</h4>
<p>复用已有的设计和实现的方法</p>
<ol>
<li>通过组合/聚合关系</li>
<li>通过继承</li>
</ol>
<p>组合/聚合可以使系统更加<strong>灵活</strong>，<strong>降低</strong>类与类之间的<strong>耦合度</strong>，一个类的变化对其他类造成的影响较小。</p>
<blockquote>
<p>使用继承时，需要严格遵循里氏代换原则</p>
</blockquote>
<blockquote>
<p>继承来进行复用的主要问题在于继承复用会破坏系统的<strong>封装性</strong>。因为继承会将基类实现<strong>细节暴露</strong>给子类。从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性</p>
</blockquote>
<h3 id="迪米特法则-（Law-of-Demeter-LoD）"><a class="header-anchor" href="#迪米特法则-（Law-of-Demeter-LoD）"> </a>迪米特法则 （Law of Demeter,LoD）</h3>
<h3 id="定义-v8"><a class="header-anchor" href="#定义-v8"> </a>定义</h3>
<p>一个软件实体应当<strong>尽可能少</strong>地与<strong>其他实体</strong>发生<strong>相互作用</strong></p>
<p>迪米特法则又称为<strong>最少知识原则（Least Knowledge Principle，LKP）</strong></p>
<h3 id="要求作用-v2"><a class="header-anchor" href="#要求作用-v2"> </a>要求作用</h3>
<p>如果一个系统符合迪米特法则，那么当其中<strong>某一个模块发生修改</strong>时，就会尽量<strong>少地影响其他</strong>模块，<strong>扩展</strong>会相对<strong>容易</strong>。</p>
<p>迪米特法则要求<strong>限制</strong>软件实体之间<strong>通信的宽度和深度</strong>。</p>
<p>不要和陌生人说话，只与<strong>直接朋友</strong>通信</p>
<p><strong>朋友包括</strong></p>
<ul>
<li>当前对象本身<code>this</code></li>
<li>以<strong>参数形式</strong>传入当前对象<strong>方法</strong>中的对象</li>
<li>当前对象的<strong>成员</strong>对象</li>
<li>如果当前对象的成员对象是一个<strong>集合</strong>，那么<strong>集合中的元素</strong>也都是朋友。</li>
<li>当前对象所<strong>创建的对象</strong>。</li>
</ul>
<p>能够降低系统的<strong>耦合度</strong></p>
<ul>
<li>可以通过引入第三者来降低现有对象之间的耦合</li>
</ul>
<p>在类的结构设计上，每一个类都应当尽量<strong>降低</strong>其<strong>成员变量</strong>和<strong>成员函数</strong>的<strong>访问权限</strong></p>
<h3 id="反例-v4"><a class="header-anchor" href="#反例-v4"> </a>反例</h3>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201211204406607.png" alt="image-20201211204406607"></p>
<p><strong>改善后</strong></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201211204422063.png" alt="image-20201211204422063"></p>
<h2 id="创建型模式-Creational-Pattern"><a class="header-anchor" href="#创建型模式-Creational-Pattern"> </a>创建型模式 Creational Pattern</h2>
<p>创建型模式关注对象的创建过程</p>
<p>将对象的<strong>创建</strong>和使用分离。</p>
<p>在使用对象时<strong>无须关心对象</strong>的<strong>创建细节</strong>，从而<strong>降低</strong>系统的耦合度，让设计方案更易于修改和扩展。</p>
<p><strong>创建模式回答三个问题</strong></p>
<ul>
<li>创建什么</li>
<li>由谁创建</li>
<li>何时创建</li>
</ul>
<h3 id="单例模式-Singleton-Pattern"><a class="header-anchor" href="#单例模式-Singleton-Pattern"> </a>单例模式 Singleton Pattern</h3>
<h4 id="定义-v9"><a class="header-anchor" href="#定义-v9"> </a>定义</h4>
<p>确保某一个类<strong>只有一个实例</strong>，而且<strong>自行实例化</strong>并向<strong>整个系统</strong>提供这个实例，这个类称为<strong>单例类</strong>，它提供<strong>全局访问的方法</strong>。</p>
<p><strong>三个要点</strong></p>
<ol>
<li>某个类只能有一个实例</li>
<li>它必须自行创建这个实例</li>
<li>它必须自行向整个系统提供这个实例</li>
</ol>
<h4 id="内容"><a class="header-anchor" href="#内容"> </a>内容</h4>
<p><strong>举例</strong>：Windows的任务管理器只能打开一个</p>
<p>单例模式的<strong>动机</strong>：确保对象的<strong>唯一性</strong></p>
<ul>
<li>节约系统资源</li>
<li>确保系统中的某个类只有唯一一个实例，该类创建成功后，<strong>无法再创建</strong>同类型的其它对象，所有操作都基于这个<strong>唯一实例</strong></li>
</ul>
<h4 id="单例模式创建过程"><a class="header-anchor" href="#单例模式创建过程"> </a>单例模式创建过程</h4>
<ol>
<li>将该类的<strong>构造器的可见性</strong>改成<code>private</code>
<ul>
<li>禁止类的外部直接使用<code>new</code>来创建对象，确保实例的唯一性</li>
</ul>
</li>
<li>在该类内部创建并<strong>保存</strong>这个<strong>唯一实例</strong>，
<ul>
<li>定义一个<strong>静态</strong>的该类型的<strong>私有成员变量</strong></li>
</ul>
</li>
<li>增加一个<strong>公有</strong>的<strong>静态方法</strong>
<ul>
<li>让外界使用该成员变量，同时需要解决实例化该成员变量的时机</li>
</ul>
</li>
</ol>
<p><strong>示例</strong></p>
<p>修改前</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TaskManager</span><span class="params">()</span>&#123;&#125; <span class="comment">//初始化窗口  构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayProcesses</span><span class="params">()</span> &#123;&#125; <span class="comment">//显示进程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayServices</span><span class="params">()</span>&#123;&#125; <span class="comment">//显示服务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">TaskManager</span> <span class="variable">tm</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">TaskManager</span><span class="params">()</span>&#123;&#125; <span class="comment">//初始化窗口  构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TaskManager <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tm == <span class="literal">null</span>)&#123;</span><br><span class="line">            tm = <span class="keyword">new</span> <span class="title class_">TaskManager</span>(); <span class="comment">//自行实例化</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayProcesses</span><span class="params">()</span> &#123;&#125; <span class="comment">//显示进程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayServices</span><span class="params">()</span>&#123;&#125; <span class="comment">//显示服务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释说明</p>
<ul>
<li><code>public static TaskManager getInstance()</code>首先应该声明为<code>public</code>，以便外界的其他对象访问。其次，应该声明为<code>static</code>，因为该类的构造器已经被声明为<code>private</code>，不能通过<code>new</code>来创建对象，外界可以直接通过类名来访问。</li>
<li>成员变量<code>private static TaskManager tm = null;</code>为什么需要声明为<strong>静态</strong>的呢？
<ul>
<li>首先，<code>getInstance()</code>的方式声明为<code>static</code>的，而<strong>静态方法</strong>中<strong>只能访问静态</strong>的<strong>成员变量</strong></li>
<li>其次，对于<strong>静态字段</strong>，即所有对象都会共享该类的静态字段，但是对于单例模式也只有唯一一个对象，这条作用不大</li>
</ul>
</li>
<li>这种方法叫做<strong>懒汉式单例</strong></li>
</ul>
<p><strong>单例模式结构图</strong></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201216163723612.png" alt="image-20201216163723612"></p>
<h4 id="懒汉式单例存在的问题"><a class="header-anchor" href="#懒汉式单例存在的问题"> </a>懒汉式单例存在的问题</h4>
<p>考虑以下情景</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//负载均衡器 单例类 待优化版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoadBalancer</span> &#123;</span><br><span class="line">    <span class="comment">//储存唯一实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">LoadBalancer</span> <span class="variable">loadBalancer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//服务器集合</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; serverList = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LoadBalancer</span><span class="params">()</span>&#123;</span><br><span class="line">        serverList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// ... (1)</span></span><br><span class="line">        <span class="comment">// ... more work</span></span><br><span class="line">        <span class="comment">// 接下来在真实环境中还有包括大量初始化的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LoadBalancer <span class="title function_">getLoadBalancer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(loadBalancer == <span class="literal">null</span>)&#123;</span><br><span class="line">            loadBalancer = <span class="keyword">new</span> <span class="title class_">LoadBalancer</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> loadBalancer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addServer</span><span class="params">(String server)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeServer</span><span class="params">(String server)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServer</span><span class="params">()</span>&#123;<span class="keyword">return</span> serverList.get(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(serverList.size()));&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>问题发现</strong></p>
<p>在<strong>多线程环境</strong>中,如果<em>线程A</em><strong>第一次</strong>调用<code>getLoadBalancer</code>方法创建并启动负载均衡器时，<code>if(loadBalancer == null)</code>这条语句判断为<code>true</code>，因此进入<strong>实例化</strong>的语句。</p>
<p>在实例化语句中，由于<code>LoadBalancer</code>的<strong>构造器</strong>中需要进行大量的初始化工作，需要<strong>一段时间</strong>才能够完成该操作。</p>
<p>而在此时（即唯一实例的负载均衡器还在创建但是没有创建完成的初始化过程中），如果<strong>另一个</strong><em>线程B</em>也再一次调用了<code>getLoadBalancer</code>方法。由于<em>线程A</em>还在初始化负载均衡器中，实际上该成员变量<code>loadBalancer</code>的值仍为<code>null</code>，因此<em>线程B</em>在<code>if(loadBalancer == null)</code>的条件判断也为<code>true</code>，因此<strong>也去实例化</strong>一个负载均衡器对象。</p>
<p>最终导致创建了多个instance对象，违背了单例模式的初衷，导致系统发生错误。</p>
<p>解决方式<strong>饿汉式单例类（Eager Singleton）<strong>和</strong>懒汉式单例类（Lazy Singleton）</strong></p>
<h4 id="饿汉式单例类"><a class="header-anchor" href="#饿汉式单例类"> </a>饿汉式单例类</h4>
<h5 id="实现方法"><a class="header-anchor" href="#实现方法"> </a>实现方法</h5>
<p>在<strong>定义</strong>静态变量的时候就<strong>实例化</strong>单例类，因此在<strong>类加载</strong>的时候就已经创建了单例对象</p>
<h5 id="实现代码-v3"><a class="header-anchor" href="#实现代码-v3"> </a>实现代码</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EagerSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">EagerSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EagerSingleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EagerSingleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>饿汉式单例结构图</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201216183951684.png" alt="image-20201216183951684"></p>
<h4 id="懒汉式单例类"><a class="header-anchor" href="#懒汉式单例类"> </a>懒汉式单例类</h4>
<p>懒汉式单例模式采用<strong>延时加载（Lazy load）技术</strong>，即需要的时候再加载实例</p>
<ul>
<li>懒汉式单例在<strong>第一次</strong>调用<code>getInstance</code>方法的时才<strong>实例化</strong></li>
<li>在<strong>类加载</strong>时并<strong>不自行实例化</strong></li>
</ul>
<p><strong>线程安全改进，但效率低下版本</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">LazySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相同形式不同写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">LazySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(LazySingleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解释说明</strong></p>
<ul>
<li>在<code>getInstance</code>方法前面增加<strong>关键字<code>synchronized</code><strong>进行</strong>线程锁定</strong>，以处理<strong>多线程同时访问</strong>问题</li>
</ul>
<p><strong>问题</strong></p>
<ul>
<li>每次调用<code>getInstance</code>方法都需要进行<strong>线程锁定判断</strong></li>
<li>在高并发访问的环境中，将会导致性能大大降低</li>
</ul>
<p><strong>改进思考</strong></p>
<p>无须对整个<code>getInstance</code>方法进行锁定，只是在条件判断<code>if(instance == null)</code>中会发生并发访问问题。</p>
<p><strong>只有</strong>实例<strong>不存在</strong>的时候，才需要创建实例，进行加锁实例化。是否可以在<code>if(instance == null)</code>内加锁？这样就可以在实例不为<code>null</code>，不进行<code>synchronized</code>判断。</p>
<p><strong>初步改进，但没有解决问题版本</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">LazySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(LazySingleton.class)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>问题说明</strong></p>
<p>单纯的将锁加在<code>instance = new LazySingleton();</code>中，仍会发生最上面写到的“懒汉式单例存在的问题”中所说的问题，即<strong>对象不唯一</strong>的问题。</p>
<p>当线程A和线程B都调用<code>getInstance()</code>时，如果实例还没创建，则都能通过<code>if (instance == null)</code>的判断。而线程A和线程B只是排队来调用<code>instance = new LazySingleton()</code>这句语句，结果是会产生不止一个实例对象。</p>
<p><strong>懒汉式单例类进一步改进</strong></p>
<p><strong>双重检查锁定（Double-Check Locking）</strong>：在<code>synchronized</code>锁定代码中，再进行一次<code>instance == null</code>判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">LazySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 第一重判断</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 锁定代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span>(LazySingleton.class)&#123;</span><br><span class="line">                <span class="comment">// 第二重判断</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u><strong>注意事项</strong></u></p>
<ul>
<li>使用<strong>双重检查锁定</strong>来实现懒汉式单例类，需要在静态成员变量<code>instance</code>加上修饰符<code>volatile</code>
<ul>
<li>被<code>volatile</code>修饰的成员变量可以确保<strong>多个线程正确处理</strong></li>
<li><code>volatile</code>关键字会屏蔽虚拟机的代码优化，可能会导致系统运行效率低</li>
</ul>
</li>
</ul>
<h4 id="饿汉式单例类和懒汉式单例类比较"><a class="header-anchor" href="#饿汉式单例类和懒汉式单例类比较"> </a>饿汉式单例类和懒汉式单例类比较</h4>
<p><strong>饿汉式单例类</strong></p>
<ul>
<li>在<strong>类被加载</strong>的时候就将自己实例化。</li>
<li><strong>优点</strong>
<ul>
<li>无须考虑多线程访问问题</li>
<li><strong>调用速度</strong>和<strong>反应时间</strong>优于懒汉式单例类</li>
</ul>
</li>
<li><strong>缺点</strong>
<ul>
<li>由于无论系统运行时是否需要使用该单例对象，都会创建，因此<strong>资源利用效率</strong>不及懒汉式单例类</li>
<li>系统加载时，需要创建饿汉式单例对象，加载时间会较长</li>
</ul>
</li>
</ul>
<p><strong>懒汉式单例类</strong></p>
<ul>
<li>在<strong>第一次使用</strong>时创建</li>
<li><strong>优点</strong>
<ul>
<li>无须一直占用系统资源，实现延迟加载</li>
</ul>
</li>
<li><strong>缺点</strong>
<ul>
<li>需要处理多线程同时访问的问题</li>
<li>资源初始化可能耗费大量时间，多线程同时首次引用的概率变大，需要通过双重检查锁等机制进行控制，系统性能收到影响。</li>
</ul>
</li>
</ul>
<h4 id="Initialization-on-Demand-Holder-（IoDH）"><a class="header-anchor" href="#Initialization-on-Demand-Holder-（IoDH）"> </a>Initialization on Demand Holder （IoDH）</h4>
<p>IoDH结合了<strong>懒汉式单例类</strong>和<strong>饿汉式单例类</strong>的优点</p>
<ul>
<li>既实现了<strong>延迟加载</strong>又保证<strong>线程安全</strong>，<strong>不影响系统性能</strong></li>
</ul>
<p><strong>实现方式</strong></p>
<p>单例类中定义一个<strong>静态内部类</strong>。在<strong>内部类</strong>中创建<strong>单例对象</strong>。通过<strong>外部类</strong>的<code>getInstance()</code>返回给外界。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialization on Demand</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HolderClass</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HolderClass.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解释说明</strong></p>
<ul>
<li><strong>静态单例对象</strong>没有作为<code>Singleton</code>的成员变量直接实例化，类加载时不会实例化<code>Singleton</code></li>
<li>第一次调用<code>getInstance()</code>会<strong>加载内部类</strong><code>HolderClass</code>。内部类中定义<code>static</code>类型变量<code>instance</code>，此时会<strong>首先初始化</strong>这个成员变量，由<strong>Java虚拟机保证线程安全</strong>，确保该成员变量只能初始化一次。</li>
<li><code>getInstance()</code>方法没有任何线程锁定，对性能不会造成影响</li>
</ul>
<h4 id="单例模式总结"><a class="header-anchor" href="#单例模式总结"> </a>单例模式总结</h4>
<p><strong>优点</strong></p>
<ul>
<li>单例模式提供了对<strong>唯一实例</strong>的<strong>受控访问</strong></li>
<li>节约系统资源
<ul>
<li>系统内存中只存在一个对象</li>
<li>对需要<strong>频繁创建和销毁的对象</strong>，单例模式提高性能</li>
</ul>
</li>
<li>基于单例模式的扩展，可以提供允许可变数目的实例（<strong>多例类</strong>）
<ul>
<li>既节省系统资源，又解决了由于<strong>单例对象共享过多有损性能</strong>的问题</li>
</ul>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>
<p>缺少抽象层，扩展性差</p>
</li>
<li>
<p>职责过重，一定程度上违背<strong>单一职责原则</strong></p>
<ul>
<li>即提供<strong>创建</strong>对象方法又提供<strong>业务</strong>方法（创建和本身功能<strong>耦合</strong>）</li>
</ul>
</li>
<li>
<p>由于垃圾回收机制，如果单例对象长时间没用，可能会被当垃圾回收。</p>
<ul>
<li>再次使用时重新实例化，原本的单例对象状态丢失</li>
</ul>
</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>只需要一个<strong>实例对象</strong>
<ul>
<li>例如唯一的序列号生成器、资源管理器</li>
<li>考虑<strong>资源消耗太大</strong>而只允许创建一个对象</li>
</ul>
</li>
<li>只需要一个公共访问点
<ul>
<li>除了该公共访问点，不能通过其他途径访问该实例</li>
</ul>
</li>
</ul>
<h3 id="简单工厂模式-Simple-Factory-Pattern"><a class="header-anchor" href="#简单工厂模式-Simple-Factory-Pattern"> </a>简单工厂模式 Simple Factory Pattern</h3>
<h4 id="定义-v10"><a class="header-anchor" href="#定义-v10"> </a>定义</h4>
<p>定义一个工厂类，它可以<strong>根据参数</strong>的不同<strong>返回不同类的实例</strong>，被创建的实例通常都具有<strong>共同的父类</strong>。</p>
<p>因为在简单工厂模式中用于<strong>创建实例</strong>的方法是静态(static)方法，因此<strong>简单工厂模式</strong>又被称为静态工厂方法(Static<br>
Factory Method)模式，它属于类创建型模式。</p>
<h4 id="内容-v2"><a class="header-anchor" href="#内容-v2"> </a>内容</h4>
<p>要点：需要什么，只需要<strong>传入</strong>一个正确的参数，就可以<strong>获取</strong>所需要的对象，而无须知道其创建细节。</p>
<ul>
<li><strong>客户端</strong>通过<strong>工厂类</strong>来创建一个产品类的实例，而<strong>无须直接使用new关键字</strong>来创建对象</li>
</ul>
<p><strong>简单工厂模式结构图</strong></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201224175352126.png" alt="image-20201224175352126"></p>
<p>简单工厂模式主要包含<strong>3</strong>种角色</p>
<ul>
<li><strong><code>Factory</code>(工厂角色)</strong>：即工厂类，它是<strong>简单工厂模式的核心</strong>，负责实现<strong>创建</strong>所有产品<strong>实例</strong>的内部逻辑。
<ul>
<li>工厂类<strong>可以被外界直接调用</strong>，<strong>创建</strong>所需的产品<strong>对象</strong>；</li>
<li>在工厂类中提供了<strong>静态的工厂方法</strong><code>factoryMethod()</code>,它的返回类型为<strong>抽象产品类型Product</strong>。</li>
</ul>
</li>
<li><strong><code>Product</code>(抽象产品角色)</strong>：它是工厂类所创建的所有<strong>对象的父类</strong>，<strong>封装了</strong>各种产品对象的<strong>公有方法</strong>.
<ul>
<li>提高系统的<strong>灵活性</strong>，使得在工厂类中只需<strong>定义</strong>一个<strong>通用</strong>的工厂方法，因为所有创建的具体产品对象都是其子类对象。</li>
</ul>
</li>
<li><strong><code>ConcreteProduct</code>(具体产品角色)</strong>：它是简单工厂模式的<strong>创建目标</strong>，所有被创建的对象都充当这个角色的某个<strong>具体类的实例</strong>。
<ul>
<li>每一个具体产品角色都<strong>继承了抽象产品角色</strong>，需要<strong>实现</strong>在抽象产品中声明的<strong>抽象方法</strong>。</li>
</ul>
</li>
</ul>
<h4 id="说明"><a class="header-anchor" href="#说明"> </a>说明</h4>
<ul>
<li>根据实际情况设计一个<strong>产品层次结构</strong>，将所有产品类<strong>公共的代码</strong>移至<strong>抽象产品类</strong>，并在抽象产品类中<strong>声明一些抽象方法</strong>，以供不同的具体产品类来实现</li>
<li>在<strong>没有工厂类之前</strong>，客户端一般会使用new `关键字来直接创建产品对象</li>
<li>在<strong>引人工厂类</strong>之后，客户端可以通过工厂类来创建产品，在简单工厂模式中，工厂类提供了一个<strong>静态工厂方法</strong>供客户端使用，根据所传入的参数不同可以创建不同的产品对象。</li>
</ul>
<h4 id="代码实现-v20"><a class="header-anchor" href="#代码实现-v20"> </a>代码实现</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodSame</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//公共方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">methodDiff</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProduct</span> <span class="keyword">extends</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="comment">//实现业务方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodDiff</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//业务方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="comment">//静态工厂方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title function_">getProduct</span><span class="params">(String arg)</span>&#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(arg.equalsIgnoreCase(<span class="string">&quot;A&quot;</span>))&#123;</span><br><span class="line">            product = <span class="keyword">new</span> <span class="title class_">ConcreteProductA</span>();</span><br><span class="line">            <span class="comment">//初始化设置product</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arg.equalsIgnoreCase(<span class="string">&quot;B&quot;</span>))&#123;</span><br><span class="line">            product = <span class="keyword">new</span> <span class="title class_">ConcreteProductB</span>();</span><br><span class="line">            <span class="comment">//初始化设置product</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Product product;</span><br><span class="line">        product = Factory.getProduct(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        product.methodSame();</span><br><span class="line">        product.methodDiff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建对象和使用对象"><a class="header-anchor" href="#创建对象和使用对象"> </a>创建对象和使用对象</h4>
<p><strong>对象</strong>相关的<strong>职责</strong>通常有3类</p>
<ul>
<li>对象<strong>本身</strong>所具有的职责
<ul>
<li>对象本身具有的<strong>数据</strong>和<strong>行为</strong>，可通过<strong>公开</strong>的方法来实现其职责。</li>
</ul>
</li>
<li><strong>创建</strong>对象的职责
<ul>
<li>创建对象的方式
<ol>
<li><code>new</code>关键字直接创建
<ul>
<li><code>new</code>简单。但是灵活性差：创建对象和使用对象耦合在一起，会违背开闭原则</li>
<li>解决办法是引入<strong>工厂类</strong>，降低因为产品或工厂类改变所带来的维护工作量</li>
</ul>
</li>
<li>通过<strong>反射机制</strong>创建对象</li>
<li>通过<code>clone()</code>方法创建对象</li>
<li>通过工厂类创建对象</li>
</ol>
</li>
</ul>
</li>
<li><strong>使用</strong>对象的职责</li>
</ul>
<p>工厂模式<strong>强调</strong>：将对象的<strong>创建</strong>和<strong>使用分离</strong></p>
<ul>
<li>
<p>只能A创建B或A使用B，不能两种关系都有</p>
<ul>
<li>这样更符合单一职责原则，有利于对功能的复用和系统的维护</li>
</ul>
</li>
<li>
<p>能够防止用来实例一个类的数据和代码在多个类到处都是</p>
<ul>
<li>构造对象还需要设置参数，环境配置等</li>
</ul>
</li>
<li>
<p>提供一系列<strong>名字不同</strong>的<strong>工厂方法</strong>，而每个工厂方法对应一个构造函数</p>
<ul>
<li>客服端可以以更加可读易懂的方法来创建对象</li>
</ul>
</li>
</ul>
<h4 id="简单工厂模式的简化"><a class="header-anchor" href="#简单工厂模式的简化"> </a>简单工厂模式的简化</h4>
<p>将<strong>抽象产品类</strong>和<strong>工厂类</strong>合并，将静态工厂方法移至抽象产品类</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201224201619925.png" alt="image-20201224201619925"></p>
<h4 id="简单工厂类总结"><a class="header-anchor" href="#简单工厂类总结"> </a>简单工厂类总结</h4>
<p><strong>优点</strong></p>
<ul>
<li>实现对象的创建和使用分离</li>
<li>客户端<strong>无须知道</strong>所创建的<strong>具体产品类的类名</strong>，只需要知道具体产品类所对应的<strong>参数</strong>即可</li>
<li>通过引人配置文件，可以在<strong>不修改客户端代码</strong>的情况下<strong>更换和增加</strong>新的<strong>具体产品类</strong>，在一定程度上<strong>提高了系统的灵活性</strong>。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>工厂类责任过重
<ul>
<li>集中所有产品的创建逻辑</li>
</ul>
</li>
<li>简单工厂模式会<strong>增加</strong>系统中<strong>类的个数</strong>
<ul>
<li>增加系统的复杂度和理解难度</li>
</ul>
</li>
<li>系统扩展困难
<ul>
<li>添加新产品需要修改工厂逻辑</li>
<li>产品类型过多时，造成工厂逻辑复杂，不利于系统的扩展和维护</li>
<li>使用了<strong>静态</strong>工厂方法，工厂角色无法形成基于继承的等级结构</li>
</ul>
</li>
</ul>
<p><strong>适用场景</strong></p>
<ul>
<li>工厂类负责创建的对象比较少</li>
<li>客户端<strong>只知道</strong>传入工厂类的<strong>参数</strong>，对于如何创建对象并不关心。</li>
</ul>
<h3 id="工厂方法模式-Factory-Method-Pattern"><a class="header-anchor" href="#工厂方法模式-Factory-Method-Pattern"> </a>工厂方法模式 Factory Method Pattern</h3>
<p>通常说的工厂模式指的是工厂方法模式</p>
<h4 id="定义-v11"><a class="header-anchor" href="#定义-v11"> </a>定义</h4>
<p>定义一个用于<strong>创建对象</strong>的<strong>接口</strong>，让<strong>子类</strong>决定将<strong>哪一个类</strong>实例化。工厂方法模式让一个类的<strong>实例化延迟</strong>到其子类。工厂方法模式又<br>
简称为<strong>工厂模式(Factory Pattern)</strong>,又可称作<strong>虚拟构造器模式(Virtual Constructor Pattern)<strong>或</strong>多态工厂模式(Polymorphic Factory Pattern)</strong>。工厂方法模式是一种类创建型模式。</p>
<h4 id="简单工厂模式存在的缺点"><a class="header-anchor" href="#简单工厂模式存在的缺点"> </a>简单工厂模式存在的缺点</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">    <span class="comment">//静态工厂方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title function_">createLogger</span> <span class="params">(String args)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(args.equalsIgnoreCase(<span class="string">&quot;db&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//连接数据库，代码省略</span></span><br><span class="line">            <span class="comment">//创建数据库日志记录器对象</span></span><br><span class="line">            <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatabaseLogger</span>();</span><br><span class="line">            <span class="comment">//初始化数据库日志记录器，代码省略</span></span><br><span class="line">            <span class="keyword">return</span> logger;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(args.equalsIgnoreCase(<span class="string">&quot;file&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//创建日志文件，代码省略</span></span><br><span class="line">            <span class="comment">//创建文件日志记录器对象</span></span><br><span class="line">            <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileLogger</span>();</span><br><span class="line">            <span class="comment">//初始化文件日志记录器，代码省略</span></span><br><span class="line">            <span class="keyword">return</span> logger;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然简单工厂模式将该对象的创建和使用分离，但存在以下两个问题</p>
<ul>
<li>工厂类过于庞大，包含大量<code>if lese</code>语句，导致维护和测试难道大</li>
<li>系统扩展不灵活，如果要增加新类型的日志记录器，必须修改静态工厂方法的业务逻辑，违反开闭原则</li>
</ul>
<p>而在<strong>工厂方法模式</strong>中，不再提供一个统一的工厂类来创建所有的产品对象，而是针对<strong>不同的产品</strong>提供<strong>不同的工厂</strong>，系统提供一个与产品等级结构对应的工厂等级结构</p>
<h4 id="内容-v3"><a class="header-anchor" href="#内容-v3"> </a>内容</h4>
<p>工厂方法模式提供一个<strong>抽象工厂接口</strong>来声明抽象工厂方法，而由其子类来<strong>具体实现工厂方法</strong>，创建<strong>具体的产品对象</strong>。</p>
<p>工厂模式结构图：</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210312090446928.png" alt="image-20210312090446928"></p>
<p>主要有4个角色：</p>
<ol>
<li>Product(抽象产品)：它是定义产品的<strong>接口</strong>，是工厂方法模式所创建对象的<strong>超类型</strong>，也就是产品对象的公共父类。</li>
<li>ConcreteProduct(具体产品)：它实现了<strong>抽象产品接口</strong>，某种类型的<strong>具体产品</strong>由专门的<strong>具体工厂</strong>创建，具体工厂和具体产品之间一一对应。</li>
<li>Factory(抽象工厂)：在抽象工厂类中，声明了工厂方法(Factory Method),用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该<strong>接口</strong>。</li>
<li>ConcreteFactory（具体工厂)：它是抽象工厂类的<strong>子类</strong>，实现了抽象工厂中定义的工厂方法，并可由<strong>客户端调用</strong>，返回一个具体产品类的实例。</li>
</ol>
<h4 id="代码实现-v21"><a class="header-anchor" href="#代码实现-v21"> </a>代码实现</h4>
<p>抽象工厂可以是接口，也可以是抽象类或者具体类。只是声明工厂方法，没有具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体产品对象的创建由抽象工厂类的实现类实现。在创建过程中，还可以负责对象的初始化，资源与环境的配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct</span> ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="工厂方法模式优点"><a class="header-anchor" href="#工厂方法模式优点"> </a>工厂方法模式优点</h4>
<ol>
<li>通过工厂方法创建所需的产品，同时隐藏具体产品类实现细节</li>
<li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键，工厂方法模式之所以又被称为多态工厂模式，正是因为所有的具体工厂类都具有同一抽象父类、</li>
<li>系统的可扩展性提高，符合开闭原则，在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以</li>
</ol>
<p><strong>主要缺点</strong></p>
<ol>
<li>增加新的产品，需要写新的具体产品类和具体工厂类，使得系统类的个数成对增加，增加系统复杂度，以及编译开销</li>
<li>客户端使用抽象层进行定义，增加系统的抽象性和理解难度</li>
</ol>
<p><strong>适用场景</strong></p>
<ul>
<li>客户端不知道其所需要的对象的类</li>
<li>抽象工厂类通过其子类来指定具体创建哪个对象：利用对象的多态和里氏代换原则</li>
</ul>
<h3 id="抽象工厂模式-Abstract-Factory-Pattern"><a class="header-anchor" href="#抽象工厂模式-Abstract-Factory-Pattern"> </a>抽象工厂模式 Abstract Factory Pattern</h3>
<p>工厂方法模式的缺点：每一个具体的工厂对应一个具体的产品。大量的工厂类，增加系统的开销</p>
<h4 id="定义-v12"><a class="header-anchor" href="#定义-v12"> </a>定义</h4>
<p>提供一个创建<strong>一系列</strong>相关或相互依赖对象的<strong>接口</strong>，而<strong>无须指定</strong>它们<strong>具体的类</strong>。抽象工厂模式又称为 Kit 模式，它是一种对象创建<br>
型模式。为创建一组对象提供了一种解决方案。</p>
<p><strong>概念</strong></p>
<ul>
<li>产品等级结构：产品等级结构即产品的继承结构。例如抽象电视机和具体品牌的电视机构成一个产品等级结构</li>
<li>产品族：指同一个工厂生产的，位于不同产品等级结构中的一组产品。例如海尔工厂生产的海尔电视机、海尔电冰箱等</li>
</ul>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210508141710004.png" alt="image-20210508141710004"></p>
<p>使用抽象工厂模式：当系统所提供的工厂生产的具体产品并不是一个简单的对象，而是位于多个产品等级结构、属于不同类型的具体产品时</p>
<p>抽象工厂模式包含4个角色：</p>
<ol>
<li>AbstractFactory（抽象工厂）：声明了一组用于创建一族产品的方法，每一个方法对应一种产品。</li>
<li>ConcreteFactory（具体工厂）：实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。</li>
<li>AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。</li>
<li>ConcreteProduct（具体产品）：定义具体工厂生产的具体产品对象，实现在抽象产品接口中声明业务方法</li>
</ol>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210508150529509.png" alt="image-20210508150529509"></p>
<p><strong>抽象工厂模式的开闭原则的倾斜性</strong>： 抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦。</p>
<ul>
<li>增加产品族。抽象工厂模式支持了开闭原则</li>
<li>增加新的产品等级结构。违背了开闭原则：需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法</li>
</ul>
<h3 id="原型模式-Prototype-Pattern"><a class="header-anchor" href="#原型模式-Prototype-Pattern"> </a>原型模式 Prototype Pattern</h3>
<h4 id="定义-v13"><a class="header-anchor" href="#定义-v13"> </a>定义</h4>
<p>使用<strong>原型实例</strong>指定<strong>创建对象的种类</strong>，并且通过<strong>复制</strong>这些<strong>原型</strong>创建新的对象。原型模式是一种对象创建型模式。</p>
<p><strong>工作原理：</strong></p>
<p>将一个<strong>原型对象</strong>传给那个<strong>要发动创建</strong>的对象，这个要发动创建的对象通过<strong>请求原型对象</strong>克隆自己来实现创建过程。创建克隆对象的<strong>工厂</strong>就是<strong>原型类自身</strong>，工厂方法由克隆方法来实现。</p>
<p><strong>注意：</strong></p>
<ul>
<li>通过克隆方法创建的对象是全新的对象
<ul>
<li>内存中拥有新的地址</li>
</ul>
</li>
<li>克隆产生的对象的修改不会对原型对象造成任何影响
<ul>
<li>克隆对象相互独立</li>
</ul>
</li>
</ul>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210512140621752.png" alt="image-20210512140621752"></p>
<p><strong>三种角色：</strong></p>
<ol>
<li>Prototype(抽象原型类)：声明<strong>克隆方法</strong>的接口，是所有具体原型类的<strong>公共父类</strong>，可以是<strong>抽象类</strong>、<strong>接口</strong>、<strong>具体实现类</strong>。</li>
<li>ConcretePrototype(具体原型类)：<strong>实现</strong>在抽象原型类中声明的<strong>克隆方法</strong>，在克隆方法中<strong>返回自己的一个克隆对象</strong>。</li>
<li>Client(客户类)：客户类中直接实例化或通过工厂方法等方式<strong>创建一个原型对象</strong>，再通过<strong>调用该对象的克隆方法</strong>即可得到克隆对象。</li>
</ol>
<blockquote>
<p>Java中，java.lang.Object类提供一个clone方法，但是要调用clone方法必须让该类实现<code>Cloneable</code>接口，并重写clone方法，否则灰抛出<code>CloneNotSupportedException</code>异常</p>
</blockquote>
<h4 id="浅拷贝（浅克隆）"><a class="header-anchor" href="#浅拷贝（浅克隆）"> </a>浅拷贝（浅克隆）</h4>
<ul>
<li>成员变量是值类型（基本数据类型）：复制一份</li>
<li>成员变量是引用类型：指向相同的内存地址</li>
</ul>
<h4 id="深拷贝（深克隆）"><a class="header-anchor" href="#深拷贝（深克隆）"> </a>深拷贝（深克隆）</h4>
<ul>
<li>无论成员变量是值类型还是引用类型都会复制一份</li>
</ul>
<p><strong>深拷贝的复制方式：</strong></p>
<p>可以通过序列化等方式实现。</p>
<p>序列化方式的深拷贝：将序列化对象写入一个流中，再从流里将其读出来</p>
<blockquote>
<p>注意：能够实现序列化的对象类必须实现<code>Serializable</code>接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用序列化技术实现深克隆</span></span><br><span class="line"><span class="keyword">public</span> WeeklyLog <span class="title function_">deepClone</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, OptionalDataException &#123;</span><br><span class="line">    <span class="comment">//将对象写入流中</span></span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">bao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>()；</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bao);</span><br><span class="line">    oos.writeObject(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">//将对象从流中取出</span></span><br><span class="line">    <span class="type">ByteArrayInputstream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bao.toByteArray());</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">    <span class="keyword">return</span> (WeeklyLog)ois.readobject();</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="建造者模式-Builder-Pattern"><a class="header-anchor" href="#建造者模式-Builder-Pattern"> </a>建造者模式 Builder Pattern</h3>
<h4 id="定义-v14"><a class="header-anchor" href="#定义-v14"> </a>定义</h4>
<p>将一个复杂对象的<strong>构建</strong>与它的<strong>表示分离</strong>，使得<strong>同样的构建过程</strong>可以<strong>创建不同的表示</strong></p>
<h2 id="结构型模式-Structural-Pattern"><a class="header-anchor" href="#结构型模式-Structural-Pattern"> </a>结构型模式 Structural Pattern</h2>
<h3 id="适配器模式-Adapter-Pattern"><a class="header-anchor" href="#适配器模式-Adapter-Pattern"> </a>适配器模式 Adapter Pattern</h3>
<h3 id="桥接模式-Bridge-Pattern"><a class="header-anchor" href="#桥接模式-Bridge-Pattern"> </a>桥接模式 Bridge Pattern</h3>
<h3 id="组合模式-Composite-Pattern"><a class="header-anchor" href="#组合模式-Composite-Pattern"> </a>组合模式 Composite Pattern</h3>
<h3 id="装饰模式-Decorator-Pattern"><a class="header-anchor" href="#装饰模式-Decorator-Pattern"> </a>装饰模式 Decorator Pattern</h3>
<h3 id="外观模式-Facade-Pattern"><a class="header-anchor" href="#外观模式-Facade-Pattern"> </a>外观模式 Facade Pattern</h3>
<h3 id="享元模式-Flyweight-Pattern"><a class="header-anchor" href="#享元模式-Flyweight-Pattern"> </a>享元模式 Flyweight Pattern</h3>
<h3 id="代理模式-Proxy-Pattern"><a class="header-anchor" href="#代理模式-Proxy-Pattern"> </a>代理模式 Proxy Pattern</h3>
<h2 id="行为型模式-Behavioral-Pattern"><a class="header-anchor" href="#行为型模式-Behavioral-Pattern"> </a>行为型模式 Behavioral Pattern</h2>
<h3 id="职责链模式-Chain-of-Responsibility-Pattern"><a class="header-anchor" href="#职责链模式-Chain-of-Responsibility-Pattern"> </a>职责链模式 Chain of Responsibility Pattern</h3>
<h3 id="命令模式-Command-Pattern"><a class="header-anchor" href="#命令模式-Command-Pattern"> </a>命令模式 Command Pattern</h3>
<h3 id="解释器模式-Interpreter-Pattern"><a class="header-anchor" href="#解释器模式-Interpreter-Pattern"> </a>解释器模式 Interpreter Pattern</h3>
<h3 id="迭代器模式-Iterator-Pattern"><a class="header-anchor" href="#迭代器模式-Iterator-Pattern"> </a>迭代器模式 Iterator Pattern</h3>
<h3 id="中介者模式-Mediator-Pattern"><a class="header-anchor" href="#中介者模式-Mediator-Pattern"> </a>中介者模式 Mediator Pattern</h3>
<h3 id="备忘录模式-Memento-Pattern"><a class="header-anchor" href="#备忘录模式-Memento-Pattern"> </a>备忘录模式 Memento Pattern</h3>
<h3 id="观察者模式-Observer-Pattern"><a class="header-anchor" href="#观察者模式-Observer-Pattern"> </a>观察者模式 Observer Pattern</h3>
<h3 id="状态模式-State-Pattern"><a class="header-anchor" href="#状态模式-State-Pattern"> </a>状态模式 State Pattern</h3>
<h3 id="策略模式-Strategy-Pattern"><a class="header-anchor" href="#策略模式-Strategy-Pattern"> </a>策略模式 Strategy Pattern</h3>
<h3 id="模板方法模式-Template-Method-Pattern"><a class="header-anchor" href="#模板方法模式-Template-Method-Pattern"> </a>模板方法模式 Template Method Pattern</h3>
<h3 id="访问者模式-Visitor-Pattern"><a class="header-anchor" href="#访问者模式-Visitor-Pattern"> </a>访问者模式 Visitor Pattern</h3>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag"><i class="fa fa-tag"></i> 设计模式</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/11/11/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%80%94%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/" rel="prev" title="Java核心技术—对象与类">
                  <i class="fa fa-chevron-left"></i> Java核心技术—对象与类
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/11/14/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%80%94%E7%BB%A7%E6%89%BF/" rel="next" title="Java核心技术—继承">
                  Java核心技术—继承 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">闽ICP备2021001502号 </a>
      <img src="/images/%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" alt=""><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=35058202000501" rel="noopener" target="_blank">闽公网安备 35058202000501号 </a>
  </div>

<div class="copyright">
  &copy; 2020 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-seedling"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZQB</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">598k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">16:36</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/comments.js"></script><script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/utils.js"></script><script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/motion.js"></script><script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/next-boot.js"></script><script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/bookmark.js"></script>

  
<script src="https://unpkg.com/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/third-party/search/local-search.js"></script>



  <script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/third-party/fancybox.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://unpkg.com/mathjax@3.2.1/es5/tex-mml-chtml.js","integrity":"sha256-hlC2uSQYTmPsrzGZTEQEg9PZ1a/+SV6VBCTclohf2og="}}</script>
<script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://unpkg.com/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"qibinaoe","repo":"blog-comments","client_id":"157704bd238da130367f","client_secret":"b0bc6368a8d8c75ba5562dabf654a38242c9600f","admin_user":"qibinaoe","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://unpkg.com/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"2bd986909097e7692e96311ab383ef64"}</script>
<script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/third-party/comments/gitalk.js"></script>

</body>
</html>
