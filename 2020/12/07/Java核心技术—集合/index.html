<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#f3a683"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-bin.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-bin.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-bin.png">
  <link rel="mask-icon" href="/images/logo-bin.svg" color="#f3a683">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"qibinaoe.top","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":true,"color":"#FF8B8B","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/config.js"></script>

    <meta name="description" content="Java核心技术书中有关集合框架的学习记录">
<meta property="og:type" content="article">
<meta property="og:title" content="Java核心技术—集合">
<meta property="og:url" content="http://qibinaoe.top/2020/12/07/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%80%94%E9%9B%86%E5%90%88/index.html">
<meta property="og:site_name" content="学习记录之家">
<meta property="og:description" content="Java核心技术书中有关集合框架的学习记录">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20201207164318982.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20201208100844986.png">
<meta property="article:published_time" content="2020-12-07T01:17:52.000Z">
<meta property="article:modified_time" content="2022-06-08T05:00:10.775Z">
<meta property="article:author" content="ZQB">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Java核心技术">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://algorithm-image.qibinaoe.top/image-20201207164318982.png">


<link rel="canonical" href="http://qibinaoe.top/2020/12/07/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%80%94%E9%9B%86%E5%90%88/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://qibinaoe.top/2020/12/07/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%80%94%E9%9B%86%E5%90%88/","path":"2020/12/07/Java核心技术—集合/","title":"Java核心技术—集合"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java核心技术—集合 | 学习记录之家</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">学习记录之家</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">better and better</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook/" rel="section"><i class="fa fa-book fa-fw"></i>留言板</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="nav-number">1.</span> <span class="nav-text">Java集合框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E7%A6%BB"><span class="nav-number">1.1.</span> <span class="nav-text">接口和实现分离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Collection%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.2.</span> <span class="nav-text">Collection接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-v2"><span class="nav-number">1.3.</span> <span class="nav-text">迭代器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.</span> <span class="nav-text">集合框架的接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E5%9F%BA%E6%9C%AC%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.1.</span> <span class="nav-text">集合基本接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Collection%E5%92%8CMap"><span class="nav-number">2.1.1.</span> <span class="nav-text">Collection和Map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#List"><span class="nav-number">2.1.2.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ListIterator"><span class="nav-number">2.1.3.</span> <span class="nav-text">ListIterator</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8-LinkedList"><span class="nav-number">2.2.</span> <span class="nav-text">链表 LinkedList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8-ArrayList"><span class="nav-number">2.3.</span> <span class="nav-text">数组列表 ArrayList</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList%E4%B8%8EVector"><span class="nav-number">2.3.1.</span> <span class="nav-text">ArrayList与Vector</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-v3"><span class="nav-number">2.4.</span> <span class="nav-text">HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E9%9B%86-HashSet"><span class="nav-number">2.4.1.</span> <span class="nav-text">散列集 HashSet</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeSet-%E6%A0%91%E9%9B%86"><span class="nav-number">2.5.</span> <span class="nav-text">TreeSet 树集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97-Queue-%E5%92%8C-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97-Deque"><span class="nav-number">2.6.</span> <span class="nav-text">队列 Queue 和  双端队列 Deque</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-PriorityQueue"><span class="nav-number">2.7.</span> <span class="nav-text">优先队列 PriorityQueue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%A0%E5%B0%84-map"><span class="nav-number">3.</span> <span class="nav-text">映射 map</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">3.1.</span> <span class="nav-text">基本操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E6%98%A0%E5%B0%84%E6%9D%A1%E7%9B%AE"><span class="nav-number">3.2.</span> <span class="nav-text">更新映射条目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%B1%E6%95%A3%E5%88%97%E6%98%A0%E5%B0%84-WeakHashMap"><span class="nav-number">3.3.</span> <span class="nav-text">弱散列映射 WeakHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">3.3.1.</span> <span class="nav-text">工作原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E6%95%A3%E5%88%97%E9%9B%86%E4%B8%8E%E6%98%A0%E5%B0%84-LinkedHashSet-LinkedHashMap"><span class="nav-number">3.4.</span> <span class="nav-text">链接散列集与映射 LinkedHashSet LinkedHashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E9%9B%86%E4%B8%8E%E6%98%A0%E5%B0%84-EnumSet-EnumMap"><span class="nav-number">3.5.</span> <span class="nav-text">枚举集与映射 EnumSet EnumMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AF%86%E6%95%A3%E5%88%97%E6%98%A0%E5%B0%84-IdentityHashMap"><span class="nav-number">3.6.</span> <span class="nav-text">标识散列映射 IdentityHashMap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE%E4%B8%8E%E5%8C%85%E8%A3%85%E5%99%A8"><span class="nav-number">4.</span> <span class="nav-text">视图与包装器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E8%8C%83%E5%9B%B4"><span class="nav-number">4.1.</span> <span class="nav-text">子范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E4%BF%AE%E6%94%B9%E8%A7%86%E5%9B%BE"><span class="nav-number">4.2.</span> <span class="nav-text">不可修改视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E8%A7%86%E5%9B%BE"><span class="nav-number">4.3.</span> <span class="nav-text">同步视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E5%9E%8B%E8%A7%86%E5%9B%BE"><span class="nav-number">4.4.</span> <span class="nav-text">检查型视图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="nav-number">5.1.</span> <span class="nav-text">泛型算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">5.2.</span> <span class="nav-text">排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">5.3.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">5.4.</span> <span class="nav-text">集合与数组的转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%97%E7%95%99%E7%9A%84%E9%9B%86%E5%90%88"><span class="nav-number">6.</span> <span class="nav-text">遗留的集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashTable%E7%B1%BB"><span class="nav-number">6.1.</span> <span class="nav-text">HashTable类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE-Enumeration"><span class="nav-number">6.2.</span> <span class="nav-text">枚举 Enumeration</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E6%98%A0%E5%B0%84-Properties"><span class="nav-number">6.3.</span> <span class="nav-text">属性映射 Properties</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88-Stack"><span class="nav-number">6.4.</span> <span class="nav-text">栈 Stack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E9%9B%86-BitSet"><span class="nav-number">6.5.</span> <span class="nav-text">位集 BitSet</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZQB"
      src="/images/me_avatar.png">
  <p class="site-author-name" itemprop="name">ZQB</p>
  <div class="site-description" itemprop="description">Better Me</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/qibinaoe" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;qibinaoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:780891896@qq.com" title="E-Mail → mailto:780891896@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://gagalab.tech/" title="https:&#x2F;&#x2F;gagalab.tech&#x2F;" rel="noopener" target="_blank">嘎嘎研究所</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://qibinaoe.top/2020/12/07/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%80%94%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me_avatar.png">
      <meta itemprop="name" content="ZQB">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习记录之家">
      <meta itemprop="description" content="Better Me">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java核心技术—集合 | 学习记录之家">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java核心技术—集合
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-07 09:17:52" itemprop="dateCreated datePublished" datetime="2020-12-07T09:17:52+08:00">2020-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-08 13:00:10" itemprop="dateModified" datetime="2022-06-08T13:00:10+08:00">2022-06-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>32k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>53 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="Java集合框架"><a class="header-anchor" href="#Java集合框架"> </a>Java集合框架</h2>
<h3 id="接口和实现分离"><a class="header-anchor" href="#接口和实现分离"> </a>接口和实现分离</h3>
<p>Java集合类库将**接口（interface）<strong>与</strong>实现（implementation）**分离。</p>
<ul>
<li>Java中定义了相应的接口
<ul>
<li><code>public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123;...&#125;</code></li>
</ul>
</li>
<li>具体的实现类继承了该接口</li>
<li>循环数组队列可以使用<code>ArrayDeque</code>类</li>
<li>链表队列使用<code>LinkedList</code>类</li>
</ul>
<!-- more -->
<p>可以使用<strong>接口类型</strong>存放集合引用。</p>
<p>只有在构造集合对象的时候才会使用具体的类，在使用的时候不需要关心是何种方式实现的</p>
<p>有一组名字以<code>Abstract</code>开头的类，例如<code>AbstractQueue</code>，这些类是为<strong>类库实现者</strong>设计的</p>
<h3 id="Collection接口"><a class="header-anchor" href="#Collection接口"> </a>Collection接口</h3>
<p>集合类的基本接口是<code>Collection</code>接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;E&gt; &#123;</span><br><span class="line">    Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>add方法用于向集合 添加元素
<ul>
<li>添加元素改变了集合返回true；如果集合没有发生变化，返回false。</li>
<li>集（set）如果对象已存在则返回false</li>
</ul>
</li>
<li>iterator方法返回一个实现了<code>Iterator</code>接口的对象，该迭代器对象依次访问集合中的元素</li>
</ul>
<h3 id="迭代器-v2"><a class="header-anchor" href="#迭代器-v2"> </a>迭代器</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the next element in the iteration.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the next element in the iteration</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException if the iteration has no more elements</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@implSpec</span></span></span><br><span class="line"><span class="comment">     * The default implementation throws an instance of</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> UnsupportedOperationException&#125; and performs no other action.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if the &#123;<span class="doctag">@code</span> remove&#125;</span></span><br><span class="line"><span class="comment">     *         operation is not supported by this iterator</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalStateException if the &#123;<span class="doctag">@code</span> next&#125; method has not</span></span><br><span class="line"><span class="comment">     *         yet been called, or the &#123;<span class="doctag">@code</span> remove&#125; method has already</span></span><br><span class="line"><span class="comment">     *         been called after the last call to the &#123;<span class="doctag">@code</span> next&#125;</span></span><br><span class="line"><span class="comment">     *         method</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;remove&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>返回调用<code>next</code>方法可以逐个访问集合中的每个元素</p>
<p>到达了<strong>集合末尾</strong>，next方法会抛出<code>NoSuchElementException</code></p>
<p>在调用<code>next</code>之前调用<code>hasNext</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c = ...;</span><br><span class="line">Iterator&lt;String&gt; iter = c.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> iter.next();</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“for each”循环转换为带有迭代器的循环</p>
<p>因此&quot;for each&quot;循环可以处理任何<strong>实现了<code>Iterable</code>接口的对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String element : c)&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>Collection</code>接口扩展了<code>Iterable</code>接口，因此标准类库的任何集合都可以使用for each循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="built_in">this</span>) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> Spliterator&lt;T&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>调用<code>forEachRemaining</code>方法并提供lambda表达式来处理每一个元素，直到没有元素为止</p>
<p><code>iterator.forEachRemaing(element -&gt; do something with element);</code></p>
<p><strong>访问元素的顺序取决于集合类型</strong></p>
<ul>
<li>HashSet会按照基本上随机的顺序获得元素</li>
</ul>
<blockquote>
<p>Iterator接口的next和hasNext方法和Enumeration接口的nextElement和hasMoreElements方法作用一样</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Enumeration</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasMoreElements</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    E <span class="title function_">nextElement</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java迭代器的<strong>查找操作</strong>和<strong>位置变更</strong>紧密<strong>耦合</strong></p>
<ul>
<li>查找一个元素的唯一方法是调用<code>next</code>，查找操作的同时，迭代器的位置就会随之向前移动</li>
<li>可以认为Java迭代器位于两个元素之间，调用<code>next</code>时，迭代器就越过下一个元素。并返回刚刚越过的那个元素的引用</li>
</ul>
<p>next方法和remove方法调用之间存在<strong>依赖性</strong></p>
<ul>
<li>
<p>Iterator接口的 remove方法将会删除上次调用<code>next</code>方法时<strong>返回的元素</strong></p>
<ul>
<li>
<p>如果想删除指定位置上的元素，仍然需要越过这个元素</p>
</li>
<li>
<p>如果调用remove之前没有调用next，将是不合法的</p>
</li>
<li>
<pre><code class="language-JAVA">it.remove();
if.remove();//ERROR
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 泛型实用方法</span><br><span class="line"></span><br><span class="line">Collection和Iterator是泛型接口</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;</span><br><span class="line">    int size();</span><br><span class="line">    boolean isEmpty();</span><br><span class="line">    boolean contains(Object o);</span><br><span class="line">    Iterator&lt;E&gt; iterator();</span><br><span class="line">    Object[] toArray();</span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br><span class="line">    boolean add(E e);</span><br><span class="line">    boolean remove(Object o);</span><br><span class="line">    boolean containsAll(Collection&lt;?&gt; c);</span><br><span class="line">    boolean addAll(Collection&lt;? extends E&gt; c);</span><br><span class="line">    boolean removeAll(Collection&lt;?&gt; c);</span><br><span class="line">    default boolean removeIf(Predicate&lt;? super E&gt; filter) &#123;</span><br><span class="line">        Objects.requireNonNull(filter);</span><br><span class="line">        boolean removed = false;</span><br><span class="line">        final Iterator&lt;E&gt; each = iterator();</span><br><span class="line">        while (each.hasNext()) &#123;</span><br><span class="line">            if (filter.test(each.next())) &#123;</span><br><span class="line">                each.remove();</span><br><span class="line">                removed = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return removed;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean retainAll(Collection&lt;?&gt; c);</span><br><span class="line">    void clear();</span><br><span class="line">    boolean equals(Object o);</span><br><span class="line">    int hashCode();</span><br><span class="line">    @Override</span><br><span class="line">    default Spliterator&lt;E&gt; spliterator() &#123;</span><br><span class="line">        return Spliterators.spliterator(this, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default Stream&lt;E&gt; stream() &#123;</span><br><span class="line">        return StreamSupport.stream(spliterator(), false);</span><br><span class="line">    &#125;</span><br><span class="line">    default Stream&lt;E&gt; parallelStream() &#123;</span><br><span class="line">        return StreamSupport.stream(spliterator(), true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
<p>还有一个叫做<code>public abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; </code>类，实现了大部分<code>Collection</code>接口的方法，来方便实现者</p>
<p>但是可以在Collection添加默认方法，也可以达到同样的效果</p>
<h2 id="集合框架的接口"><a class="header-anchor" href="#集合框架的接口"> </a>集合框架的接口</h2>
<p>Java集合框架中接口的关系，其中箭头表示继承关系（<code>extends</code>）</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201207164318982.png" alt="image-20201207164318982"></p>
<h3 id="集合基本接口"><a class="header-anchor" href="#集合基本接口"> </a>集合基本接口</h3>
<h4 id="Collection和Map"><a class="header-anchor" href="#Collection和Map"> </a>Collection和Map</h4>
<p>集合有两个基本接口<code>Collection</code>（集合）和<code>Map</code>（映射）</p>
<ul>
<li>集合插入元素<code>boolean add(E element)</code></li>
<li>集合读取元素，可以用迭代器访问元素</li>
<li>映射（Map）包含键/值对
<ul>
<li>用<code>put</code>方法插入 :   <code>V put(K key, V value);</code></li>
<li>用<code>get</code>方法读取值:   <code>V get(K key)</code></li>
</ul>
</li>
</ul>
<h4 id="List"><a class="header-anchor" href="#List"> </a>List</h4>
<p><code>List</code>是一个<strong>有序集合（ordered collection）</strong>。</p>
<p>元素会增加到容器中的特定位置</p>
<p>访问元素方式</p>
<ul>
<li>迭代器方法
<ul>
<li>必须<strong>按顺序访问</strong>元素</li>
</ul>
</li>
<li>整数索引方法
<ul>
<li>又称<strong>随机访问（random access）</strong>，可以<strong>任意顺序</strong>访问元素</li>
</ul>
</li>
</ul>
<p><code>List</code>中随机访问的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span></span><br></pre></td></tr></table></figure>
<h4 id="ListIterator"><a class="header-anchor" href="#ListIterator"> </a>ListIterator</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ListIterator</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterator</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>
<p><code>ListIterator</code>接口是<code>Iterator</code>的一个子接口。它定义了一个方法用于在迭代器位置前面增加一个元素<code>void add(E element)</code></p>
<p>两种有序集合</p>
<ul>
<li>
<p>数组支持的有序集合</p>
<ul>
<li>可以快速地随机访问</li>
<li>适合使用List方法并提供一个整数索引访问</li>
</ul>
</li>
<li>
<p>链表支持的有序集合</p>
<ul>
<li>
<p>随机访问很慢</p>
</li>
<li>
<p>最好使用迭代器遍历</p>
</li>
<li>
<p>但是<code>LinkedList</code>仍然继承了<code>List</code>接口</p>
</li>
<li>
<pre><code class="language-JAVA">public class LinkedList&lt;E&gt;
    extends AbstractSequentialList&lt;E&gt;
    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### Set</span><br><span class="line"></span><br><span class="line">集（Set）接口等同于`Collection`接口。但是集的方法的行为有更严谨的定义</span><br><span class="line"></span><br><span class="line">- `add`方法不允许增加重复元素</span><br><span class="line">- `equals`方法：只要两个集包含同样到元素就是相等，而不要求元素需要有同样的顺序</span><br><span class="line">- `hashCode`方法定义要保证包含相同元素的两个集会得到相同的散列码</span><br><span class="line"></span><br><span class="line">#### SortedSet和SortedMap</span><br><span class="line"></span><br><span class="line">`SortedSet`和`SortedMap`接口提供用于排序的比较器对象。定义了可以得到集合子集视图的方法。</span><br><span class="line"></span><br><span class="line">#### NavigableSet和NavigableMap</span><br><span class="line"></span><br><span class="line">Java6引入了`NavigableSet`和`NavigableMap`接口，包含一些用于搜索和遍历有序集和映射的方法。</span><br><span class="line"></span><br><span class="line">`TreeSet`和`TreeMap`类实现了这些接口。</span><br><span class="line"></span><br><span class="line">## 具体集合</span><br><span class="line"></span><br><span class="line">除了以`Map`结尾的类之外，其他类都实现了`Collection`接口。以`Map`结尾的类实现了`Map`接口</span><br><span class="line"></span><br><span class="line">| 集合类型        | 描述                                             |</span><br><span class="line">| --------------- | ------------------------------------------------ |</span><br><span class="line">| ArrayList       | 可以**动态**增加和缩减的一个**索引**序列         |</span><br><span class="line">| LinkedList      | 可以在任何位置**高效插入和删除**的一个有序序列   |</span><br><span class="line">| ArrayDeque      | 实现为**循环数组**的一个**双端队列**             |</span><br><span class="line">| HashSet         | 没有重复元素的一个**无序**集合                   |</span><br><span class="line">| TreeSet         | 一个**有序**集                                   |</span><br><span class="line">| EnumSet         | 一个包含**枚举类型**值的集                       |</span><br><span class="line">| LinkedHashSet   | 一个可以**记住元素插入次序**的集                 |</span><br><span class="line">| PriorityQueue   | 允许高效**删除最小元素**的一个集合               |</span><br><span class="line">| HashMap         | 存储键/值关联的一个数据结构                      |</span><br><span class="line">| TreeMap         | **键有序**的一个映射                             |</span><br><span class="line">| EnumMap         | 键属于**枚举类型**的一个映射                     |</span><br><span class="line">| LinkedHashMap   | 可以**记住键/值项添加次序**的一个映射            |</span><br><span class="line">| WeakHashMap     | 值不会再别处使用时就可以被**垃圾回收**的一个映射 |</span><br><span class="line">| IdentityHashMap | 用`==`而不是用equals比较键的一个映射             |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 集合框架中的类</span><br><span class="line"></span><br><span class="line">![image-20201207213253315](http://algorithm-image.qibinaoe.top/image-20201207213253315.png)</span><br><span class="line"></span><br><span class="line">![image-20201207215131415](http://algorithm-image.qibinaoe.top/image-20201207215131415.png)</span><br><span class="line"></span><br><span class="line">书上P376页图9-5中，对于`ArrayQueue`的位置有些偏差</span><br><span class="line"></span><br><span class="line">```Java</span><br><span class="line">public class ArrayQueue&lt;T&gt; extends AbstractList&lt;T&gt;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="链表-LinkedList"><a class="header-anchor" href="#链表-LinkedList"> </a>链表 LinkedList</h3>
<p>数组和数组列表（ArrayList）缺点：从中间删除或插入元素的开销大</p>
<p>Java中，所有链表实际上都是**双向链接（doubly linked）**的。每个链接存放着其前驱的引用。</p>
<p><code>LinkedList.add</code>方法将对象添加到链表的<strong>尾部</strong></p>
<p>对于插入链表中间，由于迭代器描述集合的位置，可以通过迭代器完成该操作</p>
<ul>
<li>只有对自然有序的集合使用迭代器添加元素才有实际意义</li>
<li>set数据类型是无序的，因此<code>Iterator</code>接口中没有<code>add</code>方法</li>
</ul>
<p><code>ListIterator</code>继承<code>Iterator</code>，包含了<code>add</code>方法</p>
<p>这里<code>add</code>方法与<code>Collection.add</code>不同，不返回<code>boolean</code>类型，假定add操作总会改变链表</p>
<p>同时<code> E previous();</code>和<code>boolean hasPrevious();</code>可以反向遍历链表</p>
<ul>
<li><code>previous</code>方法返回<strong>跨越</strong>过的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ListIterator</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    E <span class="title function_">previous</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">previousIndex</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LinkedList</code>类的<code>listIterator</code>方法返回一个实现了<code>ListIterator</code>接口的迭代器对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> listIterator(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ListIterator</code>的<code>add</code>方法在迭代器位置<strong>之前</strong>添加一个新的对象，注意可以认为迭代器的位置在两个元素之间</p>
<p>一个刚由<code>listIterator</code>方法返回并指向链表表头的迭代器调用<code>add</code>，新添加的元素成为链表的新表头</p>
<p>在迭代器越过链表的最后一个元素（即hasNext()返回false），添加元素称为链表新的表尾</p>
<p>如果链表有n个元素，则有n+1的位置可以 添加新元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|ABC</span><br><span class="line">A|BC</span><br><span class="line">AB|C</span><br><span class="line">ABC|</span><br></pre></td></tr></table></figure>
<p>如果一个迭代器在修改集合，另一个在遍历集合，则会出现混乱</p>
<ul>
<li><code>ListIterator</code>可以检测到这种修改</li>
<li>如果一个迭代器发现它的集合被另一个迭代器修改了，或是该集合自身的某个方法修改了（就是集合变了的意思），就会抛出<code>ConcurrentModificationException</code>异常</li>
<li>集合可以跟踪更改操作（添加或删除元素）的次数，每个迭代器都会为它负责的更改操作<strong>维护</strong>一个<strong>单独</strong>的<strong>更改操作数</strong>。
<ul>
<li>在迭代器被调用方法的开始，迭代器会检查它自己的更改操作数是否和集合的更改操作数相等。不一致就抛出<code>ConcurrentModificationException</code></li>
<li>链表只跟踪对列表的<strong>结构性修改</strong>，例如添加和删除<strong>链接</strong>
<ul>
<li><code>set</code>方法不被视为结构性修改</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><code>contains</code>方法检测某个元素是否出现在链表中</p>
<p><strong>链表不支持快速随机访问</strong></p>
<ul>
<li>如果要查看链表中的第n个元素，就得从头开始，越过n-1个元素（<code>get</code>方法进行优化：如果索引大于<code>size()/2</code>，则从列表后端向前搜索元素）</li>
</ul>
<p><strong><u>划重点</u></strong>：不要用下面这种虚假的效率极低的随机访问遍历列表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++)</span><br><span class="line">    <span class="keyword">do</span> something with list.get(i);</span><br></pre></td></tr></table></figure>
<p>列表迭代器能够告诉当前位置的索引：由于Java迭代器指向两个元素之间的位置，所以有两个索引</p>
<ul>
<li><code>nextIndex</code>返回下一次调用<code>next</code>方法时返回元素的整数索引</li>
<li><code>previousIndex</code>返回下一次调用<code>previous</code>方法时返回元素的整数索引</li>
<li><code>list.listIterator(n).next()</code>和<code>list.get(n)</code>会产生同一个元素</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>
<p>区别迭代器<code>ListIterator</code>的<code>add</code>和集合本身的<code>add</code>的区别</p>
</li>
<li>
<p>迭代器的<code>add</code>是在迭代器<strong>之前</strong>的位置添加的</p>
<ul>
<li>原本<code>A|BCD</code></li>
<li>调用add后（新增个P）</li>
<li><code>AP|BCD</code>注意迭代器的位置</li>
</ul>
</li>
<li>
<p>调用迭代器的<code>remove</code>方法是删除<code>next</code>方法或者<code>previous</code>方法返回的那个元素</p>
<ul>
<li>因此调用next()后，remove方法删除的是迭代器左侧的元素</li>
<li>调用previous后，remove方法删除的是迭代器右侧的元素</li>
</ul>
</li>
<li>
<p>同<code>remove</code>一样，迭代器的<code>set</code>方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; a = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">a.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">a.add(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">a.add(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">ListIterator&lt;String&gt; iterator = a.listIterator();</span><br><span class="line">System.out.println(a);<span class="comment">//[one, two, three]</span></span><br><span class="line">iterator.next();</span><br><span class="line">iterator.remove();</span><br><span class="line">System.out.println(a);<span class="comment">//[two, three]</span></span><br><span class="line">iterator.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(a);<span class="comment">//[aaa, two, three]</span></span><br><span class="line">iterator.previous();</span><br><span class="line">iterator.remove();</span><br><span class="line">System.out.println(a);<span class="comment">//[two, three]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; a = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">a.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">a.add(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">a.add(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">ListIterator&lt;String&gt; iterator = a.listIterator();</span><br><span class="line">System.out.println(a);<span class="comment">//[one, two, three]</span></span><br><span class="line">iterator.next();</span><br><span class="line">iterator.set(<span class="string">&quot;yi&quot;</span>);</span><br><span class="line">System.out.println(a);<span class="comment">//[yi, two, three]</span></span><br><span class="line">iterator.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(a);<span class="comment">//[yi, aaa, two, three]</span></span><br><span class="line">iterator.previous();</span><br><span class="line">iterator.set(<span class="string">&quot;ooo&quot;</span>);</span><br><span class="line">System.out.println(a);<span class="comment">//[yi, ooo, two, three]</span></span><br></pre></td></tr></table></figure>
<h3 id="数组列表-ArrayList"><a class="header-anchor" href="#数组列表-ArrayList"> </a>数组列表 ArrayList</h3>
<p><code>List</code>接口用于描述一个有序集合，并且集合中每个元素的位置很重要。</p>
<p>访问元素的协议</p>
<ul>
<li>通过迭代器</li>
<li>通过<code>get</code>和<code>set</code>方法随机地访问每个元素</li>
</ul>
<p><code>ArrayList</code>封装了一个动态再分配的对象数组</p>
<h4 id="ArrayList与Vector"><a class="header-anchor" href="#ArrayList与Vector"> </a><code>ArrayList</code>与<code>Vector</code></h4>
<ul>
<li>Vetor类的所有方法都是同步的
<ul>
<li>可以安全地从两个线程发访问一个Vector对象</li>
<li>只从一个线程访问Vector的话，代码会在同步操作浪费大量时间</li>
</ul>
</li>
<li>ArrayList方法不是同步的</li>
</ul>
<h3 id="HashMap-v3"><a class="header-anchor" href="#HashMap-v3"> </a>HashMap</h3>
<ul>
<li>链表和数组允许指定元素次序，但是不知道具体位置则需要访问所有元素</li>
</ul>
<p>如果不在意元素顺序，能够快速查找元素（缺点就是无法控制元素出现的次序）</p>
<ul>
<li>散列表（hash table）
<ul>
<li>为每个<strong>对象</strong>计算一个整数</li>
</ul>
</li>
<li>散列码（hash code）
<ul>
<li>对象的实例字段得出的整数</li>
</ul>
</li>
</ul>
<p>在Java中，散列表用链表数组实现。每个<strong>列表</strong>被称为<strong>桶（bucket）</strong></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201208100844986.png" alt="image-20201208100844986"></p>
<p>要查找表中对象的位置</p>
<ul>
<li>先计算出该对象的散列码</li>
<li>散列码与<strong>桶的总数取余</strong></li>
<li>得到结果为保存该元素的桶的索引</li>
</ul>
<p>**散列冲突（hash collision）**要插入元素时，桶已经被填充了。这时需要将新对象与桶中所有对象进行比较，查看这个对象是否存在。</p>
<ul>
<li>如果散列码合理地随机分布，桶的数目足够大，需要比较的次数就会少</li>
</ul>
<p>在Java8中，桶满时会从<strong>链表</strong>变成<strong>平衡二叉树</strong>。</p>
<ul>
<li>散列函数选择不好，发生很多冲突。</li>
<li>恶意代码试图在散列表中填充多个相同散列码的值</li>
<li>这种情况下，改成平衡二叉树能提高性能</li>
</ul>
<p><strong>桶数</strong>是用于收集有<strong>相同散列值</strong>的桶的<strong>数目</strong>（相同散列值的对象放在同一个桶中）（散列表的索引即为桶的索引）</p>
<p>可以指定一个初始的桶数</p>
<p>桶数设置为预计元素个数的75%~150%，标准类库使用的桶数试试2的幂，默认是16</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap.java</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment">     * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment">     * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap.java</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment">     * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment">     * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment">     * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">//HashMap内部维护一个Node数组，同时该数组长度为2的幂</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap.java</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment">     * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next; <span class="comment">// 可以看到这是一条链表</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>再散列（reshashed）</strong></p>
<ul>
<li>如果散列太慢，就需要再散列</li>
<li>创建一个桶数更多的表，将所有元素插入到新表，然后丢弃原来的表</li>
<li>装填因子（load factor）：确定何时对散列表进行再散列
<ul>
<li>如果装填因子为0.75（默认值），说明表中已经填满了75%以上，就会<strong>自动</strong>再散列，新表的桶数是原来的<strong>两倍</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap.java</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap.java</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment">     * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">     * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">     * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">     * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">        <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="literal">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong><u>注意</u></strong></p>
<ul>
<li>HashMap和HashTable区别？</li>
</ul>
<h4 id="散列集-HashSet"><a class="header-anchor" href="#散列集-HashSet"> </a>散列集 HashSet</h4>
<p>集是没有重复元素的</p>
<p>集允许快速地查找现有的元素。但是要查找一个元素，需要有所要查找的那个元素的<strong>准确副本</strong></p>
<ul>
<li>集的add方法要先在集中查找要添加的对象，如果不存在，就添加这个对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map; <span class="comment">// HashSet内部维护一个HashMap</span></span><br><span class="line">     </span><br><span class="line">    ...</span><br><span class="line">         </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line">   	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>contains</code>方法用来快速查找某个元素是否已经在，它只查看<strong>一个桶</strong>中的元素，不必查看集合中的所有元素</p>
<p><strong>散列集迭代器</strong>会依次访问所有的桶</p>
<p><u><strong>注意</strong></u></p>
<ul>
<li>HashSet是一个Set，存的是对象，而不是键值对（虽然HashSet里维护着一个HashMap）</li>
</ul>
<h3 id="TreeSet-树集"><a class="header-anchor" href="#TreeSet-树集"> </a>TreeSet 树集</h3>
<p>树集是一个有序集合（sorted collection）。</p>
<p>可以以<strong>任意顺序</strong>将元素<strong>插入</strong>到集合中。在对集合进行遍历时，值将自动地按照<strong>排序后的顺序</strong>呈现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableSet</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;String&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">ts.add(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">ts.add(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">ts.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">System.out.println(ts); <span class="comment">// [apple, cat, dog]</span></span><br><span class="line"><span class="keyword">for</span>(String s : ts) System.out.println(s); <span class="comment">//apple cat dog</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>要使用树集TreeSet，<strong>必须</strong>能够比较元素。</p>
<p>这些元素必须实现Comparable接口，或者构造集时，必须提供一个Comparator</p>
</blockquote>
<p>错误示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeSet&lt;Who&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        ts.add(<span class="keyword">new</span> <span class="title class_">Who</span>(<span class="string">&quot;cool&quot;</span>)); <span class="comment">//ERROR java.lang.ClassCastException : CollectionTest.Who cannot be cast to java.lang.Comparable</span></span><br><span class="line">        ts.add(<span class="keyword">new</span> <span class="title class_">Who</span>(<span class="string">&quot;good&quot;</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> <span class="title class_">Who</span>(<span class="string">&quot;bad&quot;</span>));</span><br><span class="line">        System.out.println(ts);</span><br><span class="line">        <span class="keyword">for</span>(Who s : ts) System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Who</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Who</span><span class="params">(String n)</span>&#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Who&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提供 <code>Comparator</code></p>
<ul>
<li><code>TreeSet&lt;Who&gt; ts = new TreeSet&lt;&gt;((Who w1,Who w2) -&gt;w1.getName().compareTo(w2.getName()) );</code></li>
</ul>
<p><code>TreeSet</code>中的排序时用**红黑树（red-black tree）**实现的。</p>
<p>每次将一个元素添加到树中时，都会将其放置在正确的排序位置上。因此迭代器总是以有序的顺序访问每个元素。</p>
<p>将一个元素添加到树中要比<strong>添加</strong>到散列表中<strong>慢</strong>。</p>
<p>与<strong>检查</strong>数组或链表中的<strong>重复元素</strong>相比，使用树会<strong>快很多</strong>。</p>
<p>查找新元素的正确位置平均需要logn次比较。</p>
<p>如果不需要数据是有序的，就没有必要付出排序的开销。</p>
<h3 id="队列-Queue-和-双端队列-Deque"><a class="header-anchor" href="#队列-Queue-和-双端队列-Deque"> </a>队列 Queue 和  双端队列 Deque</h3>
<ul>
<li>
<p>队列允许高效地在尾部添加元素，并在头部删除元素。</p>
</li>
<li>
<p>双端队列允许在头部和尾部都高效地添加或删除元素</p>
</li>
<li>
<p>队列不支持在中间添加元素</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Deque</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Queue</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable			</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDeque</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;E&gt;</span><br><span class="line">                           <span class="keyword">implements</span> <span class="title class_">Deque</span>&lt;E&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>
<p>Queue中定义的方法</p>
<ul>
<li><code>boolean add(E element)</code></li>
<li><code>boolean offer(E element)</code>
<ul>
<li>如果队列没满，给定的元素添加到队列的队尾，并返回true。</li>
<li>如果队列已满，<code>add</code>方法将抛出<code>IllegalStateException</code>；<code>offer</code>方法返回false</li>
</ul>
</li>
<li><code>E remove()</code></li>
<li><code>E poll()</code>
<ul>
<li>如果队列不为空，删除并返回这个队列队头元素</li>
<li>如果队列为空，<code>remove</code>方法抛出<code>NoSuchElementException</code>；<code>poll</code>方法返回<code>null</code></li>
</ul>
</li>
<li><code>E element()</code></li>
<li><code>E peek()</code>
<ul>
<li>如果队列不为空，返回这个队列队头的元素，但不删除</li>
<li>如果队列为空，<code>element</code>方法抛出<code>NoSuchElementException</code>；<code>peek</code>方法返回<code>null</code></li>
</ul>
</li>
</ul>
<p>Deque中定义的方法也类似Queue定义的一样，也是成对出现的，同时分别为头位置和位位置定义方法</p>
<ul>
<li><code>void addFirst(E e)</code></li>
<li><code>void addLast(E e)</code></li>
<li><code>boolean offerFirst(E e)</code></li>
<li><code>boolean offerLast(E e)</code></li>
<li><code>E removeFirst()</code></li>
<li><code>E removeLast()</code></li>
<li><code>E pollFirst()</code></li>
<li><code>E pollLast()</code></li>
<li><code>E getFirst()</code></li>
<li><code>E getLast()</code></li>
<li><code>E peekFirst()</code></li>
<li><code>E peekLast()</code></li>
</ul>
<h3 id="优先队列-PriorityQueue"><a class="header-anchor" href="#优先队列-PriorityQueue"> </a>优先队列 PriorityQueue</h3>
<p>优先队列中的元素可以按<strong>任意顺序插入</strong>，但是会按照<strong>有序的顺序</strong>进行<strong>检索</strong></p>
<p>即调用<code>remove</code>方法，总会获得当前优先队列中<strong>最小的元素</strong></p>
<p>优先队列并没有对所有元素进行排序。</p>
<p>如果迭代处理这些元素，并不需要对它进行排序（看下方代码）</p>
<p>优先队列使用了堆（heap）（堆是自组织的二叉树），在添加（add）或删除（remove）操作可以让最小元素移动到根，而不必花费时间对元素进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;LocalDate&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">pq.add(LocalDate.of(<span class="number">1902</span>,<span class="number">12</span>,<span class="number">9</span>));</span><br><span class="line">pq.add(LocalDate.of(<span class="number">1804</span>,<span class="number">12</span>,<span class="number">29</span>));</span><br><span class="line">pq.add(LocalDate.of(<span class="number">1992</span>,<span class="number">2</span>,<span class="number">7</span>));</span><br><span class="line">pq.add(LocalDate.of(<span class="number">1202</span>,<span class="number">2</span>,<span class="number">9</span>));</span><br><span class="line"><span class="keyword">for</span>(LocalDate date : pq) System.out.println(date);<span class="comment">// 1202-02-09 1804-12-29 1992-02-07 1902-12-09</span></span><br><span class="line"><span class="keyword">while</span> (!pq.isEmpty()) System.out.println(pq.remove()); <span class="comment">// 1202-02-09 1804-12-29 1902-12-09 1992-02-07</span></span><br></pre></td></tr></table></figure>
<p>代码可以发现，add操作后，堆顶总是最小元素。而remove操作的时候，堆顶也总是最小元素</p>
<p>优先队列的典型用法是任务调度。每个任务都有一个优先级，任务以随机顺序添加到队列中。每次启动一个新的任务时，都将优先级最高的任务从队列中删除。</p>
<p><strong><u>注意</u></strong></p>
<ul>
<li>与TreeSet一样，优先队列既可以保存实现<code>Comparable</code>接口的类对象，也可以保存构造器中提供的<code>Comparator</code>对象
<ul>
<li>实践发现，如果没有实现这些接口，优先队列添加一个元素，还是能够正常保存，但是添加两个元素就抛出<code>java.lang.ClassCastException: CollectionTest.Who cannot be cast to java.lang.Comparable</code></li>
</ul>
</li>
</ul>
<h2 id="映射-map"><a class="header-anchor" href="#映射-map"> </a>映射 map</h2>
<h3 id="基本操作"><a class="header-anchor" href="#基本操作"> </a>基本操作</h3>
<p>映射用来存放<strong>键/值对</strong></p>
<p>Java类库位映射提供了两个通用的实现<code>HashMap</code>和<code>TreeMap</code>。这两个类都实现了<code>Map</code>接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取与键关联的值；返回与键关联的对象，如果映射中没有这个对象，则返回null。</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得与键关联的值；返回与键关联的对象，如果未在映射中找到这个键，则返回defaultValue</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? defaultValue : e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将关联的一对键和值放入映射中，如果这个键已经存在，新的对象将取代与这个键关联的旧对象。这个方法将返回键关联的旧值。如果之前没有这个键，则返回null。</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        putMapEntries(m, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getNode(hash(key), key) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对这个映射中的所有键/值对应用这个动作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> K, ? <span class="built_in">super</span> V&gt; action)</span> &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableMap</span>&lt;K,V&gt;, Cloneable, java.io.Serializable&#123;</span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">()</span> &#123;</span><br><span class="line">        comparator = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        comparator = <span class="literal">null</span>;</span><br><span class="line">        putAll(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        comparator = m.comparator();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            buildFromSorted(m.size(), m.entrySet().iterator(), <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">firstKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key(getFirstEntry());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">lastKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key(getLastEntry());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>散列映射（HashMap）对<strong>键</strong>进行<strong>散列</strong></p>
<p>树映射（TreeMap）根据键的顺序将元素组织为一个搜索树</p>
<p><strong>散列</strong>或<strong>比较函数</strong>只应用于<strong>键</strong>，与键关联的值不进行散列或比较</p>
<ul>
<li>这句话的意思是，对于HashMap，散列只对key键进行散列，value是什么不会影响到散列</li>
<li>对于TreeMap，里面元素的比较，只会比较键。</li>
</ul>
<p>散列稍微快些，如果<strong>不需要</strong>按照<strong>有序</strong>的顺序<strong>访问键</strong>，最好选择<strong>散列映射</strong>。</p>
<p>要想检索一个对象，必须<strong>使用键</strong></p>
<p>迭代处理映射的键和值，使用<code>forEach</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((k,v)-&gt;</span><br><span class="line">           System.out.println(<span class="string">&quot;key=&quot;</span> + k + <span class="string">&quot;, valaue=&quot;</span> + v));</span><br></pre></td></tr></table></figure>
<p><u><strong>注意</strong></u>：</p>
<ul>
<li>TreeMap同TreeSet和PriorityQueue一样，需要要么存入的Key实现<code>Comparable</code>接口或者提供<code>Comparator</code>给构造器</li>
</ul>
<h3 id="更新映射条目"><a class="header-anchor" href="#更新映射条目"> </a>更新映射条目</h3>
<p>对于一个映射进行更新value操作：<code>counts.put(word,counts.get(word)+1)</code>。如果是第一次放入word，则会返回null而报出空指针异常。</p>
<p>解决办法</p>
<ul>
<li>
<pre><code class="language-java">counts.put(word,counts.getOrDefault(word,0)+1);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  counts.putIfAbsent(word,0);</span><br><span class="line">  counts.put(word,counts.get(word)+1);</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li>
<pre><code class="language-java">counts.merge(word,1,Integer::sum); // 如果键原先不存在，则存入(word,1)，否则使用Integer::sum函数组合原值和1
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 映射视图</span><br><span class="line"></span><br><span class="line">映射的视图（view）是实现了`Collection`接口或某个子接口的对象</span><br><span class="line"></span><br><span class="line">有3种视图：键集、值集合（由于值元素不一定唯一，所以不是集）、键/值对集。</span><br><span class="line"></span><br><span class="line">方法：</span><br><span class="line"></span><br><span class="line">```Java</span><br><span class="line">Set&lt;K&gt; keySet()</span><br><span class="line">Collection&lt;V&gt; values()</span><br><span class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()    </span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<p>枚举一个映射的所有键</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; keys = map.keySet();</span><br><span class="line"><span class="keyword">for</span>( String key : keys)&#123;</span><br><span class="line">	<span class="keyword">do</span> something wwith key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, Employee&gt; entry : staff.entrySet())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">k</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">v</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    <span class="keyword">do</span> something with k, v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((k,v))</span><br></pre></td></tr></table></figure>
<p>声明的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line">        Set&lt;K&gt; ks = keySet;</span><br><span class="line">        <span class="keyword">if</span> (ks == <span class="literal">null</span>) &#123;</span><br><span class="line">            ks = <span class="keyword">new</span> <span class="title class_">KeySet</span>();</span><br><span class="line">            keySet = ks;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span> &#123;</span><br><span class="line">    Collection&lt;V&gt; vs = values;</span><br><span class="line">    <span class="keyword">if</span> (vs == <span class="literal">null</span>) &#123;</span><br><span class="line">        vs = <span class="keyword">new</span> <span class="title class_">Values</span>();</span><br><span class="line">        values = vs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="literal">null</span> ? (entrySet = <span class="keyword">new</span> <span class="title class_">EntrySet</span>()) : es;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在<strong>键集视图</strong>上调用<strong>迭代器</strong>的<code>remove</code>方法，实际上会从映射中删除这个<strong>键</strong>和与它<strong>关联的值</strong></p>
<p><strong>不能</strong>向<strong>键集视图</strong>中<strong>添加元素</strong></p>
<ul>
<li>试图调用<code>add</code>方，会抛出一个<code>UnsupportedOperationException</code></li>
</ul>
<p><strong>映射条目集视图</strong>也有同样的限制</p>
<p>三种视图都可以删除元素，但是不可以添加元素</p>
<p>对于<code>Map.Entry</code></p>
<ul>
<li><code>K getKey()</code></li>
<li><code>V getValue()</code></li>
<li><code>V setValue(V newValue)</code>
<ul>
<li>将相关映射中的值改为新值，并返回原来的值</li>
</ul>
</li>
</ul>
<h3 id="弱散列映射-WeakHashMap"><a class="header-anchor" href="#弱散列映射-WeakHashMap"> </a>弱散列映射 WeakHashMap</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakHashMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt; &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reference queue for cleared WeakEntries</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Expunges stale entries from the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">expungeStaleEntries</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object x; (x = queue.poll()) != <span class="literal">null</span>; ) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, table.length);</span><br><span class="line"></span><br><span class="line">                Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">                Entry&lt;K,V&gt; p = prev;</span><br><span class="line">                <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">                    Entry&lt;K,V&gt; next = p.next;</span><br><span class="line">                    <span class="keyword">if</span> (p == e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (prev == e)</span><br><span class="line">                            table[i] = next;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            prev.next = next;</span><br><span class="line">                        <span class="comment">// Must not null out e.next;</span></span><br><span class="line">                        <span class="comment">// stale entries may be in use by a HashIterator</span></span><br><span class="line">                        e.value = <span class="literal">null</span>; <span class="comment">// Help GC</span></span><br><span class="line">                        size--;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;Object&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakReference</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Reference</span>&lt;T&gt;</span><br></pre></td></tr></table></figure>
<p><code>WeakHashMap</code>解决的问题：在映射中的一个值，它对应的键已经不在程序中的任何地方使用，即对于某个键的最后一个引用已经消失，那么不再有任何途径可以引用这个值的对象了。<strong>但是</strong>，由于程序中的没有这个<strong>键</strong>，就无法从映射中删除这个键/值对了。</p>
<p>而垃圾回收器会<strong>跟踪</strong>活动的对象。只要<strong>映射对象</strong>是活动的，则其中所有的桶都是活动的，所以它们不能被回收。</p>
<p><code>WeakHashMap</code>：当对<strong>键</strong>的唯一引用来自散列表映射条目时，这个数据结构将于垃圾回收器协同工作一起删除键/值对</p>
<h4 id="工作原理"><a class="header-anchor" href="#工作原理"> </a>工作原理</h4>
<p><code>WeakHashMap</code>使用**弱引用（weak references）**保存键。</p>
<p><code>WeakReference</code>对象将包含<strong>另一个对象的引用</strong>（这里时一个散列表的键）。</p>
<p>垃圾回收器采用一种特有的方式处理这种类型对象。</p>
<ul>
<li>正常情况下，如果垃圾回收器发现某个对象已经没有他人引用了，就将其回收。</li>
<li>如果一个对象只能由<code>WeakReference</code>引用，垃圾回收器也会将其回收，但会将引用这个对象的弱引用放入一个队列。
<ul>
<li><code>WeakHashMap</code>周期性的检查队列，以便找出新添加的弱引用。</li>
<li>一个弱引用进入队列意味着这个<strong>键</strong>不再被他人使用，并且已经回收，<code>WeakHashMap</code>将删除先关联的映射条目</li>
</ul>
</li>
</ul>
<h3 id="链接散列集与映射-LinkedHashSet-LinkedHashMap"><a class="header-anchor" href="#链接散列集与映射-LinkedHashSet-LinkedHashMap"> </a>链接散列集与映射 LinkedHashSet LinkedHashMap</h3>
<p><code>LinkedHashSet</code>和<code>LinkedHashSMap</code>类会记住插入<strong>元素项</strong>的顺序，避免散列表中的项看起来顺序是随机的。</p>
<p>在表中插入元素项时，就会并入到双向链表中</p>
<p>链接散列表映射可以使用访问呢顺序，而不是插入顺序来迭代处理映射条目。</p>
<ul>
<li>每次调用<code>get</code>或<code>put</code>时，收到影响的项将从当前的位置删除，并放到项链表的尾部。
<ul>
<li><strong>只影响</strong>项在<strong>链表</strong>中的<strong>位置</strong>，而<strong>散列表的桶不会受影响</strong>。映射条目总是在键散列码对应的桶中。</li>
</ul>
</li>
</ul>
<p>访问顺序对实现缓存的“最近最少使用”原则十分重要。</p>
<ul>
<li>将访问频率高的元素放入内存，而访问频率低的元素从数据库中读取</li>
<li>当表中找不到元素项而且表相当满时，可以得到迭代器并删除它，枚举的前几个元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可重写<code>removeEldestEntry</code>来实现自动删除eldest项</p>
<h3 id="枚举集与映射-EnumSet-EnumMap"><a class="header-anchor" href="#枚举集与映射-EnumSet-EnumMap"> </a>枚举集与映射 EnumSet EnumMap</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">EnumSet</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Cloneable</span>, java.io.Serializable</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumMap</span>&lt;K <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;K&gt;, V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K, V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Cloneable</span><br></pre></td></tr></table></figure>
<p><code>EnumSet</code>是一个枚举类型元素集的高效实现。</p>
<p>由于枚举类型只有有限个实例i，所以<code>EnumSet</code>内部用<strong>位序列</strong>实现。如果对应的值在集中，则相应的位置为1</p>
<p><code>EnumSet</code>类没有公共构造器，用<strong>静态工厂方法</strong>构造集</p>
<p>注意：Java8不允许在定义局部枚举类，即在方法内定义内</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">WeekDay</span> &#123;MONDAY ,TUESDAY, WEDENESDAY,  THURSDAY, FRIDAY,SATURDAY, SUNDAY&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EnumSet&lt;WeekDay&gt; always = EnumSet.allOf(WeekDay.class);</span><br><span class="line">EnumSet&lt;WeekDay&gt; mever = EnumSet.noneOf(WeekDay.class);</span><br><span class="line">EnumSet&lt;WeekDay&gt; workday = EnumSet.range(WeekDay.MONDAY,WeekDay.FRIDAY);</span><br><span class="line">EnumSet&lt;WeekDay&gt; mwf = EnumSet.of(WeekDay.MONDAY,WeekDay.WEDENESDAY,WeekDay.FRIDAY);</span><br><span class="line">System.out.println(always);<span class="comment">//[MONDAY, TUESDAY, WEDENESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY]</span></span><br><span class="line">System.out.println(mever);<span class="comment">//[]</span></span><br><span class="line">System.out.println(workday);<span class="comment">//[MONDAY, TUESDAY, WEDENESDAY, THURSDAY, FRIDAY]</span></span><br><span class="line">System.out.println(mwf);<span class="comment">//[MONDAY, WEDENESDAY, FRIDAY]</span></span><br></pre></td></tr></table></figure>
<p><code>EnumMap</code>是一个键类型位枚举类型的映射。需要在构造器中指定键类型。</p>
<blockquote>
<p>E extends Enum<E>意思是E是一个枚举类型</p>
</blockquote>
<h3 id="标识散列映射-IdentityHashMap"><a class="header-anchor" href="#标识散列映射-IdentityHashMap"> </a>标识散列映射 IdentityHashMap</h3>
<p>键的散列值不是用hashCode函数计算的，而是用<code>System.identityHashCode</code>计算。这是<code>Object.hashCode</code>根据对象的<strong>内存地址</strong>计算散列码时所使用的方法。</p>
<p>两对象比较的时候，<code>IdentityHashMap</code>类使用<code>==</code>，而不使用<code>equals</code></p>
<p><strong>不同键</strong>对象即使内容相同，也被视为不同对象。</p>
<p>在实现对象遍历算法（如对象串行化），可以用来跟踪哪些对象已经遍历过。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdentityHashMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, java.io.Serializable, Cloneable&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object x, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> System.identityHashCode(x);</span><br><span class="line">        <span class="comment">// Multiply by -127, and left-shift to use least bit as part of hash</span></span><br><span class="line">        <span class="keyword">return</span> ((h &lt;&lt; <span class="number">1</span>) - (h &lt;&lt; <span class="number">8</span>)) &amp; (length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="视图与包装器"><a class="header-anchor" href="#视图与包装器"> </a>视图与包装器</h2>
<p>可以使用视图（view）来获得其他实现了<code>Collection</code>接口或<code>Map</code>接口的对象。</p>
<p><code>KeySet</code>方法返回一个实现了<code>Set</code>接口的类对象，由这个类方法操纵原映射。这种集合称为视图</p>
<h3 id="子范围"><a class="header-anchor" href="#子范围"> </a>子范围</h3>
<p>为集合建立子范围（subrange）视图</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public interface List&lt;E&gt; extends Collection&lt;E&gt;</span></span><br><span class="line">List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public interface SortedSet&lt;E&gt; extends Set&lt;E&gt;</span></span><br><span class="line">SortedSet&lt;E&gt; <span class="title function_">subSet</span><span class="params">(E fromElement, E toElement)</span>;</span><br><span class="line">SortedSet&lt;E&gt; <span class="title function_">headSet</span><span class="params">(E toElement)</span>;</span><br><span class="line">SortedSet&lt;E&gt; <span class="title function_">tailSet</span><span class="params">(E fromElement)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public interface SortedMap&lt;K,V&gt; extends Map&lt;K,V&gt; 、</span></span><br><span class="line">SortedMap&lt;K,V&gt; <span class="title function_">subMap</span><span class="params">(K fromKey, K toKey)</span>;</span><br><span class="line">SortedMap&lt;K,V&gt; <span class="title function_">headMap</span><span class="params">(K toKey)</span>;</span><br><span class="line">SortedMap&lt;K,V&gt; <span class="title function_">tailMap</span><span class="params">(K fromKey)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public interface NavigableSet&lt;E&gt; extends SortedSet&lt;E&gt; </span></span><br><span class="line">NavigableSet&lt;E&gt; <span class="title function_">subSet</span><span class="params">(E fromElement, <span class="type">boolean</span> fromInclusive,</span></span><br><span class="line"><span class="params">                           E toElement,   <span class="type">boolean</span> toInclusive)</span>;</span><br><span class="line">NavigableSet&lt;E&gt; <span class="title function_">headSet</span><span class="params">(E toElement, <span class="type">boolean</span> inclusive)</span>;</span><br><span class="line">NavigableSet&lt;E&gt; <span class="title function_">tailSet</span><span class="params">(E fromElement, <span class="type">boolean</span> inclusive)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="不可修改视图"><a class="header-anchor" href="#不可修改视图"> </a>不可修改视图</h3>
<p><code>Collections</code>类中，有方法可以生成集合的<strong>不可修改视图（unmodifiable view）</strong></p>
<p>这些视图对现有集合增加了一个运行时检查，如果发现试图对集合修改，就抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public class Collections </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">unmodifiableCollection</span><span class="params">(Collection&lt;? extends T&gt; c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UnmodifiableCollection</span>&lt;&gt;(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="title function_">unmodifiableSet</span><span class="params">(Set&lt;? extends T&gt; s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UnmodifiableSet</span>&lt;&gt;(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; SortedSet&lt;T&gt; <span class="title function_">unmodifiableSortedSet</span><span class="params">(SortedSet&lt;T&gt; s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UnmodifiableSortedSet</span>&lt;&gt;(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; NavigableSet&lt;T&gt; <span class="title function_">unmodifiableNavigableSet</span><span class="params">(NavigableSet&lt;T&gt; s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UnmodifiableNavigableSet</span>&lt;&gt;(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">unmodifiableList</span><span class="params">(List&lt;? extends T&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (list <span class="keyword">instanceof</span> RandomAccess ?</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">UnmodifiableRandomAccessList</span>&lt;&gt;(list) :</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">UnmodifiableList</span>&lt;&gt;(list));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title function_">unmodifiableMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UnmodifiableMap</span>&lt;&gt;(m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; SortedMap&lt;K,V&gt; <span class="title function_">unmodifiableSortedMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UnmodifiableSortedMap</span>&lt;&gt;(m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; NavigableMap&lt;K,V&gt; <span class="title function_">unmodifiableNavigableMap</span><span class="params">(NavigableMap&lt;K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UnmodifiableNavigableMap</span>&lt;&gt;(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>视图只是<strong>包装</strong>了<strong>接口</strong>而不是具体的集合对象，所以<strong>只能访问接口中定义的方法</strong>。</p>
<p>例如<code>LinkedList</code>类的<code>addFirst</code>和<code>addList</code>由于不是<code>List</code>接口的方法，不能通过不可修改的视图访问这些方法</p>
<p>如果将集或列表转换成集合，就再也无法检测其内容是否相同（而是判断是否为同一个对象）。视图采用这种工作方式</p>
<p><code>unmodifiableSet</code>和<code>unmodifiableList</code>方法使用底层集合的<code>equals</code>方法和<code>hashCode</code>方法</p>
<h3 id="同步视图"><a class="header-anchor" href="#同步视图"> </a>同步视图</h3>
<p>通过视图机制来确保常规集合是线程安全的，而没有实现线程安全的集合类。</p>
<ul>
<li><code>Collections</code>类的静态<code>synchhronizedMap</code>方法可以将任何一个映射转换成有同步访问方法的Map</li>
</ul>
<h3 id="检查型视图"><a class="header-anchor" href="#检查型视图"> </a>检查型视图</h3>
<p>检查型视图对泛型类型可能出现的问题提供调试支持。</p>
<ul>
<li>将错误类型的元素混入泛型集合中</li>
</ul>
<p><code>List&lt;String&gt; safeStrings = Collections.checkedList(strings,String.class)</code></p>
<blockquote>
<p>检查型视图受限于虚拟机可以完成的运行时检查。对于ArrayList&lt;Pair<String>&gt;，无法阻止插入Pair<Date></p>
</blockquote>
<h2 id="算法"><a class="header-anchor" href="#算法"> </a>算法</h2>
<h3 id="泛型算法"><a class="header-anchor" href="#泛型算法"> </a>泛型算法</h3>
<p>通过接口（interface）</p>
<p>考虑高效地执行这个算法所需要的<strong>最小集合接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; T <span class="title function_">max</span><span class="params">(Collection&lt;T&gt; c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(c.isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    Iterator&lt;T&gt; iter = c.iterator();</span><br><span class="line">    <span class="type">T</span> <span class="variable">largest</span> <span class="operator">=</span> iter.next();</span><br><span class="line">    <span class="keyword">while</span>(iter.hasNext())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">next</span> <span class="operator">=</span> iter.next();</span><br><span class="line">        <span class="keyword">if</span>(largest.compareTo(next) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            largest = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> largest;z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序"><a class="header-anchor" href="#排序"> </a>排序</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(staff);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">staff.sort(Comparator.comparingDouble(Employee::getSalary));</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">staff.sort(Comparator.reverseOrder())</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">staff.sort(Comparator.comparingDouble(Employee::getSalary).reversed());</span><br></pre></td></tr></table></figure>
<p>Java是将所有元素转入一个<strong>数组</strong>，将<strong>数组进行排序</strong>，然后再将排序后的序列<strong>复制回列表</strong></p>
<p>Java使用归并排序，因为其稳定</p>
<p>要排序的列表，列表必须是<strong>可修改</strong>的，但不一定可以改变大小</p>
<ul>
<li>如果列表支持<code>set</code>方法，则是可修改的（modifiable）</li>
<li>如果列表支持<code>add</code>和<code>remove</code>方法，则是可改变大小的（resizable）</li>
</ul>
<h3 id="二分查找"><a class="header-anchor" href="#二分查找"> </a>二分查找</h3>
<p><code>Collections</code>类的<code>binarySearch</code>要求</p>
<ul>
<li>集合<strong>必须</strong>是有序的。</li>
<li>要查找某个元素，必须提供集合（集合要实现<code>List</code>接口）以及要查找的元素</li>
<li>如果集合没有采用<code>Comparable</code>接口，那么还要提供比较器对象</li>
<li>只有采用随机访问，二分查找才有意义。如果提供链表，则退化为线性查找</li>
</ul>
<h3 id="集合与数组的转换"><a class="header-anchor" href="#集合与数组的转换"> </a>集合与数组的转换</h3>
<p><code>toArray</code>方法得到的结果是对象（Object）数组</p>
<p><code>Object[] values = staff.toArray()</code>;</p>
<p>而强制类型转换是不允许的</p>
<p><code>String[] values = (String[]) staff.toArray(); // ERROR</code></p>
<p>可以使用<code>toArray</code>方法的变体，提供一个指定类型且长度为0的数组。返回的数组就会创建为相同的数组类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public interface List&lt;E&gt; extends Collection&lt;E&gt;</span></span><br><span class="line">Object[] toArray();</span><br><span class="line">&lt;T&gt; T[] toArray(T[] a);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span></span><br><span class="line"><span class="comment">//        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span></span><br><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="comment">// Make a new array of a&#x27;s runtime type, but my contents:</span></span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; words = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">words.add(<span class="string">&quot;cool&quot;</span>);</span><br><span class="line">words.add(<span class="string">&quot;bad&quot;</span>);</span><br><span class="line">words.add(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">String[] values = words.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p><strong><u>注意</u></strong></p>
<p>以下是<strong>不允许</strong>的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">ans.add(<span class="number">1</span>);</span><br><span class="line">ans.add(<span class="number">2</span>);</span><br><span class="line">ans.add(<span class="number">3</span>);</span><br><span class="line"><span class="type">int</span>[] result = ans.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>]); <span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>
<p>报错原因</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Required type: T[]</span><br><span class="line">Provided: <span class="type">int</span>[]</span><br><span class="line">reason: no <span class="title function_">instance</span><span class="params">(s)</span> of type <span class="title function_">variable</span><span class="params">(s)</span> T exist so that <span class="type">int</span>[] conforms to T[]</span><br><span class="line">即基本类型不能转换成类型变量</span><br></pre></td></tr></table></figure>
<p>同时也可以构造一个大小正确的数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] values = words.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[words.size()]);</span><br></pre></td></tr></table></figure>
<h2 id="遗留的集合"><a class="header-anchor" href="#遗留的集合"> </a>遗留的集合</h2>
<h3 id="HashTable类"><a class="header-anchor" href="#HashTable类"> </a>HashTable类</h3>
<ul>
<li><code>HashTable</code>类和<code>HashMap</code>类的作用一样，接口也基本相同。</li>
<li><code>HashTable</code>类和<code>Vector</code>类的方法都是同步的</li>
</ul>
<p>应该使用<code>HashMap</code></p>
<p>如果需要并发访问，使用<code>ConcurrentHashMap</code></p>
<h3 id="枚举-Enumeration"><a class="header-anchor" href="#枚举-Enumeration"> </a>枚举 Enumeration</h3>
<p>遗留的结合使用Enumeration接口遍历元素序列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Enumeration</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasMoreElements</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    E <span class="title function_">nextElement</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似<code>Iterator</code>接口的<code>hasNext</code>方法和<code>next</code>方法</p>
<h3 id="属性映射-Properties"><a class="header-anchor" href="#属性映射-Properties"> </a>属性映射 Properties</h3>
<p>属性映射（property map）是一个特殊类型的映射结构</p>
<ul>
<li>键和值都是字符串</li>
<li>这个映射可以很容易保存到文件以及从人间加载</li>
<li>有一个<strong>二级表</strong>存放<strong>默认值</strong></li>
</ul>
<p>属性映射的类名为<code>Properties</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Properties</span> <span class="keyword">extends</span> <span class="title class_">Hashtable</span>&lt;Object,Object&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">settings</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">settings.setProperty(<span class="string">&quot;width&quot;</span>,<span class="string">&quot;600.0&quot;</span>);</span><br><span class="line">settings.setProperty(<span class="string">&quot;filename&quot;</span>,<span class="string">&quot;/home/qibin/cool.txt&quot;</span>);</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;program.properties&quot;</span>);</span><br><span class="line">settings.store(fileOutputStream,<span class="string">&quot;Program Properties&quot;</span>); <span class="comment">//第二个参数为文件中的注释</span></span><br></pre></td></tr></table></figure>
<p>program.properties文件内容</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#Program Properties</span><br><span class="line">#Wed Dec 09 21:48:06 CST 2020</span><br><span class="line">filename=/home/qibin/cool.txt</span><br><span class="line">width=600.0</span><br></pre></td></tr></table></figure>
<p><code>System.getProperties()</code></p>
<p>如果要储存复杂的配置信息，应该使用<code>Preferences</code>类</p>
<h3 id="栈-Stack"><a class="header-anchor" href="#栈-Stack"> </a>栈 Stack</h3>
<p><code>Stack</code>类扩展了<code>Vector</code>类，但是可以使用非栈操作<code>insert</code>和<code>remove</code>方法在任何地方插入和删除值，而不只是在栈顶</p>
<h3 id="位集-BitSet"><a class="header-anchor" href="#位集-BitSet"> </a>位集 BitSet</h3>
<p><code>BitSet</code>类用于储存一个<strong>位序列</strong>（不是数学意义上的集，更恰当说法为<strong>位向量</strong>或<strong>位数组</strong>）</p>
<p>高效地储存位序列（如标志）就可以使用位集。使用位集要比使用<code>Boolean</code>对象的<code>ArrayList</code>高效多</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BitSet</span> <span class="variable">bucketOfBits</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitSet</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">//第i位处于”开“状态返回true,否则返回false</span></span><br><span class="line">System.out.println(bucketOfBits.get(i));<span class="comment">//false</span></span><br><span class="line"><span class="comment">//将第i位 置为”开“状态</span></span><br><span class="line">bucketOfBits.set(i);</span><br><span class="line">System.out.println(bucketOfBits.get(i));<span class="comment">//true</span></span><br><span class="line"><span class="comment">//将第i位 置为”关“状态</span></span><br><span class="line">bucketOfBits.clear(i);</span><br><span class="line">System.out.println(bucketOfBits.get(i));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public class BitSet implements Cloneable, java.io.Serializable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回位集的逻辑长度，即1+位集最高位的索引</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (wordsInUse == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BITS_PER_WORD * (wordsInUse - <span class="number">1</span>) +</span><br><span class="line">            (BITS_PER_WORD - Long.numberOfLeadingZeros(words[wordsInUse - <span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//与另一个位集进行逻辑与</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">and</span><span class="params">(BitSet set)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">or</span><span class="params">(BitSet set)</span> &#123; <span class="comment">//逻辑或</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">xor</span><span class="params">(BitSet set)</span> &#123;<span class="comment">//异或</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">andNot</span><span class="params">(BitSet set)</span> &#123; <span class="comment">//对应另一个位集中设置为1的所有位，将这个位集中相应的位清楚为0</span></span><br><span class="line">    <span class="comment">// Perform logical (a &amp; !b) on words in common</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
              <a href="/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/" rel="tag"><i class="fa fa-tag"></i> Java核心技术</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/12/01/Java%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E2%80%94%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" rel="prev" title="Java核心技术—泛型程序设计">
                  <i class="fa fa-chevron-left"></i> Java核心技术—泛型程序设计
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/12/10/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%80%94%E5%B9%B6%E5%8F%91/" rel="next" title="Java核心技术—并发">
                  Java核心技术—并发 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">闽ICP备2021001502号 </a>
      <img src="/images/%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" alt=""><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=35058202000501" rel="noopener" target="_blank">闽公网安备 35058202000501号 </a>
  </div>

<div class="copyright">
  &copy; 2020 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-seedling"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZQB</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">605k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">16:49</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/comments.js"></script><script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/utils.js"></script><script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/motion.js"></script><script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/next-boot.js"></script><script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/bookmark.js"></script>

  
<script src="https://unpkg.com/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/third-party/search/local-search.js"></script>



  <script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/third-party/fancybox.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://unpkg.com/mathjax@3.2.1/es5/tex-mml-chtml.js","integrity":"sha256-hlC2uSQYTmPsrzGZTEQEg9PZ1a/+SV6VBCTclohf2og="}}</script>
<script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://unpkg.com/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"qibinaoe","repo":"blog-comments","client_id":"157704bd238da130367f","client_secret":"b0bc6368a8d8c75ba5562dabf654a38242c9600f","admin_user":"qibinaoe","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://unpkg.com/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"e5af6b7623d9b4cd40704519b2127373"}</script>
<script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/third-party/comments/gitalk.js"></script>

</body>
</html>
