<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#f3a683"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-bin.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-bin.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-bin.png">
  <link rel="mask-icon" href="/images/logo-bin.svg" color="#f3a683">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"qibinaoe.top","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":true,"color":"#FF8B8B","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/config.js"></script>

    <meta name="description" content="leetcode 树专题的刷题记录">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode—树">
<meta property="og:url" content="http://qibinaoe.top/2020/12/15/leetcode%E2%80%94%E6%A0%91/index.html">
<meta property="og:site_name" content="Qibin&#39;s Blog">
<meta property="og:description" content="leetcode 树专题的刷题记录">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/balance_1.jpg">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/balance_2.jpg">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/ex_depth.jpg">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20201217104230565.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/binarysearchtree_improved.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/tilt1.jpg">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/tilt2.jpg">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/tilt3.jpg">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20201219164624286.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20201219164646422.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/narytreeexample.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/narytreeexample.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/trim1.jpg">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/trim2.jpg">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/tree.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/leaf-similar-1.jpg">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/leaf-similar-2.jpg">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/bst1.jpg">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/bst2.jpg">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/q1248-01.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/q1248-02.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/q1248-03.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/sum-of-root-to-leaf-binary-numbers.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/binarytree.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/inorder_1.jpg">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/inorder_5.jpg">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/inorder_4.jpg">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/116_sample.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/117_sample.png">
<meta property="article:published_time" content="2020-12-15T03:30:17.000Z">
<meta property="article:modified_time" content="2022-06-08T04:59:10.705Z">
<meta property="article:author" content="ZQB">
<meta property="article:tag" content="leetcode">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="树">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://algorithm-image.qibinaoe.top/balance_1.jpg">


<link rel="canonical" href="http://qibinaoe.top/2020/12/15/leetcode%E2%80%94%E6%A0%91/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://qibinaoe.top/2020/12/15/leetcode%E2%80%94%E6%A0%91/","path":"2020/12/15/leetcode—树/","title":"leetcode—树"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>leetcode—树 | Qibin's Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Qibin's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">better and better</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook/" rel="section"><i class="fa fa-book fa-fw"></i>留言板</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91"><span class="nav-number">1.</span> <span class="nav-text">100. 相同的树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v45"><span class="nav-number">1.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v33"><span class="nav-number">1.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E2%80%94%E2%80%94%E9%80%92%E5%BD%92"><span class="nav-number">1.3.</span> <span class="nav-text">解题代码深度优先——递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E2%80%94%E2%80%94%E9%98%9F%E5%88%97"><span class="nav-number">1.4.</span> <span class="nav-text">解题代码广度优先——队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.</span> <span class="nav-text">101. 对称二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v46"><span class="nav-number">2.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF1-v9"><span class="nav-number">2.2.</span> <span class="nav-text">解题思路1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%811-v11"><span class="nav-number">2.3.</span> <span class="nav-text">解题代码1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v13"><span class="nav-number">2.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v13"><span class="nav-number">2.5.</span> <span class="nav-text">解题代码2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number">3.</span> <span class="nav-text">104. 二叉树的最大深度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v47"><span class="nav-number">3.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v34"><span class="nav-number">3.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81%E9%80%92%E5%BD%92"><span class="nav-number">3.3.</span> <span class="nav-text">解题代码递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81%E8%BF%AD%E4%BB%A3"><span class="nav-number">3.4.</span> <span class="nav-text">解题代码迭代</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86-II"><span class="nav-number">4.</span> <span class="nav-text">107. 二叉树的层次遍历 II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v48"><span class="nav-number">4.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v35"><span class="nav-number">4.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%811-0"><span class="nav-number">4.3.</span> <span class="nav-text">解题代码1.0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%811-1"><span class="nav-number">4.4.</span> <span class="nav-text">解题代码1.1</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">5.</span> <span class="nav-text">108. 将有序数组转换为二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v49"><span class="nav-number">6.</span> <span class="nav-text">题目</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v36"><span class="nav-number">6.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v20"><span class="nav-number">6.2.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">7.</span> <span class="nav-text">110. 平衡二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v50"><span class="nav-number">7.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v37"><span class="nav-number">7.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v21"><span class="nav-number">7.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="nav-number">8.</span> <span class="nav-text">111. 二叉树的最小深度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v51"><span class="nav-number">8.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF1-v10"><span class="nav-number">8.2.</span> <span class="nav-text">解题思路1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%811-0-v2"><span class="nav-number">8.3.</span> <span class="nav-text">解题代码1.0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%811-1-v2"><span class="nav-number">8.4.</span> <span class="nav-text">解题代码1.1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v14"><span class="nav-number">8.5.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v14"><span class="nav-number">8.6.</span> <span class="nav-text">解题代码2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="nav-number">9.</span> <span class="nav-text">112. 路径总和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v52"><span class="nav-number">9.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF1-v11"><span class="nav-number">9.2.</span> <span class="nav-text">解题思路1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%811-v12"><span class="nav-number">9.3.</span> <span class="nav-text">解题代码1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v15"><span class="nav-number">9.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v15"><span class="nav-number">9.5.</span> <span class="nav-text">解题代码2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">10.</span> <span class="nav-text">226. 翻转二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v53"><span class="nav-number">10.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v38"><span class="nav-number">10.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%811%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A"><span class="nav-number">10.3.</span> <span class="nav-text">解题代码1自底向上</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B"><span class="nav-number">10.4.</span> <span class="nav-text">解题代码2自顶向下</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">11.</span> <span class="nav-text">235. 二叉搜索树的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v54"><span class="nav-number">11.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF1-v12"><span class="nav-number">11.2.</span> <span class="nav-text">解题思路1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%811-v13"><span class="nav-number">11.3.</span> <span class="nav-text">解题代码1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v16"><span class="nav-number">11.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v16"><span class="nav-number">11.5.</span> <span class="nav-text">解题代码2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="nav-number">12.</span> <span class="nav-text">257. 二叉树的所有路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v55"><span class="nav-number">12.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v39"><span class="nav-number">12.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v22"><span class="nav-number">12.3.</span> <span class="nav-text">解题代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v17"><span class="nav-number">12.4.</span> <span class="nav-text">解题思路2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="nav-number">13.</span> <span class="nav-text">404. 左叶子之和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v56"><span class="nav-number">13.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v40"><span class="nav-number">13.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v23"><span class="nav-number">13.3.</span> <span class="nav-text">解题代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v18"><span class="nav-number">13.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-0"><span class="nav-number">13.5.</span> <span class="nav-text">解题代码2.0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-1"><span class="nav-number">13.6.</span> <span class="nav-text">解题代码2.1</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0"><span class="nav-number">14.</span> <span class="nav-text">501. 二叉搜索树中的众数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v57"><span class="nav-number">14.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF1-v13"><span class="nav-number">14.2.</span> <span class="nav-text">解题思路1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%811%E6%95%88%E7%8E%87%E8%BE%83%E4%BD%8E%E7%89%88"><span class="nav-number">14.3.</span> <span class="nav-text">解题代码1效率较低版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2%E5%88%9D%E6%AD%A5%E4%BC%98%E5%8C%96"><span class="nav-number">14.4.</span> <span class="nav-text">解题思路2初步优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v17"><span class="nav-number">14.5.</span> <span class="nav-text">解题代码2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF3%E5%86%8D%E4%BC%98%E5%8C%96-morris%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">14.6.</span> <span class="nav-text">解题思路3再优化 morris中序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%813-v5"><span class="nav-number">14.7.</span> <span class="nav-text">解题代码3</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE"><span class="nav-number">15.</span> <span class="nav-text">530. 二叉搜索树的最小绝对差</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v58"><span class="nav-number">15.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v41"><span class="nav-number">15.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%811-0-v3"><span class="nav-number">15.3.</span> <span class="nav-text">解题代码1.0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-0-v2"><span class="nav-number">15.4.</span> <span class="nav-text">解题代码2.0</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="nav-number">16.</span> <span class="nav-text">543. 二叉树的直径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v59"><span class="nav-number">16.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v42"><span class="nav-number">16.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v24"><span class="nav-number">16.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#559-N-%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number">17.</span> <span class="nav-text">559. N 叉树的最大深度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v60"><span class="nav-number">17.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF1-v14"><span class="nav-number">17.2.</span> <span class="nav-text">解题思路1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%811-v14"><span class="nav-number">17.3.</span> <span class="nav-text">解题代码1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v18"><span class="nav-number">17.4.</span> <span class="nav-text">解题代码2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%813-v6"><span class="nav-number">17.5.</span> <span class="nav-text">解题代码3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%814-v3"><span class="nav-number">17.6.</span> <span class="nav-text">解题代码4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%815"><span class="nav-number">17.7.</span> <span class="nav-text">解题代码5</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#563-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9D%A1%E5%BA%A6"><span class="nav-number">18.</span> <span class="nav-text">563. 二叉树的坡度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v61"><span class="nav-number">18.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v43"><span class="nav-number">18.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v25"><span class="nav-number">18.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#572-%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91"><span class="nav-number">19.</span> <span class="nav-text">572. 另一个树的子树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v62"><span class="nav-number">19.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v44"><span class="nav-number">19.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v26"><span class="nav-number">19.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#589-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">20.</span> <span class="nav-text">589. N叉树的前序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v63"><span class="nav-number">20.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF1-v15"><span class="nav-number">20.2.</span> <span class="nav-text">解题思路1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%811-v15"><span class="nav-number">20.3.</span> <span class="nav-text">解题代码1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v19"><span class="nav-number">20.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v19"><span class="nav-number">20.5.</span> <span class="nav-text">解题代码2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#590-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">21.</span> <span class="nav-text">590. N叉树的后序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v64"><span class="nav-number">21.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v45"><span class="nav-number">21.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v27"><span class="nav-number">21.3.</span> <span class="nav-text">解题代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v20"><span class="nav-number">21.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v20"><span class="nav-number">21.5.</span> <span class="nav-text">解题代码2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF3-v5"><span class="nav-number">21.6.</span> <span class="nav-text">解题思路3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%813-v7"><span class="nav-number">21.7.</span> <span class="nav-text">解题代码3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%813-1"><span class="nav-number">21.8.</span> <span class="nav-text">解题代码3.1</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#606-%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">22.</span> <span class="nav-text">606. 根据二叉树创建字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v65"><span class="nav-number">22.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v46"><span class="nav-number">22.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v28"><span class="nav-number">22.3.</span> <span class="nav-text">解题代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%98%E6%96%B9%E9%A2%98%E8%A7%A3%E4%BB%A3%E7%A0%81%E9%80%92%E5%BD%92"><span class="nav-number">22.4.</span> <span class="nav-text">官方题解代码递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%E5%AE%98%E8%A7%A3%E4%BB%A3%E7%A0%81%E9%80%92%E5%BD%92"><span class="nav-number">22.5.</span> <span class="nav-text">改进官解代码递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v21"><span class="nav-number">22.6.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v21"><span class="nav-number">22.7.</span> <span class="nav-text">解题代码2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">23.</span> <span class="nav-text">617. 合并二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v66"><span class="nav-number">23.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v47"><span class="nav-number">23.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%811-v16"><span class="nav-number">23.3.</span> <span class="nav-text">解题代码1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%811-1-v3"><span class="nav-number">23.4.</span> <span class="nav-text">解题代码1.1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v22"><span class="nav-number">23.5.</span> <span class="nav-text">解题思路2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#637-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="nav-number">24.</span> <span class="nav-text">637. 二叉树的层平均值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v67"><span class="nav-number">24.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF1-v16"><span class="nav-number">24.2.</span> <span class="nav-text">解题思路1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%811-v17"><span class="nav-number">24.3.</span> <span class="nav-text">解题代码1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v23"><span class="nav-number">24.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v22"><span class="nav-number">24.5.</span> <span class="nav-text">解题代码2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#653-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-IV-%E8%BE%93%E5%85%A5-BST"><span class="nav-number">25.</span> <span class="nav-text">653. 两数之和 IV - 输入 BST</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v68"><span class="nav-number">25.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v48"><span class="nav-number">25.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v29"><span class="nav-number">25.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">26.</span> <span class="nav-text">669. 修剪二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v69"><span class="nav-number">26.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v49"><span class="nav-number">26.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v30"><span class="nav-number">26.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#671-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">27.</span> <span class="nav-text">671. 二叉树中第二小的节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v70"><span class="nav-number">27.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v50"><span class="nav-number">27.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v31"><span class="nav-number">27.3.</span> <span class="nav-text">解题代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v24"><span class="nav-number">27.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v23"><span class="nav-number">27.5.</span> <span class="nav-text">解题代码2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="nav-number">28.</span> <span class="nav-text">700. 二叉搜索树中的搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v71"><span class="nav-number">28.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v51"><span class="nav-number">28.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v32"><span class="nav-number">28.3.</span> <span class="nav-text">解题代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v25"><span class="nav-number">28.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v24"><span class="nav-number">28.5.</span> <span class="nav-text">解题代码2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%813-v8"><span class="nav-number">28.6.</span> <span class="nav-text">解题代码3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%813-v9"><span class="nav-number">28.7.</span> <span class="nav-text">解题代码3</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#783-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%8A%82%E7%82%B9%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB"><span class="nav-number">29.</span> <span class="nav-text">783. 二叉搜索树节点最小距离</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v72"><span class="nav-number">29.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v52"><span class="nav-number">29.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v33"><span class="nav-number">29.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#872-%E5%8F%B6%E5%AD%90%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%A0%91"><span class="nav-number">30.</span> <span class="nav-text">872. 叶子相似的树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v73"><span class="nav-number">30.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v53"><span class="nav-number">30.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v34"><span class="nav-number">30.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#897-%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="nav-number">31.</span> <span class="nav-text">897. 递增顺序查找树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v74"><span class="nav-number">31.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v54"><span class="nav-number">31.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v35"><span class="nav-number">31.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#938-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C"><span class="nav-number">32.</span> <span class="nav-text">938. 二叉搜索树的范围和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v75"><span class="nav-number">32.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v55"><span class="nav-number">32.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v36"><span class="nav-number">32.3.</span> <span class="nav-text">解题代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v26"><span class="nav-number">32.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v25"><span class="nav-number">32.5.</span> <span class="nav-text">解题代码2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF3-v6"><span class="nav-number">32.6.</span> <span class="nav-text">解题思路3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%813-v10"><span class="nav-number">32.7.</span> <span class="nav-text">解题代码3</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#965-%E5%8D%95%E5%80%BC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">33.</span> <span class="nav-text">965. 单值二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v76"><span class="nav-number">33.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v56"><span class="nav-number">33.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v37"><span class="nav-number">33.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#993-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9"><span class="nav-number">34.</span> <span class="nav-text">993. 二叉树的堂兄弟节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v77"><span class="nav-number">34.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v57"><span class="nav-number">34.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v38"><span class="nav-number">34.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1022-%E4%BB%8E%E6%A0%B9%E5%88%B0%E5%8F%B6%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">35.</span> <span class="nav-text">1022. 从根到叶的二进制数之和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v78"><span class="nav-number">35.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v58"><span class="nav-number">35.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v39"><span class="nav-number">35.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="nav-number">36.</span> <span class="nav-text">剑指 Offer 27. 二叉树的镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v79"><span class="nav-number">36.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v59"><span class="nav-number">36.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v40"><span class="nav-number">36.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-28-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">37.</span> <span class="nav-text">剑指 Offer 28. 对称的二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v80"><span class="nav-number">37.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v41"><span class="nav-number">37.2.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-32-II-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-II"><span class="nav-number">38.</span> <span class="nav-text">剑指 Offer 32 - II. 从上到下打印二叉树 II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v81"><span class="nav-number">38.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v60"><span class="nav-number">38.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v42"><span class="nav-number">38.3.</span> <span class="nav-text">解题代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v27"><span class="nav-number">38.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v26"><span class="nav-number">38.5.</span> <span class="nav-text">解题代码2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9"><span class="nav-number">39.</span> <span class="nav-text">剑指 Offer 54. 二叉搜索树的第k大节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v82"><span class="nav-number">39.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v61"><span class="nav-number">39.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v43"><span class="nav-number">39.3.</span> <span class="nav-text">解题代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v28"><span class="nav-number">39.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v27"><span class="nav-number">39.5.</span> <span class="nav-text">解题代码2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-55-I-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="nav-number">40.</span> <span class="nav-text">剑指 Offer 55 - I. 二叉树的深度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v83"><span class="nav-number">40.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v44"><span class="nav-number">40.2.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-55-II-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">41.</span> <span class="nav-text">剑指 Offer 55 - II. 平衡二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v84"><span class="nav-number">41.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v62"><span class="nav-number">41.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v45"><span class="nav-number">41.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-68-I-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">42.</span> <span class="nav-text">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v85"><span class="nav-number">42.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v63"><span class="nav-number">42.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v46"><span class="nav-number">42.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-68-II-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">43.</span> <span class="nav-text">剑指 Offer 68 - II. 二叉树的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v86"><span class="nav-number">43.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v64"><span class="nav-number">43.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v47"><span class="nav-number">43.3.</span> <span class="nav-text">解题代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v29"><span class="nav-number">43.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v28"><span class="nav-number">43.5.</span> <span class="nav-text">解题代码2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF3-v7"><span class="nav-number">43.6.</span> <span class="nav-text">解题思路3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%813-v11"><span class="nav-number">43.7.</span> <span class="nav-text">解题代码3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF4-v3"><span class="nav-number">43.8.</span> <span class="nav-text">解题思路4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%814-v4"><span class="nav-number">43.9.</span> <span class="nav-text">解题代码4</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-04-02-%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91"><span class="nav-number">44.</span> <span class="nav-text">面试题 04.02. 最小高度树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v87"><span class="nav-number">44.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v65"><span class="nav-number">44.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v48"><span class="nav-number">44.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-04-04-%E6%A3%80%E6%9F%A5%E5%B9%B3%E8%A1%A1%E6%80%A7"><span class="nav-number">45.</span> <span class="nav-text">面试题 04.04. 检查平衡性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v88"><span class="nav-number">45.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v66"><span class="nav-number">45.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v49"><span class="nav-number">45.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-17-12-BiNode"><span class="nav-number">46.</span> <span class="nav-text">面试题 17.12. BiNode</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v89"><span class="nav-number">46.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v67"><span class="nav-number">46.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v50"><span class="nav-number">46.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">47.</span> <span class="nav-text">94. 二叉树的中序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v90"><span class="nav-number">47.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E9%80%92%E5%BD%92"><span class="nav-number">47.2.</span> <span class="nav-text">解题思路递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81%E9%80%92%E5%BD%92-v2"><span class="nav-number">47.3.</span> <span class="nav-text">解题代码递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E8%BF%AD%E4%BB%A3"><span class="nav-number">47.4.</span> <span class="nav-text">解题思路迭代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81%E8%BF%AD%E4%BB%A3-v2"><span class="nav-number">47.5.</span> <span class="nav-text">解题代码迭代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AFmorris"><span class="nav-number">47.6.</span> <span class="nav-text">解题思路morris</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v51"><span class="nav-number">47.7.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-II"><span class="nav-number">48.</span> <span class="nav-text">95. 不同的二叉搜索树 II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v91"><span class="nav-number">48.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v68"><span class="nav-number">48.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v52"><span class="nav-number">48.3.</span> <span class="nav-text">解题代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2TODO"><span class="nav-number">48.4.</span> <span class="nav-text">解题思路2TODO</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">49.</span> <span class="nav-text">96. 不同的二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v92"><span class="nav-number">49.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v69"><span class="nav-number">49.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v53"><span class="nav-number">49.3.</span> <span class="nav-text">解题代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2TODO-v2"><span class="nav-number">49.4.</span> <span class="nav-text">解题思路2TODO</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">50.</span> <span class="nav-text">98. 验证二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v93"><span class="nav-number">50.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v70"><span class="nav-number">50.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v54"><span class="nav-number">50.3.</span> <span class="nav-text">解题代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v30"><span class="nav-number">50.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v29"><span class="nav-number">50.5.</span> <span class="nav-text">解题代码2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#99-%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">51.</span> <span class="nav-text">99. 恢复二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v94"><span class="nav-number">51.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v71"><span class="nav-number">51.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v55"><span class="nav-number">51.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">52.</span> <span class="nav-text">102. 二叉树的层序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v95"><span class="nav-number">52.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v72"><span class="nav-number">52.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v56"><span class="nav-number">52.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">53.</span> <span class="nav-text">103. 二叉树的锯齿形层序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v96"><span class="nav-number">53.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v73"><span class="nav-number">53.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v57"><span class="nav-number">53.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">54.</span> <span class="nav-text">105. 从前序与中序遍历序列构造二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v97"><span class="nav-number">54.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v74"><span class="nav-number">54.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v58"><span class="nav-number">54.3.</span> <span class="nav-text">解题代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v31"><span class="nav-number">54.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v30"><span class="nav-number">54.5.</span> <span class="nav-text">解题代码2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">55.</span> <span class="nav-text">106. 从中序与后序遍历序列构造二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v98"><span class="nav-number">55.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v75"><span class="nav-number">55.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v59"><span class="nav-number">55.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II"><span class="nav-number">56.</span> <span class="nav-text">113. 路径总和 II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v99"><span class="nav-number">56.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v76"><span class="nav-number">56.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v60"><span class="nav-number">56.3.</span> <span class="nav-text">解题代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v32"><span class="nav-number">56.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v31"><span class="nav-number">56.5.</span> <span class="nav-text">解题代码2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="nav-number">57.</span> <span class="nav-text">114. 二叉树展开为链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v100"><span class="nav-number">57.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v77"><span class="nav-number">57.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v61"><span class="nav-number">57.3.</span> <span class="nav-text">解题代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v33"><span class="nav-number">57.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v32"><span class="nav-number">57.5.</span> <span class="nav-text">解题代码2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="nav-number">58.</span> <span class="nav-text">116. 填充每个节点的下一个右侧节点指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v101"><span class="nav-number">58.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF1-v17"><span class="nav-number">58.2.</span> <span class="nav-text">解题思路1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%811-v18"><span class="nav-number">58.3.</span> <span class="nav-text">解题代码1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v34"><span class="nav-number">58.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v33"><span class="nav-number">58.5.</span> <span class="nav-text">解题代码2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF3-v8"><span class="nav-number">58.6.</span> <span class="nav-text">解题思路3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%813-v12"><span class="nav-number">58.7.</span> <span class="nav-text">解题代码3</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-II"><span class="nav-number">59.</span> <span class="nav-text">117. 填充每个节点的下一个右侧节点指针 II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v102"><span class="nav-number">59.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v78"><span class="nav-number">59.2.</span> <span class="nav-text">解题思路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v79"><span class="nav-number">60.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C"><span class="nav-number">61.</span> <span class="nav-text">129. 求根到叶子节点数字之和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v103"><span class="nav-number">61.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v80"><span class="nav-number">61.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v62"><span class="nav-number">61.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">62.</span> <span class="nav-text">144. 二叉树的前序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v104"><span class="nav-number">62.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v81"><span class="nav-number">62.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v63"><span class="nav-number">62.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">63.</span> <span class="nav-text">145. 二叉树的后序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v105"><span class="nav-number">63.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v82"><span class="nav-number">63.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v64"><span class="nav-number">63.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#173-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">64.</span> <span class="nav-text">173. 二叉搜索树迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v106"><span class="nav-number">64.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E4%B8%80"><span class="nav-number">64.2.</span> <span class="nav-text">解题思路一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81%E4%B8%80"><span class="nav-number">64.3.</span> <span class="nav-text">解题代码一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E4%BA%8C"><span class="nav-number">64.4.</span> <span class="nav-text">解题思路二</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81%E4%BA%8C"><span class="nav-number">64.5.</span> <span class="nav-text">解题代码二</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="nav-number">65.</span> <span class="nav-text">199. 二叉树的右视图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v107"><span class="nav-number">65.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v83"><span class="nav-number">65.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v65"><span class="nav-number">65.3.</span> <span class="nav-text">解题代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-v35"><span class="nav-number">65.4.</span> <span class="nav-text">解题思路2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%812-v34"><span class="nav-number">65.5.</span> <span class="nav-text">解题代码2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="nav-number">66.</span> <span class="nav-text">222. 完全二叉树的节点个数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v108"><span class="nav-number">66.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E4%B8%80-v2"><span class="nav-number">66.2.</span> <span class="nav-text">解题思路一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81%E4%B8%80-v2"><span class="nav-number">66.3.</span> <span class="nav-text">解题代码一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E4%BA%8C-v2"><span class="nav-number">66.4.</span> <span class="nav-text">解题思路二</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81%E4%BA%8C-v2"><span class="nav-number">66.5.</span> <span class="nav-text">解题代码二</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">67.</span> <span class="nav-text">230. 二叉搜索树中第K小的元素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v109"><span class="nav-number">67.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v84"><span class="nav-number">67.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v66"><span class="nav-number">67.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">68.</span> <span class="nav-text">236. 二叉树的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v110"><span class="nav-number">68.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v85"><span class="nav-number">68.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v67"><span class="nav-number">68.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-III"><span class="nav-number">69.</span> <span class="nav-text">337. 打家劫舍 III</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v111"><span class="nav-number">69.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v86"><span class="nav-number">69.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v68"><span class="nav-number">69.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III"><span class="nav-number">70.</span> <span class="nav-text">437. 路径总和 III</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v112"><span class="nav-number">70.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v87"><span class="nav-number">70.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v69"><span class="nav-number">70.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#449-%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">71.</span> <span class="nav-text">449. 序列化和反序列化二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v113"><span class="nav-number">71.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v88"><span class="nav-number">71.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v70"><span class="nav-number">71.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">72.</span> <span class="nav-text">450. 删除二叉搜索树中的节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-v114"><span class="nav-number">72.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-v89"><span class="nav-number">72.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E4%BB%A3%E7%A0%81-v71"><span class="nav-number">72.3.</span> <span class="nav-text">解题代码</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZQB"
      src="/images/me_avatar.png">
  <p class="site-author-name" itemprop="name">ZQB</p>
  <div class="site-description" itemprop="description">Better Me</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/qibinaoe" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;qibinaoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:780891896@qq.com" title="E-Mail → mailto:780891896@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://gagalab.tech/" title="https:&#x2F;&#x2F;gagalab.tech&#x2F;" rel="noopener" target="_blank">嘎嘎研究所</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://qibinaoe.top/2020/12/15/leetcode%E2%80%94%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me_avatar.png">
      <meta itemprop="name" content="ZQB">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qibin's Blog">
      <meta itemprop="description" content="Better Me">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="leetcode—树 | Qibin's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          leetcode—树
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-15 11:30:17" itemprop="dateCreated datePublished" datetime="2020-12-15T11:30:17+08:00">2020-12-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-08 12:59:10" itemprop="dateModified" datetime="2022-06-08T12:59:10+08:00">2022-06-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>104k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2:53</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>本篇是leetcode树Tag的学习记录</p>
<p>所有题目来自于 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/tag/tree/">树</a></p>
<!-- more -->
<h2 id="100-相同的树"><a class="header-anchor" href="#100-相同的树"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/same-tree/">100. 相同的树</a></h2>
<h3 id="题目-v45"><a class="header-anchor" href="#题目-v45"> </a>题目</h3>
<p>给定两个二叉树，编写一个函数来检验它们是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<blockquote>
<p>示例 1:<br>
输入:       1         1<br>
/ \       / <br>
2   3     2   3</p>
<p>[1,2,3],   [1,2,3]<br>
输出: true</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
输入:      1          1<br>
/           <br>
2             2</p>
<p>[1,2],     [1,null,2]<br>
输出: false</p>
</blockquote>
<blockquote>
<p>示例 3:<br>
输入:       1         1<br>
/ \       / <br>
2   1     1   2</p>
<p>[1,2,1],   [1,1,2]<br>
输出: false</p>
</blockquote>
<h3 id="解题思路-v33"><a class="header-anchor" href="#解题思路-v33"> </a>解题思路</h3>
<p>完成这题的思路就是遍历一下这两棵树，如果遍历过程中两个树中同一个位置的每个结点都相同，则说明这两棵树是相同的</p>
<p>对于遍历的方法有很多，比如深度优先、广度优先</p>
<h3 id="解题代码深度优先——递归"><a class="header-anchor" href="#解题代码深度优先——递归"> </a>解题代码深度优先——递归</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p == <span class="literal">null</span> || q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p.val != q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码广度优先——队列"><a class="header-anchor" href="#解题代码广度优先——队列"> </a>解题代码广度优先——队列</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">// 广度遍历</span></span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> ^ q == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        Deque&lt;TreeNode&gt; queue1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; queue2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue1.offer(p);</span><br><span class="line">        queue2.offer(q);</span><br><span class="line">        <span class="keyword">while</span>(!queue1.isEmpty() &amp;&amp; !queue2.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">t1</span> <span class="operator">=</span> queue1.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">t2</span> <span class="operator">=</span> queue2.poll();</span><br><span class="line">            <span class="keyword">if</span>(t1.val != t2.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">l1</span> <span class="operator">=</span> t1.left;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">l2</span> <span class="operator">=</span> t2.left;</span><br><span class="line">            <span class="keyword">if</span>(l1 == <span class="literal">null</span> ^ l2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="literal">null</span>) queue1.offer(l1);</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="literal">null</span>) queue2.offer(l2);</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">r1</span> <span class="operator">=</span> t1.right;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">r2</span> <span class="operator">=</span> t2.right;</span><br><span class="line">            <span class="keyword">if</span>(r1 == <span class="literal">null</span> ^ r2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(r1 != <span class="literal">null</span>) queue1.offer(r1);</span><br><span class="line">            <span class="keyword">if</span>(r2 != <span class="literal">null</span>) queue2.offer(r2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue1.isEmpty() &amp;&amp; queue2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="101-对称二叉树"><a class="header-anchor" href="#101-对称二叉树"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></h2>
<h3 id="题目-v46"><a class="header-anchor" href="#题目-v46"> </a>题目</h3>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
<blockquote>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。<br>
1<br>
/ <br>
2   2<br>
/ \ / <br>
3  4 4  3</p>
</blockquote>
<blockquote>
<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:<br>
1<br>
/ <br>
2   2<br>
\   <br>
3    3</p>
</blockquote>
<h3 id="解题思路1-v9"><a class="header-anchor" href="#解题思路1-v9"> </a>解题思路1</h3>
<p>通过递归的方法，每一个小的迭代解决的问题是两个指针指向的值是否相等，如果相等的话，则判断一个指针的左子树是否和另一个指针的右子树相等，一个指针的右子树是否和另一个指针的左子树相等</p>
<h3 id="解题代码1-v11"><a class="header-anchor" href="#解题代码1-v11"> </a>解题代码1</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//用一个栈来判断左右两个子树是否一样</span></span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">return</span> check(root.left,root.right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode p, TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> || q == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> p.val==q.val &amp;&amp; check(p.left,q.right) &amp;&amp; check(p.right,q.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v13"><a class="header-anchor" href="#解题思路2-v13"> </a>解题思路2</h3>
<p>借助一个队列，通过迭代的方式解决这题。但本质的思路跟解题思路1是类似的，即判断当前的两个结点的值是否一样，如果一样则接下来需要保证下一次判断的时候，是判断一个是左子树、另一个是右子树。或者反过来。</p>
<h3 id="解题代码2-v13"><a class="header-anchor" href="#解题代码2-v13"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">       queue.offer(root);</span><br><span class="line">       queue.offer(root);</span><br><span class="line">       <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">           <span class="comment">//取出的两个应该是镜像对称位置的</span></span><br><span class="line">           <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">           <span class="type">TreeNode</span> <span class="variable">q</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">           <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">           <span class="keyword">if</span>(p == <span class="literal">null</span> || q == <span class="literal">null</span> || p.val != q.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            queue.offer(p.left);</span><br><span class="line">            queue.offer(q.right);</span><br><span class="line">            queue.offer(p.right);</span><br><span class="line">            queue.offer(q.left);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="104-二叉树的最大深度"><a class="header-anchor" href="#104-二叉树的最大深度"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h2>
<h3 id="题目-v47"><a class="header-anchor" href="#题目-v47"> </a>题目</h3>
<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<blockquote>
<p>示例：<br>
给定二叉树 [3,9,20,null,null,15,7]，<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回它的最大深度 3 。</p>
</blockquote>
<h3 id="解题思路-v34"><a class="header-anchor" href="#解题思路-v34"> </a>解题思路</h3>
<p>可以通过递归的思路，空结点为0，非空的话，则是当前结点的1，加上左右子树中，深度最大的那个数。</p>
<p>也可以 用迭代的方式，通过广度优先去遍历每一层，每一层加一，同时对于每一层的迭代中，需要将该层的所有结点从队列中取出，再放入其左右子树，才能判断一层是否遍历完。</p>
<h3 id="解题代码递归"><a class="header-anchor" href="#解题代码递归"> </a>解题代码递归</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+ (left&gt;right?left:right);     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>精简版</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">root</span> <span class="operator">=</span>= <span class="literal">null</span>? <span class="number">0</span> : Math.max(maxDepth(root.left),maxDepth(root.right))+<span class="number">1</span>;     </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码迭代"><a class="header-anchor" href="#解题代码迭代"> </a>解题代码迭代</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//广度优先</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">deep</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size-- &gt; <span class="number">0</span> )&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">t</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(t.left != <span class="literal">null</span>) queue.offer(t.left);</span><br><span class="line">                <span class="keyword">if</span>(t.right != <span class="literal">null</span>) queue.offer(t.right);</span><br><span class="line">            &#125;</span><br><span class="line">            deep++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="107-二叉树的层次遍历-II"><a class="header-anchor" href="#107-二叉树的层次遍历-II"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层次遍历 II</a></h2>
<h3 id="题目-v48"><a class="header-anchor" href="#题目-v48"> </a>题目</h3>
<p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<blockquote>
<p>例如：<br>
给定二叉树 [3,9,20,null,null,15,7],<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回其自底向上的层次遍历为：<br>
[<br>
[15,7],<br>
[9,20],<br>
[3]<br>
]</p>
</blockquote>
<h3 id="解题思路-v35"><a class="header-anchor" href="#解题思路-v35"> </a>解题思路</h3>
<p>对于这题实现的思路主要是参考于”104. 二叉树的最大深度“中广度优先的方法，将每一次在一层的遍历的数字储存在一块，最后要么通过栈的方式逆输出，或者直接通过链表插入头的方式输出。或者最后翻转一遍数组或链表</p>
<p><code>LinkedList</code>实现了<code>addFirst</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        linkFirst(e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>List</code>接口中有声明<code>void add(int index, E element);</code>的方法，所以可以直接<code>add(0,val)</code>的方式插入</p>
<h3 id="解题代码1-0"><a class="header-anchor" href="#解题代码1-0"> </a>解题代码1.0</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        LinkedList&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); <span class="comment">//用于层次遍历的队列</span></span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; curLayer = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">//新一层元素</span></span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                curLayer.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span> ) queue.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span> ) queue.offer(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.addFirst(curLayer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码1-1"><a class="header-anchor" href="#解题代码1-1"> </a>解题代码1.1</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); <span class="comment">//用于层次遍历的队列</span></span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; curLayer = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">//新一层元素</span></span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                curLayer.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span> ) queue.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span> ) queue.offer(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(<span class="number">0</span>,curLayer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="108-将有序数组转换为二叉搜索树"><a class="header-anchor" href="#108-将有序数组转换为二叉搜索树"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h2>
<h2 id="题目-v49"><a class="header-anchor" href="#题目-v49"> </a>题目</h2>
<p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<blockquote>
<p>示例:<br>
给定有序数组: [-10,-3,0,5,9],<br>
一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：<br>
0<br>
/ <br>
-3   9<br>
/   /<br>
-10  5</p>
</blockquote>
<h3 id="解题思路-v36"><a class="header-anchor" href="#解题思路-v36"> </a>解题思路</h3>
<p>看到这题就想起来之前做链表专题有一题类似的“<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a>”</p>
<p>其中我写的”解题思路1“就是先将链表转成数组再进行转换。</p>
<h3 id="解题代码-v20"><a class="header-anchor" href="#解题代码-v20"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> subArray2BST(nums,<span class="number">0</span>,nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">subArray2BST</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="comment">//左开右闭</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = subArray2BST(nums,left,mid);</span><br><span class="line">        root.right = subArray2BST(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="110-平衡二叉树"><a class="header-anchor" href="#110-平衡二叉树"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a></h2>
<h3 id="题目-v50"><a class="header-anchor" href="#题目-v50"> </a>题目</h3>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<blockquote>
<p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p>
</blockquote>
<p>示例 1：<br>
输入：root = [3,9,20,null,null,15,7]<br>
输出：true</p>
<p><img src="http://algorithm-image.qibinaoe.top/balance_1.jpg" alt="img"></p>
<p>示例 2：<br>
输入：root = [1,2,2,3,3,null,null,4,4]<br>
输出：false</p>
<p><img src="http://algorithm-image.qibinaoe.top/balance_2.jpg" alt="img"></p>
<p>示例 3：<br>
输入：root = []<br>
输出：true</p>
<h3 id="解题思路-v37"><a class="header-anchor" href="#解题思路-v37"> </a>解题思路</h3>
<p>这题有很明显的递归的影子</p>
<p>如果一棵树是高度平衡二叉树，则它子树也是高度平衡二叉树。</p>
<p>因此我们可以通过递归，先判断一个结点的左右子树是否都为高度平衡二叉树，然后再看加上当前结点和左右子树构成更大的树，是否为高度平衡二叉树</p>
<h3 id="解题代码-v21"><a class="header-anchor" href="#解题代码-v21"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> root.left;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> root.right;</span><br><span class="line">        <span class="keyword">if</span>(!isBalanced(left) || !isBalanced(right)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Math.abs(getHeight(left) - getHeight(right))&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getHeight(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getHeight(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="111-二叉树的最小深度"><a class="header-anchor" href="#111-二叉树的最小深度"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h2>
<h3 id="题目-v51"><a class="header-anchor" href="#题目-v51"> </a>题目</h3>
<p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p>说明：叶子节点是指没有子节点的节点。</p>
<blockquote>
<p>示例 1：<br>
输入：root = [3,9,20,null,null,15,7]<br>
输出：2</p>
<p><img src="http://algorithm-image.qibinaoe.top/ex_depth.jpg" alt="img"></p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：root = [2,null,3,null,4,null,5,null,6]<br>
输出：5</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201217104230565.png" alt="image-20201217104230565"></p>
</blockquote>
<h3 id="解题思路1-v10"><a class="header-anchor" href="#解题思路1-v10"> </a>解题思路1</h3>
<p><u>注意这题有个坑</u></p>
<p>题目的意思并<strong>不是</strong>单纯的求出左右两个子树的最短路径。</p>
<p>题目意思是到<strong>叶节点</strong>的最短路径，而叶节点的定义为：左右两个子树<strong>均为空</strong>。</p>
<p>所以当一个根节点中，假设其左子树为空，右子树不为空。不能认定为其长度为空。长度应该是右子树的最短路径。</p>
<p>总之，这题想表达的意思是：<strong>不是</strong>到<strong>空结点</strong>的最短路径，<strong>而是</strong>到<strong>叶子节点</strong>的<strong>最短路径</strong>。</p>
<p>解题代码1的思路是如果遇到只有单个子树的根节点，则返回非空子树的长度</p>
<p>解题代码2的思路是只计算不是空结点的子树的深度</p>
<h3 id="解题代码1-0-v2"><a class="header-anchor" href="#解题代码1-0-v2"> </a>解题代码1.0</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getDepth(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="comment">// 这题有个坑</span></span><br><span class="line">        <span class="comment">// 根节点不属于叶子结点</span></span><br><span class="line">        <span class="comment">// 所以如果根节点的只有一个子树为空，则最短路径为到另一棵非空子树的最短的路径</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span>) <span class="keyword">return</span> getDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.right == <span class="literal">null</span>) <span class="keyword">return</span> getDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> getDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> getDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.min(leftDepth,rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码1-1-v2"><a class="header-anchor" href="#解题代码1-1-v2"> </a>解题代码1.1</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getDepth(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>) min = Math.min(min,getDepth(root.left));</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>) min = Math.min(min,getDepth(root.right));</span><br><span class="line">        <span class="keyword">return</span> min + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v14"><a class="header-anchor" href="#解题思路2-v14"> </a>解题思路2</h3>
<p>另一种做法是广度遍历</p>
<p>广度遍历借助队列的结构，根据这道题，需要判断一整层是否都没有存在叶子节点，才需要使我们记录的最小深度加一。</p>
<p>所以类似“<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a>”这道题的解法，需要先记录队列长度，遍历整层再判断</p>
<p>对于官方解法不是将整层取出来遍历，而是定义一个新的类来保存该结点以及该节点所对应的深度，这样就不需要将整层取出来了。</p>
<h3 id="解题代码2-v14"><a class="header-anchor" href="#解题代码2-v14"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>) queue.offer(root.left);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>) queue.offer(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//我们需要一整层的结果，才能判断该层是否存在最短的叶子节点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="comment">//找到叶子结点</span></span><br><span class="line">                <span class="keyword">if</span>(cur.left == <span class="literal">null</span> &amp;&amp; cur. right == <span class="literal">null</span>) <span class="keyword">return</span> depth+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) queue.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//整层都没有叶子节点</span></span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="112-路径总和"><a class="header-anchor" href="#112-路径总和"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a></h2>
<h3 id="题目-v52"><a class="header-anchor" href="#题目-v52"> </a>题目</h3>
<p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<blockquote>
<p>示例:<br>
给定如下二叉树，以及目标和 sum = 22，<br>
5<br>
/ <br>
4   8<br>
/     / <br>
11  13  4<br>
/  \      <br>
7    2      1<br>
返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p>
</blockquote>
<h3 id="解题思路1-v11"><a class="header-anchor" href="#解题思路1-v11"> </a>解题思路1</h3>
<p>可以通过递归的方式。如果当前判断当前根节点是否存在满足路径总和，即判断其左右子节点是否存在满足总路径和。</p>
<p>同时要注意该题是到叶子节点的总路径和，而不是到空结点的总路径和。所以遍历的思想参考“<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a>”的做法</p>
<h3 id="解题代码1-v12"><a class="header-anchor" href="#解题代码1-v12"> </a>解题代码1</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过递归的方式，判断根节点是否有该目标和</span></span><br><span class="line">        <span class="comment">// 即判断子节点是否有减去根节点的值的目标和</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> sum-root.val==<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.right,sum-root.val) || hasPathSum(root.left,sum-root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v15"><a class="header-anchor" href="#解题思路2-v15"> </a>解题思路2</h3>
<p>也可以通过广度优先的方式，进行遍历。</p>
<p>一个队列用于保存该层结点</p>
<p>另一个队列用于保存该层结点所对应：从上层传下来的值，减去自身值。即如果该队列存在一个叶子节点，同时对应数值队列的值为0，则该叶子节点为满足的结点</p>
<h3 id="解题代码2-v15"><a class="header-anchor" href="#解题代码2-v15"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">//广度优先遍历</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queueNode = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; queueValue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queueNode.offer(root);</span><br><span class="line">        queueValue.offer(sum-root.val);</span><br><span class="line">        <span class="keyword">while</span>(!queueNode.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">curNode</span> <span class="operator">=</span> queueNode.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> queueValue.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span>curNode.left;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> curNode.right;</span><br><span class="line">            <span class="keyword">if</span>(leftNode == <span class="literal">null</span> &amp;&amp; rightNode == <span class="literal">null</span> &amp;&amp; val == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(leftNode != <span class="literal">null</span>)&#123;</span><br><span class="line">                queueNode.offer(leftNode);</span><br><span class="line">                queueValue.offer(val - leftNode.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rightNode != <span class="literal">null</span>)&#123;</span><br><span class="line">                queueNode.offer(rightNode);</span><br><span class="line">                queueValue.offer(val - rightNode.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="226-翻转二叉树"><a class="header-anchor" href="#226-翻转二叉树"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h2>
<h3 id="题目-v53"><a class="header-anchor" href="#题目-v53"> </a>题目</h3>
<p>翻转一棵二叉树。</p>
<blockquote>
<p>示例：<br>
输入：<br>
4<br>
/     <br>
2        7<br>
/  \       /   <br>
1    3     6    9<br>
输出：<br>
4<br>
/        <br>
7            2<br>
/   \         /   <br>
9     6      3    1</p>
</blockquote>
<h3 id="解题思路-v38"><a class="header-anchor" href="#解题思路-v38"> </a>解题思路</h3>
<p>这题用递归的做法较为简单</p>
<p>有两种递归思路</p>
<ol>
<li>自底向上的对换左右子树</li>
<li>自顶向下的对换左右子树</li>
</ol>
<h3 id="解题代码1自底向上"><a class="header-anchor" href="#解题代码1自底向上"> </a>解题代码1自底向上</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//递归做法</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//一种是先转换当前结点，再转换子节点</span></span><br><span class="line">        <span class="comment">//另一种是先转换子节点，再转换当前结点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> invertTree(root.left);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> invertTree(root.right);</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码2自顶向下"><a class="header-anchor" href="#解题代码2自顶向下"> </a>解题代码2自顶向下</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//递归做法</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//一种是先转换当前结点，再转换子节点</span></span><br><span class="line">        <span class="comment">//另一种是先转换子节点，再转换当前结点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="235-二叉搜索树的最近公共祖先"><a class="header-anchor" href="#235-二叉搜索树的最近公共祖先"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h2>
<h3 id="题目-v54"><a class="header-anchor" href="#题目-v54"> </a>题目</h3>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="http://algorithm-image.qibinaoe.top/binarysearchtree_improved.png" alt="img"></p>
<blockquote>
<p>示例 1:<br>
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>
输出: 6<br>
解释: 节点 2 和节点 8 的最近公共祖先是 6。</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>
输出: 2<br>
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p>
</blockquote>
<p>说明:<br>
所有节点的值都是唯一的。<br>
p、q 为不同节点且均存在于给定的二叉搜索树中。</p>
<h3 id="解题思路1-v12"><a class="header-anchor" href="#解题思路1-v12"> </a>解题思路1</h3>
<p>开始的时候，没有注意到该结点为二叉搜索树，没有利用这个二叉搜索树的的性质的时候（即<strong>左子树的值都比根节点小，右子树的值都比根节点大</strong>），一脸懵逼。但是注意到这点问题就变得比较简单</p>
<p>首先可以通过递归的方式。获取<strong>根节点的值</strong>、<strong>结点<code>p</code>的值</strong>、<strong>结点<code>q</code>的值</strong>。然后从根节点开始，比较它们大小。同时为了方便，可以先算出<code>p</code>和<code>q</code>中的最大值和最小值</p>
<p>可以分成5种情况</p>
<ul>
<li>根节点值大于最大值</li>
<li>根节点值等于最大值</li>
<li>根节点的值小于最大值，大于最小值</li>
<li>根节点的值等于最小值</li>
<li>根节点的值小于最小值</li>
</ul>
<p>可以通过树的图，清楚的看到。</p>
<p>如果大于最大值，则意味着，<code>p</code>、<code>q</code>两个结点都会在根节点左边。此时递归判断根节点的左孩子和<code>p</code>、<code>q</code>的关系</p>
<p>如果等于最大值的情况。说明根节点即为最大值所在的结点，而最小值在根节点的左子树中，此时返回根节点</p>
<p>如果大于最小组，小于最大值。说明，最小值在根节点的左子树，最大值在根节点的右子树，此时返回根节点</p>
<p>如果等于最小值。说明根节点为最小值的结点，而最大值在根节点的右子树中，此时也可以直接返回根节点</p>
<p>如果小于最小值，说明<code>p</code>和<code>q</code>都在根节点的右子树中，此时就去判断根节点的右孩子和<code>p</code>、<code>q</code>的关系</p>
<h3 id="解题代码1-v13"><a class="header-anchor" href="#解题代码1-v13"> </a>解题代码1</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> min;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        min = Math.min(p.val,q.val);</span><br><span class="line">        max = Math.max(p.val,q.val);</span><br><span class="line">        <span class="keyword">return</span> getCommonAncestor(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">getCommonAncestor</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; max)&#123;</span><br><span class="line">            <span class="comment">//最近公共祖先在左子树中</span></span><br><span class="line">            <span class="keyword">return</span> getCommonAncestor(root.left);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val == max)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; min)&#123;</span><br><span class="line">            <span class="comment">//p和q分别在左右两子树中，因此该结点为最近的公共祖先</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val == min)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//在右子树</span></span><br><span class="line">            <span class="keyword">return</span> getCommonAncestor(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v16"><a class="header-anchor" href="#解题思路2-v16"> </a>解题思路2</h3>
<p>也可以通过迭代的方式，思路大同小异</p>
<h3 id="解题代码2-v16"><a class="header-anchor" href="#解题代码2-v16"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(p.val,q.val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.max(p.val,q.val);</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val &gt; max)&#123;</span><br><span class="line">            <span class="comment">//最近公共祖先在左子树中</span></span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val == max)&#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; min)&#123;</span><br><span class="line">                <span class="comment">//p和q分别在左右两子树中，因此该结点为最近的公共祖先</span></span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val == min)&#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//在右子树</span></span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="257-二叉树的所有路径"><a class="header-anchor" href="#257-二叉树的所有路径"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h2>
<h3 id="题目-v55"><a class="header-anchor" href="#题目-v55"> </a>题目</h3>
<p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<blockquote>
<p>示例:<br>
输入:<br>
1<br>
/   <br>
2     3<br>
<br>
5<br>
输出: [“1-&gt;2-&gt;5”, “1-&gt;3”]</p>
</blockquote>
<p>解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3</p>
<h3 id="解题思路-v39"><a class="header-anchor" href="#解题思路-v39"> </a>解题思路</h3>
<p>对于这道题，应该用深度优先去遍历。在递归的过程中，携带上一层的路径字符串，同时判断遍历到的该结点的情况，如果非叶子节点，则拼接并递归到叶子节点。</p>
<p>注意一下路径字符串拼接的样子</p>
<h3 id="解题代码-v22"><a class="header-anchor" href="#解题代码-v22"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; ans;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        getPath(root,path);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPath</span><span class="params">(TreeNode root,String path)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//说明该节点为叶子结点</span></span><br><span class="line">            path += String.valueOf(root.val);</span><br><span class="line">            ans.add(path);</span><br><span class="line">        &#125;</span><br><span class="line">        path = path + String.valueOf(root.val)+ <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            getPath(root.left,path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            getPath(root.right,path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v17"><a class="header-anchor" href="#解题思路2-v17"> </a>解题思路2</h3>
<p>该题也可以通过广度遍历，利用两个队列，一个用于储存结点，一个用于储存该结点所对应的路径字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//广度优先遍历</span></span><br><span class="line">        <span class="comment">//基本思路是一个储存结点的队列 对应一个储存路径字符串的队列</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queueNode = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;String&gt; queuePath = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        queueNode.offer(root);</span><br><span class="line">        queuePath.offer(Integer.toString(root.val));</span><br><span class="line">        <span class="keyword">while</span>(!queueNode.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">curNode</span> <span class="operator">=</span> queueNode.poll();</span><br><span class="line">            <span class="type">String</span> <span class="variable">curPath</span> <span class="operator">=</span> queuePath.poll();</span><br><span class="line">            <span class="keyword">if</span>(curNode.left == <span class="literal">null</span> &amp;&amp; curNode.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                ans.add(curPath);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(curNode.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                queueNode.offer(curNode.left);</span><br><span class="line">                queuePath.offer(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(curPath).append(<span class="string">&quot;-&gt;&quot;</span>).append(Integer.toString(curNode.left.val)).toString());   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curNode.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                queueNode.offer(curNode.right);</span><br><span class="line">                queuePath.offer(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(curPath).append(<span class="string">&quot;-&gt;&quot;</span>).append(Integer.toString(curNode.right.val)).toString());   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="404-左叶子之和"><a class="header-anchor" href="#404-左叶子之和"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-left-leaves/">404. 左叶子之和</a></h2>
<h3 id="题目-v56"><a class="header-anchor" href="#题目-v56"> </a>题目</h3>
<p>计算给定二叉树的所有左叶子之和。</p>
<blockquote>
<p>示例：<br>
3<br>
/  <br>
9   20<br>
/  <br>
15   7<br>
在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</p>
</blockquote>
<h3 id="解题思路-v40"><a class="header-anchor" href="#解题思路-v40"> </a>解题思路</h3>
<p>这题我的思路是通过递归来寻找<strong>左叶子节点</strong>，并将其返回。而如何判断递归到的这一个结点是左节点还是右节点呢？我通过在遍历下一层的时候传入一个值（例如左子孩子为0，右孩子为1）这样就解决该结点是左孩子还是右孩子的问题。</p>
<p>而如何获得总和呢？通过递归的思路，如果该结点为左叶子节点，意味着这个结点的左叶子之后为它本身。如果为中间结点的话，则左叶子节点之和和其左子树的叶子节点加上其右子树的叶子节点</p>
<h3 id="解题代码-v23"><a class="header-anchor" href="#解题代码-v23"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> checkLeftSum(<span class="number">0</span>,root.left) + checkLeftSum(<span class="number">1</span>,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">checkLeftSum</span><span class="params">(<span class="type">int</span> type,TreeNode root)</span>&#123;</span><br><span class="line">        <span class="comment">//type 0 左孩子 </span></span><br><span class="line">        <span class="comment">//type 1 右孩子</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">0</span> &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> checkLeftSum(<span class="number">0</span>,root.left) + checkLeftSum(<span class="number">1</span>,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v18"><a class="header-anchor" href="#解题思路2-v18"> </a>解题思路2</h3>
<p>官方题解的整体思路是提前判断。</p>
<p>如果根节点不为空的话，提前判断该根节点的左孩子如果是左叶子节点，是则记录该值；如果为空，则不关；如果是中间节点，则继续访问。判断右孩子如果为叶子节点，则不管；如果为空，则不管；如果为中间结点，则继续访问。同时在这个过程中，累加左叶子结点的值。</p>
<h3 id="解题代码2-0"><a class="header-anchor" href="#解题代码2-0"> </a>解题代码2.0</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root==<span class="literal">null</span>? <span class="number">0</span> : dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isLeaf(root.left))&#123;</span><br><span class="line">                ans += root.left.val;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans += dfs(root.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span> &amp;&amp; !isLeaf(root.right))&#123;</span><br><span class="line">            ans += dfs(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLeaf</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码2-1"><a class="header-anchor" href="#解题代码2-1"> </a>解题代码2.1</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isLeaf(cur.left))&#123;</span><br><span class="line">                    sum+= cur.left.val;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    queue.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span> &amp;&amp; !isLeaf(cur.right))&#123;</span><br><span class="line">                queue.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLeaf</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="501-二叉搜索树中的众数"><a class="header-anchor" href="#501-二叉搜索树中的众数"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></h2>
<h3 id="题目-v57"><a class="header-anchor" href="#题目-v57"> </a>题目</h3>
<p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p>
<p>假定 BST 有如下定义：</p>
<p>结点左子树中所含结点的值小于等于当前结点的值<br>
结点右子树中所含结点的值大于等于当前结点的值<br>
左子树和右子树都是二叉搜索树</p>
<blockquote>
<p>例如：<br>
给定 BST [1,null,2,2],<br>
1<br>
<br>
2<br>
/<br>
2<br>
返回[2].</p>
</blockquote>
<blockquote>
<p>提示：如果众数超过1个，不需考虑输出顺序<br>
进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p>
</blockquote>
<h3 id="解题思路1-v13"><a class="header-anchor" href="#解题思路1-v13"> </a>解题思路1</h3>
<p>开始我解决这题的想法是通过简单粗暴的方式。既然题目需要众数，那我们就把整个树遍历一遍，同时储存每一个出现过的数字的次数。最后再挑出最大值塞进答案中，即可。</p>
<p>但是这种做法效率和空间利用率较低</p>
<h3 id="解题代码1效率较低版"><a class="header-anchor" href="#解题代码1效率较低版"> </a>解题代码1效率较低版</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            map.put(cur.val,map.getOrDefault(cur.val,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) queue.offer(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) queue.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> maxValue;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="keyword">if</span>(count &gt; maxCount)&#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">                maxCount = count;</span><br><span class="line">                ans.clear();</span><br><span class="line">                ans.add(value);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count == maxCount)&#123;</span><br><span class="line">                ans.add(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[ans.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ans.size(); i++)&#123;</span><br><span class="line">            result[i] = ans.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2初步优化"><a class="header-anchor" href="#解题思路2初步优化"> </a>解题思路2初步优化</h3>
<p>看了官解的做法，这道题可以通过两步优化：一、优化哈希表储存的空间。二、优化遍历树占用的栈空间</p>
<p>先是优化哈希表的储存空间</p>
<p>可以注意到，题目给的二叉树是一棵<strong>二叉搜索树BST</strong>，而BST树通过<strong>中序遍历（左孩子、根节点、右孩子）<strong>得到的结果是一个有序的数组，由于题目给的BST树是存在相同数字的，所以遍历结果是一个</strong>非递减的序列</strong>。</p>
<p>而如何不使用哈希表去记录存在的众数呢？</p>
<p>可以注意到，出现的相同数字是连续出现的。因此我们可以通过以下几个变量去实时记录和更改众数</p>
<ul>
<li><code>base</code>：记录当前遍历的数字。
<ul>
<li>通过记录这个数字，才可以在遍历下一个结点时，判断是否在连续数字出现的区间中</li>
</ul>
</li>
<li><code>count</code>：记录当前遍历的数字出现的次数
<ul>
<li>如果第一次<code>base</code>与上一次不同，则更改<code>base</code>，同时<code>count</code>置为一。否则<code>count++</code></li>
</ul>
</li>
<li><code>maxCount</code>：来保存目前为止，出现过的最大<code>count</code>值
<ul>
<li>如果<code>count &gt; maxCount</code>，说明最大众数已经变了，需要<strong>清空</strong>已经保存的答案数组。同时将新的众数加入答案数组中，并把<code>maxCount = count</code></li>
<li>如果<code>count == maxCount</code>，说明遍历到的当前数字与记录中的数字，出现的次数一致，都是众数。因此将该数加入答案数组中</li>
</ul>
</li>
<li><code>answers</code>：答案数组，用于保存出现的次数最多的数字。因为众数可能不唯一，所以声明为数组</li>
</ul>
<h3 id="解题代码2-v17"><a class="header-anchor" href="#解题代码2-v17"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; answers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 这里不赋值的话，也是默认为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[answers.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; answers.size(); i++)&#123;</span><br><span class="line">            result[i] = answers.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="comment">//递归的方式进行中序遍历</span></span><br><span class="line">        <span class="comment">//会占用栈空间</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        update(root.val); <span class="comment">//判断当前结点，进行操作</span></span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(val == base)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            base = val;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; maxCount)&#123;</span><br><span class="line">            <span class="comment">//说明之前存的答案数组都是假的众数，清空</span></span><br><span class="line">            answers.clear();</span><br><span class="line">            answers.add(val);</span><br><span class="line">            maxCount = count;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count == maxCount)&#123;</span><br><span class="line">            answers.add(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路3再优化-morris中序遍历"><a class="header-anchor" href="#解题思路3再优化-morris中序遍历"> </a>解题思路3再优化 morris中序遍历</h3>
<p>在一般的中序遍历中，由于访问顺序是左孩子-&gt;根节点-&gt;右孩子。</p>
<p>所以如果我们直接去访问左孩子，而不做任何措施保存根节点，这样我们就回不到根节点了。</p>
<p>所以通常做法是：</p>
<p>如果通过递归回溯的方式，那么在访问左孩子时，根节点被压入栈空间中。当递归返回时，根节点就回来了。</p>
<p>如果通过迭代的方式，也需要我们手动维护一个栈。所以这两种方法都需要消耗栈空间的大小。</p>
<p>而morris中序遍历通过改变树的结构，来达到访问左节点的时候能够保存当前结点，以便前驱结点访问后，能够回到当前结点。</p>
<p>对于morris中序遍历思想的学习，我是结合 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-zhong-shu-by-leetcode-/">leetcode官解介绍</a>和 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13J411z7Z5?from=search&amp;seid=13089413801761549678">【算法奇淫技】第一期Morris遍历（二叉树的特殊遍历法）</a>的学习。</p>
<p>其中实现的最基本操作就是：将<strong>当前结点</strong>的<strong>左孩子</strong>的<strong>最右结点</strong>指向<strong>当前结点</strong>。</p>
<p>这样做的目的是，我们在每一次访问某个结点时，去找到其左孩子的最右结点。这个“左孩子的最右结点”即为当前结点的前驱结点（前驱结点意思就是按中序遍历的顺序中，访问了“左孩子的最右结点”之后，就该访问当前结点了）。</p>
<p>当我们找到了“左孩子的最右结点”后，需要判断，这个节点是否已经指向了当前结点。如果没有，就将其指向当前结点；如果指向了，说明我们已经设置过这个结点，同时也表明当前结点的左子树都已经遍历过了，接下来是访问当前结点，然后去访问其右孩子。</p>
<p>当然，如果当前结点连左孩子都没有的时候，说明可以直接访问当前结点，在访问右孩子。直到遍历到左右孩子都为空。</p>
<p>虽然morris算法的空间复杂度为O(1)，但是这种算法的时间上的效率会相对较低一点，毕竟对于每个节点都要去看一看它左孩子的最右结点。</p>
<h3 id="解题代码3-v5"><a class="header-anchor" href="#解题代码3-v5"> </a>解题代码3</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; answers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 这里不赋值的话，也是默认为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        morris(root);</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[answers.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; answers.size(); i++)&#123;</span><br><span class="line">            result[i] = answers.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">morris</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="comment">//morris中序遍历</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//判断左子树是否为空</span></span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//说明当前结点可以进行操作</span></span><br><span class="line">                update(root.val);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//获得当前结点的左子树的最右结点</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">prev</span> <span class="operator">=</span> root.left;</span><br><span class="line">                <span class="keyword">while</span>(prev.right != <span class="literal">null</span> &amp;&amp; prev.right != root) prev = prev.right;</span><br><span class="line">                <span class="comment">//判断是否是当前结点</span></span><br><span class="line">                <span class="comment">//如果是，说明已经设置过，可以进行访问</span></span><br><span class="line">                <span class="comment">//如果没有，则将其右节点指向当前结点，并访问其左节点，因为我们已经将当前节点储存到leftNode.right，所以不用担心访问不到</span></span><br><span class="line">                <span class="keyword">if</span>(prev.right == root)&#123;</span><br><span class="line">                    prev.right = <span class="literal">null</span>; <span class="comment">//复原，但是不写不影响答案</span></span><br><span class="line">                    update(root.val);</span><br><span class="line">                    root = root.right;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    prev.right = root;</span><br><span class="line">                    root = root.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(val == base)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            base = val;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; maxCount)&#123;</span><br><span class="line">            <span class="comment">//说明之前存的答案数组都是假的众数，清空</span></span><br><span class="line">            answers.clear();</span><br><span class="line">            answers.add(val);</span><br><span class="line">            maxCount = count;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count == maxCount)&#123;</span><br><span class="line">            answers.add(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="530-二叉搜索树的最小绝对差"><a class="header-anchor" href="#530-二叉搜索树的最小绝对差"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h2>
<h3 id="题目-v58"><a class="header-anchor" href="#题目-v58"> </a>题目</h3>
<p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p>
<blockquote>
<p>示例：<br>
输入：<br>
1<br>
<br>
3<br>
/<br>
2<br>
输出：<br>
1<br>
解释：<br>
最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。</p>
</blockquote>
<p>提示：</p>
<p>树中至少有 2 个节点。</p>
<h3 id="解题思路-v41"><a class="header-anchor" href="#解题思路-v41"> </a>解题思路</h3>
<p>注意到这题是一棵BST树。而题目要求的是差的绝对值的最小值。那么这个数值只可能出现在两个相邻结点中（即某个结点与它的前驱结点或某个结点与它的后继结点）。</p>
<p>根据这个思路，我们进行中序遍历，并边遍历，边判断是否是最小绝对差。</p>
<p>我认为这题的难点在于上一个数值（<code>preval</code>）的初始化和最小绝对差（<code>minAbs</code>）的初始化。</p>
<p>于是我就采用最土的方式：判断是否是第一个数，判断是否是第二个数，来解决这个问题</p>
<p>注：开始的时候，我是这样初始化的：<code>preval = Integer.MIN_VALUE;</code> 和<code>minAbs = Integer.MAX_VALUE;</code>结果出现了整型溢出了。</p>
<p>看到官解它是这样初始化的：<code>preval = -1</code> 和<code>minAbs = Integer.MAX_VALUE;</code>然后通过判断<code>preval == -1</code>来分辨是否是第一次。</p>
<h3 id="解题代码1-0-v3"><a class="header-anchor" href="#解题代码1-0-v3"> </a>解题代码1.0</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> preval; <span class="comment">//上一个数值</span></span><br><span class="line">    <span class="type">int</span> minAbs; <span class="comment">// 最小绝对值</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">first</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">//判断是否是第一个数</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">second</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 判断是否是第二个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//中序遍历，计算两个相邻数的差值</span></span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">return</span> minAbs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        calculate(root.val);</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="comment">//1.计算差值的绝对值</span></span><br><span class="line">        <span class="comment">//2.比较与记录值的大小</span></span><br><span class="line">        <span class="keyword">if</span>(first)&#123;</span><br><span class="line">            preval = val;</span><br><span class="line">            first = <span class="literal">false</span>;</span><br><span class="line">            second = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> Math.abs(val-preval);</span><br><span class="line">        <span class="keyword">if</span>(second)&#123;</span><br><span class="line">            minAbs = diff;</span><br><span class="line">            preval = val;</span><br><span class="line">            second = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;            </span><br><span class="line">        &#125;</span><br><span class="line">        minAbs = diff &lt; minAbs?diff:minAbs;</span><br><span class="line">        preval = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码2-0-v2"><a class="header-anchor" href="#解题代码2-0-v2"> </a>解题代码2.0</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> preval; <span class="comment">//上一个数值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">minAbs</span> <span class="operator">=</span> Integer.MAX_VALUE; <span class="comment">// 最小绝对值</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">first</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">//判断是否是第一个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//中序遍历，计算两个相邻数的差值</span></span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">return</span> minAbs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        calculate(root.val);</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="comment">//1.计算差值的绝对值</span></span><br><span class="line">        <span class="comment">//2.比较与记录值的大小</span></span><br><span class="line">        <span class="keyword">if</span>(first)&#123;</span><br><span class="line">            preval = val;</span><br><span class="line">            first = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> Math.abs(val-preval);</span><br><span class="line">        minAbs = diff &lt; minAbs?diff:minAbs;</span><br><span class="line">        preval = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="543-二叉树的直径"><a class="header-anchor" href="#543-二叉树的直径"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h2>
<h3 id="题目-v59"><a class="header-anchor" href="#题目-v59"> </a>题目</h3>
<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<blockquote>
<p>示例 :<br>
给定二叉树<br>
1<br>
/ <br>
2   3<br>
/ \<br>
4   5<br>
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p>
</blockquote>
<p>注意：两结点之间的路径长度是以它们之间边的数目表示。</p>
<h3 id="解题思路-v42"><a class="header-anchor" href="#解题思路-v42"> </a>解题思路</h3>
<p>这题计算树的直径，可以看到，计算直径的过程又与计算树的高度有关系（“<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a>”）。即一个树的某个结点的直径即为其左子树的深度加上右子树的深度。</p>
<p>因此，我们可以根据递归算出左子树的深度，右子树的深度，（注意<u><strong>“两结点之间的路径长度是以它们之间边的数目表示”</strong></u>，因此深度之和后不需要再加1），然后相加判断当前的直径是否是最大直径。由于最大直径只需要一个变量即可满足，因此可以把它定义在函数外，然后的每个递归中去判断当前的直径和最大直径大小即可</p>
<h3 id="解题代码-v24"><a class="header-anchor" href="#解题代码-v24"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">maxDiameter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//可以在获取树的高度的同时，计算是否大于最大直径，如果是，更新</span></span><br><span class="line">        <span class="comment">// 由于最大直径在整个计算过程具有唯一性，所以定义成全局变量就可以了，不需要每次递归都返回</span></span><br><span class="line">        height(root);</span><br><span class="line">        <span class="keyword">return</span> maxDiameter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> height(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> height(root.right);</span><br><span class="line">        <span class="comment">//判断是否大于最大直径</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">diameter</span> <span class="operator">=</span> leftHeight+rightHeight;</span><br><span class="line">        <span class="keyword">if</span>(diameter &gt; maxDiameter) maxDiameter = diameter;</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftHeight,rightHeight) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="559-N-叉树的最大深度"><a class="header-anchor" href="#559-N-叉树的最大深度"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></h2>
<h3 id="题目-v60"><a class="header-anchor" href="#题目-v60"> </a>题目</h3>
<p>给定一个 N 叉树，找到其最大深度。</p>
<p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p>
<p>N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。</p>
<blockquote>
<p>示例 1：<br>
输入：root = [1,null,3,2,4,null,5,6]<br>
输出：3</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>
输出：5</p>
</blockquote>
<blockquote>
<p>提示：<br>
树的深度不会超过 1000 。<br>
树的节点数目位于 [0, 104] 之间。</p>
</blockquote>
<h3 id="解题思路1-v14"><a class="header-anchor" href="#解题思路1-v14"> </a>解题思路1</h3>
<p>我觉得求N叉树的最大深度的思想与“<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a>”的思想是一样的。</p>
<p>主要有两种方式去做：</p>
<ol>
<li>
<p>通过深度优先遍历，用递归的方式，判断N个孩子的最大深度，然后返回自身加1</p>
</li>
<li>
<p>通过广度优先遍历，借助队列的方式，遍历到最深层</p>
</li>
</ol>
<p>不同点在于孩子的个数，N叉树需要把每个孩子都取出来，然后获取其值最大的那个孩子。</p>
<p>由于要比较这N个孩子的最小值，想想太过麻烦，于是想到<code>PriorityQueue</code>能够取出最小值（或者最大值），通过传入一个<code>Comparator</code>即可实现。于是第一种方法就是借助优先队列完成</p>
<h3 id="解题代码1-v14"><a class="header-anchor" href="#解题代码1-v14"> </a>解题代码1</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="comment">//递归法</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//获取孩子们的最大深度</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((Integer a, Integer b)-&gt; b-a);</span><br><span class="line">        <span class="keyword">for</span>(Node child : root.children)&#123;</span><br><span class="line">            <span class="keyword">if</span>(child != <span class="literal">null</span>) queue.offer(maxDepth(child));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty()?<span class="number">1</span> : queue.poll()+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码2-v18"><a class="header-anchor" href="#解题代码2-v18"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="comment">//递归法</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.children.isEmpty()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        List&lt;Integer&gt; heights = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Node child : root.children)&#123;</span><br><span class="line">            heights.add(maxDepth(child));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Collections.max(heights)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码3-v6"><a class="header-anchor" href="#解题代码3-v6"> </a>解题代码3</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个版本是最快的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="comment">//递归法</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.children.isEmpty()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(Node child : root.children)&#123;</span><br><span class="line">            ans = Math.max(maxDepth(child),ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码4-v3"><a class="header-anchor" href="#解题代码4-v3"> </a>解题代码4</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="comment">//层次遍历法</span></span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) queue.add(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="comment">//整层取出来</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">for</span>(Node child : cur.children)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(child != <span class="literal">null</span>)&#123;</span><br><span class="line">                        queue.offer(child);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码5"><a class="header-anchor" href="#解题代码5"> </a>解题代码5</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这方法最慢</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="comment">//层次遍历法</span></span><br><span class="line">        Queue&lt;Pair&lt;Node,Integer&gt;&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) queue.add(<span class="keyword">new</span> <span class="title class_">Pair</span>(root,<span class="number">1</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            Pair&lt;Node,Integer&gt; p = queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">curDepth</span> <span class="operator">=</span> p.getValue();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">curNode</span> <span class="operator">=</span> p.getKey();</span><br><span class="line">            depth = curDepth &gt; depth ? curDepth : depth;</span><br><span class="line">            <span class="keyword">for</span>(Node child : curNode.children)&#123;</span><br><span class="line">                <span class="keyword">if</span>(child != <span class="literal">null</span>) queue.offer(<span class="keyword">new</span> <span class="title class_">Pair</span>(child,curDepth + <span class="number">1</span>));</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="563-二叉树的坡度"><a class="header-anchor" href="#563-二叉树的坡度"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-tilt/">563. 二叉树的坡度</a></h2>
<h3 id="题目-v61"><a class="header-anchor" href="#题目-v61"> </a>题目</h3>
<p>给定一个二叉树，计算 整个树 的坡度 。</p>
<p>一个树的 节点的坡度 定义即为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。</p>
<p>整个树 的坡度就是其所有节点的坡度之和。</p>
<blockquote>
<p>示例 1：<br>
输入：root = [1,2,3]<br>
输出：1<br>
解释：<br>
节点 2 的坡度：|0-0| = 0（没有子节点）<br>
节点 3 的坡度：|0-0| = 0（没有子节点）<br>
节点 1 的坡度：|2-3| = 1（左子树就是左子节点，所以和是 2 ；右子树就是右子节点，所以和是 3 ）<br>
坡度总和：0 + 0 + 1 = 1</p>
<p><img src="http://algorithm-image.qibinaoe.top/tilt1.jpg" alt="img"></p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：root = [4,2,9,3,5,null,7]<br>
输出：15<br>
解释：<br>
节点 3 的坡度：|0-0| = 0（没有子节点）<br>
节点 5 的坡度：|0-0| = 0（没有子节点）<br>
节点 7 的坡度：|0-0| = 0（没有子节点）<br>
节点 2 的坡度：|3-5| = 2（左子树就是左子节点，所以和是 3 ；右子树就是右子节点，所以和是 5 ）<br>
节点 9 的坡度：|0-7| = 7（没有左子树，所以和是 0 ；右子树正好是右子节点，所以和是 7 ）<br>
节点 4 的坡度：|(3+5+2)-(9+7)| = |10-16| = 6（左子树值为 3、5 和 2 ，和是 10 ；右子树值为 9 和 7 ，和是 16 ）<br>
坡度总和：0 + 0 + 0 + 2 + 7 + 6 = 15</p>
<p><img src="http://algorithm-image.qibinaoe.top/tilt2.jpg" alt="img"></p>
</blockquote>
<blockquote>
<p>示例 3：<br>
输入：root = [21,7,14,1,1,2,2,3,3]<br>
输出：9</p>
<p><img src="http://algorithm-image.qibinaoe.top/tilt3.jpg" alt="img"></p>
</blockquote>
<blockquote>
<p>提示：<br>
树中节点数目的范围在 [0, 104] 内<br>
-1000 &lt;= Node.val &lt;= 1000</p>
</blockquote>
<h3 id="解题思路-v43"><a class="header-anchor" href="#解题思路-v43"> </a>解题思路</h3>
<p>要解决这题首先要理解题目中坡度的意思。</p>
<p><strong>一个</strong>结点的<strong>坡度</strong>指的是：该结点的<strong>左子树</strong>中的所有结点的<strong>值之和</strong>与该结点的<strong>右子树</strong>的所有结点的<strong>值之和</strong>，这两个左子树的和与右子树的和的<strong>差的绝对值</strong></p>
<p>而对于题目要<strong>求</strong>的是<strong>整个树</strong>的坡度。即<strong>每个结点</strong>的坡度的<strong>和</strong>。</p>
<p>显然这个题目有种递归的感觉，但是又带点迷惑性。因为对于某个结点而言，我们要算的是其左右子树的差。但是我们又要其左右子树的和，来返回给父结点。</p>
<p>因此我想到的解决办法是定义一个全局变量<code>totalTilt = 0</code>初始化为零。我们先不管坡度的定义。我们去思考，如何去算一个结点的左子树之和，和其右子树子树，并返回这两个值的总和。解决了这个问题之后。我们只需要在递归的过程中。将一个结点的左右子树和的差的绝对值加入我们定义的全局变量，即可得到答案。</p>
<h3 id="解题代码-v25"><a class="header-anchor" href="#解题代码-v25"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">totalTilt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTilt</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        treeSum(root);</span><br><span class="line">        <span class="keyword">return</span> totalTilt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">treeSum</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSum</span> <span class="operator">=</span>  treeSum(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightSum</span> <span class="operator">=</span> treeSum(root.right);</span><br><span class="line">        totalTilt+= Math.abs(leftSum-rightSum);</span><br><span class="line">        <span class="keyword">return</span> root.val + leftSum + rightSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="572-另一个树的子树"><a class="header-anchor" href="#572-另一个树的子树"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subtree-of-another-tree/">572. 另一个树的子树</a></h2>
<h3 id="题目-v62"><a class="header-anchor" href="#题目-v62"> </a>题目</h3>
<p>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p>
<blockquote>
<p>示例 1:<br>
给定的树 s:<br>
3<br>
/ <br>
4   5<br>
/ <br>
1   2<br>
给定的树 t：<br>
4<br>
/ <br>
1   2<br>
返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
给定的树 s：<br>
3<br>
/ <br>
4   5<br>
/ <br>
1   2<br>
/<br>
0<br>
给定的树 t：<br>
4<br>
/ <br>
1   2<br>
返回 false。</p>
</blockquote>
<h3 id="解题思路-v44"><a class="header-anchor" href="#解题思路-v44"> </a>解题思路</h3>
<p>这题显然可以用递归的方法去求解。即判断一棵树t是否是另一棵树s的子树，只需判断t和s是否是相等的树，或者t和s的左子树相等，或者t和s的右子树相等，或者t是s的左子树的一棵子树，或者t是s的右子树的一棵子树。根据这个条件可以写递归的函数。</p>
<p>但是要注意一点，要区别子树和相等的条件。以下是<strong>错误</strong>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> ^ t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> &amp;&amp; t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.val != t.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> isSubtree(s.left,t) || isSubtree(s.right,t);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (isSubtree(s.left,t.left) &amp;&amp; isSubtree(s.right,t.right)) || isSubtree(s.left,t) || isSubtree(s.right,t);<span class="comment">//ERROR 主要是这一步是错的。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在分析一下最后一个<code>return</code>为什么是错的：</p>
<p>这个语句块的条件是s的值等于t的值。那么s和t可能就是一棵相同的树，那么继续判断是不是真的是一棵相同树，应该判断s的左子树是否和t的左子树<strong>完全相等</strong>，s的右子树是否和t的右子树<strong>完全相等</strong>。而这个语句块却写的是：<code>isSubtree(s.left,t.left) &amp;&amp; isSubtree(s.right,t.right)</code>即s的左子树是否包括t.左子树（有可能存在s的左子树中有t的左子树中没有的结点），s的右子树是否包括t的右子树。这样一来，成为子树的条件就<strong>放宽</strong>了，导致出错。</p>
<p>例如当s为</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201219164624286.png" alt="image-20201219164624286"></p>
<p>t为</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201219164646422.png" alt="image-20201219164646422"></p>
<p>就错了。</p>
<h3 id="解题代码-v26"><a class="header-anchor" href="#解题代码-v26"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> ^ t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> &amp;&amp; t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.val != t.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> isSubtree(s.left,t) || isSubtree(s.right,t);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (isSameTree(s.left,t.left) &amp;&amp; isSameTree(s.right,t.right)) || isSubtree(s.left,t) || isSubtree(s.right,t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode s, TreeNode t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> ^ t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> &amp;&amp; t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.val != t.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> isSameTree(s.left,t.left) &amp;&amp; isSameTree(s.right,t.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="589-N叉树的前序遍历"><a class="header-anchor" href="#589-N叉树的前序遍历"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/">589. N叉树的前序遍历</a></h2>
<h3 id="题目-v63"><a class="header-anchor" href="#题目-v63"> </a>题目</h3>
<p>给定一个 N 叉树，返回其节点值的前序遍历。</p>
<p>例如，给定一个 3叉树 :</p>
<p><img src="http://algorithm-image.qibinaoe.top/narytreeexample.png" alt="img">返回其前序遍历: [1,3,5,6,2,4]。</p>
<p>说明: 递归法很简单，你可以使用迭代法完成此题吗?</p>
<h3 id="解题思路1-v15"><a class="header-anchor" href="#解题思路1-v15"> </a>解题思路1</h3>
<p>递归法的思路就是简单的前序遍历的写法，只需要遍历左右孩子改成循环遍历每个孩子</p>
<h3 id="解题代码1-v15"><a class="header-anchor" href="#解题代码1-v15"> </a>解题代码1</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; answer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        answer.add(root.val);</span><br><span class="line">        <span class="comment">//遍历孩子节点们</span></span><br><span class="line">        <span class="keyword">for</span>(Node child : root.children) dfs(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v19"><a class="header-anchor" href="#解题思路2-v19"> </a>解题思路2</h3>
<p>用迭代的方法就是利用栈的方式，先将根节点压栈。</p>
<p>判断停止的条件是栈不为空</p>
<p>先弹出栈顶元素，进行访问，然后将该元素的孩子从右自左开始压栈。这样下一个栈顶元素就是其最左孩子。符合前序遍历的顺序</p>
<h3 id="解题代码2-v19"><a class="header-anchor" href="#解题代码2-v19"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; answer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> answer;</span><br><span class="line">        Deque&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.addLast(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span>stack.removeLast();</span><br><span class="line">            List&lt;Node&gt; children = cur.children;</span><br><span class="line">            <span class="comment">//孩子入栈</span></span><br><span class="line">            Collections.reverse(children);</span><br><span class="line">            <span class="keyword">for</span>(Node child : children) stack.addLast(child);</span><br><span class="line">            answer.add(cur.val);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="590-N叉树的后序遍历"><a class="header-anchor" href="#590-N叉树的后序遍历"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">590. N叉树的后序遍历</a></h2>
<h3 id="题目-v64"><a class="header-anchor" href="#题目-v64"> </a>题目</h3>
<p>给定一个 N 叉树，返回其节点值的后序遍历。</p>
<p>例如，给定一个 3叉树 :</p>
<p><img src="http://algorithm-image.qibinaoe.top/narytreeexample.png" alt="img"></p>
<p>返回其后序遍历: [5,6,3,2,4,1].</p>
<p>说明: 递归法很简单，你可以使用迭代法完成此题吗?</p>
<h3 id="解题思路-v45"><a class="header-anchor" href="#解题思路-v45"> </a>解题思路</h3>
<p>递归的方式也是先取出所有的子节点，进行递归遍历。最后再访问当前结点</p>
<h3 id="解题代码-v27"><a class="header-anchor" href="#解题代码-v27"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; answer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">       postOrder(root);</span><br><span class="line">       <span class="keyword">return</span> answer; </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(Node child : root.children)&#123;</span><br><span class="line">            postOrder(child);</span><br><span class="line">        &#125;</span><br><span class="line">        answer.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v20"><a class="header-anchor" href="#解题思路2-v20"> </a>解题思路2</h3>
<p>既然要使用迭代的方式进行递归。而后序遍历的顺序是最右孩子-&gt;最左孩子-&gt;根节点</p>
<p>因此如果要利用栈的方式的话，先压根结点，再把孩子从右到左的顺序压栈。</p>
<p>按这种思路去做的话，需要记录该结点是第几次入栈，第几次出栈。当一个结点第二次出栈的时候，是可以进行访问的。</p>
<p>我是利用有一个哈希表去记录这个结点是第几次出栈</p>
<h3 id="解题代码2-v20"><a class="header-anchor" href="#解题代码2-v20"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; answer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> answer;</span><br><span class="line">        Deque&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;Node,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">// 用于存储访问次数</span></span><br><span class="line">        stack.addLast(root);</span><br><span class="line">        map.put(root,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//压栈顺序是</span></span><br><span class="line">            <span class="comment">//先压根节点，再从右自左压栈</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> stack.removeLast();</span><br><span class="line">            <span class="keyword">if</span>(map.getOrDefault(cur,<span class="number">0</span>) == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">//可以访问</span></span><br><span class="line">                answer.add(cur.val);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;Node&gt; children = cur.children;</span><br><span class="line">            stack.addLast(cur);</span><br><span class="line">            map.put(cur,map.getOrDefault(cur,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            Collections.reverse(children);</span><br><span class="line">            <span class="keyword">for</span>(Node child : children)&#123;</span><br><span class="line">                stack.addLast(child);</span><br><span class="line">                map.put(child,map.getOrDefault(child,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路3-v5"><a class="header-anchor" href="#解题思路3-v5"> </a>解题思路3</h3>
<p>“解题思路2”通过记录每个结点出栈次数来进行后续遍历，但是这样做法太过繁琐，以及需要消耗空间来储存次数。</p>
<p>可以发现</p>
<p>前序遍历的顺序是根-&gt;左-&gt;右。</p>
<p>后序遍历的顺序是左-&gt;右-&gt;根。</p>
<p>那么我们可以通过再修改前序遍历顺序，即我们将访问顺序改成：根-&gt;右-&gt;左。</p>
<p>那么这样访问后的结果就是和真正的后序遍历的结果顺序刚好相反。</p>
<p>我们可以在最后对整个结果进行一次翻转。或者在插入的过程中，向数组开头插入元素。都可以达成我们想要的结果</p>
<p>而怎么做才能做到根-&gt;右-&gt;左的顺序呢？</p>
<p>我们只需要修改压栈的顺序。</p>
<p>对于<strong>前序遍历</strong>，我们是先压右孩子，再压左孩子，来让左孩子在栈顶，右孩子在栈底。这样我们就能先访问左孩子，来完成前序遍历。</p>
<p>而对于<strong>后序遍历</strong>，我们就先压左孩子，再压右孩子，就能够先访问右孩子，再访问左孩子。这样就是根-&gt;右-&gt;左的顺序了</p>
<h3 id="解题代码3-v7"><a class="header-anchor" href="#解题代码3-v7"> </a>解题代码3</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; answer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> answer;</span><br><span class="line">        Deque&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.addLast(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> stack.removeLast();</span><br><span class="line">            answer.add(cur.val);</span><br><span class="line">            <span class="keyword">for</span>(Node child : cur.children) stack.addLast(child);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(answer);</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码3-1"><a class="header-anchor" href="#解题代码3-1"> </a>解题代码3.1</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; answer = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> answer;</span><br><span class="line">        Deque&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.addLast(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> stack.removeLast();</span><br><span class="line">            answer.addFirst(cur.val);</span><br><span class="line">            <span class="keyword">for</span>(Node child : cur.children) stack.addLast(child);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="606-根据二叉树创建字符串"><a class="header-anchor" href="#606-根据二叉树创建字符串"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-string-from-binary-tree/">606. 根据二叉树创建字符串</a></h2>
<h3 id="题目-v65"><a class="header-anchor" href="#题目-v65"> </a>题目</h3>
<p>你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。</p>
<p>空节点则用一对空括号 “()” 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。</p>
<blockquote>
<p>示例 1:<br>
输入: 二叉树: [1,2,3,4]<br>
1<br>
/   <br>
2     3<br>
/<br>
4<br>
输出: “1(2(4))(3)”<br>
解释: 原本将是“1(2(4)())(3())”，<br>
在你省略所有不必要的空括号对之后，<br>
它将是“1(2(4))(3)”。</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
输入: 二叉树: [1,2,3,null,4]<br>
1<br>
/   <br>
2     3<br>
\<br>
4<br>
输出: “1(2()(4))(3)”<br>
解释: 和第一个示例相似，</p>
</blockquote>
<p>除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。</p>
<h3 id="解题思路-v46"><a class="header-anchor" href="#解题思路-v46"> </a>解题思路</h3>
<p>首先我们可以通过递归的思路实现这题。</p>
<p>首先我们讨论几种特殊情况</p>
<p>括号输出的情况</p>
<ul>
<li>当前结点为空结点
<ul>
<li>空结点按道理需要输出“()”</li>
<li>但是如果该空结点的<strong>父节点</strong>是<strong>叶子结点</strong>的时候，该空结点不需要输出空括号</li>
<li>如果该空结点的父节点是中间结点时，那就要判断整个空结点相对于父节点来说，是左结点还是右节点。
<ul>
<li>当这个空结点是左孩子时，那么其兄弟结点（父节点的右孩子）不为空。那这个空括号必须输出，才能够体现出兄弟结点</li>
<li>当这个空结点时右孩子时，那么其兄弟结点（父节点的左孩子）不为空。那么这个空括号可以省略</li>
</ul>
</li>
</ul>
</li>
<li>当前结点不为空
<ul>
<li>那么肯定要输出一个括号来包括它</li>
</ul>
</li>
</ul>
<p>现在讨论输出格式的问题</p>
<p>第一点：外层括号问题</p>
<p>可以发现答案输出的结果最外层并没有括号。那么我们可以通过<code>answer.substring(1,answer.length()-1)</code>来去掉做外层括号。</p>
<p>第二点：如何把当前结点的左右孩子“塞”进当前结点的数字的右边，右括号的左边呢？</p>
<p>我们可以在递归的流程中，先输出左括号和当前结点的值，再递归左右孩子，再补上右括号</p>
<p>根据上面的讨论，我们就可以写出递归的式子了</p>
<p>第三点：怎么知道当前结点是左孩子还是右孩子呢</p>
<p>我们可以把这件事交给父结点去判断，然后传入子递归中</p>
<h3 id="解题代码-v28"><a class="header-anchor" href="#解题代码-v28"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">StringBuilder</span> <span class="variable">answer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tree2str</span><span class="params">(TreeNode t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        dfs(t,<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> answer.substring(<span class="number">1</span>,answer.length()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode t,<span class="type">boolean</span> need)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(need) answer.append(<span class="string">&quot;()&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理当前结点</span></span><br><span class="line">        answer.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        answer.append(String.valueOf(t.val));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(t.right == <span class="literal">null</span> &amp;&amp; t.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            dfs(t.left,<span class="literal">false</span>);</span><br><span class="line">            dfs(t.right,<span class="literal">false</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dfs(t.left,<span class="literal">true</span>);</span><br><span class="line">            dfs(t.right,<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        answer.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="官方题解代码递归"><a class="header-anchor" href="#官方题解代码递归"> </a>官方题解代码递归</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接采用字符串拼接，效率低</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tree2str</span><span class="params">(TreeNode t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(t.left == <span class="literal">null</span> &amp;&amp; t.right == <span class="literal">null</span>) <span class="keyword">return</span> t.val+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(t.right == <span class="literal">null</span>) <span class="keyword">return</span> t.val + <span class="string">&quot;(&quot;</span>+tree2str(t.left)+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> t.val+<span class="string">&quot;(&quot;</span>+tree2str(t.left)+<span class="string">&quot;)&quot;</span>+<span class="string">&quot;(&quot;</span>+tree2str(t.right)+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="改进官解代码递归"><a class="header-anchor" href="#改进官解代码递归"> </a>改进官解代码递归</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">StringBuilder</span> <span class="variable">answer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tree2str</span><span class="params">(TreeNode t)</span> &#123;</span><br><span class="line">        treetostr(t);</span><br><span class="line">        <span class="keyword">return</span> answer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">treetostr</span><span class="params">(TreeNode t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>)&#123;</span><br><span class="line">            answer.append(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(t.left == <span class="literal">null</span> &amp;&amp; t.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            answer.append(t.val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(t.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            answer.append(t.val);</span><br><span class="line">            answer.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            treetostr(t.left);</span><br><span class="line">            answer.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            answer.append(t.val);</span><br><span class="line">            answer.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            treetostr(t.left);</span><br><span class="line">            answer.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">            answer.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            treetostr(t.right);</span><br><span class="line">            answer.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v21"><a class="header-anchor" href="#解题思路2-v21"> </a>解题思路2</h3>
<p>当然，也可以用迭代的方式来实现这一道题（主要参考官解）</p>
<p>要通过迭代的方式实现前序遍历，那就需要一个栈来实现我们所需要的元素顺序</p>
<p>但是我们还需要知道，什么时候，需要添加右括号。换句话说，我们不能直接把栈的元素弹出来，并添加左括号以后，就把该元素丢弃了，这样我们就无法添加右括号</p>
<p>因此我们可以在第一次访问该元素时，不弹出该元素，而是将它添加到一个集合set中，以便下一次在栈中又访问到该元素时，知道它是第二次被访问。而在第二次被访问时，就可以添加上右括号</p>
<h3 id="解题代码2-v21"><a class="header-anchor" href="#解题代码2-v21"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tree2str</span><span class="params">(TreeNode t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Set&lt;TreeNode&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        stack.offerLast(t);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> stack.peekLast();</span><br><span class="line">            <span class="keyword">if</span>(visited.contains(cur))&#123;</span><br><span class="line">                s.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">                stack.pollLast();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                visited.add(cur);</span><br><span class="line">                s.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">                s.append(cur.val);</span><br><span class="line">                <span class="keyword">if</span>(cur.left == <span class="literal">null</span> &amp;&amp; cur.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    s.append(<span class="string">&quot;()&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    stack.offerLast(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    stack.offerLast(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(<span class="number">1</span>,s.length()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="617-合并二叉树"><a class="header-anchor" href="#617-合并二叉树"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></h2>
<h3 id="题目-v66"><a class="header-anchor" href="#题目-v66"> </a>题目</h3>
<p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<blockquote>
<p>示例 1:<br>
输入:<br>
Tree 1                     Tree 2<br>
1                         2<br>
/ \                       / \<br>
3   2                   1   3<br>
/                            \   \<br>
5                               4   7<br>
输出:<br>
合并后的树:<br>
3<br>
/ <br>
4   5<br>
/ \   \<br>
5   4   7<br>
注意: 合并必须从两个树的根节点开始。</p>
</blockquote>
<h3 id="解题思路-v47"><a class="header-anchor" href="#解题思路-v47"> </a>解题思路</h3>
<p>如果通过递归想法去解决这题的话。可以先思考是要重新生成一棵新的树，或者是直接在原来的树上修改。</p>
<p>然后递归的话，要合并一棵树，我们就从一个结点入手。一个结点要被合并，则其值要等于两棵树上该位置的值。同时不能直接递归下去，这样会失去当前结点和其两个孩子结点的两个引用。因此要在一个递归中，设置其左孩子和右孩子。</p>
<h3 id="解题代码1-v16"><a class="header-anchor" href="#解题代码1-v16"> </a>解题代码1</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="literal">null</span> &amp;&amp; t2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> (t1==<span class="literal">null</span>?<span class="number">0</span>:t1.val)+(t2==<span class="literal">null</span>?<span class="number">0</span>:t2.val);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        t3.left = mergeTrees(t1==<span class="literal">null</span>?<span class="literal">null</span>:t1.left,t2==<span class="literal">null</span>?<span class="literal">null</span>:t2.left);</span><br><span class="line">        t3.right = mergeTrees(t1==<span class="literal">null</span>?<span class="literal">null</span>:t1.right,t2==<span class="literal">null</span>?<span class="literal">null</span>:t2.right);</span><br><span class="line">        <span class="keyword">return</span> t3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码1-1-v3"><a class="header-anchor" href="#解题代码1-1-v3"> </a>解题代码1.1</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="literal">null</span>) <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span>(t2 == <span class="literal">null</span>) <span class="keyword">return</span> t1;</span><br><span class="line">        t1.val = t1.val + t2.val;</span><br><span class="line">        t1.left = mergeTrees(t1.left,t2.left);</span><br><span class="line">        t1.right = mergeTrees(t1.right,t2.right);</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v22"><a class="header-anchor" href="#解题思路2-v22"> </a>解题思路2</h3>
<p>也可以通过迭代来做，即BFS。</p>
<p>通过创建3个队列，一个用于保存新生成的结点，另外两个队列分别存放两棵树</p>
<p>代码太过繁琐了就不写了</p>
<h2 id="637-二叉树的层平均值"><a class="header-anchor" href="#637-二叉树的层平均值"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></h2>
<h3 id="题目-v67"><a class="header-anchor" href="#题目-v67"> </a>题目</h3>
<p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p>
<blockquote>
<p>示例 1：<br>
输入：<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
输出：[3, 14.5, 11]<br>
解释：<br>
第 0 层的平均值是 3 ,  第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。</p>
</blockquote>
<p>提示：<br>
节点值的范围在32位有符号整数范围内。</p>
<h3 id="解题思路1-v16"><a class="header-anchor" href="#解题思路1-v16"> </a>解题思路1</h3>
<p>如果用BFS进行遍历的思路挺简单的，迭代的思考与“<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a>”一样。通过一次循环中遍历整层结点。</p>
<p>这里主要麻烦点在于数值转换</p>
<p>考虑测试用例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="number">2147483647</span>,<span class="number">2147483647</span>,<span class="number">2147483647</span>]</span><br><span class="line">预期：</span><br><span class="line">[<span class="number">2147483647.00000</span>,<span class="number">2147483647.00000</span>]</span><br></pre></td></tr></table></figure>
<p>数值溢出的错误代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Double&gt; answer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> answer;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// ERROR sum会溢出，导致结果错误 </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> size;</span><br><span class="line">            <span class="keyword">while</span>(count--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                sum += cur.val;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) queue.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">double</span> <span class="variable">average</span> <span class="operator">=</span> (<span class="type">double</span>)sum / size;</span><br><span class="line">            answer.add(average);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而将<code>sum</code>改成<code>double</code>类型可以解决这个问题，因为<code>double</code>有8个字节</p>
<h3 id="解题代码1-v17"><a class="header-anchor" href="#解题代码1-v17"> </a>解题代码1</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//这题显然BFS</span></span><br><span class="line">        List&lt;Double&gt; answer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> answer;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> size;</span><br><span class="line">            <span class="keyword">while</span>(count--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                sum += cur.val;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) queue.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            answer.add(sum / size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v23"><a class="header-anchor" href="#解题思路2-v23"> </a>解题思路2</h3>
<p>可以通过深度优先去遍历。但是深度优先我们必须要直到当前结点时第几层，所以可以通过递归传参的方式告诉下一层的层数。</p>
<p>通过累计统计特定层的总和和个数。最终再遍历相除获得结果</p>
<h3 id="解题代码2-v22"><a class="header-anchor" href="#解题代码2-v22"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//DFS做法</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Double&gt; sums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//用于储存某层的和</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 用于储存某层的个数</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root,<span class="number">0</span>);</span><br><span class="line">        List&lt;Double&gt; average = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            average.add(sums.get(i)/nums.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> average;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> level)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(level &lt; nums.size())&#123; <span class="comment">//说明已经存在该层了，直接加就完事了</span></span><br><span class="line">            nums.set(level,nums.get(level)+<span class="number">1</span>);</span><br><span class="line">            sums.set(level,sums.get(level)+root.val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            nums.add(<span class="number">1</span>);</span><br><span class="line">            sums.add(<span class="number">1.0</span>*root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left,level+<span class="number">1</span>);</span><br><span class="line">        dfs(root.right,level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="653-两数之和-IV-输入-BST"><a class="header-anchor" href="#653-两数之和-IV-输入-BST"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/">653. 两数之和 IV - 输入 BST</a></h2>
<h3 id="题目-v68"><a class="header-anchor" href="#题目-v68"> </a>题目</h3>
<p>给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</p>
<blockquote>
<p>案例 1:<br>
输入:<br>
5<br>
/ <br>
3   6<br>
/ \   <br>
2   4   7<br>
Target = 9<br>
输出: True</p>
</blockquote>
<blockquote>
<p>案例 2:<br>
输入:<br>
5<br>
/ <br>
3   6<br>
/ \   <br>
2   4   7<br>
Target = 28<br>
输出: False</p>
</blockquote>
<h3 id="解题思路-v48"><a class="header-anchor" href="#解题思路-v48"> </a>解题思路</h3>
<p>对于这题可以这样理解，它既然要两个数<code>a</code>、<code>b</code>等于一个给定和<code>k</code>，那么我们可以先选择一个数<code>a</code>，再去寻找是否存在<code>k-a</code>。</p>
<p>因此根据这个思路，我们可以边遍历边记录所遇到的值<code>a</code>，同时寻找我们已经遍历过的值中是否存在<code>k-a</code>。针对这点需求，我们可以用一个<code>HashSet</code>去存放我们已经遍历过的值</p>
<p>但是这种思路就没有利用好这棵树是一棵BST树</p>
<h3 id="解题代码-v29"><a class="header-anchor" href="#解题代码-v29"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="variable">find</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> kval;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findTarget</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//写一个前序遍历  时间复杂度O(N) 空间复杂度O(H+N)</span></span><br><span class="line">        kval = k;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> find;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(find) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedVal</span> <span class="operator">=</span> kval - root.val;</span><br><span class="line">        <span class="keyword">if</span>(set.contains(expectedVal))&#123;</span><br><span class="line">            find = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            set.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line"></span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="669-修剪二叉搜索树"><a class="header-anchor" href="#669-修剪二叉搜索树"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h2>
<h3 id="题目-v69"><a class="header-anchor" href="#题目-v69"> </a>题目</h3>
<p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树不应该改变保留在树中的元素的相对结构（即，如果没有被移除，原有的父代子代关系都应当保留）。 可以证明，存在唯一的答案。</p>
<p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p>
<blockquote>
<p>示例 1：<br>
输入：root = [1,0,2], low = 1, high = 2<br>
输出：[1,null,2]</p>
<p><img src="http://algorithm-image.qibinaoe.top/trim1.jpg" alt="img"></p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3<br>
输出：[3,2,null,1]</p>
<p><img src="http://algorithm-image.qibinaoe.top/trim2.jpg" alt="img"></p>
</blockquote>
<blockquote>
<p>示例 3：<br>
输入：root = [1], low = 1, high = 2<br>
输出：[1]</p>
</blockquote>
<blockquote>
<p>示例 4：<br>
输入：root = [1,null,2], low = 1, high = 3<br>
输出：[1,null,2]</p>
</blockquote>
<blockquote>
<p>示例 5：<br>
输入：root = [1,null,2], low = 2, high = 4<br>
输出：[2]</p>
</blockquote>
<blockquote>
<p>提示：<br>
树中节点数在范围 [1, 104] 内<br>
0 &lt;= Node.val &lt;= 104<br>
树中每个节点的值都是唯一的<br>
题目数据保证输入是一棵有效的二叉搜索树<br>
0 &lt;= low &lt;= high &lt;= 104</p>
</blockquote>
<h3 id="解题思路-v49"><a class="header-anchor" href="#解题思路-v49"> </a>解题思路</h3>
<p>这题看起来挺容易绕晕的，但是我们根据递归的思想，将这个问题分解成子问题。就考虑一个局部问题：</p>
<p>就当前结点而言。我们进行后序遍历（左-&gt;右-&gt;根），这样做的意思是，先让左子树满足修剪二叉树的规则，至于左子树要怎么满足我们先不管。再让右子树满足修剪二叉树的规则。至此，我们已经拿到了处理好的左子树、右子树，现在我们要做的工作是处理根节点并把左右子树拼在根节点上，然后返回根节点。</p>
<p>怎么处理根节点呢？</p>
<p>我们想，如果根节点的值小于了修剪规则的最小值(<code>low</code>)，这说明什么？说明根节点我们要弃掉。而根节点的左子树还要不要？根节点的左子树肯定都比根节点小，那肯定都比<code>low</code>小，那么左子树可以舍弃了。那左子树怎么办？还要不要？根据我们递归的思想，我们管好我们当前的问题：怎么处理根节点，以及怎么拼接，同时假设左右子树都是已经满足修剪规则的了。那么此时我们只需要返回右子树即可，因为右子树已经是满足修剪规则的了。</p>
<p>同理，如果根节点的值大于了修剪规则的最大值(<code>high</code>)，那么我们返回左子树即可。</p>
<p>那如果根节点是满足条件的，我们只需简单的将左右子树拼接上去即可</p>
<h3 id="解题代码-v30"><a class="header-anchor" href="#解题代码-v30"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> trimSubBST(root,low,high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimSubBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">leftChild</span> <span class="operator">=</span> trimSubBST(root.left,low,high);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightChild</span> <span class="operator">=</span> trimSubBST(root.right,low,high);</span><br><span class="line">        <span class="comment">//判断当前根节点是否保留</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; low) <span class="keyword">return</span> rightChild;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; high) <span class="keyword">return</span> leftChild;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//保留当前结点</span></span><br><span class="line">            root.left = leftChild;</span><br><span class="line">            root.right = rightChild;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="671-二叉树中第二小的节点"><a class="header-anchor" href="#671-二叉树中第二小的节点"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/">671. 二叉树中第二小的节点</a></h2>
<h3 id="题目-v70"><a class="header-anchor" href="#题目-v70"> </a>题目</h3>
<p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。</p>
<p>更正式地说，root.val = min(root.left.val, root.right.val) 总成立。</p>
<p>给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。</p>
<blockquote>
<p>示例 1：<br>
输入：root = [2,2,5,null,null,5,7]<br>
输出：5<br>
解释：最小的值是 2 ，第二小的值是 5 。</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：root = [2,2,2]<br>
输出：-1<br>
解释：最小的值是 2, 但是不存在第二小的值。</p>
</blockquote>
<p>提示：<br>
树中节点数目在范围 [1, 25] 内<br>
1 &lt;= Node.val &lt;= 231 - 1<br>
对于树中每个节点 root.val == min(root.left.val, root.right.val)</p>
<h3 id="解题思路-v50"><a class="header-anchor" href="#解题思路-v50"> </a>解题思路</h3>
<p>比较简单的思路获取整棵树的值，然后返回第二大的值</p>
<p>这里可以借助优先队列来获得第二大的数</p>
<h3 id="解题代码-v31"><a class="header-anchor" href="#解题代码-v31"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findSecondMinimumValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//定义一个最小值</span></span><br><span class="line">        <span class="comment">//遍历一遍树</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> root.val;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; priorityqueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(!priorityqueue.contains(cur.val)) priorityqueue.offer(cur.val);</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) queue.offer(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) queue.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        priorityqueue.poll();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">second</span> <span class="operator">=</span> priorityqueue.poll();</span><br><span class="line">        <span class="type">return</span> <span class="variable">second</span> <span class="operator">=</span>= <span class="literal">null</span>? -<span class="number">1</span>: second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v24"><a class="header-anchor" href="#解题思路2-v24"> </a>解题思路2</h3>
<p>这里可以去掉这里的优先队列，取而代之的是一个储存第二个大的变量<code>second</code></p>
<p><code>second</code>初始化为<code>-1</code>。在遍历的过程中，判断是否有大于根节点的值<code>root.val</code>，有则更新<code>second</code>，同时保证<code>second</code>是除了<code>min</code>是最小的</p>
<h3 id="解题代码2-v23"><a class="header-anchor" href="#解题代码2-v23"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findSecondMinimumValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//定义一个最小值</span></span><br><span class="line">        <span class="comment">//遍历一遍树</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> root.val;</span><br><span class="line">        <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(cur.val&gt;min)&#123;</span><br><span class="line">                second = second == -<span class="number">1</span>?cur.val:(cur.val&gt;second ? second: cur.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) queue.offer(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) queue.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="700-二叉搜索树中的搜索"><a class="header-anchor" href="#700-二叉搜索树中的搜索"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h2>
<h3 id="题目-v71"><a class="header-anchor" href="#题目-v71"> </a>题目</h3>
<p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p>
<blockquote>
<p>例如，<br>
给定二叉搜索树:<br>
4<br>
/ <br>
2   7<br>
/ <br>
1   3<br>
和值: 2<br>
你应该返回如下子树:<br>
2<br>
/ \<br>
1   3<br>
在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。</p>
</blockquote>
<h3 id="解题思路-v51"><a class="header-anchor" href="#解题思路-v51"> </a>解题思路</h3>
<p>这题比较简单，即判断树中有没有我们想要的结点，最直接的做法就是遍历一遍树，如果整个过程没有找到，即可返回null</p>
<p>我们可以通过BFS来遍历树，循环跳出后即没有找到的意思，返回null</p>
<h3 id="解题代码-v32"><a class="header-anchor" href="#解题代码-v32"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(cur.val == val)&#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) queue.offer(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) queue.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v25"><a class="header-anchor" href="#解题思路2-v25"> </a>解题思路2</h3>
<p>同样的，这是一棵BST树，那我们根据BST树的特点，如果<code>val</code>大于当前值，说明要在右子树找。如果<code>val</code>小于当前值，则在左子树找。如果相等，返回当前结点即可，</p>
<h3 id="解题代码2-v24"><a class="header-anchor" href="#解题代码2-v24"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val == val) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; val) <span class="keyword">return</span> searchBST(root.left,val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> searchBST(root.right,val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码3-v8"><a class="header-anchor" href="#解题代码3-v8"> </a>解题代码3</h3>
<p>同时我们可以通过迭代的方式，直接进行判断，这样就连栈空间都省了</p>
<h3 id="解题代码3-v9"><a class="header-anchor" href="#解题代码3-v9"> </a>解题代码3</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span> &amp;&amp; root.val != val)&#123;</span><br><span class="line">            root = root.val&lt;val?root.right:root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="783-二叉搜索树节点最小距离"><a class="header-anchor" href="#783-二叉搜索树节点最小距离"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/">783. 二叉搜索树节点最小距离</a></h2>
<h3 id="题目-v72"><a class="header-anchor" href="#题目-v72"> </a>题目</h3>
<p>给定一个二叉搜索树的根节点 root，返回树中任意两节点的差的最小值。</p>
<blockquote>
<p>示例：<br>
输入: root = [4,2,6,1,3,null,null]<br>
输出: 1<br>
解释:<br>
注意，root是树节点对象(TreeNode object)，而不是数组。<br>
给定的树 [4,2,6,1,3,null,null] 可表示为下图:<br>
4<br>
/   <br>
2      6<br>
/ \<br>
1   3<br>
最小的差值是 1, 它是节点1和节点2的差值, 也是节点3和节点2的差值。</p>
</blockquote>
<p>注意：</p>
<p>二叉树的大小范围在 2 到 100。<br>
二叉树总是有效的，每个节点的值都是整数，且不重复。<br>
本题与 530：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/</a> 相同</p>
<h3 id="解题思路-v52"><a class="header-anchor" href="#解题思路-v52"> </a>解题思路</h3>
<p>通过前序遍历，判断相邻两个数的差值，并与最小差值进行比较</p>
<h3 id="解题代码-v33"><a class="header-anchor" href="#解题代码-v33"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minDiff</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">first</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDiffInBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> minDiff;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        update(root);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> root.val;</span><br><span class="line">        <span class="keyword">if</span>(first)&#123;</span><br><span class="line">            base = val;</span><br><span class="line">            first = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        minDiff = val - base &lt; minDiff ? val-base : minDiff;</span><br><span class="line">        base = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="872-叶子相似的树"><a class="header-anchor" href="#872-叶子相似的树"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/leaf-similar-trees/">872. 叶子相似的树</a></h2>
<h3 id="题目-v73"><a class="header-anchor" href="#题目-v73"> </a>题目</h3>
<p>请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 叶值序列 。</p>
<p><img src="http://algorithm-image.qibinaoe.top/tree.png" alt="img"></p>
<p>举个例子，如上图所示，给定一棵叶值序列为 (6, 7, 4, 9, 8) 的树。<br>
如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 叶相似 的。<br>
如果给定的两个头结点分别为 root1 和 root2 的树是叶相似的，则返回 true；否则返回 false 。</p>
<p>示例 1：</p>
<p><img src="http://algorithm-image.qibinaoe.top/leaf-similar-1.jpg" alt="img"></p>
<p>输入：root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]<br>
输出：true</p>
<p>示例 2：<br>
输入：root1 = [1], root2 = [1]<br>
输出：true</p>
<p>示例 3：<br>
输入：root1 = [1], root2 = [2]<br>
输出：false</p>
<p>示例 4：<br>
输入：root1 = [1,2], root2 = [2,2]<br>
输出：true</p>
<p>示例 5：</p>
<p><img src="http://algorithm-image.qibinaoe.top/leaf-similar-2.jpg" alt="img"></p>
<p>输入：root1 = [1,2,3], root2 = [1,3,2]<br>
输出：false</p>
<p>提示：<br>
给定的两棵树可能会有 1 到 200 个结点。<br>
给定的两棵树上的值介于 0 到 200 之间。</p>
<h3 id="解题思路-v53"><a class="header-anchor" href="#解题思路-v53"> </a>解题思路</h3>
<p>这题所谓的寻找叶值序列判断相等</p>
<p>本质上就是找出两颗树的叶子结点，然后判断是否相等</p>
<p>那么怎么寻找叶子节点？只需要左右结点都为空，即使叶子节点。然后可以将两棵树的叶子节点分别放入两个数组中，然后判断是否相等</p>
<h3 id="解题代码-v34"><a class="header-anchor" href="#解题代码-v34"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">leafSimilar</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="comment">//首先找出叶子结点</span></span><br><span class="line">        <span class="comment">// 判断相等</span></span><br><span class="line">        List&lt;Integer&gt; array1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; array2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(root1,array1);</span><br><span class="line">        dfs(root2,array2);</span><br><span class="line">        <span class="comment">//判断相等</span></span><br><span class="line">        <span class="keyword">return</span> array1.equals(array2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,List&lt;Integer&gt; array)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left,array);</span><br><span class="line">        <span class="comment">//判断是否是叶子结点</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            array.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right,array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="897-递增顺序查找树"><a class="header-anchor" href="#897-递增顺序查找树"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/increasing-order-search-tree/">897. 递增顺序查找树</a></h2>
<h3 id="题目-v74"><a class="header-anchor" href="#题目-v74"> </a>题目</h3>
<p>给你一个树，请你 按中序遍历 重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。</p>
<blockquote>
<p>示例 ：<br>
输入：[5,3,6,2,4,null,8,1,null,null,null,7,9]<br>
5<br>
/ <br>
3    6<br>
/ \    <br>
2   4    8<br>
/        / \<br>
1        7   9<br>
输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]<br>
1<br>
<br>
2<br>
<br>
3<br>
<br>
4<br>
<br>
5<br>
<br>
6<br>
<br>
7<br>
<br>
8<br>
<br>
9</p>
</blockquote>
<p>提示：<br>
给定树中的结点数介于 1 和 100 之间。<br>
每个结点都有一个从 0 到 1000 范围内的唯一整数值。</p>
<h3 id="解题思路-v54"><a class="header-anchor" href="#解题思路-v54"> </a>解题思路</h3>
<p>既然要中序遍历来形成一条只有通过右结点连接在一起的一条链。</p>
<p>那我们开始想象，我如果我们通过中序遍历，先遍历到了这颗树的最左的叶子结点，那我们需要怎么做才能把当前这个最左的叶子结点，接在它父节点上面呢？</p>
<p>可以想到，在栈弹出时，我们回到了该节点的父节点，这时候如果我们有这个最左的叶子结点的一个引用，我们就能够直接操作，将最左的叶子节点的右孩子指向当前结点即可。</p>
<p>然后接下来将保存当前结点的引用，并递归到下一层，或者弹出当前栈，回到父节点，再进行同样的操作</p>
<h3 id="解题代码-v35"><a class="header-anchor" href="#解题代码-v35"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">TreeNode</span> <span class="variable">prevNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">increasingBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="comment">//拼接</span></span><br><span class="line">        <span class="keyword">if</span>(prevNode == <span class="literal">null</span>)&#123;</span><br><span class="line">            head = root;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            prevNode.right = root;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = <span class="literal">null</span>;</span><br><span class="line">        prevNode = root;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="938-二叉搜索树的范围和"><a class="header-anchor" href="#938-二叉搜索树的范围和"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-sum-of-bst/">938. 二叉搜索树的范围和</a></h2>
<h3 id="题目-v75"><a class="header-anchor" href="#题目-v75"> </a>题目</h3>
<p>给定二叉搜索树的根结点 root，返回值位于范围 [low, high] 之间的所有结点的值的和。</p>
<blockquote>
<p>示例 1：</p>
<p><img src="http://algorithm-image.qibinaoe.top/bst1.jpg" alt="img"></p>
<p>输入：root = [10,5,15,3,7,null,18], low = 7, high = 15<br>
输出：32</p>
</blockquote>
<blockquote>
<p>示例 2：</p>
<p><img src="http://algorithm-image.qibinaoe.top/bst2.jpg" alt="img"></p>
<p>输入：root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10<br>
输出：23</p>
</blockquote>
<blockquote>
<p>提示：<br>
树中节点数目在范围 [1, 2 * 104] 内<br>
1 &lt;= Node.val &lt;= 105<br>
1 &lt;= low &lt;= high &lt;= 105<br>
所有 Node.val 互不相同</p>
</blockquote>
<h3 id="解题思路-v55"><a class="header-anchor" href="#解题思路-v55"> </a>解题思路</h3>
<p>这题其实和“<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a>”一样的，然后我们递归的过程中，对于在该区间的值进行累加</p>
<h3 id="解题代码-v36"><a class="header-anchor" href="#解题代码-v36"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="comment">//首先要找到 [low, high] 的结点</span></span><br><span class="line">        <span class="comment">//然后计算这些结点的总和</span></span><br><span class="line">        <span class="comment">//构成我们想要的树,同时在遍历过程计算值</span></span><br><span class="line">        trimSubBST(root,low,high);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimSubBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">        <span class="comment">// 返回一个已经裁剪好的树</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">leftChild</span> <span class="operator">=</span> trimSubBST(root.left,low,high);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightChild</span> <span class="operator">=</span> trimSubBST(root.right,low,high);</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; low) <span class="keyword">return</span> rightChild;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; high) <span class="keyword">return</span> leftChild;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            root.left = leftChild;</span><br><span class="line">            root.right = rightChild;</span><br><span class="line">            sum += root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v26"><a class="header-anchor" href="#解题思路2-v26"> </a>解题思路2</h3>
<p>想想其实我想复杂了，题目并不要求去生成这样一棵树。那我们只需要在递归的过程中，去看结点的值是否在[low,high]之间，即可累加</p>
<h3 id="解题代码2-v25"><a class="header-anchor" href="#解题代码2-v25"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="comment">//首先要找到 [low, high] 的结点</span></span><br><span class="line">        <span class="comment">//然后计算这些结点的总和</span></span><br><span class="line">        <span class="comment">//构成我们想要的树,同时在遍历过程计算值</span></span><br><span class="line">        dfs(root,low,high);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left,low,high);</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt;= low &amp;&amp; root.val &lt;= high) sum+= root.val;</span><br><span class="line">        dfs(root.right,low,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路3-v6"><a class="header-anchor" href="#解题思路3-v6"> </a>解题思路3</h3>
<p>解题思路2中的做法没有用到BST的特点，我们可以判断一下当前结点值，来选择递归的路径</p>
<h3 id="解题代码3-v10"><a class="header-anchor" href="#解题代码3-v10"> </a>解题代码3</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="comment">//首先要找到 [low, high] 的结点</span></span><br><span class="line">        <span class="comment">//然后计算这些结点的总和</span></span><br><span class="line">        <span class="comment">//构成我们想要的树,同时在遍历过程计算值</span></span><br><span class="line">        dfs(root,low,high);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; low) dfs(root.right,low,high);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; high) dfs(root.left,low,high);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sum+= root.val;</span><br><span class="line">            dfs(root.right,low,high);</span><br><span class="line">            dfs(root.left,low,high);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="965-单值二叉树"><a class="header-anchor" href="#965-单值二叉树"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/univalued-binary-tree/">965. 单值二叉树</a></h2>
<h3 id="题目-v76"><a class="header-anchor" href="#题目-v76"> </a>题目</h3>
<p>如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。<br>
只有给定的树是单值二叉树时，才返回 true；否则返回 false。</p>
<blockquote>
<p>示例 1：<br>
输入：[1,1,1,1,1,null,1]<br>
输出：true</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：[2,2,2,5,2]<br>
输出：false</p>
</blockquote>
<p>提示：<br>
给定树的节点数范围是 [1, 100]。<br>
每个节点的值都是整数，范围为 [0, 99] 。</p>
<h3 id="解题思路-v56"><a class="header-anchor" href="#解题思路-v56"> </a>解题思路</h3>
<p>简单的做法就是把树过一遍，出现不同的值就返回false即可</p>
<h3 id="解题代码-v37"><a class="header-anchor" href="#解题代码-v37"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isUnivalTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.offerLast(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> root.val;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pollLast();</span><br><span class="line">            <span class="keyword">if</span>(cur.val != val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) stack.offerLast(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) stack.offerLast(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="993-二叉树的堂兄弟节点"><a class="header-anchor" href="#993-二叉树的堂兄弟节点"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cousins-in-binary-tree/">993. 二叉树的堂兄弟节点</a></h2>
<h3 id="题目-v77"><a class="header-anchor" href="#题目-v77"> </a>题目</h3>
<p>在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。<br>
如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。<br>
我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。<br>
只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。</p>
<blockquote>
<p>示例 1：</p>
<p><img src="http://algorithm-image.qibinaoe.top/q1248-01.png" alt="img"></p>
<p>输入：root = [1,2,3,4], x = 4, y = 3<br>
输出：false</p>
</blockquote>
<blockquote>
<p>示例 2：</p>
<p><img src="http://algorithm-image.qibinaoe.top/q1248-02.png" alt="img"></p>
<p>输入：root = [1,2,3,null,4,null,5], x = 5, y = 4<br>
输出：true</p>
</blockquote>
<blockquote>
<p>示例 3：</p>
<p><img src="http://algorithm-image.qibinaoe.top/q1248-03.png" alt="img"></p>
<p>输入：root = [1,2,3,null,4], x = 2, y = 3<br>
输出：false</p>
</blockquote>
<blockquote>
<p>提示：<br>
二叉树的节点数介于 2 到 100 之间。<br>
每个节点的值都是唯一的、范围为 1 到 100 的整数。</p>
</blockquote>
<h3 id="解题思路-v57"><a class="header-anchor" href="#解题思路-v57"> </a>解题思路</h3>
<p>根据题目给的条件，堂兄弟结点的深度是一致的，说明我们可以通过层次优先遍历来在一次循环中，去判断是否存在堂兄弟结点。</p>
<p>因此我们通过一个队列去进行BFS</p>
<p>其次，我们需要直到如何判断同一层的结点是否是一个堂兄弟节点</p>
<p>我的思路是根据出现的两个结点的相对位置判断</p>
<ul>
<li>两个出现的位置大于1则肯定是堂兄弟结点</li>
<li>也有可能出现位置相距为1，但是不同父节点的情况，这种情况，较小的位置的数字为奇数（从0开始计算）</li>
</ul>
<h3 id="解题代码-v38"><a class="header-anchor" href="#解题代码-v38"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCousins</span><span class="params">(TreeNode root, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="comment">// 由于堂兄弟结点在同一层，所以用层次遍历比较方便</span></span><br><span class="line">        <span class="comment">// 通过判断两个结点的距离来判断是否是同父节点</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Queue&lt;Pair&lt;TreeNode,Integer&gt;&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;TreeNode,Integer&gt;(root,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="comment">//取出同一层</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">firstPos</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">secondPos</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                Pair&lt;TreeNode,Integer&gt; cur = queue.poll();</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">curNode</span> <span class="operator">=</span> cur.getKey();</span><br><span class="line">                <span class="type">int</span> <span class="variable">curPos</span> <span class="operator">=</span> cur.getValue();</span><br><span class="line">                <span class="keyword">if</span>(firstPos == -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curNode.val == x)&#123;</span><br><span class="line">                        firstPos = curPos;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curNode.val == y)&#123;</span><br><span class="line">                        firstPos = curPos;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curNode.val == x)&#123;</span><br><span class="line">                        secondPos = curPos;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curNode.val == y)&#123;</span><br><span class="line">                        secondPos = curPos;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//压入子节点</span></span><br><span class="line">                <span class="keyword">if</span>(curNode.left != <span class="literal">null</span>) queue.offer(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;TreeNode,Integer&gt;(curNode.left,pos));</span><br><span class="line">                pos++;</span><br><span class="line">                <span class="keyword">if</span>(curNode.right != <span class="literal">null</span>) queue.offer(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;TreeNode,Integer&gt;(curNode.right,pos));</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断是否有堂兄弟</span></span><br><span class="line">            <span class="keyword">if</span>(firstPos == -<span class="number">1</span> ^ secondPos == -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(firstPos != -<span class="number">1</span> &amp;&amp; secondPos != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> secondPos - firstPos &gt; <span class="number">1</span> || firstPos % <span class="number">2</span> == <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1022-从根到叶的二进制数之和"><a class="header-anchor" href="#1022-从根到叶的二进制数之和"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-root-to-leaf-binary-numbers/">1022. 从根到叶的二进制数之和</a></h2>
<h3 id="题目-v78"><a class="header-anchor" href="#题目-v78"> </a>题目</h3>
<p>给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1，那么它表示二进制数 01101，也就是 13 。</p>
<p>对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。</p>
<p>返回这些数字之和。题目数据保证答案是一个 32 位 整数。</p>
<blockquote>
<p>示例 1：<br>
输入：root = [1,0,1,0,1,0,1]<br>
输出：22<br>
解释：(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22</p>
<p><img src="http://algorithm-image.qibinaoe.top/sum-of-root-to-leaf-binary-numbers.png" alt="img"></p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：root = [0]<br>
输出：0</p>
</blockquote>
<blockquote>
<p>示例 3：<br>
输入：root = [1]<br>
输出：1</p>
</blockquote>
<blockquote>
<p>示例 4：<br>
输入：root = [1,1]<br>
输出：3</p>
</blockquote>
<blockquote>
<p>提示：<br>
树中的结点数介于 1 和 1000 之间。<br>
Node.val 为 0 或 1 。</p>
</blockquote>
<h3 id="解题思路-v58"><a class="header-anchor" href="#解题思路-v58"> </a>解题思路</h3>
<p>首先考虑递归的思路，在题目中，要计算一条路径（根到叶子节点）的值，需要到叶子节点的时候，我们才能确定。因此在递归过程中，我们需要同时传递到当前节点的值。</p>
<p>如果在递归中，当前节点已经是叶子节点了，说明我们可以计算该值并保存下来，因此这里我们定义一个全局变量。而对于计算一条链的值，考虑到这是二进制，所以可以用位操作进行计算。即前面的链向左位移1位，再加上当前节点的值，即构成了整条链的值。</p>
<p>如果当前节点不是叶子节点的话。那有可能出现的是空结点，对于空结点我们不去理会，我们只关心当前节点是不是<strong>叶子节点</strong>，是就计算，不是就继续左右两个子节点递归。因此出现空结点的情况是由于父节点是只有一个孩子，另一个孩子会帮忙算这条链的值，我们来到了空孩子的位置。</p>
<h3 id="解题代码-v39"><a class="header-anchor" href="#解题代码-v39"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRootToLeaf</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        calRootToLeaf(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calRootToLeaf</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span>&#123;</span><br><span class="line">        <span class="comment">//sum 表示之前结点的和</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(isLeaf(root))&#123;</span><br><span class="line">            totalSum += (sum&lt;&lt;<span class="number">1</span>)+root.val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            calRootToLeaf(root.left,(sum&lt;&lt;<span class="number">1</span>)+root.val);</span><br><span class="line">            calRootToLeaf(root.right,(sum&lt;&lt;<span class="number">1</span>)+root.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLeaf</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-27-二叉树的镜像"><a class="header-anchor" href="#剑指-Offer-27-二叉树的镜像"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h2>
<h3 id="题目-v79"><a class="header-anchor" href="#题目-v79"> </a>题目</h3>
<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<blockquote>
<p>例如输入：<br>
4<br>
/   <br>
2     7<br>
/ \   / <br>
1   3 6   9<br>
镜像输出：<br>
4<br>
/   <br>
7     2<br>
/ \   / <br>
9   6 3   1<br>
示例 1：<br>
输入：root = [4,2,7,1,3,6,9]<br>
输出：[4,7,2,9,6,3,1]</p>
</blockquote>
<p>限制：<br>
0 &lt;= 节点个数 &lt;= 1000<br>
注意：本题与主站 226 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/">https://leetcode-cn.com/problems/invert-binary-tree/</a></p>
<h3 id="解题思路-v59"><a class="header-anchor" href="#解题思路-v59"> </a>解题思路</h3>
<p>这题使用递归思路挺简单的。即一棵树的镜像的原理是将其左右子树交换，同时左右子树也要是镜像的</p>
<h3 id="解题代码-v40"><a class="header-anchor" href="#解题代码-v40"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        mirrorTree(root.left);</span><br><span class="line">        mirrorTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-28-对称的二叉树"><a class="header-anchor" href="#剑指-Offer-28-对称的二叉树"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></h2>
<h3 id="题目-v80"><a class="header-anchor" href="#题目-v80"> </a>题目</h3>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<pre><code>1
</code></pre>
<p>/ <br>
2   2<br>
/ \ / <br>
3  4 4  3<br>
但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<pre><code>1
</code></pre>
<p>/ <br>
2   2<br>
\   <br>
3    3</p>
<p>示例 1：</p>
<p>输入：root = [1,2,2,3,4,4,3]<br>
输出：true<br>
示例 2：</p>
<p>输入：root = [1,2,2,null,3,null,3]<br>
输出：false</p>
<p>限制：</p>
<p>0 &lt;= 节点个数 &lt;= 1000</p>
<p>注意：本题与主站 101 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">https://leetcode-cn.com/problems/symmetric-tree/</a></p>
<h3 id="解题代码-v41"><a class="header-anchor" href="#解题代码-v41"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSubSymmetric(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubSymmetric</span><span class="params">(TreeNode t1, TreeNode t2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="literal">null</span> ^ t2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="literal">null</span> &amp;&amp;  <span class="literal">null</span> == t2)  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1.val == t2.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> isSubSymmetric(t1.left,t2.right) &amp;&amp; isSubSymmetric(t1.right,t2.left);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a class="header-anchor" href="#剑指-Offer-32-II-从上到下打印二叉树-II"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h2>
<h3 id="题目-v81"><a class="header-anchor" href="#题目-v81"> </a>题目</h3>
<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<blockquote>
<p>例如:<br>
给定二叉树: [3,9,20,null,null,15,7],<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回其层次遍历结果：<br>
[<br>
[3],<br>
[9,20],<br>
[15,7]<br>
]</p>
</blockquote>
<h3 id="解题思路-v60"><a class="header-anchor" href="#解题思路-v60"> </a>解题思路</h3>
<p>显然这题考察层次遍历,同时需要一次性将整层都取出来,所以要先读取该层的个数</p>
<h3 id="解题代码-v42"><a class="header-anchor" href="#解题代码-v42"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">t</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                level.add(t.val);</span><br><span class="line">                <span class="keyword">if</span>(t.left != <span class="literal">null</span>) queue.offer(t.left);</span><br><span class="line">                <span class="keyword">if</span>(t.right != <span class="literal">null</span>) queue.offer(t.right);            </span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v27"><a class="header-anchor" href="#解题思路2-v27"> </a>解题思路2</h3>
<p>同时也可以通过递归的方式去实现将每一层作为一组放到一个数组中去.</p>
<p>虽然遍历的顺序不是按照广度优先的顺序,但是可以根据每一层储存的位置于其深度是对应的,因此我们只需要记住正在操作的该节点的深度,根据深度去访问其应该归属的数组即可</p>
<h3 id="解题代码2-v26"><a class="header-anchor" href="#解题代码2-v26"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//迭代法的思路是根据深度优先，但是在遍历每一个节点的时候，我们能够确定该节点的深度，根据深度取出对应的数组加进去就可以了</span></span><br><span class="line">        ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">0</span>,root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> depth, TreeNode t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//判断该层是否已经存在数组</span></span><br><span class="line">        <span class="comment">//即判断ans.get(depth)是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(ans.size() == depth)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        ans.get(depth).add(t.val);</span><br><span class="line">        <span class="comment">//先访问左子树再访问右子树能够保证从左到右的顺序</span></span><br><span class="line">        dfs(depth+<span class="number">1</span>,t.left);</span><br><span class="line">        dfs(depth+<span class="number">1</span>,t.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-54-二叉搜索树的第k大节点"><a class="header-anchor" href="#剑指-Offer-54-二叉搜索树的第k大节点"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></h2>
<h3 id="题目-v82"><a class="header-anchor" href="#题目-v82"> </a>题目</h3>
<p>给定一棵二叉搜索树，请找出其中第k大的节点。</p>
<blockquote>
<p>示例 1:<br>
输入: root = [3,1,4,null,2], k = 1<br>
3<br>
/ <br>
1   4<br>
<br>
2<br>
输出: 4</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
输入: root = [5,3,6,2,4,null,null,1], k = 3<br>
5<br>
/ <br>
3   6<br>
/ <br>
2   4<br>
/<br>
1<br>
输出: 4</p>
</blockquote>
<p>限制：<br>
1 ≤ k ≤ 二叉搜索树元素个数</p>
<h3 id="解题思路-v61"><a class="header-anchor" href="#解题思路-v61"> </a>解题思路</h3>
<p>注意题目给的是BST树,那利用BST树的特点,中序遍历的话是从小到大的访问.那我们就仿照中序遍历,将访问顺序改成<code>右-&gt;中-&gt;左</code>,那就是从大到小的访问顺序了.</p>
<h3 id="解题代码-v43"><a class="header-anchor" href="#解题代码-v43"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthLargest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//注意这是一棵BST树</span></span><br><span class="line">        <span class="comment">//根据中序遍历的输出是从小到大</span></span><br><span class="line">        <span class="comment">//仿照中序遍历，我们先访问右子树，再当前节点，再左子树，即可从大到小遍历</span></span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; k) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">        <span class="comment">//访问当前节点</span></span><br><span class="line">        <span class="keyword">if</span>(count == k)&#123;</span><br><span class="line">            <span class="comment">//这里就不考虑k &gt; 树的结点树的情况</span></span><br><span class="line">            ans = root.val;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v28"><a class="header-anchor" href="#解题思路2-v28"> </a>解题思路2</h3>
<p>尝试用迭代的方式执行.</p>
<p>仿照中序遍历的非递归版本(迭代的方式)</p>
<h3 id="解题代码2-v27"><a class="header-anchor" href="#解题代码2-v27"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthLargest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//注意这是一棵BST树</span></span><br><span class="line">        <span class="comment">//根据中序遍历的输出是从小到大</span></span><br><span class="line">        <span class="comment">//仿照中序遍历，我们先访问右子树，再当前节点，再左子树，即可从大到小遍历</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//非递归版本</span></span><br><span class="line">       <span class="comment">//栈</span></span><br><span class="line">       Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">       <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       <span class="comment">//压栈的整体思路是：</span></span><br><span class="line">       <span class="comment">//不断将当前结点以及当前结点靠右的一整排压栈</span></span><br><span class="line">       <span class="comment">//直到达到最右端，即root == null的时候</span></span><br><span class="line">       <span class="comment">//此时要弹出栈顶，访问能够访问的最右端。这个被访问的结点相当于当前结点（因为被访问）</span></span><br><span class="line">       <span class="comment">//访问后，需要去看当前被访问的左结点（因为我们要的访问顺序是右中左）</span></span><br><span class="line">       <span class="comment">//因此我们将root = root.left。但这并不代表我们就要访问其左节点</span></span><br><span class="line">       <span class="comment">//再下一次循环中我们又将其最右的一整排压栈。</span></span><br><span class="line">       <span class="keyword">while</span>(!stack.isEmpty() || root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//不断将右节点压栈</span></span><br><span class="line">            <span class="comment">//注意这里不是标准的中序遍历访问顺序</span></span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.offerLast(root);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//到底了</span></span><br><span class="line">                <span class="comment">//此时到达最右</span></span><br><span class="line">                <span class="comment">//弹出栈顶，访问元素，再左子树</span></span><br><span class="line">                root = stack.pollLast();</span><br><span class="line">                <span class="keyword">if</span>(count == k)&#123;</span><br><span class="line">                    <span class="keyword">return</span> root.val;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//这里是随便一个数字，因为如果保证k是小于等于树的个数的话，是执行不到这句的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-55-I-二叉树的深度"><a class="header-anchor" href="#剑指-Offer-55-I-二叉树的深度"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度</a></h2>
<h3 id="题目-v83"><a class="header-anchor" href="#题目-v83"> </a>题目</h3>
<p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<blockquote>
<p>例如：<br>
给定二叉树 [3,9,20,null,null,15,7]，<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回它的最大深度 3 。</p>
</blockquote>
<p>提示：<br>
节点总数 &lt;= 10000<br>
注意：本题与主站 104 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a></p>
<h3 id="解题代码-v44"><a class="header-anchor" href="#解题代码-v44"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root!=<span class="literal">null</span>?Math.max(maxDepth(root.left),maxDepth(root.right))+<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-55-II-平衡二叉树"><a class="header-anchor" href="#剑指-Offer-55-II-平衡二叉树"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a></h2>
<h3 id="题目-v84"><a class="header-anchor" href="#题目-v84"> </a>题目</h3>
<p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<blockquote>
<p>示例 1:<br>
给定二叉树 [3,9,20,null,null,15,7]<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回 true 。</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
给定二叉树 [1,2,2,3,3,null,null,4,4]<br>
1<br>
/ <br>
2   2<br>
/ <br>
3   3<br>
/ <br>
4   4<br>
返回 false 。</p>
</blockquote>
<p>限制：<br>
1 &lt;= 树的结点个数 &lt;= 10000<br>
注意：本题与主站 110 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/">https://leetcode-cn.com/problems/balanced-binary-tree/</a></p>
<h3 id="解题思路-v62"><a class="header-anchor" href="#解题思路-v62"> </a>解题思路</h3>
<p>一棵树要平衡,不仅要当前结点是平衡,其左右结点也要是平衡</p>
<h3 id="解题代码-v45"><a class="header-anchor" href="#解题代码-v45"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(getDepth(root.left)-getDepth(root.right))&lt;<span class="number">2</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root!=<span class="literal">null</span>?Math.max(getDepth(root.left),getDepth(root.right))+<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a class="header-anchor" href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h2>
<h3 id="题目-v85"><a class="header-anchor" href="#题目-v85"> </a>题目</h3>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。<br>
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>
例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<blockquote>
<p>示例 1:<br>
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>
输出: 6<br>
解释: 节点 2 和节点 8 的最近公共祖先是 6。</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>
输出: 2<br>
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p>
</blockquote>
<p>说明:<br>
所有节点的值都是唯一的。<br>
p、q 为不同节点且均存在于给定的二叉搜索树中。<br>
注意：本题与主站 235 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p>
<h3 id="解题思路-v63"><a class="header-anchor" href="#解题思路-v63"> </a>解题思路</h3>
<p>这题要注意的一点是什么时候去遍历左子树,什么时候去遍历右子树</p>
<p>如果当前结点的值大于最大值,说明当前结点也比其公共祖先还大,得去左子树找.如果去右子树找的话,那右子树的每一个结点都大于当前结点,那就更找不到了</p>
<p>同理小于最小值</p>
<h3 id="解题代码-v46"><a class="header-anchor" href="#解题代码-v46"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode ancestor;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">//分类讨论</span></span><br><span class="line">        dfs(root,p,q);</span><br><span class="line">        <span class="keyword">return</span> ancestor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.max(p.val,q.val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(p.val,q.val);</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; min)&#123;</span><br><span class="line">            dfs(root.right,p,q);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; max)&#123;</span><br><span class="line">            dfs(root.left,p,q);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ancestor = root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-68-II-二叉树的最近公共祖先"><a class="header-anchor" href="#剑指-Offer-68-II-二叉树的最近公共祖先"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></h2>
<h3 id="题目-v86"><a class="header-anchor" href="#题目-v86"> </a>题目</h3>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src="http://algorithm-image.qibinaoe.top/binarytree.png" alt="img"></p>
<blockquote>
<p>示例 1:<br>
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>
输出: 3<br>
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>
输出: 5<br>
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</p>
</blockquote>
<p>说明:<br>
所有节点的值都是唯一的。<br>
p、q 为不同节点且均存在于给定的二叉树中。<br>
注意：本题与主站 236 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p>
<h3 id="解题思路-v64"><a class="header-anchor" href="#解题思路-v64"> </a>解题思路</h3>
<p>注意,这题与上一题&quot;<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a>&quot;的区别在于,本题不是BST树,那注定效率就比不上是BST树的搜索.</p>
<p>想到第一种解题方法是,从上到下去判断当前结点是不是最近公共祖先.</p>
<p>首先我们先判断是不是祖先.如果是祖先的话,那么该节点包含这两个结点<code>p</code>,<code>q</code>(包含等于情况).</p>
<p>判断完是不是祖先后,接着判断是不是最近祖先,如果是最近祖先的话,那么其层数应该比较深,所以我们定义一个变量去记录当前较近祖先的值</p>
<p>但是这种做法有很多重复的判断,每个结点都去遍历一遍其子树,因此效率非常低</p>
<h3 id="解题代码-v47"><a class="header-anchor" href="#解题代码-v47"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode ancestor;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 祖先的层数，越大越好</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">// 从上到下，逐个判断当前结点是不是最近最近公共祖先</span></span><br><span class="line">        <span class="comment">// 但是会出现很多冗余的操作，所以效率会低</span></span><br><span class="line">        ancestor = root;</span><br><span class="line">        findAncestor(root,p,q,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ancestor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q, <span class="type">int</span> depth)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 先判断当前结点是不是祖先</span></span><br><span class="line">        <span class="keyword">if</span>(isChild(root,p) &amp;&amp; isChild(root,q))&#123;</span><br><span class="line">            <span class="keyword">if</span>(age &lt; depth)&#123;</span><br><span class="line">                ancestor = root;</span><br><span class="line">                age = depth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断其左右结点是不是</span></span><br><span class="line">        findAncestor(root.left,p,q,depth+<span class="number">1</span>);</span><br><span class="line">        findAncestor(root.right,p,q,depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isChild</span><span class="params">(TreeNode root, TreeNode p)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">return</span> <span class="variable">root</span> <span class="operator">=</span>= p || isChild(root.left,p) || isChild(root.right,p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v29"><a class="header-anchor" href="#解题思路2-v29"> </a>解题思路2</h3>
<p>我们可以通过后序遍历来避免重复执行重复的代码</p>
<p>因为后序遍历,第一次出现符合的祖先必定为最近公共祖先</p>
<p>如果判断一个结点是最近公共祖先呢?</p>
<p>第一种情况是左子树存在一个结点<code>p</code>,右子树存在另一个结点<code>q</code>,那么当前结点<code>root</code>即为最近公共祖先</p>
<p>如果当前结点等于<code>p</code>或<code>q</code>,那么其左子树(或右子树)如果存在另一个结点,则当前结点是最近公共祖先.</p>
<p>根据我们可以写下代码参考<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-ii-er-cha-shu-de-zui-jin-gong-gon-7/">面试题68 - II. 二叉树的最近公共祖先（后序遍历 DFS ，清晰图解）</a></p>
<p>其中返回值代表的意思是要么返回空,要么返回最近公共祖先,因此其最近公共祖先是不断往上层传递</p>
<h3 id="解题代码2-v28"><a class="header-anchor" href="#解题代码2-v28"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">// 从下到上</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || root == p || root == q ) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p , q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> ) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路3-v7"><a class="header-anchor" href="#解题思路3-v7"> </a>解题思路3</h3>
<p>根据解题思路2的思想,用官方题解的代码去写<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/er-cha-shu-de-zui-jin-gong-gong-zu-xian-6fdt7/">官方题解递归</a></p>
<h3 id="解题代码3-v11"><a class="header-anchor" href="#解题代码3-v11"> </a>解题代码3</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode ans;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        dfs(root,p,q);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">lson</span> <span class="operator">=</span> dfs(root.left,p,q);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rson</span> <span class="operator">=</span> dfs(root.right,p,q);</span><br><span class="line">        <span class="comment">//判断成立条件</span></span><br><span class="line">        <span class="keyword">if</span>((lson &amp;&amp; rson) || ((root.val == p.val || root.val == q.val) &amp;&amp;(lson || rson)))&#123;</span><br><span class="line">            ans = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lson || rson || root.val == p.val || root.val == q.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路4-v3"><a class="header-anchor" href="#解题思路4-v3"> </a>解题思路4</h3>
<p>可以根据hashmap去储存每一条链的每个结点</p>
<p>然后取<code>p</code>去保存该路径(从root到p)</p>
<p>接着去寻找<code>q</code>网上倒退的过程中,在hashset中第一次出现重复结点即为最近公共结点</p>
<h3 id="解题代码4-v4"><a class="header-anchor" href="#解题代码4-v4"> </a>解题代码4</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;TreeNode,TreeNode&gt; map;</span><br><span class="line">    Set&lt;TreeNode&gt; set;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">// 先获取每个结点及其父节点构成键值对，存入hashmap</span></span><br><span class="line">        <span class="comment">// 再获取p的路径（从root到p）存入hashSet</span></span><br><span class="line">        <span class="comment">// 再从q开始，往上遍历，第一次出现存在的结点即为最近公共结点</span></span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        dfs(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">null</span>)&#123;</span><br><span class="line">            set.add(p);</span><br><span class="line">            p = map.get(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(q)) <span class="keyword">return</span> q;</span><br><span class="line">            q = map.get(q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            map.put(root.left,root);</span><br><span class="line">            dfs(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            map.put(root.right,root);</span><br><span class="line">            dfs(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题-04-02-最小高度树"><a class="header-anchor" href="#面试题-04-02-最小高度树"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-height-tree-lcci/">面试题 04.02. 最小高度树</a></h2>
<h3 id="题目-v87"><a class="header-anchor" href="#题目-v87"> </a>题目</h3>
<p>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。</p>
<blockquote>
<p>示例:<br>
给定有序数组: [-10,-3,0,5,9],<br>
一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：<br>
0<br>
/ \<br>
-3   9<br>
/   /<br>
-10  5</p>
</blockquote>
<h3 id="解题思路-v65"><a class="header-anchor" href="#解题思路-v65"> </a>解题思路</h3>
<p>如果要生成一个高度最小的二叉树，则尽量让左右两个子树的个数相等。于是我们就规定数组的中间结点为根节点。</p>
<h3 id="解题代码-v48"><a class="header-anchor" href="#解题代码-v48"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sortedBST(nums,<span class="number">0</span>,nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedBST</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="comment">//取中间作为根节点</span></span><br><span class="line">        <span class="comment">// 规定左闭右开</span></span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = sortedBST(nums,left,mid);</span><br><span class="line">        root.right =sortedBST(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题-04-04-检查平衡性"><a class="header-anchor" href="#面试题-04-04-检查平衡性"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/check-balance-lcci/">面试题 04.04. 检查平衡性</a></h2>
<h3 id="题目-v88"><a class="header-anchor" href="#题目-v88"> </a>题目</h3>
<p>实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过 1。</p>
<blockquote>
<p>示例 1:<br>
给定二叉树 [3,9,20,null,null,15,7]<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回 true 。</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
给定二叉树 [1,2,2,3,3,null,null,4,4]<br>
1<br>
/ <br>
2   2<br>
/ <br>
3   3<br>
/ <br>
4   4<br>
返回 false 。</p>
</blockquote>
<h3 id="解题思路-v66"><a class="header-anchor" href="#解题思路-v66"> </a>解题思路</h3>
<p>同”<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a>“</p>
<h3 id="解题代码-v49"><a class="header-anchor" href="#解题代码-v49"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 只需在获取高度的过程中，判断其左右两个子树是否高度平衡</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> getHeight(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> getHeight(root.right);</span><br><span class="line">        <span class="keyword">return</span>  Math.abs(leftHeight-rightHeight)&lt;=<span class="number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root!=<span class="literal">null</span>?Math.max(getHeight(root.left),getHeight(root.right))+<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题-17-12-BiNode"><a class="header-anchor" href="#面试题-17-12-BiNode"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binode-lcci/">面试题 17.12. BiNode</a></h2>
<h3 id="题目-v89"><a class="header-anchor" href="#题目-v89"> </a>题目</h3>
<p>二叉树数据结构TreeNode可用来表示单向链表（其中left置空，right为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求依然符合二叉搜索树的性质，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。</p>
<p>返回转换后的单向链表的头节点。<br>
注意：本题相对原题稍作改动</p>
<blockquote>
<p>示例：<br>
输入： [4,2,5,1,3,null,6,0]<br>
输出： [0,null,1,null,2,null,3,null,4,null,5,null,6]</p>
</blockquote>
<p>提示：<br>
节点数量不会超过 100000。</p>
<h3 id="解题思路-v67"><a class="header-anchor" href="#解题思路-v67"> </a>解题思路</h3>
<p>注意到中序遍历的访问顺序刚好为我们需要的链表顺序</p>
<p>需要注意的技巧是，通过保存上一个结点来实现拼接</p>
<p>同时需要将当前结点的left置空</p>
<h3 id="解题代码-v50"><a class="header-anchor" href="#解题代码-v50"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertBiNode</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 注意到转换后的链表其实是一个递增的，所以代表这是个中序遍历</span></span><br><span class="line">        <span class="comment">// 但是如果按通常中序遍历的递归，我们先来到了最小的结点，我们不好决定返回值</span></span><br><span class="line">        <span class="comment">// 如果返回数值最大的结点，即新构成的链表最尾巴的结点，会比较好操作，即拼接只需要O（1）的复杂度，但是这样会丢失头结点的信息，除非我们一开始就保存</span></span><br><span class="line">        <span class="comment">// 如果一直返回头节点的话，我们每次都需要将其指向链表尾部进行拼接，浪费时间。</span></span><br><span class="line">        convert(root);</span><br><span class="line">        <span class="keyword">return</span> dummy.right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">convert</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        convert(root.left);</span><br><span class="line">        <span class="keyword">if</span>(prev == <span class="literal">null</span>)&#123;</span><br><span class="line">            dummy.right = root;</span><br><span class="line">            prev = root;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            prev.right = root;</span><br><span class="line">            prev = root;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = <span class="literal">null</span>;</span><br><span class="line">        convert(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="94-二叉树的中序遍历"><a class="header-anchor" href="#94-二叉树的中序遍历"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h2>
<h3 id="题目-v90"><a class="header-anchor" href="#题目-v90"> </a>题目</h3>
<p>给定一个二叉树的根节点 root ，返回它的 中序 遍历。</p>
<blockquote>
<p>示例 1：<br>
输入：root = [1,null,2,3]<br>
输出：[1,3,2]</p>
<p><img src="http://algorithm-image.qibinaoe.top/inorder_1.jpg" alt="img"></p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：root = []<br>
输出：[]</p>
</blockquote>
<blockquote>
<p>示例 3：<br>
输入：root = [1]<br>
输出：[1]</p>
</blockquote>
<blockquote>
<p>示例 4：<br>
输入：root = [1,2]<br>
输出：[2,1]</p>
<p><img src="http://algorithm-image.qibinaoe.top/inorder_5.jpg" alt="img"></p>
</blockquote>
<blockquote>
<p>示例 5：<br>
输入：root = [1,null,2]<br>
输出：[1,2]</p>
<p><img src="http://algorithm-image.qibinaoe.top/inorder_4.jpg" alt="img"></p>
</blockquote>
<blockquote>
<p>提示：<br>
树中节点数目在范围 [0, 100] 内<br>
-100 &lt;= Node.val &lt;= 100</p>
</blockquote>
<p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>
<h3 id="解题思路递归"><a class="header-anchor" href="#解题思路递归"> </a>解题思路递归</h3>
<p>较简单不详细介绍了</p>
<h3 id="解题代码递归-v2"><a class="header-anchor" href="#解题代码递归-v2"> </a>解题代码递归</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; result;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路迭代"><a class="header-anchor" href="#解题思路迭代"> </a>解题思路迭代</h3>
<p>对于树的中序遍历而言，需要借助栈进行存储当前结点。但是使用栈的思路跟前序遍历不一样。</p>
<p>中序遍历使用栈，对于“左”、“中”、“右”而言，只存了中，然后就往“左”边跑。并不是先压“右”再压”中“。</p>
<p>因为中序遍历会最先访问树的最左结点，但是同时在访问完最左结点之后，需要能够返回上一层父节点，所以只压父节点就可以了，对于其右结点，可以 通过<code>root.right</code>进行访问。</p>
<h3 id="解题代码迭代-v2"><a class="header-anchor" href="#解题代码迭代-v2"> </a>解题代码迭代</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//不断将当前结点压栈，直到来到最左的结点</span></span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.offerLast(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//root为空，说明已经不能再左了</span></span><br><span class="line">                <span class="comment">//此时取出栈中元素进行访问</span></span><br><span class="line">                root = stack.pollLast();</span><br><span class="line">                <span class="comment">//访问操作：</span></span><br><span class="line">                result.add(root.val);</span><br><span class="line">                <span class="comment">//对于中序遍历而言，当前已经操作过左子树 当前结点， 现在应该访问其右子树</span></span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路morris"><a class="header-anchor" href="#解题思路morris"> </a>解题思路morris</h3>
<p>具体看“501. 二叉搜索树中的众数”-“解题思路3再优化 morris中序遍历”</p>
<h3 id="解题代码-v51"><a class="header-anchor" href="#解题代码-v51"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//morris算法</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//将左孩子的最右结点的指向自己</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> root.left;</span><br><span class="line">            <span class="keyword">if</span>(left != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(left.right != <span class="literal">null</span> &amp;&amp; left.right != root)&#123;</span><br><span class="line">                    left = left.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//根据left.right的结果判断当前结点是否访问过</span></span><br><span class="line">                <span class="keyword">if</span>(left.right == root)&#123;</span><br><span class="line">                    <span class="comment">//说明当前结点的左子树都访问过了，现在要访问当前结点</span></span><br><span class="line">                    <span class="comment">//访问操作:</span></span><br><span class="line">                    result.add(root.val);</span><br><span class="line">                    left.right = <span class="literal">null</span>; <span class="comment">//恢复原来的树结构</span></span><br><span class="line">                    <span class="comment">//现在访问右子树</span></span><br><span class="line">                    root = root.right;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//说明还没将当前结点接在左孩子的最右结点上</span></span><br><span class="line">                    left.right = root; <span class="comment">//保存完该节点</span></span><br><span class="line">                    <span class="comment">//进行左子树的访问</span></span><br><span class="line">                    root = root.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//没有左子树，那就直接访问当前结点</span></span><br><span class="line">                result.add(root.val);</span><br><span class="line">                <span class="comment">// 去访问右子树</span></span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="95-不同的二叉搜索树-II"><a class="header-anchor" href="#95-不同的二叉搜索树-II"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a></h2>
<h3 id="题目-v91"><a class="header-anchor" href="#题目-v91"> </a>题目</h3>
<p>给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。</p>
<p>示例：<br>
输入：3<br>
输出：<br>
[<br>
[1,null,3,2],<br>
[3,2,null,1],<br>
[3,1,null,null,2],<br>
[2,1,3],<br>
[1,null,2,null,3]<br>
]<br>
解释：<br>
以上的输出对应以下 5 种不同结构的二叉搜索树：</p>
<p>1         3     3      2      1<br>
\       /     /      / \      <br>
3     2     1      1   3      2<br>
/     /       \                 <br>
2     1         2                 3</p>
<p>提示：<br>
0 &lt;= n &lt;= 8</p>
<h3 id="解题思路-v68"><a class="header-anchor" href="#解题思路-v68"> </a>解题思路</h3>
<p>在生成一棵这样的二叉搜索树的时候，能够发现，在选定一个根节点后，去生成其左右子树的过程，又是重复生成当前结点的步骤。因此我们可以利用递归去解决这道题</p>
<h3 id="解题代码-v52"><a class="header-anchor" href="#解题代码-v52"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过递归的方式去解决这道题</span></span><br><span class="line">        <span class="comment">// 因为可以发现，生成一棵这样的二叉搜索树，在生成其左子树和右子树是其子问题，解决的方式是一致的。</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">generateTrees</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; allTrees = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); <span class="comment">// allTrees存放的是在start到end这些编号中，分别以其中某一个数字为根节点，所能生成的所有树的根节点的集合</span></span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            <span class="comment">//说明结点为空， 放入空结点</span></span><br><span class="line">            allTrees.add(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> allTrees;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//现在生成allTrees</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="comment">// i 代表当前是以i编号为根节点</span></span><br><span class="line">            <span class="comment">//生成左右子树</span></span><br><span class="line">            List&lt;TreeNode&gt; leftTrees = generateTrees(start,i-<span class="number">1</span>);</span><br><span class="line">            List&lt;TreeNode&gt; rightTrees = generateTrees(i+<span class="number">1</span>,end);</span><br><span class="line">            <span class="comment">//将左子树，右子树，根节点组合在一起</span></span><br><span class="line">            <span class="comment">//注意leftTrees和rightTrees存放的都是根节点，所以直接放在根节点的左右子树就行了</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode leftr : leftTrees)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode rightr : rightTrees)&#123;</span><br><span class="line">                    <span class="comment">//生成根节点</span></span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(i);</span><br><span class="line">                    root.left = leftr;</span><br><span class="line">                    root.right = rightr;</span><br><span class="line">                    allTrees.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allTrees;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2TODO"><a class="header-anchor" href="#解题思路2TODO"> </a>解题思路2TODO</h3>
<p>还有动态规划的解法，等学习后再来补充</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-2-7/">详细通俗的思路分析，多解法</a></p>
<h2 id="96-不同的二叉搜索树"><a class="header-anchor" href="#96-不同的二叉搜索树"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h2>
<h3 id="题目-v92"><a class="header-anchor" href="#题目-v92"> </a>题目</h3>
<p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<blockquote>
<p>示例:<br>
输入: 3<br>
输出: 5<br>
解释:<br>
给定 n = 3, 一共有 5 种不同结构的二叉搜索树<br>
1         3     3      2      1<br>
\       /     /      / \      <br>
3     2     1      1   3      2<br>
/     /       \                 <br>
2     1         2                 3</p>
</blockquote>
<h3 id="解题思路-v69"><a class="header-anchor" href="#解题思路-v69"> </a>解题思路</h3>
<p>这题解题的想法和上一道题“<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a>”的想法大致是一样的。</p>
<p>整体上递归的方法，先选定根节点，然后去分别判断左右子树的个数。与上一题不同的是，这题只需要个数，不需要具体的树，因此我们可以通过将左右子树的个数相乘即可。<strong>但是</strong>需要注意的一点是，当其中一侧为空时，则也属于一种情况，因此</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leftnums = leftnums == <span class="number">0</span>? <span class="number">1</span>:leftnums;</span><br><span class="line">rightnums = rightnums == <span class="number">0</span>? <span class="number">1</span>:rightnums;</span><br></pre></td></tr></table></figure>
<p>来使得子树为空的情况也能计算在内</p>
<p>接着只需要<code>leftnums*rightnums</code>左右子树个数相乘即可。</p>
<p>另一个与上一题不同的地方在于，左右子树由于只需要个数，因此数值<code>n</code>就能决定输出的个数<code>nums</code>。如果像上一道题，每一棵树都去计算个数的话，会超时。因此这里我们借助hashmap去保存<code>n</code>和对应的<code>nums</code>，进一步减少计算</p>
<h3 id="解题代码-v53"><a class="header-anchor" href="#解题代码-v53"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//通过递归，选定根节点后进行左右子树的判断</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numsTrees(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numsTrees</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> end - start;</span><br><span class="line">        <span class="comment">//先判断是否计算过该值</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> map.get(n);</span><br><span class="line">        <span class="keyword">if</span>(result != <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以start至end分别为根节点，生成其左右子树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">leftnums</span> <span class="operator">=</span> numsTrees(start, i-<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightnums</span> <span class="operator">=</span> numsTrees(i+<span class="number">1</span>,end);</span><br><span class="line">            leftnums = leftnums == <span class="number">0</span>? <span class="number">1</span>:leftnums;</span><br><span class="line">            rightnums = rightnums == <span class="number">0</span>? <span class="number">1</span>:rightnums;</span><br><span class="line">            nums += leftnums*rightnums;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(n,nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2TODO-v2"><a class="header-anchor" href="#解题思路2TODO-v2"> </a>解题思路2TODO</h3>
<p>官解使用动态规划，等我具体学习了动态规划再来补充</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode-solution/">不同的二叉搜索树</a></p>
<h2 id="98-验证二叉搜索树"><a class="header-anchor" href="#98-验证二叉搜索树"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h2>
<h3 id="题目-v93"><a class="header-anchor" href="#题目-v93"> </a>题目</h3>
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：<br>
节点的左子树只包含小于当前节点的数。<br>
节点的右子树只包含大于当前节点的数。<br>
所有左子树和右子树自身必须也是二叉搜索树。</p>
<blockquote>
<p>示例 1:<br>
输入:<br>
2<br>
/ <br>
1   3<br>
输出: true</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
输入:<br>
5<br>
/ <br>
1   4<br>
/ <br>
3   6<br>
输出: false<br>
解释: 输入为: [5,1,4,null,null,3,6]。<br>
根节点的值为 5 ，但是其右子节点值为 4 。</p>
</blockquote>
<h3 id="解题思路-v70"><a class="header-anchor" href="#解题思路-v70"> </a>解题思路</h3>
<p>既然是BST，那么其中序遍历必须满足递增的规律，因此我们就通过中序遍历去判断</p>
<h3 id="解题代码-v54"><a class="header-anchor" href="#解题代码-v54"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> prev;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">first</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="keyword">if</span>(first)&#123;</span><br><span class="line">            first = <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(prev &gt;= root.val)&#123;</span><br><span class="line">                ans = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = root.val;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v30"><a class="header-anchor" href="#解题思路2-v30"> </a>解题思路2</h3>
<p>一个二叉搜索树的右孩子必然都大于当前结点</p>
<p>一个二叉搜索树的左孩子必然都小于当前结点。</p>
<p>根据这个特点，我们去递归</p>
<h3 id="解题代码2-v29"><a class="header-anchor" href="#解题代码2-v29"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root, Integer lower, Integer higher)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//判断当前结点是否满足BST</span></span><br><span class="line">        <span class="keyword">if</span>(lower != <span class="literal">null</span> &amp;&amp; root.val &lt;= lower) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(higher != <span class="literal">null</span> &amp;&amp; root.val &gt;= higher) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//判断其左右孩子</span></span><br><span class="line">        <span class="comment">//左孩子的值应该介于最小值和root.val之间</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.left,lower,root.val) &amp;&amp; isValidBST(root.right,root.val,higher);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="99-恢复二叉搜索树"><a class="header-anchor" href="#99-恢复二叉搜索树"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/recover-binary-search-tree/">99. 恢复二叉搜索树</a></h2>
<h3 id="题目-v94"><a class="header-anchor" href="#题目-v94"> </a>题目</h3>
<p>给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。</p>
<p>进阶：使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？</p>
<blockquote>
<p>示例 1：<br>
输入：root = [1,3,null,null,2]<br>
输出：[3,1,null,null,2]<br>
解释：3 不能是 1 左孩子，因为 3 &gt; 1 。交换 1 和 3 使二叉搜索树有效。</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：root = [3,1,4,null,null,2]<br>
输出：[2,1,4,null,null,3]<br>
解释：2 不能在 3 的右子树中，因为 2 &lt; 3 。交换 2 和 3 使二叉搜索树有效。</p>
</blockquote>
<blockquote>
<p>提示：<br>
树上节点的数目在范围 [2, 1000] 内<br>
-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</p>
</blockquote>
<h3 id="解题思路-v71"><a class="header-anchor" href="#解题思路-v71"> </a>解题思路</h3>
<p>看到二叉搜索树就想到中序遍历。然后我们现在就研究一个升序数组进行其中任意两个数字进行调换会发生什么事。</p>
<p>首先是出现逆序对。但是这其中又有区别。当交换的是两个相邻的元素，则只出现一次逆序对。当交换的是两个不相邻的元素，则出现两个逆序对。然后我们就是要记录这两个逆序对中需要交换的元素进行交换即可</p>
<h3 id="解题代码-v55"><a class="header-anchor" href="#解题代码-v55"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recoverTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 对于一个调换两个结点的树，有两种情况</span></span><br><span class="line">        <span class="comment">// 1. 调换相邻元素，那么只需将这两个元素交换即可，同时只会出现一次逆序情况</span></span><br><span class="line">        <span class="comment">// 2. 调换不相邻的两个元素，那么存在两组元素：前面元素大于后面元素（按中序遍历），那么需要将第一组的第一个和第二组的第二个交换</span></span><br><span class="line">        <span class="comment">// 因此我们同一需要调换的两个元素定位x y。来统一处理逆序情况，</span></span><br><span class="line">        <span class="comment">// 只要出现逆序情况，我们将该组的第二个元素赋值给y，因为两种情况，y都是在第二个</span></span><br><span class="line">        <span class="comment">// 同时在x为空的情况，将该组第一个赋值给x，因为两种情况x都是在第一个</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">x</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">y</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pred</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 中序遍历</span></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.offerLast(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = stack.pollLast();</span><br><span class="line">                <span class="comment">// 开始进行遍历</span></span><br><span class="line">                <span class="keyword">if</span>(pred == <span class="literal">null</span>) &#123;</span><br><span class="line">                    pred = root;</span><br><span class="line">                    root = root.right;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//  判断是否有序</span></span><br><span class="line">                <span class="keyword">if</span>(root.val &lt; pred.val) &#123;</span><br><span class="line">                    <span class="comment">// 该组乱序</span></span><br><span class="line">                    y = root;</span><br><span class="line">                    <span class="keyword">if</span>(x == <span class="literal">null</span>) &#123;</span><br><span class="line">                        x = pred;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 说明这是第二组，可以结束了</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                pred = root;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找出需要交换的两个结点x , y </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x.val;</span><br><span class="line">        x.val = y.val;</span><br><span class="line">        y.val = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="102-二叉树的层序遍历"><a class="header-anchor" href="#102-二叉树的层序遍历"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h2>
<h3 id="题目-v95"><a class="header-anchor" href="#题目-v95"> </a>题目</h3>
<p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<blockquote>
<p>示例：<br>
二叉树：[3,9,20,null,null,15,7],<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回其层序遍历结果：<br>
[<br>
[3],<br>
[9,20],<br>
[15,7]<br>
]</p>
</blockquote>
<h3 id="解题思路-v72"><a class="header-anchor" href="#解题思路-v72"> </a>解题思路</h3>
<p>层序遍历的话使用队列即可解决，同时它需要同时取出一整层的结点，所以我们先记录该层的结点个数，再进行访问</p>
<h3 id="解题代码-v56"><a class="header-anchor" href="#解题代码-v56"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                level.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) queue.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="103-二叉树的锯齿形层序遍历"><a class="header-anchor" href="#103-二叉树的锯齿形层序遍历"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h2>
<h3 id="题目-v96"><a class="header-anchor" href="#题目-v96"> </a>题目</h3>
<p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<blockquote>
<p>例如：<br>
给定二叉树 [3,9,20,null,null,15,7],<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回锯齿形层序遍历如下：<br>
[<br>
[3],<br>
[20,9],<br>
[15,7]<br>
]</p>
</blockquote>
<h3 id="解题思路-v73"><a class="header-anchor" href="#解题思路-v73"> </a>解题思路</h3>
<p>这题本质上还是一个层序遍历，只是在将一整层的数组添加进最终的答案数组时，根据其在奇数层还是偶数层，判断是否要将其翻转过来</p>
<h3 id="解题代码-v57"><a class="header-anchor" href="#解题代码-v57"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) queue.offer(root);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">odd</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                level.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) queue.offer(cur.right); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据奇偶层来判断是否翻转</span></span><br><span class="line">            <span class="keyword">if</span>(!odd)&#123;</span><br><span class="line">                Collections.reverse(level);</span><br><span class="line">            &#125;</span><br><span class="line">            odd = !odd;</span><br><span class="line">            ans.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="105-从前序与中序遍历序列构造二叉树"><a class="header-anchor" href="#105-从前序与中序遍历序列构造二叉树"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h2>
<h3 id="题目-v97"><a class="header-anchor" href="#题目-v97"> </a>题目</h3>
<p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p>注意:<br>
你可以假设树中没有重复的元素。</p>
<blockquote>
<p>例如，给出<br>
前序遍历 preorder = [3,9,20,15,7]<br>
中序遍历 inorder = [9,3,15,20,7]<br>
返回如下的二叉树：<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7</p>
</blockquote>
<h3 id="解题思路-v74"><a class="header-anchor" href="#解题思路-v74"> </a>解题思路</h3>
<p>基本的思路是先确定根节点，再确定左右子树的根节点</p>
<p>先通过中序遍历去确定我们要搜索的范围的根节点</p>
<p>确定搜索范围后，我们再搜索范围中出现的结点中，根据前序遍历，寻找最先出现的那个结点即为根节点</p>
<p>确定当前的根节点，我们去确定左右子树的根节点，这里只需要缩小范围去递归即可。根据中序遍历，左子树的范围在其根节点索引往左。右子树的范围在其根节点索引往右</p>
<h3 id="解题代码-v58"><a class="header-anchor" href="#解题代码-v58"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] preorder;</span><br><span class="line">    <span class="type">int</span>[] inorder;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; preorderMap;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        preorderMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; preorder.length; i++)&#123;</span><br><span class="line">            preorderMap.put(preorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构造一棵二叉树首先确定根节点</span></span><br><span class="line">        <span class="comment">// 从前序遍历最先出现的即为根节点</span></span><br><span class="line">        <span class="comment">// 所以我们按前序遍历的顺序去访问</span></span><br><span class="line">        <span class="built_in">this</span>.preorder = preorder;</span><br><span class="line">        <span class="built_in">this</span>.inorder = inorder;</span><br><span class="line">        <span class="keyword">return</span> buildTree(<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//我们要根据[start,end]生成其中的根节点，这范围是中序遍历的</span></span><br><span class="line">        <span class="comment">//先找出根节点</span></span><br><span class="line">        <span class="comment">//根节点即在我们要搜索的中序遍历的范围内，最早在前序遍历出现的结点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minindex</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootindex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curval</span> <span class="operator">=</span> inorder[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">curindex</span> <span class="operator">=</span> preorderMap.get(curval);</span><br><span class="line">            <span class="keyword">if</span>(curindex &lt; minindex)&#123;</span><br><span class="line">                minindex = curindex;</span><br><span class="line">                rootindex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//生成根节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[minindex]);</span><br><span class="line">        <span class="comment">//生成左右孩子</span></span><br><span class="line">        root.left = buildTree(start,rootindex-<span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(rootindex+<span class="number">1</span>,end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v31"><a class="header-anchor" href="#解题思路2-v31"> </a>解题思路2</h3>
<p>上一个解题思路中，在每个递归都遍历一遍数组，这样的效率过低。而我们要遍历一遍数组的原因在于我们要寻找根节点在哪，同时要找出根节点分别在中序遍历和后序遍历的位置。根据这个我们可以进行优化</p>
<p>所以，我们的思想就是要知道<strong>根节点在哪</strong>?</p>
<p>注意到前序遍历的最开头是根节点，这样我们就可以轻松的创建当前根节点。</p>
<p>那如何去创建左孩子和右孩子呢？</p>
<p>左孩子就是左子树的根节点，所以我们要找出左子树范围的前序遍历的第一个。</p>
<p>这个怎么找呢？</p>
<p>知道前序遍历的顺序是：根 左 右</p>
<p>根在前序遍历的索引已经知道了，那“左子树的根在前序遍历的位置”即“根在前序遍历的索引+1”就可以获得</p>
<p>那右子树的根的索引怎么获取呢？</p>
<p>”右子树的根的索引“即为““根在前序遍历的索引”+“左子树的长度”+1”即可。</p>
<p>记住：这里说的“根的索引”指的是在其树的范围的前序遍历的<strong>第一个结点</strong></p>
<p>这样我们就知道根，左子树根，右子树根如何生成</p>
<p>现在解决如何知道左子树的长度</p>
<p>可以通过中序遍历，在中序遍历索引中[最左，根-1]为左子树范围，[根+1，最右]即为右子树范围</p>
<p>而通过hashmap去储存结点的值与对于在中序遍历的位置。我们就可以找到前序遍历的根节点在中序遍历的索引。</p>
<h3 id="解题代码2-v30"><a class="header-anchor" href="#解题代码2-v30"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] preorder;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++)&#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.preorder = preorder;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> preorder.length;</span><br><span class="line">        <span class="keyword">return</span> buildTree(<span class="number">0</span>,length-<span class="number">1</span>,<span class="number">0</span>,length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span> preLeft, <span class="type">int</span> preRight, <span class="type">int</span> inLeft, <span class="type">int</span> inRight)</span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(preLeft &gt; preRight || inLeft &gt; inRight) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//preLeft指向根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">inroot</span> <span class="operator">=</span> map.get(preorder[preLeft]);</span><br><span class="line">        <span class="comment">//生成根节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[preLeft]);</span><br><span class="line">        <span class="comment">//左子树长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSubtreesLength</span> <span class="operator">=</span> inroot - inLeft;</span><br><span class="line">        <span class="comment">//生成左右孩子</span></span><br><span class="line">        root.left = buildTree(preLeft+<span class="number">1</span>,preLeft+leftSubtreesLength,inLeft,inroot-<span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(preLeft+leftSubtreesLength+<span class="number">1</span>,preRight,inroot+<span class="number">1</span>,inRight);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="106-从中序与后序遍历序列构造二叉树"><a class="header-anchor" href="#106-从中序与后序遍历序列构造二叉树"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h2>
<h3 id="题目-v98"><a class="header-anchor" href="#题目-v98"> </a>题目</h3>
<p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意:<br>
你可以假设树中没有重复的元素。</p>
<blockquote>
<p>例如，给出<br>
中序遍历 inorder = [9,3,15,20,7]<br>
后序遍历 postorder = [9,15,7,20,3]<br>
返回如下的二叉树：<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7</p>
</blockquote>
<h3 id="解题思路-v75"><a class="header-anchor" href="#解题思路-v75"> </a>解题思路</h3>
<p>对于这道题，感觉用递归的思路会更加清晰，首先我们明确一点：</p>
<p>后序遍历是：左右根：因此根节点在最后面。</p>
<p>因此我们可以后序遍历从后往前找，最后一个就是根节点</p>
<p>根据找到根节点后，去看中序遍历的列表。</p>
<p>在中序遍历中，用后序遍历找到的根节点，去区分左右子树。</p>
<p>这样，我们又要去找左子树的根节点以及右孩子的根节点，去拼接到当前的根节点。这就有递归的味道了。</p>
<p>然后如何去写递归呢。就按照上面的思路，我们要先确定我们要寻找根节点的范围。</p>
<p>因为中序遍历的排序很好的表达出了左中右的次序关系，所以我们根据中序遍历的索引去确定我们要寻找的根节点的范围。</p>
<p>当前最左的索引<code>start</code>大于最右的索引<code>end</code>，说明已经没有存在结点了，及返回空，这个就是终止条件。</p>
<p>依次类推，如果<code>start == end</code>说明就刚好剩下一个结点，当然这不需要我们单独写出来。可以归在一般情况下。</p>
<p>假设我们知道了我们要寻找的数组下标的范围。那首先要确定根节点。</p>
<p>如何确定根节点呢？从后序遍历中，从右往左进行确认。</p>
<p>那如何知道最右的是不是我们要找的根节点的范围呢？所以我们要先对中序遍历的范围放在<code>set</code>当中，来明确我们要找到结点范围，然后在后序遍历中又在结点范围中，从右往左第一个出现的结点即为根节点。</p>
<p>这样我们就找到根节点了。</p>
<p>接下来要找左孩子和右孩子。</p>
<p>这就交给递归去完成了。显然，左孩子要寻找的范围即[最左，根结点索引的上一个]</p>
<p>右孩子要寻找的范围即[根节点索引的下一个，最右]</p>
<h3 id="解题代码-v59"><a class="header-anchor" href="#解题代码-v59"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//public HashSet&lt;TreeNode&gt; inTree = new HashSet&lt;&gt;(); //存放已经挂在树上的结点</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="comment">// 后序遍历的最后一个结点为根节点</span></span><br><span class="line">        <span class="comment">// 找到根节点后，根据中序遍历，来分别左右子树</span></span><br><span class="line">        <span class="keyword">return</span> buildTree(<span class="number">0</span>,inorder.length-<span class="number">1</span>,inorder,postorder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用递归方法实现</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span>&#123;</span><br><span class="line">        <span class="comment">//求中序遍历中，索引为[start,end]生成的树的结点</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//确定搜索范围</span></span><br><span class="line">        HashSet&lt;Integer&gt; lookfor = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++)&#123;</span><br><span class="line">            lookfor.add(inorder[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从postorder中确定根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> postorder.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curVal</span> <span class="operator">=</span> postorder[i];</span><br><span class="line">            <span class="keyword">if</span>(lookfor.contains(curVal))&#123;</span><br><span class="line">                rootVal = curVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成根节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成左右子树</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootindex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == rootVal)&#123;</span><br><span class="line">                rootindex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左子树范围[start, rootindex-1]</span></span><br><span class="line">        <span class="comment">//右子树范围[rootindex+1, end]</span></span><br><span class="line">        root.left = buildTree(start,rootindex-<span class="number">1</span>,inorder,postorder);</span><br><span class="line">        root.right = buildTree(rootindex+<span class="number">1</span>,end,inorder,postorder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="113-路径总和-II"><a class="header-anchor" href="#113-路径总和-II"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II</a></h2>
<h3 id="题目-v99"><a class="header-anchor" href="#题目-v99"> </a>题目</h3>
<p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<blockquote>
<p>说明: 叶子节点是指没有子节点的节点。<br>
示例:<br>
给定如下二叉树，以及目标和 sum = 22，<br>
5<br>
/ <br>
4   8<br>
/   / <br>
11  13  4<br>
/  \    / <br>
7    2  5   1<br>
返回:<br>
[<br>
[5,4,11,2],<br>
[5,8,4,5]<br>
]</p>
</blockquote>
<h3 id="解题思路-v76"><a class="header-anchor" href="#解题思路-v76"> </a>解题思路</h3>
<p>这种题目为输出所有路径结果，一般为递归思路</p>
<p>对于这题递归过程有几个坑</p>
<ol>
<li>二叉树的结点的值有正有负。所以不能因为到当前结点的路径之和已经大于所需要的和，就终止递归</li>
<li>这题要求的是到叶子节点。所以再将结果加入最终结果集合中时，需要先判断是否是叶子结点</li>
</ol>
<p>我采用的递归方式是每一条路径都生成了一个链表，但是这样的空间浪费非常严重</p>
<h3 id="解题代码-v60"><a class="header-anchor" href="#解题代码-v60"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; sumList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        dfs(root,sum,<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> sumList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum, LinkedList&lt;Integer&gt; ans)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        ans.add(root.val);</span><br><span class="line">        <span class="comment">//注意是到根节点</span></span><br><span class="line">        <span class="comment">//如果不是根节点就往下传,是则判断结果</span></span><br><span class="line">        <span class="comment">//二叉树的结点值可能是负数，所以不能通过正负值就终止递归</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val == targetSum) sumList.add(ans);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dfs(root.left,targetSum-root.val,(LinkedList&lt;Integer&gt;)ans.clone());</span><br><span class="line">            dfs(root.right,targetSum-root.val,(LinkedList&lt;Integer&gt;)ans.clone());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v32"><a class="header-anchor" href="#解题思路2-v32"> </a>解题思路2</h3>
<p>这里可以在上一种解题的思路上进行优化</p>
<p>第一种解题思路把每一条路径都创建一个集合去储存的原因在于，如果一直用同一个容器，那么遍历到其他条路径时，该容器会乱套。</p>
<p>那么我们可以通过一个栈的结构，将一条路径的结点压栈。由于这递归是深度优先，所以当一条路径遍历完，将结点弹出，就可以用同一个容器去遍历其他条链。同时，在符合条件的叶子节点，我们新创建一个容器来保存进答案就可以了。</p>
<h3 id="解题代码2-v31"><a class="header-anchor" href="#解题代码2-v31"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; sumList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> Deque&lt;Integer&gt; paths = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        dfs(root,sum);</span><br><span class="line">        <span class="keyword">return</span> sumList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        paths.offerLast(root.val);</span><br><span class="line">        <span class="comment">//注意是到根节点</span></span><br><span class="line">        <span class="comment">//如果不是根节点就往下传,是则判断结果</span></span><br><span class="line">        <span class="comment">//二叉树的结点值可能是负数，所以不能通过正负值就终止递归</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val == targetSum) sumList.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;(paths));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dfs(root.left,targetSum-root.val);</span><br><span class="line">            dfs(root.right,targetSum-root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        paths.pollLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="114-二叉树展开为链表"><a class="header-anchor" href="#114-二叉树展开为链表"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h2>
<h3 id="题目-v100"><a class="header-anchor" href="#题目-v100"> </a>题目</h3>
<p>给定一个二叉树，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/8010757">原地</a>将它展开为一个单链表。</p>
<blockquote>
<p>例如，给定二叉树<br>
1<br>
/ <br>
2   5<br>
/ \   <br>
3   4   6<br>
将其展开为：<br>
1<br>
<br>
2<br>
<br>
3<br>
<br>
4<br>
<br>
5<br>
<br>
6</p>
</blockquote>
<h3 id="解题思路-v77"><a class="header-anchor" href="#解题思路-v77"> </a>解题思路</h3>
<p>注意这题不是单纯一个前序遍历输出链表就完事了,而是要<strong>原地</strong>,即用原来的树结构,变成一条只有右孩子的树结构</p>
<p>那么要构成这样的形状.可就得把一个当前根节点的左子树放到当前根节点和右子树的中间,这样就构成一个顺序</p>
<p>那么这就是中序遍历的做法:先处理完左子树,使其成为一条链,再将它拼接到根节点的右孩子上,然后根节点原来的右子树拼到那条链的下面,接下来再将原来的有右子树也整成一条链,就完成了</p>
<h3 id="解题代码-v61"><a class="header-anchor" href="#解题代码-v61"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//这题是原地算法</span></span><br><span class="line">        <span class="comment">//所以应该把当前结点的左子树都加到其右子树，上面</span></span><br><span class="line">        <span class="comment">//栈</span></span><br><span class="line">        <span class="comment">// 因为要先处理完左子树 当前结点 右子树  所以是中序遍历</span></span><br><span class="line">        dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> dfs(root.left);</span><br><span class="line">        <span class="comment">//处理当前结点</span></span><br><span class="line">        root.left = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> root.right;</span><br><span class="line">        <span class="comment">//拼接</span></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> left;</span><br><span class="line">            <span class="keyword">while</span>(temp.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                temp = temp.right;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.right = right; <span class="comment">//拼接</span></span><br><span class="line">            root.right = left;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v33"><a class="header-anchor" href="#解题思路2-v33"> </a>解题思路2</h3>
<p>这里可以采用类似morris算法感觉</p>
<p>morris是将 根结点的左孩子的最右孩子的右孩子成为根节点</p>
<p>而我们就将根结点的左孩子的最右孩子的右孩子成为根节点的右孩子,根节点的右孩子成为根节点的左孩子,这样就形成了题目要求的链了</p>
<h3 id="解题代码2-v32"><a class="header-anchor" href="#解题代码2-v32"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//这题是原地算法</span></span><br><span class="line">        <span class="comment">//所以应该把当前结点的左子树都加到其右子树，上面</span></span><br><span class="line">        <span class="comment">// 我们采用一个很像morris算法的思想</span></span><br><span class="line">        <span class="comment">//注意到前序遍历是 根 左 右， 而我们将根节点的 左孩子的最右孩子 的  右孩子 设置为 根节点的 右孩子， 这样子就拼起来啦</span></span><br><span class="line">        <span class="comment">// 拼起来以后，还需要把 根节点的左孩子 接到右孩子的位置  根节点的左孩子置空</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//根节点的左孩子</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">leftChild</span> <span class="operator">=</span> cur.left;</span><br><span class="line">                <span class="comment">//寻找根节点的左孩子的最右孩子</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">preNode</span> <span class="operator">=</span> leftChild;</span><br><span class="line">                <span class="keyword">while</span>(preNode.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    preNode = preNode.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将 根节点的左孩子的最右孩子的右孩子设置为根节点的右孩子</span></span><br><span class="line">                preNode.right = cur.right;</span><br><span class="line">                <span class="comment">//接到根节点上面</span></span><br><span class="line">                cur.right = leftChild;</span><br><span class="line">                cur.left = <span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="116-填充每个节点的下一个右侧节点指针"><a class="header-anchor" href="#116-填充每个节点的下一个右侧节点指针"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h2>
<h3 id="题目-v101"><a class="header-anchor" href="#题目-v101"> </a>题目</h3>
<p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。<br>
初始状态下，所有 next 指针都被设置为 NULL。</p>
<p>进阶：<br>
你只能使用常量级额外空间。<br>
使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p>
<p>示例：</p>
<p><img src="http://algorithm-image.qibinaoe.top/116_sample.png" alt="img"></p>
<p>输入：root = [1,2,3,4,5,6,7]<br>
输出：[1,#,2,3,#,4,5,6,7,#]<br>
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，‘#’ 标志着每一层的结束。</p>
<p>提示：<br>
树中节点的数量少于 4096<br>
-1000 &lt;= node.val &lt;= 1000</p>
<h3 id="解题思路1-v17"><a class="header-anchor" href="#解题思路1-v17"> </a>解题思路1</h3>
<p>根据示例，很容易发现，通过一个层次遍历，将队列中头两个元素两两相连即可。需要注意的是一层中的最后一个节点的<code>next</code>应该是空，但是根据我们的算法，此时队列中不为空，因此要根据<code>size</code>来判断当前是否是队列的最后一个元素</p>
<p>但这种做法用到了队列，因此空间复杂度不为常量级</p>
<h3 id="解题代码1-v18"><a class="header-anchor" href="#解题代码1-v18"> </a>解题代码1</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="comment">//层次遍历</span></span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            queue.offer(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="type">Node</span> <span class="variable">nextRight</span> <span class="operator">=</span> queue.peek();</span><br><span class="line">                    cur.next = nextRight;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v34"><a class="header-anchor" href="#解题思路2-v34"> </a>解题思路2</h3>
<p>想要达到空间复杂度为常量级，就需要利用好题目给的<code>Node</code>类中含有<code>next</code>节点。而这题的难度主要在于两个非相同父节的同一层相邻节点如何构成联系。</p>
<p>可以发现，借助父节点的<code>next</code>，就可以使两个不是同一父节点的相关联。</p>
<p>而我们拼接这个<code>next</code>关系的位置，是站在父节点的那层，去拼下一层的关系。所以当父节点没有左孩子或右孩子的时候，即为叶子节点，可以终止</p>
<h3 id="解题代码2-v33"><a class="header-anchor" href="#解题代码2-v33"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据父节点的next，来连接同层但不同父节点的关系</span></span><br><span class="line">        <span class="comment">// 因此需要一层一层的遍历，需要记录每一层的左边的节点，通过leftmost.left要移动到下一层</span></span><br><span class="line">        <span class="comment">// 同一父节点的两个子节点直接相连接，不同父节点的两个子节点，通过父节点的next相连接，因此如果父节点没有next，则代表该节点也没有next</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">leftmost</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(leftmost.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> leftmost;</span><br><span class="line">            <span class="keyword">while</span>(head != <span class="literal">null</span> )&#123;</span><br><span class="line">                head.left.next = head.right;</span><br><span class="line">                <span class="keyword">if</span>(head.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                    head.right.next = head.next.left;</span><br><span class="line">                &#125;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            leftmost = leftmost.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路3-v8"><a class="header-anchor" href="#解题思路3-v8"> </a>解题思路3</h3>
<p>递归的思路去解这道题，总体思想和解题思路2是一致的，通过前序遍历的方式，我们只需要保证当前节点的next是有的，其叶子节点就能正确拼接</p>
<h3 id="解题代码3-v12"><a class="header-anchor" href="#解题代码3-v12"> </a>解题代码3</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            root.left.next = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span> &amp;&amp;root.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            root.right.next = root.next.left;</span><br><span class="line">        &#125;</span><br><span class="line">        connect(root.left);</span><br><span class="line">        connect(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="117-填充每个节点的下一个右侧节点指针-II"><a class="header-anchor" href="#117-填充每个节点的下一个右侧节点指针-II"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></h2>
<h3 id="题目-v102"><a class="header-anchor" href="#题目-v102"> </a>题目</h3>
<p>给定一个二叉树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。<br>
初始状态下，所有 next 指针都被设置为 NULL。</p>
<blockquote>
<p>进阶：<br>
你只能使用常量级额外空间。<br>
使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p>
</blockquote>
<blockquote>
<p>示例：</p>
<p><img src="http://algorithm-image.qibinaoe.top/117_sample.png" alt="img">输入：root = [1,2,3,4,5,null,7]<br>
输出：[1,#,2,3,#,4,5,7,#]<br>
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</p>
</blockquote>
<p>提示：<br>
树中的节点数小于 6000<br>
-100 &lt;= node.val &lt;= 100</p>
<h3 id="解题思路-v78"><a class="header-anchor" href="#解题思路-v78"> </a>解题思路</h3>
<p>这题和上一题的基本思路是一致的，即如果当前节点有左右孩子，直接相连接。如果当前节点只有左孩子而没有右孩子，或者是要给右孩子寻找相连接的结点时，是通过当前节点的<code>next</code>来寻找下一个能够被连接的节点。</p>
<p>但是本题由于不是完全二叉树，因此存在许多特殊情况。</p>
<p>例如与当前结点<code>head</code>相邻的<code>head.next</code>是叶子节点，但是<code>head.next.next</code>可能存在孩子节点，如果用<code>if(head.next != null)</code>来判断的话，就会出现遗漏情况，因此需要用循环语句来判断。同时在循环语句中，不能够直接<code>head = head.next</code>。这样会把我们需要连接的左右节点给漏掉</p>
<p>同时还有一点要注意的是，如何找到下一层最左边的节点。这就不能像上一题，直接<code>leftmost = leftmost.left</code>了，因为可能<code>	leftmost</code>不存在左节点，或者就是叶子节点。所以得边连接边判断最左节点。</p>
<h2 id="解题思路-v79"><a class="header-anchor" href="#解题思路-v79"> </a>解题思路</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据子节点的孩子位置情况去判断</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// 记录层次的节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">leftmost</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(leftmost != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> leftmost;</span><br><span class="line">            <span class="comment">// 在拼接的同时寻找下一层的最左边节点</span></span><br><span class="line">            leftmost = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 拼接</span></span><br><span class="line">                <span class="keyword">if</span>(head.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(leftmost == <span class="literal">null</span>)&#123;</span><br><span class="line">                        leftmost = head.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(head.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                        head.left.next = head.right;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// 寻找第一个有孩子节点的同层节点</span></span><br><span class="line">                        <span class="type">Node</span> <span class="variable">nextHead</span> <span class="operator">=</span> head.next;</span><br><span class="line">                        <span class="keyword">while</span>(nextHead != <span class="literal">null</span>)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(nextHead.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                                head.left.next = nextHead.left;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nextHead.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                                head.left.next = nextHead.right;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            nextHead = nextHead.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(head.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(leftmost == <span class="literal">null</span>)&#123;</span><br><span class="line">                        leftmost = head.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(head.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(head.next.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                            head.right.next = head.next.left;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="comment">// 寻找第一个有孩子节点的同层节点</span></span><br><span class="line">                            <span class="type">Node</span> <span class="variable">nextHead</span> <span class="operator">=</span> head.next;</span><br><span class="line">                            <span class="keyword">while</span>(nextHead != <span class="literal">null</span>)&#123;</span><br><span class="line">                                <span class="keyword">if</span>(nextHead.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                                    head.right.next = nextHead.left;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nextHead.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                                    head.right.next = nextHead.right;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;   </span><br><span class="line">                                nextHead = nextHead.next;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="129-求根到叶子节点数字之和"><a class="header-anchor" href="#129-求根到叶子节点数字之和"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">129. 求根到叶子节点数字之和</a></h2>
<h3 id="题目-v103"><a class="header-anchor" href="#题目-v103"> </a>题目</h3>
<p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。</p>
<p>例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。</p>
<p>计算从根到叶子节点生成的所有数字之和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例 1:<br>
输入: [1,2,3]<br>
1<br>
/ <br>
2   3<br>
输出: 25<br>
解释:<br>
从根到叶子节点路径 1-&gt;2 代表数字 12.<br>
从根到叶子节点路径 1-&gt;3 代表数字 13.<br>
因此，数字总和 = 12 + 13 = 25.</p>
<p>示例 2:<br>
输入: [4,9,0,5,1]<br>
4<br>
/ <br>
9   0<br>
/ <br>
5   1<br>
输出: 1026<br>
解释:<br>
从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.<br>
从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.<br>
从根到叶子节点路径 4-&gt;0 代表数字 40.<br>
因此，数字总和 = 495 + 491 + 40 = 1026.</p>
<h3 id="解题思路-v80"><a class="header-anchor" href="#解题思路-v80"> </a>解题思路</h3>
<p>通过递归的方式进行，设置一个全局变量记录总和，而当递归到叶子节点的时候将最终值加进去即可</p>
<h3 id="解题代码-v62"><a class="header-anchor" href="#解题代码-v62"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curVal</span> <span class="operator">=</span> val * <span class="number">10</span> + root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            sum += curVal;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dfs(root.left, curVal);</span><br><span class="line">            dfs(root.right, curVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="144-二叉树的前序遍历"><a class="header-anchor" href="#144-二叉树的前序遍历"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h2>
<h3 id="题目-v104"><a class="header-anchor" href="#题目-v104"> </a>题目</h3>
<p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p>
<h3 id="解题思路-v81"><a class="header-anchor" href="#解题思路-v81"> </a>解题思路</h3>
<p>前序遍历有递归，迭代和morris三种方式</p>
<p>这里写迭代</p>
<h3 id="解题代码-v63"><a class="header-anchor" href="#解题代码-v63"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.offerLast(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pollLast();</span><br><span class="line">            ans.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) stack.offerLast(cur.right);</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) stack.offerLast(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="145-二叉树的后序遍历"><a class="header-anchor" href="#145-二叉树的后序遍历"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h2>
<h3 id="题目-v105"><a class="header-anchor" href="#题目-v105"> </a>题目</h3>
<p>给定一个二叉树，返回它的 后序 遍历。</p>
<blockquote>
<p>示例:<br>
输入: [1,null,2,3]<br>
1<br>
<br>
2<br>
/<br>
3<br>
输出: [3,2,1]</p>
</blockquote>
<h3 id="解题思路-v82"><a class="header-anchor" href="#解题思路-v82"> </a>解题思路</h3>
<p>可以通过递归进行。</p>
<h3 id="解题代码-v64"><a class="header-anchor" href="#解题代码-v64"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) stack.offerLast(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pollLast();</span><br><span class="line">            ans.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) stack.offerLast(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) stack.offerLast(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="173-二叉搜索树迭代器"><a class="header-anchor" href="#173-二叉搜索树迭代器"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-search-tree-iterator/">173. 二叉搜索树迭代器</a></h2>
<h3 id="题目-v106"><a class="header-anchor" href="#题目-v106"> </a>题目</h3>
<p>实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：<br>
BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。<br>
boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。<br>
int next()将指针向右移动，然后返回指针处的数字。<br>
注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。</p>
<p>你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。</p>
<blockquote>
<p>示例：<br>
输入<br>
[“BSTIterator”, “next”, “next”, “hasNext”, “next”, “hasNext”, “next”, “hasNext”, “next”, “hasNext”]<br>
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]<br>
输出<br>
[null, 3, 7, true, 9, true, 15, true, 20, false]</p>
</blockquote>
<blockquote>
<p>解释<br>
BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);<br>
bSTIterator.next();    // 返回 3<br>
bSTIterator.next();    // 返回 7<br>
bSTIterator.hasNext(); // 返回 True<br>
bSTIterator.next();    // 返回 9<br>
bSTIterator.hasNext(); // 返回 True<br>
bSTIterator.next();    // 返回 15<br>
bSTIterator.hasNext(); // 返回 True<br>
bSTIterator.next();    // 返回 20<br>
bSTIterator.hasNext(); // 返回 False</p>
</blockquote>
<blockquote>
<p>提示：<br>
树中节点的数目在范围 [1, 105] 内<br>
0 &lt;= Node.val &lt;= 106<br>
最多调用 105 次 hasNext 和 next 操作</p>
</blockquote>
<p>进阶：<br>
你可以设计一个满足下述条件的解决方案吗？next() 和 hasNext() 操作均摊时间复杂度为 O(1) ，并使用 O(h) 内存。其中 h 是树的高度。</p>
<h3 id="解题思路一"><a class="header-anchor" href="#解题思路一"> </a>解题思路一</h3>
<p>比较简单的思路就是将这棵树的中序遍历结果用数组进行存储，然后通过维护数组索引来表示当前遍历到的位置。但是这种方法的空间复杂度为O(n)</p>
<h3 id="解题代码一"><a class="header-anchor" href="#解题代码一"> </a>解题代码一</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTIterator</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过中序遍历将树节点转换成数组</span></span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 中序遍历</span></span><br><span class="line">        dfs(root.left);</span><br><span class="line">        arr.add(root.val);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr.get(++index);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index+<span class="number">1</span> &lt; arr.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BSTIterator obj = new BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.next();</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.hasNext();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路二"><a class="header-anchor" href="#解题思路二"> </a>解题思路二</h3>
<p>可以借助栈结构，来进行中序遍历。</p>
<p>在这个过程中，我们并不需要将这棵二叉树遍历完，而是通过一个<code>cur</code>来记录根节点以及一个栈来保存<code>cur</code>的所有父节点。</p>
<p>这样我们可以通过判断<code>(cur != null) || !stack.isEmpty()</code>是否还存在next，因为刚开始的时候，还没进行遍历，栈为空，当时cur不为null。</p>
<h3 id="解题代码二"><a class="header-anchor" href="#解题代码二"> </a>解题代码二</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line">    </span><br><span class="line">    Deque&lt;TreeNode&gt; stack;</span><br><span class="line">    TreeNode cur;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTIterator</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 栈的形式进行中序遍历，同时不直接中序遍历完，而是在需要的时候进行中序遍历，再返回一个可用结果</span></span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        cur = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.offerLast(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = stack.pollLast();</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> cur.val;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (cur != <span class="literal">null</span>) || !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="199-二叉树的右视图"><a class="header-anchor" href="#199-二叉树的右视图"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h2>
<h3 id="题目-v107"><a class="header-anchor" href="#题目-v107"> </a>题目</h3>
<p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p>示例:</p>
<p>输入: [1,2,3,null,5,null,4]<br>
输出: [1, 3, 4]</p>
<blockquote>
<p>解释:<br>
1            &lt;—<br>
/   <br>
2     3         &lt;—<br>
\     <br>
5     4       &lt;—</p>
</blockquote>
<h3 id="解题思路-v83"><a class="header-anchor" href="#解题思路-v83"> </a>解题思路</h3>
<p>从右侧看到的话，就是每一层的最后一个。那么我们就想到进行层次遍历，同时获取每一层的最后一个元素即可。</p>
<h3 id="解题代码-v65"><a class="header-anchor" href="#解题代码-v65"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 层次遍历的最后一个元素</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); </span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 将一层的元素取出来</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= size; i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i == size) &#123;</span><br><span class="line">                    <span class="comment">// 最后一个</span></span><br><span class="line">                    res.add(cur.val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v35"><a class="header-anchor" href="#解题思路2-v35"> </a>解题思路2</h3>
<p>本题也可以通过递归的方式，通过深度优先的搜索路径进行访问，以根-右-左的顺序，能够保证我们第一次访问下一层最右边的结点。同是记录是否为该层第一个被访问到的结点，这个判断条件根据答案列表的长度和我们维护的一个深度变量进行判断。</p>
<h3 id="解题代码2-v34"><a class="header-anchor" href="#解题代码2-v34"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 结果列表</span></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//dfs方法</span></span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 判断当前结点是否为该层第一个被访问的结点</span></span><br><span class="line">        <span class="keyword">if</span>(res.size() == depth) &#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right, depth+<span class="number">1</span>);</span><br><span class="line">        dfs(root.left, depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="222-完全二叉树的节点个数"><a class="header-anchor" href="#222-完全二叉树的节点个数"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h2>
<h3 id="题目-v108"><a class="header-anchor" href="#题目-v108"> </a>题目</h3>
<p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p>
<p>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p>
<blockquote>
<p>示例 1：<br>
输入：root = [1,2,3,4,5,6]<br>
输出：6</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：root = []<br>
输出：0</p>
</blockquote>
<blockquote>
<p>示例 3：<br>
输入：root = [1]<br>
输出：1</p>
</blockquote>
<blockquote>
<p>提示：<br>
树中节点的数目范围是[0, 5 * 104]<br>
0 &lt;= Node.val &lt;= 5 * 104<br>
题目数据保证输入的树是 完全二叉树</p>
</blockquote>
<p>进阶：遍历树来统计节点是一种时间复杂度为 O(n) 的简单解决方案。你可以设计一个更快的算法吗？</p>
<h3 id="解题思路一-v2"><a class="header-anchor" href="#解题思路一-v2"> </a>解题思路一</h3>
<p>对于任意的二叉树，都可以通过遍历一遍所有的结点来统计结点个数。遍历的方式通过深度优先、广度优先都可。</p>
<p>但是这样遍历的方式就没有利用到本题完全二叉树的性质</p>
<h3 id="解题代码一-v2"><a class="header-anchor" href="#解题代码一-v2"> </a>解题代码一</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        count++;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路二-v2"><a class="header-anchor" href="#解题思路二-v2"> </a>解题思路二</h3>
<p>详见注解</p>
<h3 id="解题代码二-v2"><a class="header-anchor" href="#解题代码二-v2"> </a>解题代码二</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 对于完全二叉树，对于一个根节点，我们可以统计其左右子树的深度。而对于这个深度的计算，我们计算其最左那一条路径的深度</span></span><br><span class="line">        <span class="comment">// 如果根节点的左右子树的深度相同，说明其左子树肯定为一棵满二叉树。因为其左子树的叶子结点的最右结点的下一个邻居节点就是右子树的叶子节点的最左结点</span></span><br><span class="line">        <span class="comment">// 但是我们不能保证右子树为满二叉树，因为我们只是知道其右子树的最左路径的深度，不知道往右偏的任意一条路径，因此还需要去计算。</span></span><br><span class="line">        <span class="comment">// 对于这种情况，计算方法为左子树的节点个数，加上根节点，加上右子树递归统计的个数。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果左右子树的深度不相同，这时候我们只能确定，左子树的深度比右子树多一。而左子树不一定是满二叉树，但是右子树一定是比左子树深度少一的满二叉树。</span></span><br><span class="line">        <span class="comment">// 因此这种情况的计算方法就是：右子树的结点个数，加上根节点，加上左子树递归统计的个数。</span></span><br><span class="line">        <span class="comment">// 对于满二叉树的结点个数计算方法为：假设深度为depth（从1开始）,那么其深度为( 1 &lt;&lt; depth ) - 1</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span>  getDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span>(left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; left) + countNodes(root.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; right) + countNodes(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="230-二叉搜索树中第K小的元素"><a class="header-anchor" href="#230-二叉搜索树中第K小的元素"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h2>
<h3 id="题目-v109"><a class="header-anchor" href="#题目-v109"> </a>题目</h3>
<p>给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。</p>
<blockquote>
<p>示例 1：<br>
输入：root = [3,1,4,null,2], k = 1<br>
输出：1</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：root = [5,3,6,2,4,null,null,1], k = 3<br>
输出：3</p>
</blockquote>
<blockquote>
<p>提示：<br>
树中的节点数为 n 。<br>
1 &lt;= k &lt;= n &lt;= 104<br>
0 &lt;= Node.val &lt;= 104</p>
</blockquote>
<p>进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？</p>
<h3 id="解题思路-v84"><a class="header-anchor" href="#解题思路-v84"> </a>解题思路</h3>
<p>由于这是一棵BST，那么根据中序遍历得到的是一个递增的序列，那么可以记录当前访问的是第几个数，当达到第K个数的时候返回即可。</p>
<h3 id="解题代码-v66"><a class="header-anchor" href="#解题代码-v66"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 左 中  右：中序遍历</span></span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == k) &#123;</span><br><span class="line">            res = root.val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 左 中  右：中序遍历</span></span><br><span class="line">        <span class="comment">// 迭代</span></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.offerLast(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = stack.pollLast();</span><br><span class="line">                <span class="comment">// 访问root</span></span><br><span class="line">                <span class="keyword">if</span>(--k == <span class="number">0</span>) <span class="keyword">return</span> root.val;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="236-二叉树的最近公共祖先"><a class="header-anchor" href="#236-二叉树的最近公共祖先"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h2>
<h3 id="题目-v110"><a class="header-anchor" href="#题目-v110"> </a>题目</h3>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<blockquote>
<p>示例 1：<br>
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>
输出：3<br>
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>
输出：5<br>
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</p>
</blockquote>
<blockquote>
<p>示例 3：<br>
输入：root = [1,2], p = 1, q = 2<br>
输出：1</p>
</blockquote>
<blockquote>
<p>提示：<br>
树中节点数目在范围 [2, 105] 内。<br>
-109 &lt;= Node.val &lt;= 109<br>
所有 Node.val 互不相同 。<br>
p != q<br>
p 和 q 均存在于给定的二叉树中。</p>
</blockquote>
<h3 id="解题思路-v85"><a class="header-anchor" href="#解题思路-v85"> </a>解题思路</h3>
<p>可以注意到，这就是一棵普通的二叉树，不是BST，因此不能够利用BST的性质来解决。对于普通的二叉树，我们从上到下进行递归。那么我们可以规定递归函数返回值为当前结点的最近公共祖先。要么返回null，要么返回p或者q。所以我们本质是递归去寻找q或者p，所以判断当前root是否为最近公共祖先，则要满足要么root==p要么root==q，要么p和q分别分布在该根节点的左右子树中。</p>
<h3 id="解题代码-v67"><a class="header-anchor" href="#解题代码-v67"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 判断当前结点是不是公共祖先</span></span><br><span class="line">        <span class="comment">// 首先如果root等于p或者q，那么root肯定是公共祖先</span></span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// 否则其公共祖先可能在左子树或者右子树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果left为空，说明公共祖先肯定是右子树中的公共祖先</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="comment">// 如果left和right都不为空，说明p和q分别在左右子树中，那么root就是公共祖先</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="337-打家劫舍-III"><a class="header-anchor" href="#337-打家劫舍-III"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-iii/">337. 打家劫舍 III</a></h2>
<h3 id="题目-v111"><a class="header-anchor" href="#题目-v111"> </a>题目</h3>
<p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。<br>
计算在不触动警报的情况下，小偷一晚能够盗取的最高金额</p>
<blockquote>
<p>示例 1:<br>
输入: [3,2,3,null,3,null,1]<br>
3<br>
/ <br>
2   3<br>
\   \<br>
3   1<br>
输出: 7<br>
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
输入: [3,4,5,1,3,null,1]<br>
3<br>
/ <br>
4   5<br>
/ \   \<br>
1   3   1<br>
输出: 9<br>
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.</p>
</blockquote>
<h3 id="解题思路-v86"><a class="header-anchor" href="#解题思路-v86"> </a>解题思路</h3>
<p>本题所要求的就是对于一棵二叉树中，选取一些节点，有两个要求，一是节点值和最大，二是节点间两两不相邻。</p>
<p>那么我们可以用递归的思想，对于当前节点root。如果要计算该节点所构成的最大值，有两种选择。第一种是选择加上root值，但是 这样就不能加上root的左右子树，但是可以考虑root的左右子树的子树。第二种选择是不选择加上root值，那么其值就是root左右子树之和所构成的值。通过这样去编写递归算法。</p>
<p>同时在递归的过程，为了避免重复计算某棵子树所能构成的最大值，所以用一个哈希表来保存结果。</p>
<h3 id="解题代码-v68"><a class="header-anchor" href="#解题代码-v68"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;TreeNode, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 用hashmap储存已经计算过的递归</span></span><br><span class="line">        <span class="keyword">return</span> dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 对于当前根节点有两种选择</span></span><br><span class="line">        <span class="comment">// 1 选择当前根节点，那么其左右子树都不能选</span></span><br><span class="line">        <span class="comment">// 2 不选择当前根节点，那么其值为左右子树之和</span></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(root)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(root);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> Math.max(root.val + (root.left==<span class="literal">null</span>?<span class="number">0</span>:dfs(root.left.left)+dfs(root.left.right)) + (root.right==<span class="literal">null</span>?<span class="number">0</span>:dfs(root.right.left)+dfs(root.right.right)), dfs(root.left)+dfs(root.right));</span><br><span class="line">            map.put(root, val);</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="437-路径总和-III"><a class="header-anchor" href="#437-路径总和-III"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a></h2>
<h3 id="题目-v112"><a class="header-anchor" href="#题目-v112"> </a>题目</h3>
<p>给定一个二叉树，它的每个结点都存放着一个整数值。<br>
找出路径和等于给定数值的路径总数。<br>
路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。<br>
二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p>
<blockquote>
<p>示例：<br>
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8<br>
10<br>
/  <br>
5   -3<br>
/ \    <br>
3   2   11<br>
/ \   <br>
3  -2   1<br>
返回 3。和等于 8 的路径有:</p>
</blockquote>
<ol>
<li>5 -&gt; 3</li>
<li>5 -&gt; 2 -&gt; 1</li>
<li>-3 -&gt; 11</li>
</ol>
<h3 id="解题思路-v87"><a class="header-anchor" href="#解题思路-v87"> </a>解题思路</h3>
<p>本题使用前缀和的方法去解决该题。</p>
<p>为什么使用前缀和呢？如果不用前缀和的方法去解决这题的话。比较直观的一个做法是加入从该节点开始，往下去遍历每个节点，看是否存在满足条件的路径和。接着再以此类推去寻找当前节点的左右孩子的路径和个数。但是这种方法去寻找会照成大量的重复遍历和重复计算。</p>
<p>而什么是前缀和：即根节点到当前节点的路径和。例如示例的树。</p>
<p>结点5的前缀和为：10-&gt;5：15</p>
<p>结点1的前缀和为：10-&gt;5-&gt;2-&gt;1：18</p>
<p>而前缀和的好处在于我们固定了每个结点的特性，而路径和与前缀和的关系在于我们可以通过两个结点的前缀和之差，来计算该两个结点的路径和。</p>
<p>因此我们通过去遍历树的过程中，计算当前结点的前缀和，同时与其祖先节点的前缀和进行比较，去查找是否有满足条件（有targetSum）的祖先的个数，同时也计算当前结点的左右孩子中，存在符合条件的路径个数，将其相加即得到结果。</p>
<p>同时在递归的过程中，需要我们通过哈希表去储存祖先前缀和的个数。因此在遍历完当前结点后，需要弹出当前结点的前缀和，因为当前节点不会再成为任何结点的祖先</p>
<h3 id="解题代码-v69"><a class="header-anchor" href="#解题代码-v69"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 储存某个节点的祖先节点中，key:祖先节点的前缀和， value：相同前缀和的个数</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="comment">// 前缀和方法去计算某段路径中之和等于targetSum</span></span><br><span class="line">        <span class="comment">// 前缀和：某个节点到根节点root的路径之和</span></span><br><span class="line">        <span class="comment">// 判断是否存在符合条件的路径：当前节点的前缀和：curSum。以及其某个祖先节点的前缀和preSum</span></span><br><span class="line">        <span class="comment">// 如果满足下列关系prevSum + targetSum = curSum，那么就存在一条路径。</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 注意要放入前缀和为0的值，才能够正确计算出到当前节点到根节点的路径和。</span></span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> recursivePathSum(root, <span class="number">0</span>, targetSum);   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">recursivePathSum</span><span class="params">(TreeNode root, <span class="type">int</span> prevSum, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 答案，即满足targetSum的路径的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> prevSum + root.val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算是否到当前节点，有满足targetSum的路径个数</span></span><br><span class="line">        <span class="comment">// 我们需要找其祖先节点中是否存在curSum - targetSum的个数</span></span><br><span class="line">        res += map.getOrDefault(curSum-targetSum, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前缀和等于curSum的个数</span></span><br><span class="line">        map.put(curSum, map.getOrDefault(curSum, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找其左右孩子是否也有路径</span></span><br><span class="line">        res += recursivePathSum(root.left, curSum, targetSum);</span><br><span class="line">        res += recursivePathSum(root.right, curSum, targetSum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前节点弹出，应为接下来不会遍历到当前节点的子孙节点</span></span><br><span class="line">        map.put(curSum, map.get(curSum)-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="449-序列化和反序列化二叉搜索树"><a class="header-anchor" href="#449-序列化和反序列化二叉搜索树"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/serialize-and-deserialize-bst/">449. 序列化和反序列化二叉搜索树</a></h2>
<h3 id="题目-v113"><a class="header-anchor" href="#题目-v113"> </a>题目</h3>
<p>序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。<br>
设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。<br>
编码的字符串应尽可能紧凑。</p>
<blockquote>
<p>示例 1：<br>
输入：root = [2,1,3]<br>
输出：[2,1,3]</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：root = []<br>
输出：[]</p>
</blockquote>
<p>提示：<br>
树中节点数范围是 [0, 104]<br>
0 &lt;= Node.val &lt;= 104<br>
题目数据 保证 输入的树是一棵二叉搜索树。<br>
注意：不要使用类成员/全局/静态变量来存储状态。 你的序列化和反序列化算法应该是无状态的。</p>
<h3 id="解题思路-v88"><a class="header-anchor" href="#解题思路-v88"> </a>解题思路</h3>
<p>本题的树是一棵二叉搜索树，可以通过后序遍历的方式，去储存该树。后序遍历的顺序为：左 右 中。那么我们反序列的时候，可以逆着读取，先读到的是根节点。接着去生成左右子树。而二叉搜索树的右子树的值都会比根节点大，左子树的值都会比根节点小，因此我们可以传入右子树的边界范围（最大值与根节点的最大值相同，最小值必须大于根节点），和左子树的边界范围（最大值必须小于根节点，最小值与根节点相同）</p>
<h3 id="解题代码-v70"><a class="header-anchor" href="#解题代码-v70"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在序列化的过程中 通过后序遍历（左 右 中）进行储存。</span></span><br><span class="line">    <span class="comment">// 在反序列化过程中， 将序列化的字符串出入栈中，再从后往前遍历，这样就是以 根 右 左的顺序。而如何知道边界条件是通过左子树的值都小于根节点，右子树的值都大于根节点，根据这个要限定条件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">// 后序遍历</span></span><br><span class="line">        postorder(root, builder);</span><br><span class="line">        <span class="keyword">if</span>(builder.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            builder.deleteCharAt(builder.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode root, StringBuilder builder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        postorder(root.left, builder);</span><br><span class="line">        postorder(root.right, builder);</span><br><span class="line">        builder.append(root.val);</span><br><span class="line">        builder.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(data == <span class="literal">null</span> || data.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数据分割开</span></span><br><span class="line">        ArrayDeque&lt;Integer&gt; vals = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String val : data.split(<span class="string">&quot;\\s+&quot;</span>)) &#123;</span><br><span class="line">            vals.add(Integer.parseInt(val));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行恢复</span></span><br><span class="line">        <span class="keyword">return</span> helper(Integer.MIN_VALUE, Integer.MAX_VALUE,vals);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">helper</span><span class="params">(<span class="type">int</span> lower, <span class="type">int</span> upper, ArrayDeque&lt;Integer&gt; vals)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(vals.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> vals.peekLast();</span><br><span class="line">        <span class="keyword">if</span>(val &gt; upper || val &lt; lower) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vals.removeLast();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        root.right = helper(val, upper, vals);</span><br><span class="line">        root.left = helper(lower, val, vals);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser = new Codec();</span></span><br><span class="line"><span class="comment">// Codec deser = new Codec();</span></span><br><span class="line"><span class="comment">// String tree = ser.serialize(root);</span></span><br><span class="line"><span class="comment">// TreeNode ans = deser.deserialize(tree);</span></span><br><span class="line"><span class="comment">// return ans;</span></span><br></pre></td></tr></table></figure>
<h2 id="450-删除二叉搜索树中的节点"><a class="header-anchor" href="#450-删除二叉搜索树中的节点"> </a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h2>
<h3 id="题目-v114"><a class="header-anchor" href="#题目-v114"> </a>题目</h3>
<p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<p>首先找到需要删除的节点；<br>
如果找到了，删除它。<br>
说明： 要求算法时间复杂度为 O(h)，h 为树的高度。</p>
<p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。<br>
一般来说，删除节点可分为两个步骤：<br>
首先找到需要删除的节点；<br>
如果找到了，删除它。<br>
说明： 要求算法时间复杂度为 O(h)，h 为树的高度。</p>
<blockquote>
<p>示例:<br>
root = [5,3,6,2,4,null,7]<br>
key = 3<br>
5<br>
/ <br>
3   6<br>
/ \   <br>
2   4   7<br>
给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。<br>
一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。<br>
5<br>
/ <br>
4   6<br>
/     <br>
2       7<br>
另一个正确答案是 [5,2,6,null,4,null,7]。<br>
5<br>
/ <br>
2   6<br>
\   <br>
4   7</p>
</blockquote>
<h3 id="解题思路-v89"><a class="header-anchor" href="#解题思路-v89"> </a>解题思路</h3>
<p>由于这是一棵BST，按中序遍历的顺序来讲，是递增序列。对于某个结点，在其递增序列中的相邻两个结点。分别是其左孩子的最右孩子。和其右孩子的最左孩子。所以我们如果要删除该节点，就可以将这两个相邻结点选择一个来替换。</p>
<p>同时在替换后，也需要删除其用来替换的孩子。而删除孩子的过程又可以看成一个删除结点的过程</p>
<h3 id="解题代码-v71"><a class="header-anchor" href="#解题代码-v71"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(key &gt; root.val) &#123;</span><br><span class="line">            root.right = deleteNode(root.right, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; root.val) &#123;</span><br><span class="line">            root.left = deleteNode(root.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 删除当前结点</span></span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 用后继结点来代替</span></span><br><span class="line">                root.val = successor(root);</span><br><span class="line">                <span class="comment">// 删除后继结点</span></span><br><span class="line">                root.right = deleteNode(root.right, root.val);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 用前继结点来代替</span></span><br><span class="line">                root.val = predecessor(root);</span><br><span class="line">                <span class="comment">// 删除前继结点</span></span><br><span class="line">                root.left = deleteNode(root.left, root.val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 被删除的结点为叶子结点</span></span><br><span class="line">                root = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前继结点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">predecessor</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        root = root.left;</span><br><span class="line">        <span class="keyword">while</span>(root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后继结点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">successor</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        root = root.right;</span><br><span class="line">        <span class="keyword">while</span>(root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/leetcode/" rel="tag"><i class="fa fa-tag"></i> leetcode</a>
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"><i class="fa fa-tag"></i> 算法</a>
              <a href="/tags/%E6%A0%91/" rel="tag"><i class="fa fa-tag"></i> 树</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/12/10/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%80%94%E5%B9%B6%E5%8F%91/" rel="prev" title="Java核心技术—并发">
                  <i class="fa fa-chevron-left"></i> Java核心技术—并发
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/12/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AC%94%E8%AE%B0/" rel="next" title="动态规划笔记">
                  动态规划笔记 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">闽ICP备2021001502号 </a>
      <img src="/images/%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" alt=""><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=35058202000501" rel="noopener" target="_blank">闽公网安备 35058202000501号 </a>
  </div>

<div class="copyright">
  &copy; 2020 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-seedling"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZQB</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">603k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">16:45</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/comments.js"></script><script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/utils.js"></script><script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/motion.js"></script><script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/next-boot.js"></script><script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/bookmark.js"></script>

  
<script src="https://unpkg.com/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/third-party/search/local-search.js"></script>



  <script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/third-party/fancybox.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://unpkg.com/mathjax@3.2.1/es5/tex-mml-chtml.js","integrity":"sha256-hlC2uSQYTmPsrzGZTEQEg9PZ1a/+SV6VBCTclohf2og="}}</script>
<script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://unpkg.com/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"qibinaoe","repo":"blog-comments","client_id":"157704bd238da130367f","client_secret":"b0bc6368a8d8c75ba5562dabf654a38242c9600f","admin_user":"qibinaoe","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://unpkg.com/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"3e5d0ac56729acdd87afb954046ce160"}</script>
<script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/third-party/comments/gitalk.js"></script>

</body>
</html>
