<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#f3a683"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-bin.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-bin.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-bin.png">
  <link rel="mask-icon" href="/images/logo-bin.svg" color="#f3a683">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"qibinaoe.top","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":true,"color":"#FF8B8B","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/config.js"></script>

    <meta name="description" content="本篇是对Java虚拟机相关知识学习时的笔记记录">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM学习笔记">
<meta property="og:url" content="http://qibinaoe.top/2021/02/27/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Qibin&#39;s Blog">
<meta property="og:description" content="本篇是对Java虚拟机相关知识学习时的笔记记录">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20210224172607852.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20210224172633197.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20210224172648428.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20210224172755648.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20210224172954069.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20210224200502394.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20210225152556418.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20210226154433917.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20210310104117233.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20210310105631304.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20210310110508258.png">
<meta property="og:image" content="http://algorithm-image.qibinaoe.top/image-20210310111050934.png">
<meta property="article:published_time" content="2021-02-27T12:31:33.000Z">
<meta property="article:modified_time" content="2022-06-08T05:23:30.655Z">
<meta property="article:author" content="ZQB">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="jvm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://algorithm-image.qibinaoe.top/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png">


<link rel="canonical" href="http://qibinaoe.top/2021/02/27/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://qibinaoe.top/2021/02/27/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","path":"2021/02/27/JVM学习笔记/","title":"JVM学习笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JVM学习笔记 | Qibin's Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Qibin's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">better and better</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook/" rel="section"><i class="fa fa-book fa-fw"></i>留言板</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86"><span class="nav-number">1.</span> <span class="nav-text">虚拟机的内存区域划分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">1.1.</span> <span class="nav-text">程序计数器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-number">1.2.</span> <span class="nav-text">Java虚拟机栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="nav-number">1.2.1.</span> <span class="nav-text">局部变量表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="nav-number">1.3.</span> <span class="nav-text">本地方法栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%A0%86"><span class="nav-number">1.4.</span> <span class="nav-text">Java堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">1.5.</span> <span class="nav-text">方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">1.5.1.</span> <span class="nav-text">运行时常量池</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="nav-number">1.6.</span> <span class="nav-text">直接内存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.</span> <span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA"><span class="nav-number">2.1.</span> <span class="nav-text">对象创建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">2.1.1.</span> <span class="nav-text">分配方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">指针碰撞</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">空闲列表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">2.1.2.</span> <span class="nav-text">并发安全问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.1.3.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.4.</span> <span class="nav-text">执行构造函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">2.2.</span> <span class="nav-text">对象内存布局</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="nav-number">2.2.1.</span> <span class="nav-text">对象头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE"><span class="nav-number">2.2.2.</span> <span class="nav-text">实例数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E9%BD%90%E5%A1%AB%E5%85%85"><span class="nav-number">2.2.3.</span> <span class="nav-text">对齐填充</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="nav-number">2.3.</span> <span class="nav-text">对象访问定位</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84"><span class="nav-number">2.3.1.</span> <span class="nav-text">使用句柄</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE"><span class="nav-number">2.3.2.</span> <span class="nav-text">直接访问</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OOM%E5%AE%9E%E6%88%98"><span class="nav-number">3.</span> <span class="nav-text">OOM实战</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%A0%86%E6%BA%A2%E5%87%BA"><span class="nav-number">3.1.</span> <span class="nav-text">Java堆溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E6%BA%A2%E5%87%BA"><span class="nav-number">3.2.</span> <span class="nav-text">虚拟机栈和本地方法栈溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%BA%A2%E5%87%BA"><span class="nav-number">3.3.</span> <span class="nav-text">方法区和运行时常量池溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E6%9C%BA%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-number">3.4.</span> <span class="nav-text">本机直接内存溢出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="nav-number">4.</span> <span class="nav-text">垃圾收集器与内存分配策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%AD%BB%E4%BA%A1"><span class="nav-number">4.1.</span> <span class="nav-text">判断对象是否死亡</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="nav-number">4.1.1.</span> <span class="nav-text">引用计数算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="nav-number">4.1.2.</span> <span class="nav-text">可达性分析算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%A6%82%E5%BF%B5"><span class="nav-number">4.1.3.</span> <span class="nav-text">引用概念</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%AD%BB%E4%BA%A1"><span class="nav-number">4.2.</span> <span class="nav-text">对象死亡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">4.3.</span> <span class="nav-text">回收方法区</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">垃圾收集算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA"><span class="nav-number">5.1.</span> <span class="nav-text">分代收集理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-number">5.2.</span> <span class="nav-text">标记-清除算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">5.3.</span> <span class="nav-text">标记-复制算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">5.3.1.</span> <span class="nav-text">优化标记复制算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="nav-number">5.4.</span> <span class="nav-text">标记-整理算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E6%88%98%EF%BC%9A%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="nav-number">6.</span> <span class="nav-text">实战：内存分配与回收策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%85%88%E5%9C%A8Eden%E5%88%86%E9%85%8D"><span class="nav-number">6.1.</span> <span class="nav-text">对象优先在Eden分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">6.2.</span> <span class="nav-text">大对象直接进入老年代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%BF%E6%9C%9F%E5%AD%98%E6%B4%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">6.3.</span> <span class="nav-text">长期存活的对象直接进入老年代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E5%B9%B4%E9%BE%84%E5%88%A4%E6%96%AD"><span class="nav-number">6.4.</span> <span class="nav-text">动态对象年龄判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="nav-number">6.5.</span> <span class="nav-text">空间分配担保</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">7.</span> <span class="nav-text">类文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">7.1.</span> <span class="nav-text">Class类文件的结构</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZQB"
      src="/images/me_avatar.png">
  <p class="site-author-name" itemprop="name">ZQB</p>
  <div class="site-description" itemprop="description">Better Me</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/qibinaoe" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;qibinaoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:780891896@qq.com" title="E-Mail → mailto:780891896@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://gagalab.tech/" title="https:&#x2F;&#x2F;gagalab.tech&#x2F;" rel="noopener" target="_blank">嘎嘎研究所</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://qibinaoe.top/2021/02/27/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me_avatar.png">
      <meta itemprop="name" content="ZQB">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qibin's Blog">
      <meta itemprop="description" content="Better Me">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="JVM学习笔记 | Qibin's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM学习笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-27 20:31:33" itemprop="dateCreated datePublished" datetime="2021-02-27T20:31:33+08:00">2021-02-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-08 13:23:30" itemprop="dateModified" datetime="2022-06-08T13:23:30+08:00">2022-06-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>21 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>学习资料</p>
<ul>
<li>深入理解java虚拟机——JVM高级特性与最佳实践</li>
</ul>
<!-- more -->
<h2 id="虚拟机的内存区域划分"><a class="header-anchor" href="#虚拟机的内存区域划分"> </a>虚拟机的内存区域划分</h2>
<p><img src="http://algorithm-image.qibinaoe.top/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" alt="Java虚拟机运行时数据区"></p>
<ul>
<li>各个区域有各自用途，创建和销毁的时间</li>
<li>有些区域随虚拟机进程的启动而一直存在</li>
<li>有些区域依赖用户线程和启动和结束而创建和销毁</li>
</ul>
<h3 id="程序计数器"><a class="header-anchor" href="#程序计数器"> </a>程序计数器</h3>
<p>程序计数器（Program Counter Register）</p>
<ul>
<li>较小内存空间</li>
<li>当前线程所执行的字节码指示器</li>
<li>是程序控制流的指示器
<ul>
<li>分支、循环、跳转、异常处理、线程恢复等基础功能依赖于程序计数器</li>
</ul>
</li>
<li>线程<strong>私有</strong>内存</li>
</ul>
<p>字节码解释器工作：</p>
<ul>
<li>通过改变程序计数器的数值，来选取下一条需要执行的字节码指令</li>
</ul>
<p>计数器的值记录的是正在执行<strong>虚拟机</strong>执行的指令的<strong>地址</strong>。如果执行的是本地（Native）方法，则计数器的值为空（Undefined）</p>
<blockquote>
<p>此内存区域是《Java虚拟机规范》中唯一一个没有规定任何OutOfMemoryError情况的区域</p>
</blockquote>
<h3 id="Java虚拟机栈"><a class="header-anchor" href="#Java虚拟机栈"> </a>Java虚拟机栈</h3>
<p>Java虚拟机栈（Java Virtual Machine Stack）</p>
<ul>
<li>线程<strong>私有</strong>内存
<ul>
<li>与线程的生命周期相同（随着线程启动而创建，结束而销毁）</li>
</ul>
</li>
<li>虚拟机栈描述的是Java<strong>方法执行</strong>的线<strong>程内存模型</strong>
<ul>
<li>Java虚拟机栈存放的是Java方法调用的产生的栈帧（Stack Frame）
<ul>
<li>栈帧存放的是：局部变量表、操作数栈、动态连接、方法出口等信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="局部变量表"><a class="header-anchor" href="#局部变量表"> </a>局部变量表</h4>
<ul>
<li>储存
<ul>
<li>java虚拟机的基本类型（boolean, byte, char, short, int, long, float, double）</li>
<li>对象引用（指向对象起始地址的引用指针，一个代表对象的句柄）</li>
<li><code>returnAddress</code>类型（指向一条字节码指令的地址）</li>
</ul>
</li>
<li>变量槽（slot）
<ul>
<li>long和double类型占2个变量槽，其他类型占1个变量槽</li>
</ul>
</li>
</ul>
<p>局部变量表的大小（所需的内存空间）在编译时期就确定分配了。</p>
<p>每个方法在栈帧中所需要的大小（局部变量的间）也完全确定，在运行时期不会改变局部变量表的大小</p>
<p>这里的大小指的是变量槽的数量，而一个变量槽所占有多大的内存空间，由虚拟机决定</p>
<blockquote>
<p>在虚拟机栈中，《Java虚拟机规范》规定两种内存区域异常状况</p>
<ol>
<li>线程请求的栈的深度大于虚拟机所允许的深度：StackOverflowError</li>
<li>如果虚拟机是可动态扩展的（Hotspot是不可动态扩展的），无法申请到足够的内存时候：OutOfMemoryError</li>
</ol>
</blockquote>
<h3 id="本地方法栈"><a class="header-anchor" href="#本地方法栈"> </a>本地方法栈</h3>
<p>本地方法栈（Native method stacks）</p>
<ul>
<li>本地方法栈是为虚拟机所调用到的本地（native）方法服务的</li>
</ul>
<p>虚拟机栈是为虚拟机执行java方法（字节码）服务的</p>
<blockquote>
<p>栈深度溢出：StackOverflowError</p>
<p>栈扩展失败：OutOfMemoryError</p>
</blockquote>
<h3 id="Java堆"><a class="header-anchor" href="#Java堆"> </a>Java堆</h3>
<ul>
<li>是所有线程<strong>共享</strong>的内存区域</li>
<li>存放的是Java<strong>对象实例</strong></li>
<li>是垃圾收集器管理的区域</li>
<li>内存空间：物理上可以是不连续的，但是逻辑上要是连续的</li>
</ul>
<blockquote>
<p>没有内存完成对象实例的分配，并且堆无法再扩展时：OutOfMemoryError</p>
</blockquote>
<h3 id="方法区"><a class="header-anchor" href="#方法区"> </a>方法区</h3>
<ul>
<li>线程共享的区域</li>
<li>储存已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译的代码缓存</li>
<li>又称为”非堆“（non-heap）</li>
<li>内存空间：物理上可以不是连续的，但是逻辑上要求连续</li>
<li>可以选择是否进行垃圾回收，这块区域的垃圾回收的目标是常量池的回收和类型的卸载</li>
</ul>
<blockquote>
<p>无法满足新的内存分配需求时，抛出OutOfMemoryError异常</p>
</blockquote>
<h4 id="运行时常量池"><a class="header-anchor" href="#运行时常量池"> </a>运行时常量池</h4>
<p>运行时常量池（Runtime Constant Pool）是方法区的一部分</p>
<p>常量池表（存放字面量和符号引用）的内容在类加载后存放在方法区的运行时常量池中</p>
<h3 id="直接内存"><a class="header-anchor" href="#直接内存"> </a>直接内存</h3>
<ul>
<li>直接内存（Direct Memory）不是虚拟机运行时的数据区域，也不是《Java虚拟机规范》中定义的内存区域</li>
</ul>
<p>Java中的<code>NIO(New Input/Output)</code>类：通过Native函数库直接分配堆外内存，通过java堆中的<code>DirectByteBuffer</code>对象作为这块内存的引用进行操作，避免了在Java堆和native堆中来回复制数据</p>
<ul>
<li>直接内存的大小不受java堆的限制，但是会受到本机总内存和处理器寻址空间的限制</li>
</ul>
<h2 id="对象"><a class="header-anchor" href="#对象"> </a>对象</h2>
<h3 id="对象创建"><a class="header-anchor" href="#对象创建"> </a>对象创建</h3>
<p>这里讨论的是通过<code>new</code>关键字（不包括通过复制、反序列方式）创建的Java普通对象（不包括数组、<code>Class</code>对象）</p>
<blockquote>
<p>Java编译器会在Java代码中的new关键字地方，对应的字节码生成两条指令</p>
<ol>
<li>new指令</li>
<li>invokespecial指令</li>
</ol>
</blockquote>
<p>Java虚拟机遇到字节码的new指令，会根据指令的参数，检查是否能在常量池中定位到一个类的符号引用，并检查符号引用代表的类是否能已经加载、解析和初始化。没有执行类加载过程。</p>
<p>类加载检查通过后，Java虚拟机为这个新生对象分配内存。内存的大小在类加载完成后可完全确定</p>
<h4 id="分配方式"><a class="header-anchor" href="#分配方式"> </a>分配方式</h4>
<p>分配内存的方式有两种</p>
<ol>
<li>指针碰撞（Bump the pointer）</li>
<li>空闲列表（free list）</li>
</ol>
<blockquote>
<p>选择的分配方式根据的是Java堆中的内存是否规整而决定的</p>
<p>Java堆的内存是否规整是根据所采用的垃圾收集器是否带有空间压缩整理（Compact）能力决定的</p>
</blockquote>
<h5 id="指针碰撞"><a class="header-anchor" href="#指针碰撞"> </a>指针碰撞</h5>
<p>如果Java堆中的内存是绝对规整的，使用<code>Serial</code>,<code>ParNew</code>等带有压缩整理过程的收集器</p>
<p>指针：已使用的内存和未使用的内存的分界点指示器</p>
<h5 id="空闲列表"><a class="header-anchor" href="#空闲列表"> </a>空闲列表</h5>
<p>Java堆中已被使用和空闲的内存交错</p>
<p>虚拟机维护一个记录哪些内存块是可用的列表</p>
<p>使用CMS这种基于清除（Sweep）算法的收集器时</p>
<h4 id="并发安全问题"><a class="header-anchor" href="#并发安全问题"> </a>并发安全问题</h4>
<p>两种可选方案</p>
<ol>
<li>分配内存空间上采用同步处理
<ul>
<li>采用CAS配上失败重试的方式保证更新操作的原子性</li>
</ul>
</li>
<li>本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）
<ul>
<li>哪个线程分配内存就在哪个线程的缓冲区分配，当本地缓冲区用完了而需要分配新的缓冲区时，采用同步锁定</li>
</ul>
</li>
</ol>
<blockquote>
<p>-XX:+/-UseTLAB</p>
</blockquote>
<h4 id="初始化"><a class="header-anchor" href="#初始化"> </a>初始化</h4>
<p>内存分配完成后，在分配到的内存空间（不包括对象头）进行初始化为零值。</p>
<blockquote>
<p>如果使用了TLAB，则初始化可提前到TLAB分配时进行</p>
</blockquote>
<p>保证java代码中的对象实例字段不赋初始值就可以直接使用</p>
<p>对象头（Object Header）设置，例如对象是哪个类的实例，如何找到类的元数据信息，对象的哈希码（实际在使用<code>hashcode</code>时才计算），GC分代年龄</p>
<h4 id="执行构造函数"><a class="header-anchor" href="#执行构造函数"> </a>执行构造函数</h4>
<p>执行<code>Class</code>文件中的<code>&lt;init&gt;()</code>方法使得对象的其他资源和状态信息按照预定的意图构造好</p>
<h3 id="对象内存布局"><a class="header-anchor" href="#对象内存布局"> </a>对象内存布局</h3>
<p>对象在堆内存的储存布局分为三部分</p>
<ol>
<li>对象头（Header）</li>
<li>实例数据（Instance Data）</li>
<li>对齐填充（Padding）</li>
</ol>
<h4 id="对象头"><a class="header-anchor" href="#对象头"> </a>对象头</h4>
<p>对象头分成两类信息</p>
<ol>
<li>储存对象自身运行时的数据（Mark Word）</li>
<li>对象的类型指针</li>
</ol>
<p>对于对象自身运行时的数据包括哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳。这部分数据的长度在32位和64位的虚拟机中分别位32比特和64比特（8字节的1倍或2倍）</p>
<p>Mark Word为动态定义的数据结构：根据对象的状态复用自己的储存空间</p>
<p>类型指针即对象指向它的元数据类型的指针：通过该指针来确定该对象是哪个类的实例</p>
<h4 id="实例数据"><a class="header-anchor" href="#实例数据"> </a>实例数据</h4>
<p>实例数据部分是对象真正存储的有效信息</p>
<p>包括父类继承和子类定义的字段</p>
<p>储存顺序：受虚拟机分配策略参数和字段在java源码中定义顺序影响</p>
<ul>
<li>相同宽度的字段总是被分配在存放
<ul>
<li>分配顺序为：longs/doubles, ints, shorts/chars, bytes/booleans, oops(Ordinary Object Pointers)</li>
</ul>
</li>
<li>父类定义变量出现在子类之前</li>
</ul>
<h4 id="对齐填充"><a class="header-anchor" href="#对齐填充"> </a>对齐填充</h4>
<p>占位符的作用，使对象在堆中的内存满足8字节的整数倍</p>
<blockquote>
<p>HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍</p>
</blockquote>
<h3 id="对象访问定位"><a class="header-anchor" href="#对象访问定位"> </a>对象访问定位</h3>
<p>Java栈上的reference数据来操作栈上的具体对象</p>
<p>主流的访问方式有两种</p>
<ol>
<li>使用句柄</li>
<li>直接访问</li>
</ol>
<h4 id="使用句柄"><a class="header-anchor" href="#使用句柄"> </a>使用句柄</h4>
<p>java堆上开辟一块内存作为句柄池。reference中储存对象的句柄地址。句柄中对象实例数据（Java堆中）和对象类型数据（方法区中）</p>
<p>优点：reference中储存的是稳定的句柄地址，在对象移动时，只需要修改句柄中的对象示例数据指针，不需要修改reference</p>
<p>缺点:间接访问的开销</p>
<h4 id="直接访问"><a class="header-anchor" href="#直接访问"> </a>直接访问</h4>
<p>reference储存的时对象地址</p>
<p>优点：速度快，不需要多一次间接访问的开销</p>
<h2 id="OOM实战"><a class="header-anchor" href="#OOM实战"> </a>OOM实战</h2>
<p><strong>Idea版本2020.3.2</strong></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210224172607852.png" alt="image-20210224172607852"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210224172633197.png" alt="image-20210224172633197"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210224172648428.png" alt="image-20210224172648428"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210224172755648.png" alt="image-20210224172755648"></p>
<h3 id="Java堆溢出"><a class="header-anchor" href="#Java堆溢出"> </a>Java堆溢出</h3>
<blockquote>
<p>-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> OOM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOOM</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OOMObject</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;OOMObject&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">OOMObject</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210224172954069.png" alt="image-20210224172954069"></p>
<h3 id="虚拟机栈和本地方法栈溢出"><a class="header-anchor" href="#虚拟机栈和本地方法栈溢出"> </a>虚拟机栈和本地方法栈溢出</h3>
<p>HotSpot不支持栈的动态扩展</p>
<p>使用<code>-Xss</code>参数减少栈内存容量</p>
<blockquote>
<p>-Xss128k</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> OOM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaVMStackSOF</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">stackLength</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stackLeak</span><span class="params">()</span> &#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        <span class="type">JavaVMStackSOF</span> <span class="variable">oom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavaVMStackSOF</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oom.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;stack Length:&quot;</span> + oom.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210224200502394.png" alt="image-20210224200502394"></p>
<h3 id="方法区和运行时常量池溢出"><a class="header-anchor" href="#方法区和运行时常量池溢出"> </a>方法区和运行时常量池溢出</h3>
<p>在JDK8中完全使用元空间来代替永久代</p>
<p><code>String::intern</code>作用时，如果字符串常量池中已经包含一个等于此字符串对象的字符串，则返回代表池中这个字符串的对象的引用，否则将此String对象包含的字符串添加到常量池中，并返回此String对象的引用</p>
<p>字符串常量池已经移到Java堆中，只需在常量池里记录首次出现的实例的引用</p>
<p>在Java8运行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> OOM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuntimeConstantPoolOOM</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;计算机&quot;</span>).append(<span class="string">&quot;软件&quot;</span>).toString();</span><br><span class="line">        System.out.println(str1.intern() == str1); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line">        System.out.println(str2.intern() == str2); <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>元空间</p>
<ul>
<li><code>-XX:MaxMetaspaceSize</code>：元空间的最大值，默认-1不受限制</li>
<li><code>-XX:MetaspaceSize</code>指定元空间的初始空间大小，字节为单位，达到该值会触发垃圾收集进行类型卸载</li>
<li><code>-XX:MinMetaspaceFreeRadio</code>：在垃圾收集之后，控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率</li>
<li><code>-XX:MaxMetaspaceFreeRadio</code>：用于控制最大的元空间剩余容量的百分比</li>
</ul>
<h3 id="本机直接内存溢出"><a class="header-anchor" href="#本机直接内存溢出"> </a>本机直接内存溢出</h3>
<p>直接内存（Direct Memory）的容量大小通过<code>-XX:MaxDirectMemorySize</code>来指定，默认与Java堆最大值（<code>-Xmx</code>）一致</p>
<blockquote>
<p>-Xms20M -XX:MaxDirectMemorySize=10M</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> OOM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectMemoryOOM</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">unsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        unsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) unsafeField.get(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210225152556418.png" alt="image-20210225152556418"></p>
<h2 id="垃圾收集器与内存分配策略"><a class="header-anchor" href="#垃圾收集器与内存分配策略"> </a>垃圾收集器与内存分配策略</h2>
<ul>
<li>程序计数器、虚拟机栈和本地方法栈三个区域随线程而生，随线程而灭。每个栈帧分配内存的大小在类结构确定时就已知。
<ul>
<li>对于这几个区域，在方法结束或线程结束时，内存自然就跟随着回收</li>
</ul>
</li>
</ul>
<p>Java堆和方法区具有不确定性：内存分配和回收是动态的</p>
<h3 id="判断对象是否死亡"><a class="header-anchor" href="#判断对象是否死亡"> </a>判断对象是否死亡</h3>
<p>即是否不存在任何途径使用对象</p>
<ol>
<li>引用计数算法：判断对象引用数量</li>
<li>可达性分析算法：判断对象是否引用链可达</li>
</ol>
<p>java采用的是可达性分析算法</p>
<h4 id="引用计数算法"><a class="header-anchor" href="#引用计数算法"> </a>引用计数算法</h4>
<p>引用计数器：有地方引用加一，引用失效减一。当引用计数器为零时，代表对象不可能再被使用</p>
<p>优点：虽然占用一些额外的内存空间，但原理简单，效率高</p>
<p>缺点：许多例外的情况要考虑：例如单纯的引用计数难以解决对象之间相互引用的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> OOM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] bigSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testGC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        objB = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="可达性分析算法"><a class="header-anchor" href="#可达性分析算法"> </a>可达性分析算法</h4>
<p>通过一系列称为&quot;GC Roots&quot;的根对象作为起始节点集，从”GC Roots“根据引用关系向下搜索。搜索过程的路径称为引用链。</p>
<p>如果某个对象到GC Roots间没有引用链，即不可达时，则该对象不可能再被使用</p>
<p><em>固定</em>可作为GC Roots对象包括</p>
<ul>
<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数，局部变量、临时变量等</li>
<li>在方法区中，类静态属性引用的对象，譬如Java类的引用类型静态变量</li>
<li>在方法区中，常量引用的对象，譬如字符串常量池里的引用</li>
<li>在本地方法栈中JNI（native方法）引用的对象</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（<code>NullPointException</code>，<code>OutOfMemoryError</code>）等，还有系统类加载器</li>
<li>所有被同步锁（<code>synchronized</code>关键字）持有的对象</li>
<li>反应Java虚拟机内部情况的JMXBean，JVMTI中注册的回调、本地代码缓存等</li>
</ul>
<p>除固定的GC Roots集合外，还有其他对象临时性加入</p>
<ul>
<li>譬如分代收集和局部回收</li>
</ul>
<h4 id="引用概念"><a class="header-anchor" href="#引用概念"> </a>引用概念</h4>
<ul>
<li>强引用（Strongly Reference）
<ul>
<li>引用赋值：<code>Object obj = new Object();</code>的引用关系。只要强引用关系存在，垃圾收集器永远不会回收被引用的对象</li>
</ul>
</li>
<li>软引用（Soft Reference）
<ul>
<li>描述的是有用，但非必须的对象</li>
<li>只被软引用的对象，在系统将要发生内存溢出异常前，会将这些对象列入回收范围进行第二次回收。如果这次回收后仍然没有足够内存，才抛出内存异常</li>
<li><code>SoftReference</code>类</li>
</ul>
</li>
<li>弱引用（Weak Reference）
<ul>
<li>描述的是非必须的对象</li>
<li>被弱引用关联的对象只能生存到下一次垃圾收集发生为止</li>
<li>无论内存是否足够，都会回收掉只被弱引用关联的对象</li>
<li><code>WeakReference</code>类</li>
</ul>
</li>
<li>虚引用（Phantom Reference）,又叫幽灵引用，幻影引用
<ul>
<li>虚引用是否存在，对其生命周期完全没有影响</li>
<li>无法通过虚引用来取得对象实例</li>
<li>唯一目的：为了能在该对象被回收时，能受到系统的通知</li>
<li><code>PhantomReference</code>类</li>
</ul>
</li>
</ul>
<h3 id="对象死亡"><a class="header-anchor" href="#对象死亡"> </a>对象死亡</h3>
<p>一个对象真正的死亡至少要经过两次标记过程。</p>
<p>如果一个对象进行可达性分析后，发现没有GC Roots引用链可达，会进行第一次标记。随后判断该对象是否有必要执行<code>finalize()</code>方法。</p>
<p>没有必要执行<code>finalize()</code>方法情况：</p>
<ul>
<li>没有覆盖finalize()方法</li>
<li>finalize方法已经被虚拟机调用过</li>
</ul>
<p>如果有必要调用<code>finalize</code>方法，那么该对象会放入<code>F-Queue</code>队列中，并且有虚拟机创建的Finalizer线程去执行队列中对象的<code>finalize()</code>方法。</p>
<p><code>finalize</code>方法在<code>Object</code>类中，当一个对象没有任何引用与之相关联的时候，垃圾收集器在垃圾回收时会调用该方法。同时这个方法最多只会调用一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>
<p><code>finalize</code>方法是对象能够逃离被回收的最后一次机会，如果在该方法内，该对象与引用链上的任何一个对象建立关联（将this赋给某个类变量或成员变量）则将移除被回收的集合。如果该对象在finalize方法执行后仍然与GC Roots没有建立连接，或者已经执行过finalize放了后又进入即将被回收的状态，则就真的被回收</p>
<p>finalize可以用来做关闭外部资源的清理工作，但是不推荐这样做，也不建议使用这个方法，而是将清理工作交给try-finally语句</p>
<p>演示代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> FinalizeTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadLocalRandom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeEscapeGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">FinalizeEscapeGC</span> <span class="variable">SAVE_HOOK</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">isAlive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我还活着&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行finalize方法&quot;</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> <span class="title class_">FinalizeEscapeGC</span>();</span><br><span class="line">        SAVE_HOOK = <span class="literal">null</span>; <span class="comment">// 不存在GC Roots 的引用链可达</span></span><br><span class="line">        System.gc(); <span class="comment">// 调用finalize，重新有引用链可达</span></span><br><span class="line">        <span class="comment">// 让主线程阻塞，使得Finalizer线程拿到时间片，进行执行finalize</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="literal">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我被回收了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SAVE_HOOK = <span class="literal">null</span>; <span class="comment">//再一次没有GC Roots引用链可达，</span></span><br><span class="line">        System.gc(); <span class="comment">// 因为finalize已经执行过一次了，不为执行第二次，因此该对象直接被回收</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="literal">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我被回收了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210226154433917.png" alt="image-20210226154433917"></p>
<h3 id="回收方法区"><a class="header-anchor" href="#回收方法区"> </a>回收方法区</h3>
<p>垃圾回收器主要回收的对象是Java堆（尤其是Java堆中的新生代）</p>
<p>而《Java虚拟机规范》不要求虚拟机再方法区中实现垃圾收集。</p>
<blockquote>
<p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常需要Java虚拟机具有类型卸载的能力，确保不会对方法区造成过大的内存压力</p>
</blockquote>
<p>方法区中回收两部分内容</p>
<ol>
<li>废弃的常量</li>
<li>不再使用的类型</li>
</ol>
<p>废弃的常量：没有任何地方引用到该常量池中的字面量</p>
<ul>
<li>例如&quot;java&quot;字符串常量，其他类（接口）方法、字段的符号引用</li>
</ul>
<p>不再使用的类型：应该满足下面三个条件，但是满足后也不一定会被回收</p>
<ol>
<li>该类的所有实例都被回收：Java堆中不存在该类及其任何派生子类的实例</li>
<li>加载该类的类加载器已经被回收</li>
<li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用：即无法在任何地方通过反射访问该类的方法</li>
</ol>
<blockquote>
<p>-Xnoclassgc参数进行控制</p>
</blockquote>
<h2 id="垃圾收集算法"><a class="header-anchor" href="#垃圾收集算法"> </a>垃圾收集算法</h2>
<p>垃圾收集算法划分为：</p>
<ul>
<li>引用计数式垃圾收集（reference counting gc）（直接垃圾收集）</li>
<li>追踪式垃圾收集（tracing gc）（间接垃圾收集）</li>
</ul>
<p>java虚拟机采用追踪式垃圾收集</p>
<h3 id="分代收集理论"><a class="header-anchor" href="#分代收集理论"> </a><strong>分代收集理论</strong></h3>
<ul>
<li>强分代假说（strong generational hypothesis）：经历越多次垃圾收集过程的对象越难以消灭</li>
<li>弱分代假说（weak generational hypothesis）：绝大多数的对象都是朝生夕灭的</li>
<li>跨代引用假说（intergenerational reference hypothesis）：跨代引用相对于同代引用仅占少数</li>
</ul>
<p>根据分代收集理论，将java堆依据对象的年龄划分成不同的区域</p>
<p>一般至少把java堆分为</p>
<ul>
<li>新生代（young generation）</li>
<li>老年代（old generation）</li>
</ul>
<p>记忆集（remembered set）：将老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用，当发生Minor GC时，只有包含跨代引用的小块内存对象会被加入到GC Roots中进行扫描</p>
<ul>
<li>部分收集（partial GC）
<ul>
<li>新生代收集（Minor GC/Young GC）：目标是新生代的垃圾收集</li>
<li>老年代收集（Major GC/ Old GC）：目标是老年代的垃圾收集</li>
<li>混合收集（Mixed GC）：目标是整个新生代以及部分老年代</li>
</ul>
</li>
<li>整堆收集（full gc）：整个JAVA堆和方法区的垃圾收集</li>
</ul>
<h3 id="标记-清除算法"><a class="header-anchor" href="#标记-清除算法"> </a>标记-清除算法</h3>
<p>分为两阶段</p>
<ul>
<li>标记</li>
<li>清除</li>
</ul>
<p>两种方式：</p>
<ul>
<li>标记需要回收的对象，同一回收所有被标记的对象</li>
<li>标记存活的对象，同一回收未被标记的对象</li>
</ul>
<p>缺点：</p>
<ul>
<li>两个过程的执行效率都随着对象的增加而降低</li>
<li>空间碎片化</li>
</ul>
<h3 id="标记-复制算法"><a class="header-anchor" href="#标记-复制算法"> </a>标记-复制算法</h3>
<p>半区复制：将内存分成大小相等的两部分，每次只使用其中一块。当需要进行垃圾回收时，将存活的对象复制到另一块空间，然后只进行一次清理。</p>
<p>缺点：</p>
<ul>
<li>如果大量对象存活，则产生大量复制的开销</li>
<li>浪费太多的空间</li>
</ul>
<h4 id="优化标记复制算法"><a class="header-anchor" href="#优化标记复制算法"> </a><strong>优化标记复制算法</strong></h4>
<p>对于新生代的内存布局：</p>
<p>分成一块Eden空间和两块Survivor空间（Eden和Survivor占比8:1），每次使用Eden和一块Survivor。垃圾收集时，将存活对象复制到Survivor中，一并清除Eden和使用过的Survivor。</p>
<p>如果Survivor空间不够，则通过分配担保的方式进入老年代</p>
<h3 id="标记-整理算法"><a class="header-anchor" href="#标记-整理算法"> </a>标记-整理算法</h3>
<p>主要针对老年代：</p>
<p>先对需要回收的对象进行标记，然后向内存空间一端移动，接着直接清理掉边界外的内存</p>
<p>标记-清除算法和标记-整理算法的差异在于前者是一种非移动式的回收算法，后者式移动式的。</p>
<p>缺点：移动存活对象必须更新引用这些对象的地方</p>
<p>移动内存则回收时复杂，不移动则分配时复杂.</p>
<h2 id="实战：内存分配与回收策略"><a class="header-anchor" href="#实战：内存分配与回收策略"> </a>实战：内存分配与回收策略</h2>
<p>自动内存管理解决两个问题</p>
<ol>
<li>自动给对象分配内存</li>
<li>自动回收分配给对象的内存</li>
</ol>
<p>对象的内存分配，概念上讲应该都是在堆上分配（实际上可能经过及时编译后被拆撒为标量类型并间接地在栈上分配）</p>
<p>在经典的分代设计下，新生对象通常会分配到新生代，少数情况下，（例如对象大小超过异地那个阈值），也可能会直接分配在老年代</p>
<h3 id="对象优先在Eden分配"><a class="header-anchor" href="#对象优先在Eden分配"> </a>对象优先在Eden分配</h3>
<p>大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机发起一次Minor GC</p>
<blockquote>
<p>-XX:+PrintGCDetails  收集器日志参数</p>
</blockquote>
<blockquote>
<p>-Xms20M -Xmx20M -Xmn10M 限制java堆大小为20M, 其中10M给新生代（Xmn），剩下10M给老年代</p>
</blockquote>
<blockquote>
<p>-XX:SurvivorRatio=8 新生代中Eden区和Survivor区空间比例8:1</p>
</blockquote>
<p>实验中，在分配<code>al4</code>,由于<code>Eden</code>空间已经不够了，所以通过分配担保机制，将<code>al1 al2  al3</code>提前转移到老年代</p>
<p>VM参数</p>
<blockquote>
<p>-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAllocation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] al1, al2, al3, al4;</span><br><span class="line">        al1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        al2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        al3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        al4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Test1.testAllocation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210310104117233.png" alt="image-20210310104117233"></p>
<h3 id="大对象直接进入老年代"><a class="header-anchor" href="#大对象直接进入老年代"> </a>大对象直接进入老年代</h3>
<p>大对象指需要大量连续内存空间的java对象，最典型的大对象是那种很长的字符串或者元素数量很庞大的数组</p>
<p>写程序应该避免大对象</p>
<ul>
<li>遇到一群朝生夕灭的短命大对象是个坏消息</li>
</ul>
<p>避免大对象原因</p>
<ul>
<li>内存明明还有不少空间时，就触发出发垃圾收集，以获取足够连续空间才能安置好</li>
<li>复制对象，高额的内存复制开销。从Eden空间复制到Survivor</li>
</ul>
<blockquote>
<p>-XX:PretenureSizeThreshold 指定大于该设置值的对象直接在老年代分配，避免在Eden区和Survivor区来回复制</p>
</blockquote>
<blockquote>
<p>-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=3145728</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPretenureSizeThreshold</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] allocation;</span><br><span class="line">    allocation = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210310105631304.png" alt="image-20210310105631304"></p>
<h3 id="长期存活的对象直接进入老年代"><a class="header-anchor" href="#长期存活的对象直接进入老年代"> </a>长期存活的对象直接进入老年代</h3>
<p>虚拟机给每个对象定义一个对象年龄计数器，储存在对象头</p>
<p>对象通常在Eden区诞生，如果经过一次Minor GC仍存活，并且能被Survivor区容纳，则会将该对象移动到Survivor区，并讲其对象年龄设为1岁。对象在Survivor区每熬过一次MinorGC，年龄就增加1岁，当年龄增加到一定程度（默认15）就会被晋升到老年代</p>
<blockquote>
<p>-XX:MaxTenuringThreshold 对象晋升老年代的年龄阈值</p>
</blockquote>
<blockquote>
<p>-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1 -XX:+PrintTenuringDistribution</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testTenuringThreshold</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] allocation1, allocation2, allocation3;</span><br><span class="line">    allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">    allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    allocation3 = <span class="literal">null</span>;</span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210310110508258.png" alt="image-20210310110508258"></p>
<h3 id="动态对象年龄判断"><a class="header-anchor" href="#动态对象年龄判断"> </a>动态对象年龄判断</h3>
<p>hotspot虚拟机不是永远要求对象的年龄必须达到<code>-XX:MaxTenuringThreshold</code>才能晋升老年代。当Survior区中相同年龄的对象大小之和大于Survivor区大小的一半，则大于等于该年龄的对象都会晋升到老年代</p>
<blockquote>
<p>-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1 -XX:+PrintTenuringDistribution</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testTenuringThreshold2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">    allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">    allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    allocation4 = <span class="literal">null</span>;</span><br><span class="line">    allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210310111050934.png" alt="image-20210310111050934"></p>
<h3 id="空间分配担保"><a class="header-anchor" href="#空间分配担保"> </a>空间分配担保</h3>
<p>在JDK6 Update24之前：</p>
<p>在发生Minor GC之前，虚拟机会先检查老年代的最大可用连续空间是否大于新生代所有对象的空间。</p>
<p>如果满足，则这一次Minor GC是安全的。</p>
<p>如果不满足，虚拟机先查看<code>-XX:HandlePromotionFailure</code>参数的设置值，是否允许担保失败</p>
<ul>
<li>如果允许，则继续检查老年代最大可用的连续空间是否大于历此晋升到老年代队先规定平均大小。
<ul>
<li>如果大于则尝试Minor GC，但这次Minor GC是有风险的</li>
<li>如果小于则改为Full GC</li>
</ul>
</li>
<li>如果不允许，则进行Full GC</li>
</ul>
<p>在JDK6 Update24之后：</p>
<p><code>-XX:HandlePromotionFailure</code>参数不会影响到虚拟机的空间分配担保策略</p>
<p>只要老年代的可用连续空间大于新生代对象总大小或者历此晋升的平均大小，则进行Minor GC，否则进行Full GC</p>
<h2 id="类文件结构"><a class="header-anchor" href="#类文件结构"> </a>类文件结构</h2>
<ul>
<li>字节码指令所能提供的语言描述能力必须比Java语言本身更加强大</li>
</ul>
<h3 id="Class类文件的结构"><a class="header-anchor" href="#Class类文件的结构"> </a>Class类文件的结构</h3>
<ul>
<li>
<p>Class文件结构稳定</p>
</li>
<li>
<p>Class文件是一组以<em>8个字节</em>为基础单位的二进制流，各个<strong>数据项目</strong>严格<strong>按照顺序</strong>紧凑排列在文件中，中间<strong>没有</strong>添加<strong>任何分隔符</strong></p>
<ul>
<li>当遇到需要占用8个字节以上空间的数据时，按照**高位在前（Big-Endian，高位字节在地址低位，低位字节在地址高位）**的方式分割成若干个8个字节</li>
</ul>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
              <a href="/tags/jvm/" rel="tag"><i class="fa fa-tag"></i> jvm</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/02/26/%E4%B8%A4%E6%95%B0%E4%BA%A4%E6%8D%A2/" rel="prev" title="两数交换">
                  <i class="fa fa-chevron-left"></i> 两数交换
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/03/08/%E6%8E%92%E5%BA%8F/" rel="next" title="排序">
                  排序 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">闽ICP备2021001502号 </a>
      <img src="/images/%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" alt=""><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=35058202000501" rel="noopener" target="_blank">闽公网安备 35058202000501号 </a>
  </div>

<div class="copyright">
  &copy; 2020 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-seedling"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZQB</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">603k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">16:45</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/comments.js"></script><script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/utils.js"></script><script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/motion.js"></script><script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/next-boot.js"></script><script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/bookmark.js"></script>

  
<script src="https://unpkg.com/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/third-party/search/local-search.js"></script>



  <script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/third-party/fancybox.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://unpkg.com/mathjax@3.2.1/es5/tex-mml-chtml.js","integrity":"sha256-hlC2uSQYTmPsrzGZTEQEg9PZ1a/+SV6VBCTclohf2og="}}</script>
<script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://unpkg.com/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"qibinaoe","repo":"blog-comments","client_id":"157704bd238da130367f","client_secret":"b0bc6368a8d8c75ba5562dabf654a38242c9600f","admin_user":"qibinaoe","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://unpkg.com/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"2faadfddcfa3d497b058430dadb7508f"}</script>
<script src="https://unpkg.com/hexo-theme-next@8.12.1/source/js/third-party/comments/gitalk.js"></script>

</body>
</html>
