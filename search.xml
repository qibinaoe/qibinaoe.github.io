<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JAVA核心技术-概述</title>
    <url>/2020/10/06/JAVA%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="基础知识"><a class="header-anchor" href="#基础知识"> </a>基础知识</h2>
<h3 id="关键术语"><a class="header-anchor" href="#关键术语"> </a>关键术语</h3>
<ol>
<li>
<p>简单性</p>
 <!-- more -->
<p>Java语法是C++语法的纯净版，没有头文件、指针运算（指针语法）、结构、联合、操作符重载、虚基类等。</p>
</li>
<li>
<p>面向对象</p>
<p>Java与C++的主要不同在于多重继承。Java取而代之的是更简单的接口概念</p>
</li>
<li>
<p>分布式</p>
<p>能够处理HTTP/FTP之类的TCP/IP协议</p>
</li>
<li>
<p>健壮性</p>
<p>Java强调早期的问题检测、后期动态的(运行时)检测。Java采用的指针模型可以消除重写内存和损坏数据的可能性，</p>
</li>
<li>
<p>安全性</p>
<p>防范攻击：</p>
<ul>
<li>运行时堆栈溢出</li>
<li>破坏自己的进程空间之外的内存</li>
<li>未经授权读写文件</li>
<li>体系结构中立</li>
</ul>
</li>
<li>
<p>体系结构中立</p>
<p>编译器生成一个体系结构中立的目标文件格式，这些编译后的代码可以在许多处理器上运行。Java编译器生成与计算机体系结构无关的字节码指令，同时还可以动态地转换成本地机器代码。</p>
</li>
<li>
<p>可移植性</p>
<ul>
<li>基本数据类型大小以及有关运算行为都有明确的说明(数值类型有固定的字节数，消除代码移植问题)</li>
<li>二进制数据以固定的格式进行存储和传输(消除字节顺序的困扰) <strong>Java都是高字节开头（大端法）</strong></li>
<li>字符串采用标准的Unicode格式存储</li>
</ul>
<p><em><strong>注：有符号的最高位为符号位</strong></em></p>
<p><em><strong>注: 采用补码表示负数的时候， 1 1111111 表示-1 ；1 0000000 表示 -128， 所以byte的最小值是-128</strong></em></p>
<h4 id="内置数据类型"><a class="header-anchor" href="#内置数据类型"> </a>内置数据类型</h4>
<p>byte</p>
<table>
<thead>
<tr>
<th style="text-align:center">位数</th>
<th style="text-align:center">最大值</th>
<th style="text-align:center">最小值</th>
<th style="text-align:center">默认值</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">127 (2<sup>7</sup>-1)</td>
<td style="text-align:center">-128 ( -2<sup>7</sup>)</td>
<td style="text-align:center">0</td>
<td style="text-align:center">有符号的，以二进制补码表示的整数</td>
</tr>
</tbody>
</table>
<p>short</p>
<table>
<thead>
<tr>
<th style="text-align:center">位数</th>
<th style="text-align:center">最大值</th>
<th style="text-align:center">最小值</th>
<th style="text-align:center">默认值</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">32767 (2<sup>15</sup>-1)</td>
<td style="text-align:center">-32768 ( -2<sup>15</sup>)</td>
<td style="text-align:center">0</td>
<td style="text-align:center">有符号的，以二进制补码表示的整数</td>
</tr>
</tbody>
</table>
<p>int</p>
<table>
<thead>
<tr>
<th style="text-align:center">位数</th>
<th style="text-align:center">最大值</th>
<th style="text-align:center">最小值</th>
<th style="text-align:center">默认值</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">32</td>
<td style="text-align:center">2147483647 (2<sup>31</sup>-1)</td>
<td style="text-align:center">-2147483648 ( -2<sup>31</sup>)</td>
<td style="text-align:center">0</td>
<td style="text-align:center">有符号的，以二进制补码表示的整数</td>
</tr>
</tbody>
</table>
<p>long</p>
<table>
<thead>
<tr>
<th style="text-align:center">位数</th>
<th style="text-align:center">最大值</th>
<th style="text-align:center">最小值</th>
<th style="text-align:center">默认值</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">64</td>
<td style="text-align:center">2<sup>63</sup>-1</td>
<td style="text-align:center">-2<sup>63</sup></td>
<td style="text-align:center">0L</td>
<td style="text-align:center">有符号的，以二进制补码表示的整数</td>
</tr>
</tbody>
</table>
<p>float</p>
<table>
<thead>
<tr>
<th style="text-align:center">位数</th>
<th style="text-align:center">默认值</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">32</td>
<td style="text-align:center">0.0f</td>
<td style="text-align:center">单精度、符合IEEE 754标准的浮点数</td>
</tr>
</tbody>
</table>
<p>double</p>
<table>
<thead>
<tr>
<th style="text-align:center">位数</th>
<th style="text-align:center">默认值</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">64</td>
<td style="text-align:center">0.0d</td>
<td style="text-align:center">双精度、符合IEEE 754标准的浮点数</td>
</tr>
</tbody>
</table>
<p>boolean</p>
<table>
<thead>
<tr>
<th style="text-align:center">位数</th>
<th style="text-align:center">取值</th>
<th style="text-align:center">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">true 和 false</td>
<td style="text-align:center">false</td>
</tr>
</tbody>
</table>
<p>基本数据类型参考资料<a href="https://www.runoob.com/java/java-basic-datatypes.html">菜鸟教程</a></p>
<h4 id="Unicode"><a class="header-anchor" href="#Unicode"> </a>Unicode</h4>
<p>Unicode是字符集。而UTF-8、UTF-16、utf-32是编码规则。<br>
Unicode的每一个字符叫做码点(Code Point、码位)<br>
UTF-8的意思是以8位为一个编码单位的可变编码，将码位编码成1到 4个字节（参考<a href="https://www.zhihu.com/question/23374078">知乎</a>）<br>
即UTF-8的编码规则是有一定规律的，</p>
<table>
<thead>
<tr>
<th>Unicode 十六进制码点范围</th>
<th>UTF-8 二进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000 0000 - 0000 007F</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>0000 0080 - 0000 07FF</td>
<td>10xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0000 0800 - 0000 FFFF</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0001 0000 - 0010 FFFF</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>因此先将一个字符对应的Unicode的码位转成16进制，看它的码点落在哪个区间内，然后将其套用右边的模板，将该字符转换成2进制，然后从低位开始对应着填进去，如果填完后，还有没有填的X就补零。</td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>解释型</p>
<p>Java解释器可以在任何移植了解释器的机器上直接执行Java字节码。</p>
</li>
<li>
<p>高性能</p>
<p>字节码可以在运行时动态地转换成对应运行这个应用的特定CPU机器码。同时即时编译器可以监控哪些代码频繁执行并优化，同时更为复杂的优化是消除函数调用（内联）</p>
</li>
<li>
<p>多线程</p>
</li>
<li>
<p>动态性</p>
</li>
</ol>
<h3 id="GPL-General-Public-License-GNU-GPL"><a class="header-anchor" href="#GPL-General-Public-License-GNU-GPL"> </a>GPL(General Public License)(GNU GPL)</h3>
<p>(调侃成为copyleft)<br>
公共通用许可证,此许可证允许用户更改和共享程序的所有版本。<br>
保证自由软件对所有用户都是自由的。<br>
即用户使用更改遵守GPL协议的软件时候，再次发布也应该遵守GPL协议。</p>
<h3 id="JDK和JRE"><a class="header-anchor" href="#JDK和JRE"> </a>JDK和JRE</h3>
<ul>
<li>JDK(Java Development Kit)Java开发工具包 ：编写Java程序的程序员使用的软件</li>
<li>JRE(Java Runtime Environment)Java运行时环境：运行Java程序的用户使用的软件</li>
<li>SDK(Software Development Kit)软件开发工具包 ：一个过时的术语，用来描述1998~2006年之间的JDK</li>
</ul>
<p>如果不开发，只运行Java程序，则只需要安装JRE。</p>
<p>JDK包括了JRE,Java工具(javac/java/jdb)和Java基础类库(Java API)</p>
<p>JRE包括JVM(Java Virtual Machine)和Java核心类库</p>
<p>跳出Java来讲，SDK是辅助开发某一类软件的相关文档、范例和工具的集合，而联通SDK的接口叫做API。</p>
<hr>
<h3 id="javac-和-java"><a class="header-anchor" href="#javac-和-java"> </a>javac 和 java</h3>
<ul>
<li><code>javac</code> 是编译命令，可以将<code>.java</code>文件编译成<code>.class</code>字节码文件</li>
</ul>
<p><code>Hello.java</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Hello&#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		System.out.println(&quot;Hello World&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>javac Hello.java</code></p>
<ul>
<li><code>java Hello</code> 用于运行字节码文件，通过JVM进行解释运行</li>
</ul>
<h2 id="参考"><a class="header-anchor" href="#参考"> </a><a href="https://blog.csdn.net/peng86788/article/details/81296882">参考</a></h2>
<h1 id="提醒需要复习复习内容"><a class="header-anchor" href="#提醒需要复习复习内容"> </a>提醒需要复习复习内容</h1>
<ul>
<li><em><strong>二进制的原码 补码 反码</strong></em></li>
<li><em><strong>IEEE 754</strong></em></li>
<li><em><strong>大端法、小端法</strong></em></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java核心技术</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM学习笔记</title>
    <url>/2021/02/27/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>学习资料</p>
<ul>
<li>深入理解java虚拟机——JVM高级特性与最佳实践</li>
</ul>
<!-- more -->
<h2 id="虚拟机的内存区域划分"><a class="header-anchor" href="#虚拟机的内存区域划分"> </a>虚拟机的内存区域划分</h2>
<p><img src="http://algorithm-image.qibinaoe.top/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" alt="Java虚拟机运行时数据区"></p>
<ul>
<li>各个区域有各自用途，创建和销毁的时间</li>
<li>有些区域随虚拟机进程的启动而一直存在</li>
<li>有些区域依赖用户线程和启动和结束而创建和销毁</li>
</ul>
<h3 id="程序计数器"><a class="header-anchor" href="#程序计数器"> </a>程序计数器</h3>
<p>程序计数器（Program Counter Register）</p>
<ul>
<li>较小内存空间</li>
<li>当前线程所执行的字节码指示器</li>
<li>是程序控制流的指示器
<ul>
<li>分支、循环、跳转、异常处理、线程恢复等基础功能依赖于程序计数器</li>
</ul>
</li>
<li>线程<strong>私有</strong>内存</li>
</ul>
<p>字节码解释器工作：</p>
<ul>
<li>通过改变程序计数器的数值，来选取下一条需要执行的字节码指令</li>
</ul>
<p>计数器的值记录的是正在执行<strong>虚拟机</strong>执行的指令的<strong>地址</strong>。如果执行的是本地（Native）方法，则计数器的值为空（Undefined）</p>
<blockquote>
<p>此内存区域是《Java虚拟机规范》中唯一一个没有规定任何OutOfMemoryError情况的区域</p>
</blockquote>
<h3 id="Java虚拟机栈"><a class="header-anchor" href="#Java虚拟机栈"> </a>Java虚拟机栈</h3>
<p>Java虚拟机栈（Java Virtual Machine Stack）</p>
<ul>
<li>线程<strong>私有</strong>内存
<ul>
<li>与线程的生命周期相同（随着线程启动而创建，结束而销毁）</li>
</ul>
</li>
<li>虚拟机栈描述的是Java<strong>方法执行</strong>的线<strong>程内存模型</strong>
<ul>
<li>Java虚拟机栈存放的是Java方法调用的产生的栈帧（Stack Frame）
<ul>
<li>栈帧存放的是：局部变量表、操作数栈、动态连接、方法出口等信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="局部变量表"><a class="header-anchor" href="#局部变量表"> </a>局部变量表</h4>
<ul>
<li>储存
<ul>
<li>java虚拟机的基本类型（boolean, byte, char, short, int, long, float, double）</li>
<li>对象引用（指向对象起始地址的引用指针，一个代表对象的句柄）</li>
<li><code>returnAddress</code>类型（指向一条字节码指令的地址）</li>
</ul>
</li>
<li>变量槽（slot）
<ul>
<li>long和double类型占2个变量槽，其他类型占1个变量槽</li>
</ul>
</li>
</ul>
<p>局部变量表的大小（所需的内存空间）在编译时期就确定分配了。</p>
<p>每个方法在栈帧中所需要的大小（局部变量的间）也完全确定，在运行时期不会改变局部变量表的大小</p>
<p>这里的大小指的是变量槽的数量，而一个变量槽所占有多大的内存空间，由虚拟机决定</p>
<blockquote>
<p>在虚拟机栈中，《Java虚拟机规范》规定两种内存区域异常状况</p>
<ol>
<li>线程请求的栈的深度大于虚拟机所允许的深度：StackOverflowError</li>
<li>如果虚拟机是可动态扩展的（Hotspot是不可动态扩展的），无法申请到足够的内存时候：OutOfMemoryError</li>
</ol>
</blockquote>
<h3 id="本地方法栈"><a class="header-anchor" href="#本地方法栈"> </a>本地方法栈</h3>
<p>本地方法栈（Native method stacks）</p>
<ul>
<li>本地方法栈是为虚拟机所调用到的本地（native）方法服务的</li>
</ul>
<p>虚拟机栈是为虚拟机执行java方法（字节码）服务的</p>
<blockquote>
<p>栈深度溢出：StackOverflowError</p>
<p>栈扩展失败：OutOfMemoryError</p>
</blockquote>
<h3 id="Java堆"><a class="header-anchor" href="#Java堆"> </a>Java堆</h3>
<ul>
<li>是所有线程<strong>共享</strong>的内存区域</li>
<li>存放的是Java<strong>对象实例</strong></li>
<li>是垃圾收集器管理的区域</li>
<li>内存空间：物理上可以是不连续的，但是逻辑上要是连续的</li>
</ul>
<blockquote>
<p>没有内存完成对象实例的分配，并且堆无法再扩展时：OutOfMemoryError</p>
</blockquote>
<h3 id="方法区"><a class="header-anchor" href="#方法区"> </a>方法区</h3>
<ul>
<li>线程共享的区域</li>
<li>储存已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译的代码缓存</li>
<li>又称为”非堆“（non-heap）</li>
<li>内存空间：物理上可以不是连续的，但是逻辑上要求连续</li>
<li>可以选择是否进行垃圾回收，这块区域的垃圾回收的目标是常量池的回收和类型的卸载</li>
</ul>
<blockquote>
<p>无法满足新的内存分配需求时，抛出OutOfMemoryError异常</p>
</blockquote>
<h4 id="运行时常量池"><a class="header-anchor" href="#运行时常量池"> </a>运行时常量池</h4>
<p>运行时常量池（Runtime Constant Pool）是方法区的一部分</p>
<p>常量池表（存放字面量和符号引用）的内容在类加载后存放在方法区的运行时常量池中</p>
<h3 id="直接内存"><a class="header-anchor" href="#直接内存"> </a>直接内存</h3>
<ul>
<li>直接内存（Direct Memory）不是虚拟机运行时的数据区域，也不是《Java虚拟机规范》中定义的内存区域</li>
</ul>
<p>Java中的<code>NIO(New Input/Output)</code>类：通过Native函数库直接分配堆外内存，通过java堆中的<code>DirectByteBuffer</code>对象作为这块内存的引用进行操作，避免了在Java堆和native堆中来回复制数据</p>
<ul>
<li>直接内存的大小不受java堆的限制，但是会受到本机总内存和处理器寻址空间的限制</li>
</ul>
<h2 id="对象"><a class="header-anchor" href="#对象"> </a>对象</h2>
<h3 id="对象创建"><a class="header-anchor" href="#对象创建"> </a>对象创建</h3>
<p>这里讨论的是通过<code>new</code>关键字（不包括通过复制、反序列方式）创建的Java普通对象（不包括数组、<code>Class</code>对象）</p>
<blockquote>
<p>Java编译器会在Java代码中的new关键字地方，对应的字节码生成两条指令</p>
<ol>
<li>new指令</li>
<li>invokespecial指令</li>
</ol>
</blockquote>
<p>Java虚拟机遇到字节码的new指令，会根据指令的参数，检查是否能在常量池中定位到一个类的符号引用，并检查符号引用代表的类是否能已经加载、解析和初始化。没有执行类加载过程。</p>
<p>类加载检查通过后，Java虚拟机为这个新生对象分配内存。内存的大小在类加载完成后可完全确定</p>
<h4 id="分配方式"><a class="header-anchor" href="#分配方式"> </a>分配方式</h4>
<p>分配内存的方式有两种</p>
<ol>
<li>指针碰撞（Bump the pointer）</li>
<li>空闲列表（free list）</li>
</ol>
<blockquote>
<p>选择的分配方式根据的是Java堆中的内存是否规整而决定的</p>
<p>Java堆的内存是否规整是根据所采用的垃圾收集器是否带有空间压缩整理（Compact）能力决定的</p>
</blockquote>
<h5 id="指针碰撞"><a class="header-anchor" href="#指针碰撞"> </a>指针碰撞</h5>
<p>如果Java堆中的内存是绝对规整的，使用<code>Serial</code>,<code>ParNew</code>等带有压缩整理过程的收集器</p>
<p>指针：已使用的内存和未使用的内存的分界点指示器</p>
<h5 id="空闲列表"><a class="header-anchor" href="#空闲列表"> </a>空闲列表</h5>
<p>Java堆中已被使用和空闲的内存交错</p>
<p>虚拟机维护一个记录哪些内存块是可用的列表</p>
<p>使用CMS这种基于清除（Sweep）算法的收集器时</p>
<h4 id="并发安全问题"><a class="header-anchor" href="#并发安全问题"> </a>并发安全问题</h4>
<p>两种可选方案</p>
<ol>
<li>分配内存空间上采用同步处理
<ul>
<li>采用CAS配上失败重试的方式保证更新操作的原子性</li>
</ul>
</li>
<li>本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）
<ul>
<li>哪个线程分配内存就在哪个线程的缓冲区分配，当本地缓冲区用完了而需要分配新的缓冲区时，采用同步锁定</li>
</ul>
</li>
</ol>
<blockquote>
<p>-XX:+/-UseTLAB</p>
</blockquote>
<h4 id="初始化"><a class="header-anchor" href="#初始化"> </a>初始化</h4>
<p>内存分配完成后，在分配到的内存空间（不包括对象头）进行初始化为零值。</p>
<blockquote>
<p>如果使用了TLAB，则初始化可提前到TLAB分配时进行</p>
</blockquote>
<p>保证java代码中的对象实例字段不赋初始值就可以直接使用</p>
<p>对象头（Object Header）设置，例如对象是哪个类的实例，如何找到类的元数据信息，对象的哈希码（实际在使用<code>hashcode</code>时才计算），GC分代年龄</p>
<h4 id="执行构造函数"><a class="header-anchor" href="#执行构造函数"> </a>执行构造函数</h4>
<p>执行<code>Class</code>文件中的<code>&lt;init&gt;()</code>方法使得对象的其他资源和状态信息按照预定的意图构造好</p>
<h3 id="对象内存布局"><a class="header-anchor" href="#对象内存布局"> </a>对象内存布局</h3>
<p>对象在堆内存的储存布局分为三部分</p>
<ol>
<li>对象头（Header）</li>
<li>实例数据（Instance Data）</li>
<li>对齐填充（Padding）</li>
</ol>
<h4 id="对象头"><a class="header-anchor" href="#对象头"> </a>对象头</h4>
<p>对象头分成两类信息</p>
<ol>
<li>储存对象自身运行时的数据（Mark Word）</li>
<li>对象的类型指针</li>
</ol>
<p>对于对象自身运行时的数据包括哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳。这部分数据的长度在32位和64位的虚拟机中分别位32比特和64比特（8字节的1倍或2倍）</p>
<p>Mark Word为动态定义的数据结构：根据对象的状态复用自己的储存空间</p>
<p>类型指针即对象指向它的元数据类型的指针：通过该指针来确定该对象是哪个类的实例</p>
<h4 id="实例数据"><a class="header-anchor" href="#实例数据"> </a>实例数据</h4>
<p>实例数据部分是对象真正存储的有效信息</p>
<p>包括父类继承和子类定义的字段</p>
<p>储存顺序：受虚拟机分配策略参数和字段在java源码中定义顺序影响</p>
<ul>
<li>相同宽度的字段总是被分配在存放
<ul>
<li>分配顺序为：longs/doubles, ints, shorts/chars, bytes/booleans, oops(Ordinary Object Pointers)</li>
</ul>
</li>
<li>父类定义变量出现在子类之前</li>
</ul>
<h4 id="对齐填充"><a class="header-anchor" href="#对齐填充"> </a>对齐填充</h4>
<p>占位符的作用，使对象在堆中的内存满足8字节的整数倍</p>
<blockquote>
<p>HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍</p>
</blockquote>
<h3 id="对象访问定位"><a class="header-anchor" href="#对象访问定位"> </a>对象访问定位</h3>
<p>Java栈上的reference数据来操作栈上的具体对象</p>
<p>主流的访问方式有两种</p>
<ol>
<li>使用句柄</li>
<li>直接访问</li>
</ol>
<h4 id="使用句柄"><a class="header-anchor" href="#使用句柄"> </a>使用句柄</h4>
<p>java堆上开辟一块内存作为句柄池。reference中储存对象的句柄地址。句柄中对象实例数据（Java堆中）和对象类型数据（方法区中）</p>
<p>优点：reference中储存的是稳定的句柄地址，在对象移动时，只需要修改句柄中的对象示例数据指针，不需要修改reference</p>
<p>缺点:间接访问的开销</p>
<h4 id="直接访问"><a class="header-anchor" href="#直接访问"> </a>直接访问</h4>
<p>reference储存的时对象地址</p>
<p>优点：速度快，不需要多一次间接访问的开销</p>
<h2 id="OOM实战"><a class="header-anchor" href="#OOM实战"> </a>OOM实战</h2>
<p><strong>Idea版本2020.3.2</strong></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210224172607852.png" alt="image-20210224172607852"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210224172633197.png" alt="image-20210224172633197"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210224172648428.png" alt="image-20210224172648428"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210224172755648.png" alt="image-20210224172755648"></p>
<h3 id="Java堆溢出"><a class="header-anchor" href="#Java堆溢出"> </a>Java堆溢出</h3>
<blockquote>
<p>-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> OOM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOOM</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OOMObject</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;OOMObject&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">OOMObject</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210224172954069.png" alt="image-20210224172954069"></p>
<h3 id="虚拟机栈和本地方法栈溢出"><a class="header-anchor" href="#虚拟机栈和本地方法栈溢出"> </a>虚拟机栈和本地方法栈溢出</h3>
<p>HotSpot不支持栈的动态扩展</p>
<p>使用<code>-Xss</code>参数减少栈内存容量</p>
<blockquote>
<p>-Xss128k</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> OOM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaVMStackSOF</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">stackLength</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stackLeak</span><span class="params">()</span> &#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        <span class="type">JavaVMStackSOF</span> <span class="variable">oom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavaVMStackSOF</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oom.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;stack Length:&quot;</span> + oom.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210224200502394.png" alt="image-20210224200502394"></p>
<h3 id="方法区和运行时常量池溢出"><a class="header-anchor" href="#方法区和运行时常量池溢出"> </a>方法区和运行时常量池溢出</h3>
<p>在JDK8中完全使用元空间来代替永久代</p>
<p><code>String::intern</code>作用时，如果字符串常量池中已经包含一个等于此字符串对象的字符串，则返回代表池中这个字符串的对象的引用，否则将此String对象包含的字符串添加到常量池中，并返回此String对象的引用</p>
<p>字符串常量池已经移到Java堆中，只需在常量池里记录首次出现的实例的引用</p>
<p>在Java8运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> OOM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuntimeConstantPoolOOM</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;计算机&quot;</span>).append(<span class="string">&quot;软件&quot;</span>).toString();</span><br><span class="line">        System.out.println(str1.intern() == str1); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line">        System.out.println(str2.intern() == str2); <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>元空间</p>
<ul>
<li><code>-XX:MaxMetaspaceSize</code>：元空间的最大值，默认-1不受限制</li>
<li><code>-XX:MetaspaceSize</code>指定元空间的初始空间大小，字节为单位，达到该值会触发垃圾收集进行类型卸载</li>
<li><code>-XX:MinMetaspaceFreeRadio</code>：在垃圾收集之后，控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率</li>
<li><code>-XX:MaxMetaspaceFreeRadio</code>：用于控制最大的元空间剩余容量的百分比</li>
</ul>
<h3 id="本机直接内存溢出"><a class="header-anchor" href="#本机直接内存溢出"> </a>本机直接内存溢出</h3>
<p>直接内存（Direct Memory）的容量大小通过<code>-XX:MaxDirectMemorySize</code>来指定，默认与Java堆最大值（<code>-Xmx</code>）一致</p>
<blockquote>
<p>-Xms20M -XX:MaxDirectMemorySize=10M</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> OOM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectMemoryOOM</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">unsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        unsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) unsafeField.get(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210225152556418.png" alt="image-20210225152556418"></p>
<h2 id="垃圾收集器与内存分配策略"><a class="header-anchor" href="#垃圾收集器与内存分配策略"> </a>垃圾收集器与内存分配策略</h2>
<ul>
<li>程序计数器、虚拟机栈和本地方法栈三个区域随线程而生，随线程而灭。每个栈帧分配内存的大小在类结构确定时就已知。
<ul>
<li>对于这几个区域，在方法结束或线程结束时，内存自然就跟随着回收</li>
</ul>
</li>
</ul>
<p>Java堆和方法区具有不确定性：内存分配和回收是动态的</p>
<h3 id="判断对象是否死亡"><a class="header-anchor" href="#判断对象是否死亡"> </a>判断对象是否死亡</h3>
<p>即是否不存在任何途径使用对象</p>
<ol>
<li>引用计数算法：判断对象引用数量</li>
<li>可达性分析算法：判断对象是否引用链可达</li>
</ol>
<p>java采用的是可达性分析算法</p>
<h4 id="引用计数算法"><a class="header-anchor" href="#引用计数算法"> </a>引用计数算法</h4>
<p>引用计数器：有地方引用加一，引用失效减一。当引用计数器为零时，代表对象不可能再被使用</p>
<p>优点：虽然占用一些额外的内存空间，但原理简单，效率高</p>
<p>缺点：许多例外的情况要考虑：例如单纯的引用计数难以解决对象之间相互引用的问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> OOM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] bigSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testGC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        objB = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="可达性分析算法"><a class="header-anchor" href="#可达性分析算法"> </a>可达性分析算法</h4>
<p>通过一系列称为&quot;GC Roots&quot;的根对象作为起始节点集，从”GC Roots“根据引用关系向下搜索。搜索过程的路径称为引用链。</p>
<p>如果某个对象到GC Roots间没有引用链，即不可达时，则该对象不可能再被使用</p>
<p><em>固定</em>可作为GC Roots对象包括</p>
<ul>
<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数，局部变量、临时变量等</li>
<li>在方法区中，类静态属性引用的对象，譬如Java类的引用类型静态变量</li>
<li>在方法区中，常量引用的对象，譬如字符串常量池里的引用</li>
<li>在本地方法栈中JNI（native方法）引用的对象</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（<code>NullPointException</code>，<code>OutOfMemoryError</code>）等，还有系统类加载器</li>
<li>所有被同步锁（<code>synchronized</code>关键字）持有的对象</li>
<li>反应Java虚拟机内部情况的JMXBean，JVMTI中注册的回调、本地代码缓存等</li>
</ul>
<p>除固定的GC Roots集合外，还有其他对象临时性加入</p>
<ul>
<li>譬如分代收集和局部回收</li>
</ul>
<h4 id="引用概念"><a class="header-anchor" href="#引用概念"> </a>引用概念</h4>
<ul>
<li>强引用（Strongly Reference）
<ul>
<li>引用赋值：<code>Object obj = new Object();</code>的引用关系。只要强引用关系存在，垃圾收集器永远不会回收被引用的对象</li>
</ul>
</li>
<li>软引用（Soft Reference）
<ul>
<li>描述的是有用，但非必须的对象</li>
<li>只被软引用的对象，在系统将要发生内存溢出异常前，会将这些对象列入回收范围进行第二次回收。如果这次回收后仍然没有足够内存，才抛出内存异常</li>
<li><code>SoftReference</code>类</li>
</ul>
</li>
<li>弱引用（Weak Reference）
<ul>
<li>描述的是非必须的对象</li>
<li>被弱引用关联的对象只能生存到下一次垃圾收集发生为止</li>
<li>无论内存是否足够，都会回收掉只被弱引用关联的对象</li>
<li><code>WeakReference</code>类</li>
</ul>
</li>
<li>虚引用（Phantom Reference）,又叫幽灵引用，幻影引用
<ul>
<li>虚引用是否存在，对其生命周期完全没有影响</li>
<li>无法通过虚引用来取得对象实例</li>
<li>唯一目的：为了能在该对象被回收时，能受到系统的通知</li>
<li><code>PhantomReference</code>类</li>
</ul>
</li>
</ul>
<h3 id="对象死亡"><a class="header-anchor" href="#对象死亡"> </a>对象死亡</h3>
<p>一个对象真正的死亡至少要经过两次标记过程。</p>
<p>如果一个对象进行可达性分析后，发现没有GC Roots引用链可达，会进行第一次标记。随后判断该对象是否有必要执行<code>finalize()</code>方法。</p>
<p>没有必要执行<code>finalize()</code>方法情况：</p>
<ul>
<li>没有覆盖finalize()方法</li>
<li>finalize方法已经被虚拟机调用过</li>
</ul>
<p>如果有必要调用<code>finalize</code>方法，那么该对象会放入<code>F-Queue</code>队列中，并且有虚拟机创建的Finalizer线程去执行队列中对象的<code>finalize()</code>方法。</p>
<p><code>finalize</code>方法在<code>Object</code>类中，当一个对象没有任何引用与之相关联的时候，垃圾收集器在垃圾回收时会调用该方法。同时这个方法最多只会调用一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>
<p><code>finalize</code>方法是对象能够逃离被回收的最后一次机会，如果在该方法内，该对象与引用链上的任何一个对象建立关联（将this赋给某个类变量或成员变量）则将移除被回收的集合。如果该对象在finalize方法执行后仍然与GC Roots没有建立连接，或者已经执行过finalize放了后又进入即将被回收的状态，则就真的被回收</p>
<p>finalize可以用来做关闭外部资源的清理工作，但是不推荐这样做，也不建议使用这个方法，而是将清理工作交给try-finally语句</p>
<p>演示代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> FinalizeTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadLocalRandom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeEscapeGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">FinalizeEscapeGC</span> <span class="variable">SAVE_HOOK</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">isAlive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我还活着&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行finalize方法&quot;</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> <span class="title class_">FinalizeEscapeGC</span>();</span><br><span class="line">        SAVE_HOOK = <span class="literal">null</span>; <span class="comment">// 不存在GC Roots 的引用链可达</span></span><br><span class="line">        System.gc(); <span class="comment">// 调用finalize，重新有引用链可达</span></span><br><span class="line">        <span class="comment">// 让主线程阻塞，使得Finalizer线程拿到时间片，进行执行finalize</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="literal">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我被回收了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SAVE_HOOK = <span class="literal">null</span>; <span class="comment">//再一次没有GC Roots引用链可达，</span></span><br><span class="line">        System.gc(); <span class="comment">// 因为finalize已经执行过一次了，不为执行第二次，因此该对象直接被回收</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="literal">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我被回收了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210226154433917.png" alt="image-20210226154433917"></p>
<h3 id="回收方法区"><a class="header-anchor" href="#回收方法区"> </a>回收方法区</h3>
<p>垃圾回收器主要回收的对象是Java堆（尤其是Java堆中的新生代）</p>
<p>而《Java虚拟机规范》不要求虚拟机再方法区中实现垃圾收集。</p>
<blockquote>
<p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常需要Java虚拟机具有类型卸载的能力，确保不会对方法区造成过大的内存压力</p>
</blockquote>
<p>方法区中回收两部分内容</p>
<ol>
<li>废弃的常量</li>
<li>不再使用的类型</li>
</ol>
<p>废弃的常量：没有任何地方引用到该常量池中的字面量</p>
<ul>
<li>例如&quot;java&quot;字符串常量，其他类（接口）方法、字段的符号引用</li>
</ul>
<p>不再使用的类型：应该满足下面三个条件，但是满足后也不一定会被回收</p>
<ol>
<li>该类的所有实例都被回收：Java堆中不存在该类及其任何派生子类的实例</li>
<li>加载该类的类加载器已经被回收</li>
<li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用：即无法在任何地方通过反射访问该类的方法</li>
</ol>
<blockquote>
<p>-Xnoclassgc参数进行控制</p>
</blockquote>
<h2 id="垃圾收集算法"><a class="header-anchor" href="#垃圾收集算法"> </a>垃圾收集算法</h2>
<p>垃圾收集算法划分为：</p>
<ul>
<li>引用计数式垃圾收集（reference counting gc）（直接垃圾收集）</li>
<li>追踪式垃圾收集（tracing gc）（间接垃圾收集）</li>
</ul>
<p>java虚拟机采用追踪式垃圾收集</p>
<h3 id="分代收集理论"><a class="header-anchor" href="#分代收集理论"> </a><strong>分代收集理论</strong></h3>
<ul>
<li>强分代假说（strong generational hypothesis）：经历越多次垃圾收集过程的对象越难以消灭</li>
<li>弱分代假说（weak generational hypothesis）：绝大多数的对象都是朝生夕灭的</li>
<li>跨代引用假说（intergenerational reference hypothesis）：跨代引用相对于同代引用仅占少数</li>
</ul>
<p>根据分代收集理论，将java堆依据对象的年龄划分成不同的区域</p>
<p>一般至少把java堆分为</p>
<ul>
<li>新生代（young generation）</li>
<li>老年代（old generation）</li>
</ul>
<p>记忆集（remembered set）：将老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用，当发生Minor GC时，只有包含跨代引用的小块内存对象会被加入到GC Roots中进行扫描</p>
<ul>
<li>部分收集（partial GC）
<ul>
<li>新生代收集（Minor GC/Young GC）：目标是新生代的垃圾收集</li>
<li>老年代收集（Major GC/ Old GC）：目标是老年代的垃圾收集</li>
<li>混合收集（Mixed GC）：目标是整个新生代以及部分老年代</li>
</ul>
</li>
<li>整堆收集（full gc）：整个JAVA堆和方法区的垃圾收集</li>
</ul>
<h3 id="标记-清除算法"><a class="header-anchor" href="#标记-清除算法"> </a>标记-清除算法</h3>
<p>分为两阶段</p>
<ul>
<li>标记</li>
<li>清除</li>
</ul>
<p>两种方式：</p>
<ul>
<li>标记需要回收的对象，同一回收所有被标记的对象</li>
<li>标记存活的对象，同一回收未被标记的对象</li>
</ul>
<p>缺点：</p>
<ul>
<li>两个过程的执行效率都随着对象的增加而降低</li>
<li>空间碎片化</li>
</ul>
<h3 id="标记-复制算法"><a class="header-anchor" href="#标记-复制算法"> </a>标记-复制算法</h3>
<p>半区复制：将内存分成大小相等的两部分，每次只使用其中一块。当需要进行垃圾回收时，将存活的对象复制到另一块空间，然后只进行一次清理。</p>
<p>缺点：</p>
<ul>
<li>如果大量对象存活，则产生大量复制的开销</li>
<li>浪费太多的空间</li>
</ul>
<h4 id="优化标记复制算法"><a class="header-anchor" href="#优化标记复制算法"> </a><strong>优化标记复制算法</strong></h4>
<p>对于新生代的内存布局：</p>
<p>分成一块Eden空间和两块Survivor空间（Eden和Survivor占比8:1），每次使用Eden和一块Survivor。垃圾收集时，将存活对象复制到Survivor中，一并清除Eden和使用过的Survivor。</p>
<p>如果Survivor空间不够，则通过分配担保的方式进入老年代</p>
<h3 id="标记-整理算法"><a class="header-anchor" href="#标记-整理算法"> </a>标记-整理算法</h3>
<p>主要针对老年代：</p>
<p>先对需要回收的对象进行标记，然后向内存空间一端移动，接着直接清理掉边界外的内存</p>
<p>标记-清除算法和标记-整理算法的差异在于前者是一种非移动式的回收算法，后者式移动式的。</p>
<p>缺点：移动存活对象必须更新引用这些对象的地方</p>
<p>移动内存则回收时复杂，不移动则分配时复杂.</p>
<h2 id="实战：内存分配与回收策略"><a class="header-anchor" href="#实战：内存分配与回收策略"> </a>实战：内存分配与回收策略</h2>
<p>自动内存管理解决两个问题</p>
<ol>
<li>自动给对象分配内存</li>
<li>自动回收分配给对象的内存</li>
</ol>
<p>对象的内存分配，概念上讲应该都是在堆上分配（实际上可能经过及时编译后被拆撒为标量类型并间接地在栈上分配）</p>
<p>在经典的分代设计下，新生对象通常会分配到新生代，少数情况下，（例如对象大小超过异地那个阈值），也可能会直接分配在老年代</p>
<h3 id="对象优先在Eden分配"><a class="header-anchor" href="#对象优先在Eden分配"> </a>对象优先在Eden分配</h3>
<p>大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机发起一次Minor GC</p>
<blockquote>
<p>-XX:+PrintGCDetails  收集器日志参数</p>
</blockquote>
<blockquote>
<p>-Xms20M -Xmx20M -Xmn10M 限制java堆大小为20M, 其中10M给新生代（Xmn），剩下10M给老年代</p>
</blockquote>
<blockquote>
<p>-XX:SurvivorRatio=8 新生代中Eden区和Survivor区空间比例8:1</p>
</blockquote>
<p>实验中，在分配<code>al4</code>,由于<code>Eden</code>空间已经不够了，所以通过分配担保机制，将<code>al1 al2  al3</code>提前转移到老年代</p>
<p>VM参数</p>
<blockquote>
<p>-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAllocation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] al1, al2, al3, al4;</span><br><span class="line">        al1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        al2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        al3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        al4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Test1.testAllocation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210310104117233.png" alt="image-20210310104117233"></p>
<h3 id="大对象直接进入老年代"><a class="header-anchor" href="#大对象直接进入老年代"> </a>大对象直接进入老年代</h3>
<p>大对象指需要大量连续内存空间的java对象，最典型的大对象是那种很长的字符串或者元素数量很庞大的数组</p>
<p>写程序应该避免大对象</p>
<ul>
<li>遇到一群朝生夕灭的短命大对象是个坏消息</li>
</ul>
<p>避免大对象原因</p>
<ul>
<li>内存明明还有不少空间时，就触发出发垃圾收集，以获取足够连续空间才能安置好</li>
<li>复制对象，高额的内存复制开销。从Eden空间复制到Survivor</li>
</ul>
<blockquote>
<p>-XX:PretenureSizeThreshold 指定大于该设置值的对象直接在老年代分配，避免在Eden区和Survivor区来回复制</p>
</blockquote>
<blockquote>
<p>-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=3145728</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPretenureSizeThreshold</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] allocation;</span><br><span class="line">    allocation = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210310105631304.png" alt="image-20210310105631304"></p>
<h3 id="长期存活的对象直接进入老年代"><a class="header-anchor" href="#长期存活的对象直接进入老年代"> </a>长期存活的对象直接进入老年代</h3>
<p>虚拟机给每个对象定义一个对象年龄计数器，储存在对象头</p>
<p>对象通常在Eden区诞生，如果经过一次Minor GC仍存活，并且能被Survivor区容纳，则会将该对象移动到Survivor区，并讲其对象年龄设为1岁。对象在Survivor区每熬过一次MinorGC，年龄就增加1岁，当年龄增加到一定程度（默认15）就会被晋升到老年代</p>
<blockquote>
<p>-XX:MaxTenuringThreshold 对象晋升老年代的年龄阈值</p>
</blockquote>
<blockquote>
<p>-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1 -XX:+PrintTenuringDistribution</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testTenuringThreshold</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] allocation1, allocation2, allocation3;</span><br><span class="line">    allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">    allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    allocation3 = <span class="literal">null</span>;</span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210310110508258.png" alt="image-20210310110508258"></p>
<h3 id="动态对象年龄判断"><a class="header-anchor" href="#动态对象年龄判断"> </a>动态对象年龄判断</h3>
<p>hotspot虚拟机不是永远要求对象的年龄必须达到<code>-XX:MaxTenuringThreshold</code>才能晋升老年代。当Survior区中相同年龄的对象大小之和大于Survivor区大小的一半，则大于等于该年龄的对象都会晋升到老年代</p>
<blockquote>
<p>-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1 -XX:+PrintTenuringDistribution</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testTenuringThreshold2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">    allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">    allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    allocation4 = <span class="literal">null</span>;</span><br><span class="line">    allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210310111050934.png" alt="image-20210310111050934"></p>
<h3 id="空间分配担保"><a class="header-anchor" href="#空间分配担保"> </a>空间分配担保</h3>
<p>在JDK6 Update24之前：</p>
<p>在发生Minor GC之前，虚拟机会先检查老年代的最大可用连续空间是否大于新生代所有对象的空间。</p>
<p>如果满足，则这一次Minor GC是安全的。</p>
<p>如果不满足，虚拟机先查看<code>-XX:HandlePromotionFailure</code>参数的设置值，是否允许担保失败</p>
<ul>
<li>如果允许，则继续检查老年代最大可用的连续空间是否大于历此晋升到老年代队先规定平均大小。
<ul>
<li>如果大于则尝试Minor GC，但这次Minor GC是有风险的</li>
<li>如果小于则改为Full GC</li>
</ul>
</li>
<li>如果不允许，则进行Full GC</li>
</ul>
<p>在JDK6 Update24之后：</p>
<p><code>-XX:HandlePromotionFailure</code>参数不会影响到虚拟机的空间分配担保策略</p>
<p>只要老年代的可用连续空间大于新生代对象总大小或者历此晋升的平均大小，则进行Minor GC，否则进行Full GC</p>
<h2 id="类文件结构"><a class="header-anchor" href="#类文件结构"> </a>类文件结构</h2>
<ul>
<li>字节码指令所能提供的语言描述能力必须比Java语言本身更加强大</li>
</ul>
<h3 id="Class类文件的结构"><a class="header-anchor" href="#Class类文件的结构"> </a>Class类文件的结构</h3>
<ul>
<li>
<p>Class文件结构稳定</p>
</li>
<li>
<p>Class文件是一组以<em>8个字节</em>为基础单位的二进制流，各个<strong>数据项目</strong>严格<strong>按照顺序</strong>紧凑排列在文件中，中间<strong>没有</strong>添加<strong>任何分隔符</strong></p>
<ul>
<li>当遇到需要占用8个字节以上空间的数据时，按照**高位在前（Big-Endian，高位字节在地址低位，低位字节在地址高位）**的方式分割成若干个8个字节</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术—基础知识</title>
    <url>/2020/11/04/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="Java-基础知识"><a class="header-anchor" href="#Java-基础知识"> </a>Java 基础知识</h2>
<!-- more -->
<h4 id="问题"><a class="header-anchor" href="#问题"> </a>问题</h4>
<ol>
<li>为什么Java没有无符号类型</li>
<li>求余和求模区别</li>
<li>负数如何求模</li>
<li>负数如何求余</li>
</ol>
<h4 id="零碎小知识"><a class="header-anchor" href="#零碎小知识"> </a>零碎小知识</h4>
<ul>
<li>
<p>Java应用程序中的全部内容都必须放在类中</p>
</li>
<li>
<p>源代码的文件名必须与公共类的名字相同（区分大小写）</p>
</li>
<li>
<p>运行已编译的程序时，JVM从指定类中的main方法的代码开始执行</p>
</li>
<li>
<p>根据Java语言规范，main方法必须声明为public、静态的</p>
</li>
<li>
<p>Java中所有函数都是某个类的方法</p>
</li>
<li>
<p>Java中的main方法必须有一个外壳(shell)类</p>
</li>
<li>
<p><code>System.out.println(&quot;We&quot;)</code>,<code>System.out</code>对象调用<code>println</code>方法</p>
</li>
<li>
<p><code>.</code>用于调用方法<code>object.method(parameters)</code></p>
</li>
<li>
<p>注释3种形式</p>
<ul>
<li><code>// hello</code></li>
<li><code>/* */</code></li>
<li>自动生成文档,以<code>/**</code>开始，<code>*/</code>结束</li>
</ul>
</li>
<li>
<p>Java是强类型语言，共有8种基本类型</p>
<ul>
<li>整型
<ul>
<li><code>int</code> 4字节 -2 147 483 648 ~ 2 147 483 647(刚过20亿)</li>
<li><code>short</code> 2字节 -32768 ~ 32767</li>
<li><code>long</code> 8字节</li>
<li><code>byte</code> 1字节 -128~127</li>
<li>长整型数值有一个后缀<code>L</code>或<code>l</code>(如4000000000L)</li>
<li>十六进制数值有一个前缀<code>0x</code>或<code>0X</code>(如0xCAFE)</li>
<li>八进制有一个前缀<code>0</code></li>
<li>Java7开始，前缀<code>0b</code>或<code>0B</code>表示二进制数，如(0b1001)是9</li>
<li>Java7开始，可以为数字字面量加下划线(1_000_000)</li>
<li><strong>注：Java没有任何无符号(unsigned)形式的int、long、short或byte</strong></li>
<li><code>Byte.toUnsignedInt(b)</code></li>
</ul>
</li>
<li>浮点类型
<ul>
<li>float 4字节 有效位数为6~7位</li>
<li>double 8字节 有效位数位15位</li>
<li>float类型有一个后缀<code>F</code>或<code>f</code></li>
<li>没有后缀的浮点类型总是默认位<code>double</code></li>
<li>double后缀<code>D</code>或<code>d</code></li>
<li>十六进制表示浮点数值0.125 = 2<sup>-3</sup> = 0x1.0p-3。尾数采用十六进制、指数采用十进制、指数的基数是2</li>
</ul>
</li>
<li>字符类型<code>char</code>(用于表示Unicode编码的代码单元)
<ul>
<li>2个字节</li>
<li>十六进制表示<code>\u0000~\uFFFF</code></li>
<li>Unicode转义序列在解析代码之前得到处理</li>
<li>小心注释中的<code>\u</code>会报错
<ul>
<li><code>// \u000A is a new line</code></li>
<li><code>// look inside c:\users</code></li>
</ul>
</li>
<li>char类型描述了UTF-16的一个代码单元</li>
<li>总之：char是用UTF-16编码表示的Unicode码点的代码单元</li>
</ul>
</li>
<li>表示真值的<code>boolean</code>类型
<ul>
<li>
<p><code>true</code> <code>false</code></p>
</li>
<li>
<p>整型值和布尔值之间不能进行相互转换</p>
<ul>
<li><code>if (x = 0)</code>在Java中不能编译通过，因为整数表达式不能转换成布尔值j</li>
</ul>
</li>
<li>
<pre><code class="language-Java">  while(pos--)&#123; //ERROR 不能这样
      after = after.next;
  &#125;
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">- 声明一个变量之后，必须用赋值语句对变量进行显示初始化，不能使用未初始化的变量的值</span><br><span class="line"></span><br><span class="line">- Java10开始，如果可以变量的初始化推断出它的类型，就不在需要声明类型，只需使用关键字`var`，例如`var vacationDays = 12`</span><br><span class="line"></span><br><span class="line">- 关键字`final`</span><br><span class="line">  - `final`指示常量，表示这个变量只能被赋值一次，一旦被赋值之后就不能再更改，常量名使用全大写`final double CM_PER_INCH`</span><br><span class="line">  - 如果希望某个常量可以在一个类的多个方法中使用，这些常量称为类常量(class constant)。使用关键字`static final`设置一个类常量,类常量的定义位于位于`main`方法的外部，如果该类常量声明成`public`则其他类的方法也可以使用该常量</span><br><span class="line">    ```Java</span><br><span class="line">        public class Constants2</span><br><span class="line">        &#123;</span><br><span class="line">            public static final double CM_PER_INCH = 2.54;</span><br><span class="line">            </span><br><span class="line">            public static void main(String[] args)</span><br><span class="line">            &#123;</span><br><span class="line">              ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li>注：<code>const</code>是Java保留的关键字，但是目前并没有使用，必须用<code>final</code>定义常量</li>
</ul>
</li>
<li>
<p>枚举类型</p>
<ul>
<li><code>enum Size &#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;</code></li>
<li><code>Size s = Size.MEDIUM;</code></li>
<li><code>Size s = null;</code></li>
</ul>
</li>
<li>
<p>枚举类型的变量只能储存这个类型声明中给的枚举值或者特殊值<code>null</code>,<code>null</code>表示这个变量没有设置任何值</p>
</li>
<li>
<p>算术运算符</p>
<ul>
<li><code>/</code> 参与<code>/</code>的运算的两个操作数都是整数时，表示整数除法： <code>15/2 = 7</code></li>
<li><code>/</code> 参与<code>/</code>的运算的操作数存在浮点数时，表示浮点除法： <code>15.0/2 = 7.5</code></li>
<li>整数被<code>0</code>除，会抛出异常<code>java.lang.ArithmeticException: / by zero</code></li>
<li>浮点数被<code>0</code>除，得到的结果是无穷大或NaN结果<code>Infinity</code>(如果是负数，则结果是<code>-Infinity</code>)</li>
</ul>
</li>
<li>
<p><code>strictfp</code>标记的方法，则方法内的所有指令都使用严格的浮点计算</p>
</li>
<li>
<p>Java没有幂运算，因此需要借助Math类的pow方法:<code>Math.pow(x,a)</code>表示x<sup>a</sup></p>
</li>
<li>
<p><code>floorMod</code> 是Java的取模运算。 <code>%</code>是Java的取余运算，详细见<em>问题2</em></p>
</li>
<li>
<p><code>StrictMath</code>得到一个完全可预测的结果比运行速度更重要的时候</p>
</li>
<li>
<p><code>Math</code>提供一些方法使得整数运算有更好的安全性</p>
<ul>
<li><code>multiplyExact</code></li>
<li><code>addExact</code></li>
<li>…</li>
</ul>
</li>
<li>
<p>强制类型转换</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">9.997</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">nx</span> <span class="operator">=</span> (<span class="type">int</span>) x;</span><br><span class="line"><span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">9.997</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">ny</span> <span class="operator">=</span> (<span class="type">int</span>) Math.round(y);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>位运算符</p>
<ul>
<li><code>&amp;&amp;</code>和<code>||</code>用于布尔值会采用短路，但是<code>&amp;</code>和<code>|</code>用于布尔值不会采用短路</li>
<li><code>&gt;&gt;</code> <code>&lt;&lt;</code> 用于位模式左移或右移。 <code>&gt;&gt;&gt;</code>运算符会用0填充高位，注意没有<code>&lt;&lt;&lt;</code></li>
<li>位运算符的右操作数要完成模32的运算(如果左操作数是类型，则需要模64)
<ul>
<li><code>1&lt;&lt;35 == 1&lt;&lt;3 == 8</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>字符串</p>
<ul>
<li>
<p>子串</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">greeting</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> greeting.substring(<span class="number">0</span>,<span class="number">3</span>);  <span class="comment">//改子串长度为3 - 0 = 3 ; 左闭右开，即取不到3这个位置</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>拼接</p>
<ul>
<li>通过<code>+</code>进行拼接两个字符串</li>
<li>字符串于非字符串的值进行拼接的时候，后面的值会转换成字符串</li>
<li>如果需要插入间隔符，用<code>join</code> : <code>String.joint(&quot;/&quot;,&quot;S&quot;,&quot;M&quot;,&quot;L&quot;,&quot;XL&quot;); // 输出 S/M/L/XL</code></li>
</ul>
</li>
<li>
<p>String类对象是不可变的(immutable)</p>
</li>
<li>
<p>共享带来的效率高于提取子串和拼接字符串</p>
</li>
<li>
<p>原始字符串在堆中分配，对一个String类型重新赋值不会发生内存泄漏，因为Java有垃圾回收机制</p>
</li>
<li>
<p><code>String s = &quot;helloworld&quot;;</code></p>
<ul>
<li><code>s</code>是字符串变量</li>
<li><code>&quot;helloworld&quot;</code>是字符串字面量</li>
</ul>
</li>
<li>
<p>相等</p>
<ul>
<li><code>s.equals(t)</code></li>
<li><code>&quot;Hello.equals(greeting)&quot;</code></li>
<li><code>&quot;Hello&quot;.equalsIgnoreCase(&quot;hello&quot;)</code></li>
<li>注：<strong>不要用</strong><code>==</code>去判断两个字符串是否相等
<ul>
<li><code>==</code>运算符只能够确定两个字符串的位置是否相同</li>
<li>有可能内容相同的多个字符串副本放在不同的位置</li>
</ul>
</li>
<li>只有<strong>字符串字面量</strong>是共享的</li>
<li>Java的<code>compareTo</code>类似C的<code>strcmp</code>
<ul>
<li><code>if(greeting.compareTo(&quot;Hello&quot;) == 0)</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>空串</p>
<ul>
<li>空串是长度为0的字符串
<ul>
<li><code>if(str.length() == 0)</code></li>
<li><code>if(str.equals(&quot;&quot;))</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>null串</p>
<ul>
<li><code>if(str == null)</code></li>
</ul>
</li>
<li>
<p>判断一个字符串既不是null串也不是空串</p>
<ul>
<li><code>if(str != null &amp;&amp; str.length() != 0)</code></li>
<li>要先检查不为<code>null</code>，否则在<code>null</code>上调用方法会报错</li>
</ul>
</li>
<li>
<p>码点和代码单元</p>
<ul>
<li>
<p>char数据类型给是一个采用UTF-16编码表示的Unicode码点的代码单元。</p>
<ul>
<li>码点是一个编码表中的某个字符对应的代码值</li>
<li>每个字符(char)用16位表示代码单元
<ul>
<li>注意：在C和C++中，windows的32位机和64位机下，char占1个字节，这跟Java不一样。Java的char类型占2个字节(16bit)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>因此每个码点可能由多个代码单元组成</p>
</li>
<li>
<p><code>length()</code>方法返回的是采用UTF-16编码表示的给定字符串所需要的代码单元</p>
</li>
<li>
<p><code>codePointCount()</code>返回实际长度，即码点数量</p>
</li>
<li>
<p><code>charAt(n)</code>返回位置n的代码单元</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="string">&quot;hi🍺&quot;</span>;</span><br><span class="line">  System.out.println(hello.length());<span class="comment">//4</span></span><br><span class="line">  System.out.println(hello.codePointCount(<span class="number">0</span>, hello.length()));<span class="comment">//3</span></span><br><span class="line">  System.out.println(hello.charAt(<span class="number">0</span>));<span class="comment">//h</span></span><br><span class="line">  System.out.println(hello.charAt(<span class="number">2</span>));<span class="comment">//?</span></span><br><span class="line">  System.out.println(hello.charAt(<span class="number">3</span>));<span class="comment">//?</span></span><br><span class="line">  System.out.println(hello.offsetByCodePoints(<span class="number">0</span>,<span class="number">2</span>));<span class="comment">//2</span></span><br><span class="line">System.out.println(hello.codePointAt(hello.offsetByCodePoints(<span class="number">0</span>,<span class="number">2</span>)));<span class="comment">//127866</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>String</code>类实现了<code>CharSequence</code>的接口</p>
</li>
<li>
<p>构建字符串</p>
<ul>
<li>在短的字符串拼接中，如果采用<code>String</code>类进行拼接的效率低下，每次拼接时都会构建成一个新的<code>String</code>对象，耗时又浪费空间</li>
<li><code>StringBuilder</code> 字符串构造器<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构建一个空的字符串构造器</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="comment">//添加新的内容，调用append方法</span></span><br><span class="line">builder.append(ch); <span class="comment">//添加character</span></span><br><span class="line">builder.append(str); <span class="comment">//添加字符串</span></span><br><span class="line"><span class="comment">//构建完成调用toString()方法，得到String对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">completedString</span> <span class="operator">=</span> builder.toString();</span><br></pre></td></tr></table></figure>
</li>
<li><code>StringBuffer</code>
<ul>
<li><code>StringBuffer</code>效率比<code>StringBuilder</code>稍低</li>
<li><code>StringBuffer</code>允许采用多线程的方式添加或删除字符</li>
<li>如果是在单个线程执行的话，应该使用<code>StringBuilder</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>输入输出</p>
<ul>
<li>要通过控制台进行输入，需要构造一个和标准输入流System.in关联的Scanner对象<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.print(<span class="string">&quot;你的名字是？&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.nextLine();  <span class="comment">// 可以包括空格  next()不能包括空格</span></span><br><span class="line">System.out.print(<span class="string">&quot;你多大了&quot;</span>);    <span class="comment">// nextDouble</span></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">System.out.printf(name + <span class="string">&quot;  &quot;</span> + (age+<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
</li>
<li>Java5沿用C愿语言函数库中的printf方法<br>
<code>System.out.printf(&quot;%8.2f&quot;,x);</code></li>
<li><code>s</code>转换符可以格式化任意对象
<ul>
<li>实现Formattable接口的任意对象，将调用formatTo方法</li>
<li>否则调用toString方法</li>
</ul>
</li>
<li><code>String.format</code>创建格式化的字符串<br>
<code>String message = String.format(&quot;Hello, %s. Next year you'll be %d&quot;,name,age);</code></li>
</ul>
</li>
<li>
<p>文件输入输出</p>
<ul>
<li><code>String dir = System.getProperty(&quot;user.dir&quot;);</code> 获取启动目录</li>
<li>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    in = <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;./hello.txt&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(in.hasNext())&#123;</span><br><span class="line">    System.out.println(in.nextLine());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    out = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">out.println(<span class="string">&quot;不太好&quot;</span>);</span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>控制流程</p>
<ul>
<li>Java控制流程和C++类似</li>
<li>记住do while结构中，while结尾记得写分号<code>;</code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;<span class="keyword">while</span>(..);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>带标签的break语句：用于跳出多重嵌套的循环语句</p>
<ul>
<li>标签放在希望的跳出的最外层循环之外，并且紧跟一个冒号</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">read_data:</span><br><span class="line"><span class="keyword">while</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(...)</span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span> read_data;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>大数</p>
<ul>
<li>java.math包中有两个类: <code>BigInteger</code>和<code>BigDecimal</code></li>
<li>这两类可以处理任意长度数字序列的数值</li>
<li><code>valueOf()</code>将普通的数值转成大数
<ul>
<li><code>Big Integer a = BigInteger.valueOf(100);</code></li>
</ul>
</li>
<li>对于更大的数课可以用带字符串参数的构造器
<ul>
<li><code>BigInteger reallyBig = new BigInteger(&quot;2222421413254532434124323243242343243243242332432&quot;);</code></li>
</ul>
</li>
<li>大数运算
<ul>
<li>不能使用算术运算符<code>+</code> <code>-</code></li>
<li>使用<code>add</code>和<code>multyply</code>
<ul>
<li><code>BigInteger d = c.multyply(b.add(BigInteger.valueOf(2))); // d = c*(b+2)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>数组</p>
<ul>
<li>
<p>两种声明数组的方式</p>
<ol>
<li><code>int[] a</code></li>
<li><code>int a[]</code></li>
</ol>
</li>
<li>
<p>数组需要用<code>new</code>来初始化</p>
<ul>
<li><code>int[] a = new int[100];</code></li>
<li>数组长度不要求是常量
<ul>
<li><code>int[] a = new int[n];</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>一旦创建了数组就不能再改变长度</p>
</li>
<li>
<p>创建数组对象并提供初始值</p>
<ul>
<li><code>int[] a = &#123;1,2,3,4,5&#125;; //这种方式不需要new也不需要之指定长度</code></li>
</ul>
</li>
<li>
<p>允许{}中最后一个值后面带逗号、</p>
</li>
<li>
<p>匿名数组</p>
<ul>
<li><code>new int[] &#123;1,2,3,4,5&#125;</code></li>
</ul>
</li>
<li>
<p>长度为0的数组</p>
<ul>
<li><code>new int[0]</code></li>
<li><code>new int[] &#123;&#125;</code></li>
<li>注意与null不同</li>
</ul>
</li>
<li>
<p>数组初始化</p>
<ul>
<li>数字数组初始化为0</li>
<li>boolean数组初始化为false</li>
<li>对象数组初始化为null
<ul>
<li><code>String[] banes = new String[10];</code>里面都是null而不是空串</li>
</ul>
</li>
</ul>
</li>
<li>
<p>数组长度<code>array.length</code></p>
</li>
<li>
<p>for each循环</p>
<ul>
<li>for(variable : collection) statment</li>
<li>
<pre><code> for(int element : a) 
   System.out.println(element);
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ```</span><br><span class="line">  - 必须是数组或者是实现Iterable接口的类对象 </span><br><span class="line"></span><br><span class="line">- 打印数组</span><br><span class="line">  - 调用`Arrays`类的`toString`</span><br><span class="line">  - `Arrays.toString(a); //[1,2,3,4,5]`</span><br><span class="line">- 数组拷贝</span><br><span class="line">  1. 两个变量引用同一个数组</span><br><span class="line">      ```Java</span><br><span class="line">       int[] a = b;</span><br><span class="line">       a[5] = 12; // 现在b[5]也是12</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<ol start="2">
<li>数组的所有值拷贝到一个新的数组
<ul>
<li>第二个参数为新数组长度</li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Arrays.copyOf(b,b.length);</span><br></pre></td></tr></table></figure>
<ul>
<li>可以用来增加数组的大小</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Arrays.copyOf(b,b.length*<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<p>排序</p>
<ul>
<li><code>Arrays.sort()</code>采用的是优化后的快速排序</li>
</ul>
</li>
</ul>
</li>
<li>
<p>多维数组</p>
<ul>
<li>
<p>声明： <code>int[][] balances;</code></p>
</li>
<li>
<p>同样，多维数组也要经过初始化才能够使用</p>
<ul>
<li><code>balances = new int[N][M];</code></li>
<li>或者这种形式</li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] magicSquare =</span><br><span class="line">   &#123;</span><br><span class="line">   &#123;<span class="number">16</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">13</span>&#125;,</span><br><span class="line">   &#123;<span class="number">5</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">8</span>&#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果要用for each循环去访问二维数组需要两层嵌套</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">double</span>[] row : a)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">double</span> value : row)&#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将二维数组转成字符串</p>
<ul>
<li><code>System.out.println(Arrays.deepToString(a));</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>不规则数组</p>
<ul>
<li>Java本质上没有多维数组，只有一维数组，多维数组被解释成数组的数组<br>
<img src="http://algorithm-image.qibinaoe.top/%E4%B8%8D%E8%A7%84%E5%88%99%E6%95%B0%E7%BB%84.png" alt="不规则数组.png"></li>
<li>如图，其实Java中就一维数组，而每个一维数组例如<code>balances[i]</code>引用这第i子数组</li>
<li>交换多维数组中的两行  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span>[] temp = balances[i];</span><br><span class="line">balances[i] = balances[i+<span class="number">1</span>];</span><br><span class="line">balances[i+<span class="number">1</span>] = temp; </span><br></pre></td></tr></table></figure>
</li>
<li>因此多维数组中，每一行的元素个数可以不同  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] odds = <span class="keyword">new</span> <span class="title class_">int</span>[NMAX+<span class="number">1</span>][];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>; n&lt;= NMAX; n++)&#123;</span><br><span class="line">  odds[n] = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>多维数组中<code>odds.length</code>指的不是包含子数组的长度，而是仅仅有多少行（结合图理解）  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>; n &lt; odds.length; n++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; odds[n].length; k++)&#123;</span><br><span class="line">      .....</span><br><span class="line">      odds[n][k] = n*k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="问题回答"><a class="header-anchor" href="#问题回答"> </a>问题回答</h4>
<ol start="2">
<li>取余和取模区别，</li>
</ol>
<ul>
<li>
<p>取余rem  取模mod</p>
</li>
<li>
<p>被除数 ➗ 除数 ＝ 商</p>
</li>
<li>
<p><strong>取余</strong>运算在计算中，使得<strong>商值</strong>向0的方向取整(换句话是说向0的方向舍弃小数位)</p>
</li>
<li>
<p><strong>取模</strong>运算在计算中，使得<strong>商值</strong>向负无穷的方向取整(换句话是说向负无穷的方向舍弃小数位)</p>
</li>
<li>
<p>结论</p>
<ul>
<li>当被除数和除数符号相同时(同正或同负)，取余和取模结果相同</li>
<li>当被除数和除数符号相反时(一正一负)，取余和取模结果不同</li>
</ul>
</li>
<li>
<p>前提： 对于一个除法(a = bq + r),如果 a不能被b整除（a÷b)，那么能够得到两种解，一种是bq &gt; a，使得r &lt; 0。另一种是bq&lt; a，使得r &gt; 0。</p>
</li>
<li>
<p>例子</p>
<ul>
<li>mod(7,3) = 1, rem(7,3) = 1</li>
<li>mod(-7,-3) = -1, rem(7,3) = 1</li>
<li>mod(7,-3) = -2, rem(7,-3) = 1
<ul>
<li>两种解: (-2,1) , (-3,-2)</li>
</ul>
</li>
<li>mod(-7,3) = 2, rem(-7,3) = -1
<ul>
<li>两种解: (-2,-1) , (-3,2)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Java中<code>%</code>是取余。<code>Math.floorMod</code>是取模</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">r1</span> <span class="operator">=</span> (<span class="number">7</span>%<span class="number">3</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">r2</span> <span class="operator">=</span> ((-<span class="number">7</span>)%(-<span class="number">3</span>));</span><br><span class="line"><span class="type">int</span> <span class="variable">r3</span> <span class="operator">=</span> ((-<span class="number">7</span>)%<span class="number">3</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">r4</span> <span class="operator">=</span> (<span class="number">7</span>%(-<span class="number">3</span>));</span><br><span class="line"><span class="type">int</span> <span class="variable">r5</span> <span class="operator">=</span> Math.floorMod(<span class="number">7</span>,<span class="number">3</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">r6</span> <span class="operator">=</span> Math.floorMod(-<span class="number">7</span>,-<span class="number">3</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">r7</span> <span class="operator">=</span> Math.floorMod(-<span class="number">7</span>,<span class="number">3</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">r8</span> <span class="operator">=</span> Math.floorMod(<span class="number">7</span>,-<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>输出</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">-<span class="number">1</span></span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">-<span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>参考来源<a href="https://blog.csdn.net/coder_panyy/article/details/73743722">取模和求余区别</a></p>
</li>
<li>
<p>参考来源<a href="https://www.zhihu.com/question/30526656">编程语言中，取余和取模的区别到底是什么？</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java核心技术</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术—对象与类</title>
    <url>/2020/11/11/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%80%94%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="Java核心技术——第四章-对象与类"><a class="header-anchor" href="#Java核心技术——第四章-对象与类"> </a>Java核心技术——第四章 对象与类</h1>
<!-- more -->
<ul>
<li>
<p>面向对象设计(Object-oriented programming ,OOP)</p>
</li>
<li>
<p>对象的三个主要特性</p>
<ul>
<li>对象的<strong>行为</strong>——可以对对象完成哪些操作，或者可以对对象应用哪些方法？</li>
<li>对象的<strong>状态</strong>——当调用那些方法时，对象会如何相应？
<ul>
<li>状态:每个对象都保存着描述当前状况的信息</li>
<li>状态可以随时间而发生改变，但是改变不是自发的</li>
<li>对象状态的改变必须通过调用方法实现（否则破坏了封装性）</li>
</ul>
</li>
<li>对象的<strong>标识</strong>——如何区分具有相同行为和状态的不同对象？</li>
</ul>
</li>
<li>
<p>面向对象的三个基本特征</p>
<ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
</li>
<li>
<p>创建类的实例(instance): 由类class(构造对象的模板或蓝图)构造construct对象的过程</p>
</li>
<li>
<p>封装(encapsulation)的关键在于程序只能通过对象的方法与对象数据进行交互，换句话说，绝对不能让类中的方法直接访问其他类的示例字段(instance field)</p>
</li>
<li>
<p>对别对象和对象变量的概念</p>
<ul>
<li><code>Date deadline;</code> 这是一个对象遍历啊你给，不是一个对象，并且没有引用任何对象</li>
<li>对象变量初始化的方法
<ol>
<li>引用一个新构造的对象 <code>deadline = new Date();</code></li>
<li>引用一个已存在的对象 <code>deadline = birthday;</code></li>
</ol>
</li>
<li>对象变量没有实际包含对象，而是引用一个对象</li>
<li>new操作符返回值是一个引用</li>
<li>所有的Java对象都存储在<em>堆</em>中。一个对象包含另一个对象变量时，它只是包含着另一个堆对象的指针</li>
<li>Java中必须使用<code>clone</code>方法来获得对象的完整副本</li>
</ul>
</li>
<li>
<p>UTC(Coordinated Universal Time) 国际协调时间</p>
</li>
<li>
<p>GMT(Greenwich Mean Time) 格林尼治时间</p>
</li>
<li>
<p>访问器方法(accessor method) 只访问对象而不修改对象的方法</p>
</li>
<li>
<p>修改器方法(mutator method) 访问对象后，对象的状态发生改变</p>
</li>
<li>
<p>一个源文件(.java)只能由一个公共类，但可以任意数目的非公共类</p>
<ul>
<li>在编译的时候会分别为每个类生成.class文件</li>
</ul>
</li>
<li>
<p>构造器</p>
<ul>
<li>构造器结合<code>new</code>运算符调用</li>
<li>不能对一个已经存在的对象调用构造器来达到重新设置实例字段的目的</li>
<li>构造器没有返回值</li>
</ul>
</li>
<li>
<p>不要在构造器中定义与实例字段同名的局部变量</p>
</li>
<li>
<p>隐式参数与显示参数</p>
<ul>
<li><code>employee.raiseSalary(1000);</code>
<ul>
<li><code>raiseSalary</code>方法有两个参数
<ol>
<li>隐式参数： <code>employee</code>出现在方法前的<code>Employee</code>类型对象（方法调用的目标或接收者）</li>
<li>显示参数： <code>1000</code>位于方法方法名后面括号中的数值</li>
</ol>
</li>
</ul>
</li>
<li>在每个方法中，关键字<code>this</code>指示隐式参数
<ul>
<li><code>this.salary += raise;</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>Java中所有的方法都必须在类的内部定义(不同于C++),但这不表示它们是内联方法。是否将某个方法设置为内联方法是Java虚拟机的任务。即时编辑器会监视那些简短的、经常调用而且没有被覆盖的方法调用，并进行优化。</p>
</li>
<li>
<p>访问器方法</p>
<ul>
<li>不要编写返回可变对象引用的访问器方法  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> Date  hireDay;</span><br><span class="line">  <span class="keyword">public</span> Date <span class="title function_">getHireDay</span><span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> hireDay; <span class="comment">//不要这样做。因为Date类有一个更改其的方法setTime,这样做会破坏封装性</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>如果需要返回一个可变对象的引用，应该先对其克隆(clone)再返回。<code>return (Date)hireDay.clone();</code></li>
</ul>
</li>
<li>
<p>基于类的访问权限</p>
<ul>
<li>方法可以访问调用这个方法的对象的私有数据</li>
<li>一个方法可以访问所属类的所有对象的私有数据(可读可修改)  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;good&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;good&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(e2.getSalary()); <span class="comment">// 20</span></span><br><span class="line">        System.out.println(e1.equals(e2)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(e2.getSalary()); <span class="comment">//1000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> salary;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String n, <span class="type">int</span> s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        salary = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Employee l)</span> &#123;</span><br><span class="line">        l.salary = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">return</span> name.equals(l.name);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>final实例字段</p>
<ul>
<li>实例字段定义为final
<ul>
<li>这些字段必须在构造对象时初始化，即每一个构造器执行之后，这些字段的值已经设置，并且以后不能再修改这个字段</li>
</ul>
</li>
<li>final修饰符对于类型为基本类型或不可变类(类中所有方法都不会改变其对象)的字段(String)</li>
<li>final修饰可变的类会造成混乱(StringBuilder)，因为final只表示储存在final修饰的变量的对象引用不会再知识另一个不同的对象，但是这个对象可以更改</li>
</ul>
</li>
<li>
<p>静态字段</p>
<ul>
<li>一个字段定义为<code>static</code>,则每个类只有一个这样的字段
<ul>
<li>这个类的所有实例都共享这个static修饰的静态字段</li>
<li>即使没有这个对象，静态字段仍然存在</li>
<li>静态字段属于类，不属于任何单个对象</li>
</ul>
</li>
<li>对于非静态的实例字段，每个对象都有自己的副本</li>
</ul>
</li>
<li>
<p>静态常量</p>
<ul>
<li><code>public static final double PI = 3.14159265358979323846;</code></li>
<li><code>public static final PrintStream out = ...;</code></li>
<li>在<code>System</code>类中，有个<code>setOut</code>方法能够修改<code>System.out</code>为不同的流，这个方法能够修改<code>final</code>修饰变量的值的原因是因为这是个<strong>原生方法</strong>,不是在Java语言实现的，绕过Java语言的访问控制机制。</li>
</ul>
</li>
<li>
<p>静态方法</p>
<ul>
<li>不在对象上执行的方法 <code>Math.pow(x, a)</code>, 由于不使用任何对象，因此它没有隐式参数</li>
<li>静态方法没有<code>this</code>参数</li>
<li>静态方法不能访问实例字段，但是可以访问静态字段</li>
<li>非静态方法也也可以访问静态字段  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getNextId</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> nextId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里的<code>static</code>可以省略，但这样一来就得通过对象引用来调用方法</li>
</ul>
</li>
<li>
<p>工厂方法</p>
<ul>
<li>静态工厂方法构造对象
<ul>
<li>无法命名构造器
<ul>
<li>希望有两个不同的名字得到不同的实例</li>
</ul>
</li>
<li>使用构造器，无法改变所构造对象的类型</li>
</ul>
</li>
</ul>
</li>
<li>
<p>每一个类都可以有一个<code>main</code>方法</p>
<ul>
<li>对类进行的单元测试的技巧</li>
</ul>
</li>
<li>
<p>方法参数</p>
<ul>
<li>按值调用(call by value)
<ul>
<li>接受调用者提供的值</li>
<li>方法不能修改按值传递的变量的值</li>
</ul>
</li>
<li>按引用调用(call by reference)
<ul>
<li>接受的是调用者提供的变量地址</li>
<li>方法可以修改按引用传递的变量的值</li>
</ul>
</li>
<li>Java总是采用<strong>按值调用</strong>
<ul>
<li>
<p>方法得到的是所有参数值的一个副本，方法不能修改传递给它的任何参数变量的内容</p>
</li>
<li>
<p>方法参数类型</p>
<ul>
<li>基本数据类型(数字、布尔值)</li>
<li>对象引用(<em>注：对象引用也是按值传递，不是按引用传递</em>)</li>
</ul>
</li>
<li>
<p>但是通过对象引用能够修改对象的参数状态，因为方法得到的是对象引用的一个副本，原来对象引用和副本都引用同一个对象</p>
</li>
<li>
<p>证明对象引用不是按引用传递</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Employee</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;bad&quot;</span>,<span class="number">10</span>);</span><br><span class="line">      <span class="type">Employee</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;good&quot;</span>,<span class="number">20</span>);</span><br><span class="line">      System.out.println(e1.getName()); <span class="comment">// bad</span></span><br><span class="line">      System.out.println(e2.getName()); <span class="comment">// good</span></span><br><span class="line">      swap(e1,e2);</span><br><span class="line">      System.out.println(e1.getName());<span class="comment">// bad</span></span><br><span class="line">      System.out.println(e2.getName());<span class="comment">// good</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Employee e1, Employee e2)</span> &#123;</span><br><span class="line">      <span class="type">Employee</span> <span class="variable">temp</span> <span class="operator">=</span> e1;</span><br><span class="line">      e1 = e2;</span><br><span class="line">      e2 = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String n, <span class="type">int</span> s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        salary = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>对象构造</p>
<ul>
<li>重载(overloading)
<ul>
<li>相同名字，不同参数。(不仅适用于构造器，Java允许重载任何方法)(注意区分重载(overload)和覆盖(override)区别)</li>
</ul>
</li>
<li>重载解析(overloading solution)
<ul>
<li>查找匹配的过程</li>
</ul>
</li>
<li>方法的<strong>签名</strong>: 方法名+参数类型
<ul>
<li>注意，返回值不是签名的一部分</li>
</ul>
</li>
</ul>
</li>
<li>
<p>默认字段初始化</p>
<ul>
<li>构造器没有显示为字段设置初值，会被自动赋为默认值
<ul>
<li>数值为<code>0</code></li>
<li>布尔值为<code>false</code></li>
<li>对象引用为<code>null</code></li>
</ul>
</li>
<li>注意：方法中的<strong>局部变量</strong>必须明确地初始化，否则会报错</li>
</ul>
</li>
<li>
<p>无参数构造器</p>
<ul>
<li>写类的时候没有编写构造器，会提供一个无参数构造器
<ul>
<li>所有实例字段设置为默认值</li>
</ul>
</li>
<li>仅当类没有任何其他构造器的时候，才会得到一个默认的无参数构造器
<ul>
<li>如果类提供了至少一个构造器，但是没有提供无参数的构造器，那么构造对象时如果不提供参数就是不合法</li>
</ul>
</li>
</ul>
</li>
<li>
<p>显式字段初始化</p>
<ol>
<li>
<p>类定义中直接为任何字段赋值</p>
<ul>
<li>
<p>执行构造器之前先完成赋值操作</p>
</li>
<li>
<p>希望将某个字段设置为同一值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Sting</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;...&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>利用方法调用初始化一个字段</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> nextId;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> assignId();</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">assignId</span><span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nextId;</span><br><span class="line">    nextId++;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<p><code>this</code>关键字调用另一个构造器</p>
<ul>
<li>
<p>构造器的第一个语句形如<code>this(...)</code>，构造器将调用同一个类的另一个构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Employee</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;bad&quot;</span>,<span class="number">10</span>);</span><br><span class="line">      <span class="type">Employee</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;good&quot;</span>,<span class="number">20</span>);</span><br><span class="line">      System.out.println(e1.getName()); <span class="comment">// bad</span></span><br><span class="line">      System.out.println(e2.getName()); <span class="comment">// good</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">&quot;HAHAH&quot;</span> + n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String n, <span class="type">int</span> s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>(n);</span><br><span class="line">        salary = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>初始化块(initialization block)</p>
<ul>
<li>首先运行初始化块，再运行构造器的主体部分</li>
<li>通常将初始化代码放在构造器里</li>
<li>建议将初始化块放在字段定义之后</li>
</ul>
</li>
<li>
<p>调用构造器的具体处理步骤</p>
<ol>
<li>如果构造器第一行调用了另一个构造器，则基于所提供的参数执行第二个构造器</li>
<li>否则
<ol>
<li>所有数据字段初始化为其默认值</li>
<li>按照类声明中出现的顺序，执行所有字段的初始化方法和初始化块</li>
</ol>
</li>
<li>执行构造器主题代码</li>
</ol>
</li>
<li>
<p>静态字段初始化</p>
<ol>
<li>提供初始值
<ul>
<li><code>private static int nextId = 1;</code></li>
</ul>
</li>
<li>静态的初始化块、</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">Random</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">  nextId = generator.nextInt(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>包</p>
<ul>
<li>一个类可以使用所属包的所有类，以及其他包的公共类</li>
<li>在包中定位类是编译器(compiler)的工作。</li>
<li>类文件中的字节码总是使用完整的包名引用其他类</li>
<li>在Java中，通过显式地给出类名(java.util.Date)，可以完全避免使用import机制</li>
</ul>
</li>
<li>
<p>静态导入</p>
<ul>
<li><code>import</code>语句允许导入静态方法和静态字段，而不只是类</li>
<li>源文件顶部添加<code>import static java.lang.System.*;</code>
<ul>
<li>就可以使用System类的静态方法和静态字段，不必加类名前缀</li>
<li><code>out.println(&quot;Godd bye&quot;);</code></li>
<li><code>exit(0);</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>包访问</p>
<ul>
<li><code>public</code>: 可以由任意类使用</li>
<li><code>private</code>: 只能由定义它们的类使用。（提示，变量必须显示的标记为<code>private</code>，否则将默认为包访问，会破坏封装性）</li>
<li>没有指定<code>public</code>和<code>private</code>的(类、方法、变量): 可以被同一个包的所有方法访问</li>
</ul>
</li>
<li>
<p>编译器查找文件</p>
<ul>
<li>如果引用了一个类而没有指定这个类的包(不是这样<code>Date deadline = new java.util.Date();</code>),它首先查找包含这个类的包(通过<code>import</code>指令，来确定其中是否包含这个类)</li>
<li>如果找到了一个以上的类，就会产生编译时错误(因为完全限定类名必须是唯一的，与import次序无关)</li>
</ul>
</li>
<li>
<p><code>java.lang</code>包总会默认导入</p>
</li>
<li>
<p>JAR(Java Archive)</p>
<ul>
<li>JAR文件使用ZIP格式组织文件和子目录，可以使用任何ZIP工具查看JAR文件</li>
<li>Java归档文件</li>
<li>可以包含类也可以包含图片和声音等其他类型的文件</li>
<li>创建JAR文件
<ul>
<li><code>jar cvf jarFileName file1 file2...</code>
<ul>
<li>例如<code>jar cvf CalculatorClasses.jar *.class icon.gif</code></li>
</ul>
</li>
</ul>
</li>
<li>jar程序的选项类似Unix tar命令的选项</li>
<li>清单文件(mainfest)
<ul>
<li>包含在JAR文件当中，一个特殊的<code>META-INF</code>的子目录的</li>
<li>清单文件被命名为<code>MAINFEST.MF</code></li>
<li>清单文件被分成多个节
<ul>
<li>第一节称为主节(main section)</li>
<li>随后的条目用来指定命名实体的属性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>文档注释 javadoc</p>
<ul>
<li>
<p>javadoc抽取信息，为一下特性编写注释</p>
<ul>
<li>模块</li>
<li>包</li>
<li>公共类与接口</li>
<li>公共的和受保护的字段</li>
<li>公共的和受保护的构造器及方法</li>
</ul>
</li>
<li>
<p>注释放置在所描述特性的前面</p>
</li>
<li>
<p>注释以<code>/**</code>开始，以<code>*/</code>结束</p>
</li>
<li>
<p>自由格式文本(free-form text)</p>
</li>
<li>
<p>标记以@开始，如@since、@param</p>
</li>
<li>
<p>自由格式文本第一句应该是一个概要性的句子，javadoc工具将这些句子抽取出生成概要页</p>
</li>
<li>
<p>自由格式文本中可以使用html修饰符</p>
<ul>
<li><code>&lt;em&gt; ... &lt;/em&gt;</code> 强调</li>
<li><code>&lt;strong&gt; ... &lt;/strong&gt;</code> 着重强调</li>
<li><code>&lt;img ...&gt;</code> 图片</li>
<li><code>&#123;@code ...&#125;</code>等宽代码</li>
</ul>
</li>
<li>
<p>类注释</p>
<ul>
<li>类注释必须放在import语句之后，类定义之前</li>
</ul>
</li>
<li>
<p>方法注释</p>
<ul>
<li>方法必须放在所描述的方法之前</li>
<li>除了通用标记，还能使用以下标记
<ul>
<li><code>@param variable description</code>
<ul>
<li>给当前方法的参数部分添加条目</li>
<li>可以占据多行</li>
<li>一个方法的所有<code>@param</code>必须放在一起</li>
</ul>
</li>
<li><code>@return description</code>
<ul>
<li>给当前方法添加返回部分</li>
<li>可以跨多行</li>
</ul>
</li>
<li><code>@throws class description</code>
<ul>
<li>表示方法可能抛出异常</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>字段注释</p>
<ul>
<li>只需要对公共字段(通常指静态常量<code>public static final</code>)建立文档</li>
</ul>
</li>
<li>
<p>通用注释</p>
<ul>
<li><code>@since text</code>
<ul>
<li>建立一个&quot;since&quot;(始于)条目</li>
<li>&quot;text&quot;可以是引入这个特性的版本任何描述
<ul>
<li><code>@since 1.7.1</code></li>
</ul>
</li>
</ul>
</li>
<li><code>@author name</code>
<ul>
<li>作者条目</li>
<li>可以使用多个<code>@author</code>标记</li>
</ul>
</li>
<li><code>version text</code>
<ul>
<li>版本条目</li>
<li>对当前版本的任何描述</li>
</ul>
</li>
<li><code>@see</code>和<code>@link</code>
<ul>
<li>可以使用超链接，链接到javadoc文档的相关部分或外部文档</li>
<li><code>@see reference</code>
<ul>
<li>将在&quot;see also&quot;部分增加一个超链接</li>
<li>可用于类和方法</li>
<li><em>reference</em>可以有以下选择
<ol>
<li><code>package.class#feature label</code>
<ul>
<li>例如<code>@see com.horstmann.corejava.Employee#raiseSalary(double)</code></li>
<li>包名或包名和类名都可以省略，这样会定位于当前包或当前类</li>
</ul>
</li>
<li><code>&lt;a href=&quot;...&quot;&gt;label&lt;/a&gt;</code>
<ul>
<li><code>@see &lt;a href=&quot;www.horstmann.com/corejava.html&quot;&gt;The Core Java home page&lt;/a&gt;</code></li>
</ul>
</li>
<li><code>&quot;text&quot;</code>
<ul>
<li><code>@see &quot;Core Java 2 volume 2&quot;</code></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><code>&#123;@link package.class#feature lable&#125;</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>包注释</p>
<ul>
<li>需要在每个包目录中添加一个单独文件
<ol>
<li>提供<em>package-info.java</em>的Java文件</li>
</ol>
<ul>
<li>该文件包含一个初是的以<code>/**</code>和<code>*/</code>界定的javadoc注释</li>
<li>后面是一个package语句</li>
</ul>
<ol start="2">
<li>提供<code>package.html</code>的HTML文件
<ul>
<li>会抽取<code>&lt;body&gt;&lt;/body&gt;</code>之间所有文本</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>类设计技巧</p>
<ul>
<li>一定要保证数据私有
<ul>
<li>绝对不要破坏封装性</li>
</ul>
</li>
<li>一定要对数据进行初始化
<ul>
<li>不要依赖系统的默认值</li>
<li>自己提供默认值</li>
<li>所有构造器中设置默认值</li>
</ul>
</li>
<li>不要再类中使用过多的基本类型
<ul>
<li>用其他类替换使用多个相关的基本类型</li>
</ul>
</li>
<li>不是所有的字段都需要单独的字段访问器和字段更改器</li>
<li>分解有过多指责的类</li>
<li>类名和方法名要能够体现出它的职责</li>
<li>优先使用不可变类
<ul>
<li>并发更改：多个线程试图同时更新一个对象</li>
<li>如果类是不变的，可以安全地在多个线程间共享其对象</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java核心技术</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术——异常、断言和日志</title>
    <url>/2020/11/30/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%80%94%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="Java核心技术-第七章-异常、断言和日志"><a class="header-anchor" href="#Java核心技术-第七章-异常、断言和日志"> </a>Java核心技术 第七章 异常、断言和日志</h1>
<!-- more --> 
<h2 id="处理错误"><a class="header-anchor" href="#处理错误"> </a>处理错误</h2>
<p>Java使用异常处理(exception handing)的错误捕获机制</p>
<p>异常处理的任务是将控制权从<em>产生错误</em>的地方转移到能够<em>处理这种情况的错误处理器</em></p>
<p>错误的问题</p>
<ul>
<li>用户输入错误</li>
<li>设备错误</li>
<li>物理限制</li>
<li>代码错误</li>
</ul>
<p>如果方法不能够以正确的途径完成任务，可以抛出(throw)一个封装了错误信息的对象。这个方法会<strong>立刻</strong>退出，并<strong>不返回正常值</strong>(或任何值)。同时异常处理机制开始搜索能够处理这种异常状况的异常处理器(exception handler)</p>
<h3 id="异常对象"><a class="header-anchor" href="#异常对象"> </a>异常对象</h3>
<p>所有异常都是派生于<code>Throwable</code>类的一个类实例</p>
<ul>
<li><code>Throwable</code>
<ul>
<li><code>Error</code></li>
<li><code>Exception</code>
<ul>
<li>其他异常(例如<code>IOException</code>)</li>
<li><code>RuntimeException</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>Throwable</code>分成<code>Error</code>和<code>Exception</code>。</p>
<p><code>Error</code>类层描述Java运行时，系统的内部错误和资源耗尽错误。我们自身的程序不应该抛出这种类型对象。出现这种内部错误应该通知用户和妥善终止程序。</p>
<p><code>Exception</code>层分成两个分支：一个派生于<code>RuntimeException</code>，另一个分支包含其他异常。</p>
<p>由编译错误导致的异常属于<code>RuntimeException</code></p>
<ul>
<li>错误的强制类型转换</li>
<li>数组访问越界</li>
<li>访问null指针</li>
</ul>
<blockquote>
<p>如果出现<code>RuntimeException</code>异常，那么就一定是你的问题</p>
</blockquote>
<p>程序本身没有问题，由于像I/O错误这类问题导致的异常属于其他异常</p>
<p>不是派生于<code>RuntimeException</code>类的异常</p>
<ul>
<li>试图超越文件我末尾继续读取数据</li>
<li>试图打开一个不存在的文件</li>
<li>试图根据给定的字符串查找<code>Class</code>对象，而这个字符串表示的类不存在</li>
</ul>
<p>非检查型(unchecked)异常</p>
<ul>
<li>派生于<code>Error</code>类</li>
<li>派生与<code>RuntimeException</code>类</li>
</ul>
<p>检查型(checked)异常</p>
<ul>
<li>所有其他的异常</li>
</ul>
<p>编译器将检查是否为所有的<strong>检查型异常</strong>提供了<strong>异常处理器</strong></p>
<p>方法不仅需要告诉编译器将要返回什么值，还要告诉编译器有可能发生什么错误</p>
<p>要在方法的首部指出这个方法可能抛出一个异常，以反映这个方法可能抛出的<strong>检查型异常</strong> <code>public FileInputStream(String name) throws FileNotFoundException</code></p>
<p>如果真的抛出了一个异常对象，运行时，系统就会开始搜索知道如何处理<code>FileNotFoundException</code>对象的异常处理器</p>
<h4 id="检查型异常"><a class="header-anchor" href="#检查型异常"> </a>检查型异常</h4>
<p>会抛出异常的情况:</p>
<ul>
<li>调用一个抛出<strong>检查型异常</strong>的方法，如<code>FileInputStream</code>构造器</li>
<li>检测到一个错误，并且利用throw语句抛出一个检查型异常</li>
<li>程序出现错误，例如<code>a[-1] = 0;</code>会抛出一个非检查型异常(<code>ArrayIndexOutOfBoundsException</code>)</li>
<li>Java虚拟机或运行时库出现内部错误</li>
</ul>
<p>异常规范(exception specification)声明</p>
<p>一个方法可能抛出多个<strong>检查型异常类型</strong>，在方法首部列出所有的<strong>异常类</strong>，每个异常类之间用逗号隔开</p>
<ul>
<li>一个方法必须声明所有可能抛出的检查型异常</li>
<li>非检查型异常
<ul>
<li>不需要声明Java的内部错误，即从<code>Error</code>继承的异常
<ul>
<li>在我们控制之外</li>
</ul>
</li>
<li>不应该声明从<code>RuntimeException</code>继承的非检查型异常
<ul>
<li>这种错误在我们控制中，应该从一开始去避免。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如果子类覆盖超类的第一个方法</p>
<ul>
<li><em>子类</em>方法中声明的检查型异常<strong>不能</strong>比<em>超类</em>方法中声明的异常更<em>通用</em>
<ul>
<li>子类可以抛出更特定的异常或者不抛出异常</li>
</ul>
</li>
<li><em>超类</em><strong>没有</strong>抛出任何检查型异常，<em>子类</em>也<strong>不能抛出</strong>任何检查型异常</li>
</ul>
<p>抛出的异常实例可能属于声明的异常的类，也可能属于这个类的任意一个子类</p>
<h4 id="抛出异常的方式"><a class="header-anchor" href="#抛出异常的方式"> </a>抛出异常的方式</h4>
<ul>
<li>找到一个合适的异常类</li>
<li>创建这个类的一个对象</li>
<li>将对象抛出</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">readData</span><span class="params">(Scanner in)</span> <span class="keyword">throws</span> EOFException</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span>(...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!in.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n&lt;len)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EOFException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建异常类"><a class="header-anchor" href="#创建异常类"> </a>创建异常类</h4>
<p>情况：遇到任何标准异常类都无法描述清楚的问题</p>
<p>派生于<code>Exception</code>的类或派生于<code>Exception</code>的某个子类</p>
<p>写两个构造器：一个是默认的构造器，一个是包含详细描述信息的构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileFormatException</span> <span class="keyword">extends</span> <span class="title class_">IOException</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileFormatException</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileFormatException</span><span class="params">(String grip)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(grip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="捕获异常"><a class="header-anchor" href="#捕获异常"> </a>捕获异常</h3>
<h4 id="捕获异常-v2"><a class="header-anchor" href="#捕获异常-v2"> </a>捕获异常</h4>
<p>如果发生异常，但没有在任何地方捕获这个异常，储层徐就会终止，并在控制台上打印这个异常的类型和一个堆栈轨迹</p>
<p>捕获异常需要设置try/catch语句块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    code</span><br><span class="line">    more code</span><br><span class="line">   	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ExceptionType e)</span><br><span class="line">&#123;</span><br><span class="line">    handle <span class="keyword">for</span> <span class="built_in">this</span> type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果try语句块中任何代码抛出了catch子句指定的一个异常类
<ul>
<li>程序将跳过try语句块的其余代码</li>
<li>层序执行catch子句中处理器代码</li>
</ul>
</li>
<li>如果try语句块中的代码没有抛出任何异常，那么程序跳过catch子句</li>
<li>如果方法中任何代码抛出了catch子句中没有声明的一个异常类型
<ul>
<li>方法立即退出</li>
</ul>
</li>
</ul>
<p>如果编写一个方法覆盖超类的方法，而超类方法中没有抛出异常，则必须捕获方法代码中出现的每一个检查型异常。即不允许子类的throws说明符中出现超类方法未列出的异常类</p>
<h4 id="捕获多个异常"><a class="header-anchor" href="#捕获多个异常"> </a>捕获多个异常</h4>
<p>对不同类型的异常做出不同的处理为每个异常类型使用一个单独的catch子句，在Java 7中，同一个catch子句中可以捕获多个异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    code that might <span class="keyword">throw</span> exceptions</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (FileNotFoundException | UnknownHostException e)</span><br><span class="line">&#123;</span><br><span class="line">    emergency action <span class="keyword">for</span> missing files and unknown hosts</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOExeption e)</span><br><span class="line">&#123;</span><br><span class="line">    emergency action <span class="keyword">for</span> all other I/O problems</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>e.getMessage</code> 获得更多信息</p>
</li>
<li>
<p><code>e.getClass().getName()</code> 异常对象的实际类型</p>
</li>
</ul>
<p>捕获多个异常时，异常变量隐含为<code>final</code>变量</p>
<p>捕获多个异常会让代码更简单和高效</p>
<h4 id="再次抛出异常与异常链"><a class="header-anchor" href="#再次抛出异常与异常链"> </a>再次抛出异常与异常链</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    access the database</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (SQLException original)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ServletException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;database error&quot;</span>);</span><br><span class="line">    e.initCause(original);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="finally-子句"><a class="header-anchor" href="#finally-子句"> </a>finally 子句</h5>
<p>不管是否有异常被捕获，finally子句的代码都会执行</p>
<p>finally子句用于处理资源分配后的清理</p>
<p>try语句可以只有finally子句而没有catch子句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    code that might <span class="keyword">throw</span> exception</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    show error message</span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 6  我是finnaly子句后的第一条语句 </span></span><br></pre></td></tr></table></figure>
<p>情况分析</p>
<ul>
<li><strong>代码没有抛出异常</strong>，程序首先执行try语句块中全部代码，然后执行finally子句中的代码，再执行finally子句之后的第一条语句
<ul>
<li>即 1、2、5、6</li>
</ul>
</li>
<li><strong>代码抛出异常并在catch中捕获</strong>
<ul>
<li>try中执行到语句发生异常的位置，跳过try中的剩余部分代码，在一个catch子句中捕获。执行catch子句中的代码，最后执行finally子句中的代码
<ul>
<li>如果catch子句没有抛出异常，则将执行finally子句后的第一条语句
<ul>
<li>执行顺序为1、3、4、5、6</li>
</ul>
</li>
<li>如果catch子句抛出异常，则异常将抛回这个方法的调用者
<ul>
<li>执行顺序为1、3、5</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>代码抛出了一个异常，但没有任何catch子句捕获这个异常</strong>。程序执行try语句块的语句直到抛出异常位置，然后跳过try语句块中剩余代码，然后执行finally子句的语句，并将异常返回给这个方法的调用者
<ul>
<li>执行顺序1、5</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        code that might <span class="keyword">throw</span> exception</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException)</span><br><span class="line">&#123;</span><br><span class="line">    show error message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>内层try语句块时确保关闭输入流</li>
<li>外层try语句块时确保报告出现的错误</li>
</ul>
<p><strong>finally子的体，用于清理资源。不要把改变控制流的语句(return, throw, break, continue)放在finally子句中</strong></p>
<p>错误示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">parseInt</span><span class="params">(String s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//ERROR</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在方法返回前，会执行finally子句块，如果finally块也有一个return语句，这个返回值将会遮蔽原来的返回值</li>
</ul>
<p><strong>问题</strong>:这里的返回值是多少?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> at.method();</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案是100;</p>
<p>反编译后的代码大致为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">return</span> j;</span><br></pre></td></tr></table></figure>
<p><strong>问题2</strong>：会打印finally吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try...&quot;</span>);</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案是：只打印了&quot;try…&quot;，因为执行<code>System.exit(0);</code>后，JVM已经退出了</p>
<h4 id="try-with-resources-Java-7新特性"><a class="header-anchor" href="#try-with-resources-Java-7新特性"> </a>try-with-resources (Java 7新特性)</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Closeable</span> <span class="keyword">extends</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>try-with-resources语句(带资源的try语句)的最简形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> ...)</span><br><span class="line">&#123;</span><br><span class="line">    work with res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>try块退出时，会自动调用<code>res.close();</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(<span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./word.txt&quot;</span>), StandardCharsets.UTF_8);</span><br><span class="line">    <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="string">&quot;./out.txt&quot;</span>,StandardCharsets.UTF_8))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (in.hasNext())</span><br><span class="line">    &#123;</span><br><span class="line">        out.println(in.next().toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>try()</code>中如果只有一个资源，不用分号。如果有多个资源，最后一个资源后面不用分号。</p>
<p>try-with-resources能够自动清理资源，但是还是要写<code>throws</code>或者<code>catch</code>语句</p>
<h3 id="使用异常的技巧"><a class="header-anchor" href="#使用异常的技巧"> </a>使用异常的技巧</h3>
<ul>
<li>异常处理不能代替简单的判断
<ul>
<li>基本规则：只在异常情况下使用异常</li>
</ul>
</li>
<li>不要过分地细化异常
<ul>
<li>极端例子：每个句子都写一个try</li>
<li>承诺：将正常处理与错误处理分开</li>
</ul>
</li>
<li>充分利用异常的层次结构
<ul>
<li>应该寻找一个适合的子类或创建自己的异常类</li>
<li>不要为逻辑错误抛出异常</li>
<li>能够将一种异常转换成另一种更加合适的异常，那么不要犹豫。</li>
</ul>
</li>
<li>不要压制异常</li>
<li>在检测错误时，“苛刻”比放任更好</li>
<li>不要羞于传递异常</li>
</ul>
<h2 id="断言"><a class="header-anchor" href="#断言"> </a>断言</h2>
<p>关键字<code>assert</code></p>
<p>形式</p>
<ul>
<li>
<p><code>assert conditon</code></p>
</li>
<li>
<p><code>assert condition : expression</code></p>
</li>
</ul>
<p>Java中3种处理系统错误的机制</p>
<ul>
<li>抛出一个异常</li>
<li>日志</li>
<li>使用断言</li>
</ul>
<p>使用断言的场景</p>
<ul>
<li>断言失败是致命的、不可恢复的错误</li>
<li>断言检查只是在开发和测试阶段打开</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java核心技术</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术—接口、lambda表达式与内部类</title>
    <url>/2020/11/22/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%80%94%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="Java核心技术-第六章-接口、lambda表达式与内部类"><a class="header-anchor" href="#Java核心技术-第六章-接口、lambda表达式与内部类"> </a>Java核心技术 第六章 接口、lambda表达式与内部类</h2>
<h3 id="接口"><a class="header-anchor" href="#接口"> </a>接口</h3>
<!-- more -->
<p>接口<em>不是</em>类，而是对希望符合这个接口的<em>类</em>的一组<em>需求</em></p>
<p>接口用来描述类应该做什么，而不指定它们具体应该如何做</p>
<p>举例，<code>Arrays</code>类中的<code>sort</code>方法实现了对对象数组进行排序，但是当然不是任意的对象数组都能够进行排序，因此，如果想使用<code>sort</code>方法进行排序，则对象所属的类必须实现<code>Comparable</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T o)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现Comparable接口的类，都需要包含compareTo方法，这里Comparable接口为一个泛型类型，因此实现该接口的时候需要带上类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Employee&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Employee o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Comparable也可以使用不带类型参数的，但是这样在实现的方法里就有Object类型的参数，需要手动的进行强制转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">other</span> <span class="operator">=</span> (Employee)o;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><em>接口</em>中所有<em>方法</em>都是自动是<strong>public</strong>方法，可以不提供关键字<em>public</em>,但是提供也是可以的</p>
</li>
<li>
<p>在实现接口的类中，重写的方法必须明确声明为<strong>public</strong>,否则编译器会认为是包可见性而报错。</p>
</li>
<li>
<p>接口可以定义常量</p>
</li>
<li>
<p>接口<strong>没有</strong><em>实例字段</em></p>
</li>
</ul>
<p>实现接口的步骤</p>
<ol>
<li>将类声明为实现给定的接口</li>
<li>对接口中的所有方法提供定义</li>
</ol>
<hr>
<p>书上问题：</p>
<blockquote>
<p>为什么不能直接在类中直接提供一个<code>compareTo</code>方法，而必须实现<code>Comparable接口</code>呢？</p>
</blockquote>
<p>回答</p>
<blockquote>
<p>Java是一种强类型(strongly typed)语言，调用方法的时候，编译器要检查该方法确实存在。如果一个类实现了Comparable的接口，可以确保拥有compareTo方法，</p>
</blockquote>
<p>书上问题：</p>
<blockquote>
<p>对于继承了实现Comparable接口的子类之间比较的问题</p>
</blockquote>
<p>解决办法：</p>
<ul>
<li>如果不同子类中的比较有不同的含义(意思就是同一个类中可以进行比较，但是与另一个类无法进行比较)，应该将属于不同类的对象之间的比较视为非法的。每个compareTo方法开始时进行检测 <code>if(getClass() != other.getClass()) throw new ClassCastException();</code></li>
<li>如果存在一个能够比较子类对象的通用算法，可以在超类中提供一个compareTo方法，并将这个方法声明为final</li>
</ul>
<hr>
<p>接口不能用<code>new</code>运算符实例化一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x = <span class="keyword">new</span> <span class="title class_">Comparable</span>(...) <span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>
<p>能够声明接口的变量，同时该接口变量必须引用实现了这个接口的类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparable x; <span class="comment">// OK</span></span><br><span class="line">x = <span class="keyword">new</span> <span class="title class_">Employee</span>(...) <span class="comment">//Employee必须实现Comparable接口才能够引用</span></span><br></pre></td></tr></table></figure>
<p>使用<code>instanceof</code>来检查一个对象是否实现了某个特定的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( anObject <span class="keyword">instanceof</span> Comparable) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>接口链： 从通用性较高的接口扩展到专用性较高的接口</p>
<ul>
<li>接口通过<code>extends</code>来实现接口的扩展</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Moveable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Powered</span> <span class="keyword">extends</span> <span class="title class_">Moveable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">milesPerGallon</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">SPEED_LIMIT</span> <span class="operator">=</span> <span class="number">95</span>; <span class="comment">// a public static final constant</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>接口中的<em>方法</em>都自动设置为<strong>public</strong></p>
</li>
<li>
<p>接口中的<em>字段</em>总是<strong>public</strong> <strong>static</strong> <strong>final</strong></p>
<ul>
<li>注：在接口中可以显示的标记出来，也可以不标记出来</li>
</ul>
</li>
<li>
<p>每个类只能有一个超类</p>
</li>
<li>
<p>每个类能够实现多个接口</p>
<ul>
<li>实现多个接口用逗号隔开: <code>class Employee implements Cloneable, Comparable</code></li>
</ul>
</li>
</ul>
<hr>
<p>书上问题：</p>
<blockquote>
<p>为什么不直接继承抽象类？</p>
</blockquote>
<p>回答：</p>
<blockquote>
<p>Java每个类只能扩展一个类</p>
</blockquote>
<p>书上问题：</p>
<blockquote>
<p>为什么Java不采用多重继承(multiple inheritance)</p>
</blockquote>
<p>回答：</p>
<blockquote>
<p>多重继承会让语言变得复杂和效率低下</p>
</blockquote>
<hr>
<p>允许在接口中添加静态(statics)方法，但是有违将接口作为抽象规范的初衷</p>
<p>通常做法：将静态方法放在伴随类中，例如表中库的中接口和实用工具类成对出现，Collection/Collections 和Path/Paths</p>
<h4 id="默认方法"><a class="header-anchor" href="#默认方法"> </a>默认方法</h4>
<p>用<code>default</code>修饰符来标记默认方法</p>
<p>可以为<em>接口</em>实现<em>默认</em>方法</p>
<p>如果一个<em>接口</em>(<code>interface</code>)中有<code>default</code>标识的方法，实现这个接口的类可以不用实现<code>default</code>标识的方法，但是还是一定要实现不是<em>默认方法</em>，也不是<em>静态方法</em>。</p>
<p>默认方法的好处就是保证了<em>源代码兼容(source compatible)</em>，<em>接口演化(interface evolution)</em></p>
<p>默认方法里面可以调用其他方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="默认方法冲突"><a class="header-anchor" href="#默认方法冲突"> </a>默认方法冲突</h4>
<p>情景：一个接口中有默认方法，同时在超类或者另一个接口也有定义同样的方法</p>
<p>解决规则</p>
<ul>
<li>
<p><strong>超类优先</strong></p>
<ul>
<li>如果超类提供具体的方法，同名且有相同参数类型(签名相同)的默认方法会被忽略</li>
</ul>
</li>
<li>
<p><em>接口</em>冲突的情况</p>
<ul>
<li>如果一个接口提供默认方法，另一个接口提供了同名且参数类型相同的方法(无论是否是默认参数)，<strong>必须覆盖这个方法</strong>解决冲突
<ul>
<li>
<p>重新写这个方法</p>
</li>
<li>
<p>使用其中一个接口实现的方法，这里要加<code>super</code>才能够使用这个方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mystyle</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span>,MyInterface2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodDefault</span><span class="params">()</span> &#123;</span><br><span class="line">        MyInterface.<span class="built_in">super</span>.methodDefault();  <span class="comment">// methodDefault MyInterface</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">methodDefault</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodDefault MyInterface&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodStatic</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodStatic&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">methodDefault</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodDefault MyInterface2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodStatic</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodStatic2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如果一个类<em>implements</em>一个接口，但是不实现里面的方法，就需要将该类定义为抽象类(abstract)</p>
<p>不要让静默方法重新定义Object类中的方法，因为所有类都继承Object类，根据类优先的原则，静默方法里面定义的Object类的方法是没有效果的。</p>
<h4 id="接口与回调"><a class="header-anchor" href="#接口与回调"> </a>接口与回调</h4>
<p>回调(callback)： 指定某个特定事件发生时应该采取的动作</p>
<p>对于事件发送时应该采取的<strong>动作</strong>，Java不是通过传入一个函数，而是通过传入一个对象。调用该对象实现的方法即为动作。那么怎么知道应该调用哪个动作呢？因此该类应该去实现某个接口(interface)，通过重写该接口中的方法来明确这个动作。</p>
<p>例如一个定时器<code>Timer</code>类，通过一定时间间隔调用一个方法</p>
<p>这是<code>Timer</code>的构造器，可以看到其中一个参数是<code>ActionListener listener</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Timer</span><span class="params">(<span class="type">int</span> delay, ActionListener listener)</span> &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>ActionListener</code>,这是一个接口，因此如果想要实现这个功能，需要写一个类去继承该接口，并实现这个方法，传入<code>Timer</code>，这样就能够正确的调用所需要触发的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ActionListener</span> <span class="keyword">extends</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Invoked when an action occurs.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Comparator-接口"><a class="header-anchor" href="#Comparator-接口"> </a>Comparator 接口</h4>
<p>需求：如果我们想按照自己的需求对于字符串(String)进行比较排序，例如按照长度进行排序，并不关心字典顺序。那么让<code>String</code>类实现<code>Comparable</code>接口是行不通的。</p>
<p>原因有两个</p>
<ol>
<li>最根本的原因是<code>String</code>是final类，不能够继承来重写方法</li>
<li>即使我们可以重写<code>String</code>实现<code>Comparable</code>接口的<code>compareTo</code>方法，但是对于新的需求的时候，还得去改代码，这样不太方便和现实，因为<code>compareTo</code>方法只能写一个</li>
</ol>
<p>因此<code>Arrays.sort()</code>有第二个版本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">        sort(a);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">            legacyMergeSort(a, c);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            TimSort.sort(a, <span class="number">0</span>, a.length, c, <span class="literal">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个参数是要被排序的数组，第二个参数即为一个比较器(comparator)。该比较器是实现了<code>Comparator</code>接口的类的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此我们可以这样实现一个比较器的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LengthComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;String&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.length() - o2.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在传入<code>Arrays.sort()</code>时，比较器的参数需要实例化，因为<code>Arrays.sort()</code>内部是通过调用对象的方法进行比较的:<code>if (c.compare(a[runHi++], a[lo]) &lt; 0)</code></p>
<h4 id="对象克隆"><a class="header-anchor" href="#对象克隆"> </a>对象克隆</h4>
<ul>
<li>
<p>用<code>=</code>来为一个包含对象引用的变量建立副本时，只是将原变量和副本指向<em>同一个对象的引用</em></p>
</li>
<li>
<p>Object类中有一个声明为protected的clone方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br></pre></td></tr></table></figure>
<ul>
<li>浅拷贝
<ul>
<li>Object类中这个clone方法默认是浅拷贝，即没有克隆对象中引用的其他对象</li>
<li>如果对象中的所有数字段都是数值或其他基本类型，拷贝字段没有问题</li>
<li>如果对象包含子对象的引用，拷贝字段就会得到相同子对象的另一个引用
<ul>
<li>原对象和克隆的对象会共享信息</li>
</ul>
</li>
<li>如果原对象和浅克隆对象<em>共享</em>的子对象是不可变的类(例如 String)，则共享安全</li>
<li>如果共享子对象一直包含不变的常量、没有更改其方法改变它、没有方法生成引用，则也是安全</li>
</ul>
</li>
<li>深拷贝(deep copy)
<ul>
<li>克隆对象的时候同时克隆所有子对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>对于克隆对象需要确定几点</p>
<ol>
<li>默认的clone方法是否满足要求</li>
<li>是否可以在可变的子对象调用clone来修补默认的clone方法</li>
<li>是否不该使用clone</li>
</ol>
<p>如果需要使用clone方法有以下步骤</p>
<ol>
<li>实现Cloneable接口</li>
<li>重新定义clone方法，并指定public访问修饰符</li>
</ol>
<p>注意</p>
<ul>
<li>
<p>如果要使用clone的方法，虽然重写了clone方法，却没有实现Cloneable的接口，会抛出异常<code>java.lang.CloneNotSupportedException</code></p>
</li>
<li>
<p>将修饰符改成public的原因是为了在所有的方法都能够克隆对象</p>
</li>
<li>
<p>标记接口(tagging interface) 记号接口(marker interface)</p>
<ul>
<li>标记接口不包含任何方法</li>
<li>唯一作用是允许在类型查询中使用<code>instanceof</code>
<ul>
<li>例如<code>if(obj instanceof Cloneable)...</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Cloneable里面没有方法，clone方法是从Object类继承的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现浅拷贝</p>
<ol>
<li>实现Cloneable接口</li>
<li>clone定义为public</li>
<li>调用super.clone()</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Father <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (Father) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Object类中返回类型是Object类，根据协变返回类型，可以在子类中指定正确的返回类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br></pre></td></tr></table></figure>
<p>实现深拷贝</p>
<p>实现深拷贝除了浅拷贝的基础上实现的基本类型，还需要克隆对象中可变的实例字段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">cloned</span> <span class="operator">=</span> (Employee) <span class="built_in">super</span>.clone();</span><br><span class="line"></span><br><span class="line">        cloned.hireDay = (Date) hireDay.clone();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>所有数组类型都有一个公共(public)的clone方法，可以建立一个新数组，包含原数组所有元素的副本</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] cloned = nums.clone();</span><br><span class="line">cloned[<span class="number">2</span>] = <span class="number">100</span>;</span><br><span class="line">System.out.println(Arrays.toString(nums)); <span class="comment">// [2, 3, 5, 7, 11, 13]</span></span><br><span class="line">System.out.println(Arrays.toString(cloned)); <span class="comment">// [2, 3, 100, 7, 11, 13]</span></span><br></pre></td></tr></table></figure>
<h2 id="lambda表达式"><a class="header-anchor" href="#lambda表达式"> </a>lambda表达式</h2>
<p>lambda表达式是一个可传递的<em>代码块</em>，可以在以后执行一次或多次</p>
<p>场景：一个代码块传递到某个对象中，这个代码块会在将来某个时间调用</p>
<p>lambda表达式形式</p>
<ul>
<li>参数</li>
<li>箭头(-&gt;)</li>
<li>一个表达式
<ul>
<li>如果代码要完成的计算无法放在一个标傲世中，可以像写方法一样放在<code>&#123;&#125;</code>中，并包含显示的return语句</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(planets,(String first, String second) -&gt;</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span>(first.length() &lt;  second.length()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">if</span>(first.length() &gt;  second.length()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                        &#125;);</span><br></pre></td></tr></table></figure>
<p>如果lambda表达式没有参数，仍要提供空括号</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">() -&gt; &#123;<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) System.out.println(i);&#125;</span><br></pre></td></tr></table></figure>
<p>如果可以推导出一个lambda表达式的参数类型，则可以忽略其类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;String&gt; comp</span><br><span class="line">    = (first, second)</span><br><span class="line">        -&gt; first.length()-second.length();</span><br></pre></td></tr></table></figure>
<p>如果方法只有一个参数且这个参数类型可以推导出，则可以省略小括号</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ActionListener</span> <span class="variable">listener</span> <span class="operator">=</span> event -&gt;</span><br><span class="line">    System.out.println(<span class="string">&quot;The time is&quot;</span></span><br><span class="line">        + Instant.ofEpochMilli(event.getWhen()));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">500</span>, event -&gt;</span><br><span class="line">        System.out.println(<span class="string">&quot;The time is&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">timer.start();</span><br><span class="line"></span><br><span class="line">JOptionPane.showMessageDialog(<span class="literal">null</span>,<span class="string">&quot;Quit program?&quot;</span>);</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] planets = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;</span><br><span class="line">        <span class="string">&quot;Mercury&quot;</span>,<span class="string">&quot;venus&quot;</span>,<span class="string">&quot;earth&quot;</span>,<span class="string">&quot;Mars&quot;</span>,<span class="string">&quot;Jupiter&quot;</span>,<span class="string">&quot;Saturn&quot;</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(planets));</span><br><span class="line">Arrays.sort(planets);</span><br><span class="line">System.out.println(Arrays.toString(planets));</span><br><span class="line">Arrays.sort(planets,(String first, String second) -&gt; first.length()-second.length());</span><br><span class="line">System.out.println(Arrays.toString(planets));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(planets, (first, second) -&gt; first.length()-second.length());</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>函数式接口(functional interface)</p>
<ul>
<li>对于<em>只有一个</em><strong>抽象</strong>方法的<em>接口</em>，需要这种接口对象时，可以提供一个lambda表达式</li>
</ul>
</li>
<li>
<p>Java中，lambda表达式所能做的也<em>只是</em>转换为函数式接口</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Predicate</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeIf</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> E&gt; filter)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(filter);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.removeIf(e -&gt; e == <span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<h3 id="方法引用-method-reference"><a class="header-anchor" href="#方法引用-method-reference"> </a>方法引用(method reference)</h3>
<p>表达式<code>System.out::println</code>是一个方法引用，它指示编译器生成一个函数式接口的实例，覆盖这个接口的抽象方法来调用给定的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">500</span>, event -&gt;</span><br><span class="line">                System.out.println(event));</span><br></pre></td></tr></table></figure>
<p>使用方法引用可改写成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">500</span>, System.out::println);</span><br></pre></td></tr></table></figure>
<p>用<code>::</code>运算符分隔方法名与对象或类名</p>
<ol>
<li><code>object::instanceMethod</code></li>
<li><code>Class::instanceMethod</code></li>
<li><code>Class::staticMethod</code></li>
</ol>
<p>第一种情况下，方法引用等价于向方法传递参数的lambda表达式:<code>System.out::println</code> — <code>x-&gt;System.out.println(x)</code></p>
<p>第二种情况下，第一个参数变成方法的隐式参数：<code>Arrays.sort(planets,String::compareToIgnoreCase);</code> — <code>(x,y)-&gt;x.compareToIgnoreCase(y)</code></p>
<p>第三种情况下，所有参数都传递到静态方法:<code>Math::pow</code> — <code>(x,y)-&gt;Math.pow(x,y)</code></p>
<p>注：只有当lambda表达式的体只调用一个方法而不做其他操作的时候，才能改写成方法引用</p>
<p>方法引用和lambda表达式区别之一在于：lambda只有在调用的时候，才会抛出异常。方法引用在构造的时候就会抛出异常</p>
<p>方法引用中可以使用<code>this</code>参数，例如<code>this::equals</code> 等同于<code>x -&gt; this.equals(x)</code></p>
<p>方法引用使用<code>super</code>参数， <code>super::instanceMethod</code></p>
<h3 id="构造器引用"><a class="header-anchor" href="#构造器引用"> </a>构造器引用</h3>
<p>构造器引用的方法名为<code>new</code>，例如<code>Person::new</code>是<code>Person</code>构造器的一个引用</p>
<p>如果有多个Person构造器，编译器会从上下文推导出符合类型的构造器</p>
<p>数组类型可以建立构造器引用 <code>int[]::new</code></p>
<p>数组构造器能够克服Java无法构造泛型类型T的数组 <code>Person[] people = stream.toArray(Person[]::new)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">names.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;hello2&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;hello3&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;hello4&quot;</span>);</span><br><span class="line">Stream&lt;Father&gt; stream = names.stream().map(Father::<span class="keyword">new</span>);</span><br><span class="line">List&lt;Father&gt; fathers = stream.collect(Collectors.toList());</span><br><span class="line">System.out.println(fathers);</span><br></pre></td></tr></table></figure>
<h3 id="变量作用域"><a class="header-anchor" href="#变量作用域"> </a>变量作用域</h3>
<ul>
<li>lambda表达式就是<em>闭包</em></li>
</ul>
<p>lambda表达式有3部分</p>
<ol>
<li>一个代码块</li>
<li>参数</li>
<li>自由变量的值，这里指非参数而且不在代码中定义的变量</li>
</ol>
<p>lambda表达式可以捕获外围作用域中的变量值，要求所捕获的值是明确定义的同时值不会改变的变量</p>
<p>lambda表达式所捕获的变量必须是<em>事实最终变量(effectively final)</em>，即该变量初始化之后就i不会再为它赋新值。</p>
<p>lambda表达式的<em>体</em>与<em>嵌套块</em>具有相同的作用域：适用命名冲突和遮蔽</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">first</span> <span class="operator">=</span> Path.of(<span class="string">&quot;/usr/bin&quot;</span>);</span><br><span class="line">Comparator&lt;String&gt; comp = (first,second) -&gt; first.length() - second.length(); <span class="comment">//ERROR,重复定义变量first</span></span><br></pre></td></tr></table></figure>
<p>lambda表达式中使用<code>this</code>关键字，是指创建这个lambda表达式的方法的this参数</p>
<p>自己设计接口，其中只有一个抽象方法，用<code>@FunctionalInterface</code>注解来标记这个接口。有两个好处</p>
<ol>
<li>如果无意增加另一个抽象方法，编译器会产生错误信息</li>
<li>javadoc也指出该接口时一个函数式接口</li>
</ol>
<h2 id="内部类"><a class="header-anchor" href="#内部类"> </a>内部类</h2>
<p><em>内部类(inner class)<em>是定义在另一个类</em>中</em>的类</p>
<p>使用内部类的原因</p>
<ol>
<li>内部类可以对同一包中的其他类隐藏</li>
<li>内部类方法可以访问定义这个类的作用域中的数据，包括<em>原本的私有数据</em></li>
</ol>
<ul>
<li>C++的嵌套类与Java的内部类
<ul>
<li>Java的内部类的对象会有一个隐式引用，指向实例化这个对象的外部类对象，通过这个指针可以访问外部对象的全部状态</li>
<li>Java静态内部类没有这个指针，相当于C++的嵌套类</li>
</ul>
</li>
</ul>
<p>内部类位于外部类的内部，不代表每个外部类都有一个内部类的实例字段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>(<span class="number">100</span>, <span class="string">&quot;dog&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        dog.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OuterClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> meet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OuterClass</span><span class="params">(<span class="type">int</span> num, String name, <span class="type">boolean</span> meet)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.meet = meet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        <span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        innerClass.goodbye();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goodbye</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(meet?<span class="string">&quot;goodbye&quot;</span>:<span class="string">&quot;nice to meet you&quot;</span>); <span class="comment">// 这里的meet是外部类的meet</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部类的方法可以访问自己的数据字段，也可以访问创建它的外围类对象的数据字段(上面的<code>meet</code>)</p>
<ul>
<li>内部类的对象总有一个隐式引用，指向创建它的外部类的对象。
<ul>
<li>这个引用在内部类的定义是不可见的(即没有显示的定义这个隐式引用)</li>
<li>外围类的引用是在内部类的构造器中设置
<ul>
<li>编译器会修改所有内部类的构造器，添加一个对应外围类引用的参数</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>内部类可以是私有的(private)</p>
<p>常规类可以有包可见性或(没有访问修饰符)公共可见性(public)</p>
<p>内部类中，表示外围类的引用:<code>OuterClass.this</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goodbye</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(OuterClass.<span class="built_in">this</span>.meet?<span class="string">&quot;goodbye&quot;</span>:<span class="string">&quot;nice to meet you&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以采用以下语法更加明确的编写内部类对象的构造器 <code>outerObject.new InnerClass(construction parameters)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> <span class="built_in">this</span>.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">    innerClass.goodbye();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当内部类是公共访问的时候，可以这样构造。</p>
<p>在外围类的作用域之外，这样引用内部类 <code>OuterClass.InnerClass</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OuterClass.<span class="type">InnerClass</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>(<span class="number">200</span>, <span class="string">&quot;cat&quot;</span>, <span class="literal">false</span>).<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">OuterClass</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>(<span class="number">100</span>, <span class="string">&quot;dog&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">OuterClass.<span class="type">InnerClass</span> <span class="variable">dogson</span> <span class="operator">=</span> dog.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br></pre></td></tr></table></figure>
<p>内部类声明的所有<em>静态字段</em>必须是<em>final</em>,并初始化为一个编译时常量</p>
<p>内部类<em>不能</em>有<em>static方法</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> varible0;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">varible1</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">varible2</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//static int varible3 = 2; //ERROR 必须定义为final</span></span><br><span class="line">    <span class="comment">//final static int varible4; //ERROR 没有初始化</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部类是一个<em>编译器现象</em>，与<em>虚拟机无关</em>。编译器会把内部类转换成<em>常规的类文件</em>，用$分割外部类名与内部类名，虚拟机对此一无所知</p>
<p>例如 <code>OuterClass$InnerClass</code></p>
<p>与直接写一个常规类来访问某一个类，内部类拥有更大的访问权限。内部类可以访问外部类的私有数据，而常规类不能访问。</p>
<h3 id="局部内部类"><a class="header-anchor" href="#局部内部类"> </a>局部内部类</h3>
<p>当内部类在外部类中名字只出现一次的时候(只是在这个方法中创建这个类型的对象时使用了一次)，可以将内部类改写成局部内部类</p>
<p>即在一个方法中局部的定义这个类</p>
<p>声明局部类时，不能有访问说明符(public或private),局部类的作用域被限定在声明这个局部类的块中。局部类对外部世界完全隐藏，外部类的其他代码也不能访它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OuterClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">love</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">LocalInnerClass</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayLove</span><span class="params">()</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;love you&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LocalInnerClass</span> <span class="variable">localInnerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalInnerClass</span>();</span><br><span class="line">        localInnerClass.sayLove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>局部类不仅能够访问外部类的字段，还可以访问局部变量，但要求局部变量必须是<em>事实最终变量(effectively final)</em>，即一旦赋值就不会改变。</p>
<p>编译器检测局部内部类(<code>LocalInnerClass</code>)中对局部变量(<code>truelove</code>)的访问，为每一个变量建立相应的实例字段，并将局部变量复制到构造器，从而能够初始化这些实例字段。</p>
<p>在下面的例子中，当调用love方法执行后，局部变量truelove已经不存在了，但是在局部类中，已经拥有这个局部变量的实例字段，所以还能够获得这个值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">love</span><span class="params">(<span class="type">boolean</span> truelove)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">LocalInnerClass</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(truelove)</span><br><span class="line">                    System.out.println(<span class="string">&quot;love you&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LocalInnerClass</span> <span class="variable">localInnerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalInnerClass</span>();</span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">1000</span>, localInnerClass);</span><br><span class="line">        timer.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="匿名内部类-anonymous-inner-class"><a class="header-anchor" href="#匿名内部类-anonymous-inner-class"> </a>匿名内部类 anonymous inner class</h3>
<p>局部内部类更进一步就是匿名内部类。如果只想创建这个类的一个对象，甚至不需要为类指定名字(名字是类似<code>class Name implements interface</code>中的<code>Name</code>,不是指变量名)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">love</span><span class="params">(<span class="type">boolean</span> truelove)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ActionListener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(truelove)</span><br><span class="line">                System.out.println(<span class="string">&quot;love you&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">1000</span>, listener);</span><br><span class="line">    timer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个语法的意思是创建一个类的新对象，这个类实现了<code>ActionListener</code>接口，需要实现的方法<code>actionPerformed</code>在括号{}内定义</p>
<p>语法格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">SuperType</span>(construction parameters)</span><br><span class="line">&#123;</span><br><span class="line">    inner <span class="keyword">class</span> <span class="title class_">methods</span> and data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SuperType</code>可以是接口，如<code>ActionListener</code>,内部类要实现该接口，同时如果是接口，就不能有任何构造参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">InterfaceType</span>()</span><br><span class="line">&#123;</span><br><span class="line">    methods and data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SuperType</code>可以是类，内部类要扩展这个类</p>
<p>由于构造器的名字必须与类名相同，匿名内部类米欸有类名，所以匿名内部类不能有构造器。而这里的<code>construction parameters</code>构造参数要传递给超类<code>superclass</code>构造器</p>
<p>构造一个类的新对象与构造一个扩展了那个类的匿名内部类的对象之间的区别在于小括号后面是否有大括号</p>
<p>可以为匿名内部类提供对象初始化块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Dog&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    &#123;initialization&#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>双括号初始化(double brace initialization)</em> <code>invite(new ArrayList()&lt;String&gt;&#123;&#123;add("Harry");add("Tony");&#125;&#125;);</code>。这里外层括号建立了ArrayList的一个匿名子类，内层括号则是一个对象初始化块</p>
<h3 id="静态内部类"><a class="header-anchor" href="#静态内部类"> </a>静态内部类</h3>
<p>静态内部类：为了把一个类隐藏在另一个类的内部，并不需要内部类有外围对象的一个引用。将内部类声明为<code>static</code>就不会生成那个引用</p>
<p>只有内部类可以声明为<code>static</code></p>
<p>当静态方法中构造一个内部类，则该内部类必须是静态的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayAlg</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Pair</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>与常规内部类不同，静态内部类可以有静态字段和方法</li>
<li>接口中声明的内部类自动是<code>static</code>和<code>public</code></li>
</ul>
<hr>
<h2 id="问题-v2"><a class="header-anchor" href="#问题-v2"> </a>问题</h2>
<h3 id="问题1"><a class="header-anchor" href="#问题1"> </a>问题1</h3>
<p>实现了一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">methodDefault</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodDefault MyInterface&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodStatic</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodStatic&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>那么实现这个接口的类，需要必须重写哪些方法呢？</p>
<ul>
<li>必须重写<code>void method();</code></li>
</ul>
</li>
<li>
<p>对于<code>default void methodDefault()</code>不重写可以调用吗？</p>
<ul>
<li>可以的</li>
</ul>
</li>
<li>
<p>对于<code>static void methodStatic()</code>不重写可以调用吗？</p>
<ul>
<li>不可以的</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mystyle</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method Mystyle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Mystyle</span> <span class="variable">mystyle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mystyle</span>();</span><br><span class="line">        mystyle.method(); <span class="comment">// method Mystyle</span></span><br><span class="line">        mystyle.methodDefault(); <span class="comment">// methodDefault MyInterface</span></span><br><span class="line">        MyInterface.methodStatic(); <span class="comment">// methodStatic</span></span><br><span class="line">        <span class="comment">// mystyle.methodStatic(); // ERROR 会报找不到该方法</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="问题2"><a class="header-anchor" href="#问题2"> </a>问题2</h3>
<blockquote>
<p>为什么对于一个实现了两个拥有默认方法的接口，例如下面代码，要使用其中一个接口的默认方法时候，需要加关键字<code>super</code>呢</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mystyle</span> <span class="keyword">extends</span> <span class="title class_">MySuperClass</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span>,MyInterface2</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodDefault</span><span class="params">()</span> &#123;</span><br><span class="line">        MyInterface.<span class="built_in">super</span>.methodDefault();  <span class="comment">// methodDefault MyInterface</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySuperClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodSuperStatic</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodSuperStatic&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">methodDefault</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodDefault MyInterface&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodStatic</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodStatic&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">methodDefault</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodDefault MyInterface2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodStatic</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodStatic2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回答：</p>
<p>在Java中调用静态(static)方法通过<code>TypeName.method()</code>来调用，例如</p>
<p><code>MySuperClass.methodSuperStatic();</code></p>
<p><code>MyInterface.methodStatic();</code>8</p>
<p>而要调用父类的方法通过<code>super.method()</code>来调用，(这种形式调用的方法也可以调用父类中的静态方法)，使用super一般用来区分子类和超类都有相同签名的方法，而想要调用父类的该方法才使用的</p>
<p>对于调用实现的接口中的默认方法，使用的是<code>TypeName.super.method()</code>;调用实现的接口中的静态方法，使用的是<code>TypeName.method()</code>;不能调用实现接口的抽象方法</p>
<hr>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java核心技术</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术—并发</title>
    <url>/2020/12/10/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%80%94%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<p>多任务（multitasking）</p>
<p>并发执行的<strong>进程</strong>数目不受限于CPU数目。操作系统会为每个进程分配CPU时间片，给人并行处理的感觉。</p>
<p>每个任务在一个<strong>线程</strong>（thread）中执行，线程是控制线程的简称。</p>
<p>如果一个程序可以同时运行多个线程，则该程序是多线程（multithreaded）的</p>
<!-- more -->
<p><strong>多进程和多线程区别</strong></p>
<ul>
<li>每个进程拥有自己的一整套变量，而线程则共享 数据</li>
<li>共享变量使得线程间通信比进程间通信更有效、更容易。</li>
<li>创建和撤销一个线程比启动一个新进程的开销要小得多</li>
</ul>
<h2 id="线程"><a class="header-anchor" href="#线程"> </a>线程</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//某个类的实例想在一个线程中被执行，必须实现Runnable接口</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将执行这个任务的代码放入一个类的<code>run</code>方法，同时这个类要实现<code>Runnable</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">//task code</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p>由于<code>Runnable</code>是一个函数式接口，所以可以用lambda表达式创建实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="comment">//task code</span></span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p>启动线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;  i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;r1 &quot;</span> + i);</span><br><span class="line">            Thread.sleep((<span class="type">int</span>) (<span class="number">10</span> * Math.random()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;  i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;r2 &quot;</span> + i);</span><br><span class="line">                Thread.sleep((<span class="type">int</span>) (<span class="number">10</span> * Math.random()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r1);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r2);</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure>
<p>输出</p>
<blockquote>
<p>r1 0<br>
r2 0<br>
r1 1<br>
r2 1<br>
r2 2<br>
r1 2</p>
</blockquote>
<p>一般来说，中断用来请求终止一个线程，相应地，出现<code>InterruptedException</code>异常时，<code>run</code>方法会退出</p>
<p>也可以通过建立<code>Thread</code>类子类来定义线程，因为<code>Thread</code>类实现了Runnable接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> </span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        task code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用start方法。</p>
<p>但是不推荐这种方法，应当把<strong>要并行运行的任务与运行机制解耦合</strong></p>
<h3 id="注意"><a class="header-anchor" href="#注意"> </a>注意</h3>
<p><strong>不要</strong>直接调用<code>Thread</code>类或<code>Runnable</code>对象的<code>run</code>方法。直接调用<code>run</code>方法会在<strong>同一个线程中执行这个任务</strong>，而没有启动新的线程。应当调用<code>Thread.start</code>方法</p>
<h2 id="线程状态"><a class="header-anchor" href="#线程状态"> </a>线程状态</h2>
<p>线程可以有6种状态</p>
<ul>
<li>New 新建</li>
<li>Runnable 可运行</li>
<li>Blocked 阻塞</li>
<li>Waiting 等待</li>
<li>Timed waiting 计时等待</li>
<li>Terminated 终止</li>
</ul>
<p>确定一个线程的当前状态：调用<code>getState()</code>方法</p>
<h3 id="新建线程-New"><a class="header-anchor" href="#新建线程-New"> </a>新建线程 New</h3>
<p>用<code>new</code>操作符创建一个新线程，如<code>new Thread(r)</code></p>
<p>线程还没开始运行，它的状态是新建（<code>new</code>）的</p>
<blockquote>
<p>在线程运行之前还有一些基础工作要做</p>
</blockquote>
<h3 id="可运行线程-Runnable"><a class="header-anchor" href="#可运行线程-Runnable"> </a>可运行线程 Runnable</h3>
<p>线程处于<strong>可运行状态</strong>有两种情况</p>
<ol>
<li>一个可运行的线程可能正在运行</li>
<li>一个可运行的线程可能没有运行</li>
</ol>
<p>一旦调用<code>start</code>方法，线程就处于可运行（runnable）状态</p>
<p>一个线程<strong>开始运行后</strong>，<strong>不一定始终保持运行</strong></p>
<ul>
<li>有时需要暂停，让其他线程有机会运行</li>
</ul>
<p>线程调度的细节依赖于操作系统提供的服务</p>
<ul>
<li><strong>抢占式调度系统</strong>给每个<strong>可运行线程</strong>一个<strong>时间片</strong>来执行任务
<ul>
<li>时间片用完后，操作系统会<strong>剥夺</strong>该线程的运行权，让另一个线程一个机会来运行，操作系统会考虑优先级</li>
<li>所有的桌面以及服务器操作系统使用抢占式调度</li>
</ul>
</li>
<li><strong>协作式调度</strong>
<ul>
<li>一个线程只有在<strong>调用<code>yield</code>方法</strong>或者<strong>被阻塞</strong>或<strong>等待</strong>时，才失去控制权</li>
<li>手机等小型设备</li>
</ul>
</li>
</ul>
<p>多个处理器的机器上，可以有多个线程并行运行</p>
<p>当线程的数目多于处理器的数目，调度器还是需要分配时间片</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//public class Thread implements Runnable</span></span><br><span class="line"><span class="comment">//使当前正在执行的线程向另一个线程交出运行权。这是一个静态方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span>; </span><br></pre></td></tr></table></figure>
<h3 id="阻塞和等待线程"><a class="header-anchor" href="#阻塞和等待线程"> </a>阻塞和等待线程</h3>
<p>当线程处于<strong>阻塞</strong>或<strong>等待</strong>状态时，它<strong>暂时</strong>是<strong>不活动</strong>的</p>
<ul>
<li>它<strong>不运行</strong>任何<strong>代码</strong></li>
<li>消耗最少的资源</li>
</ul>
<p>要由<strong>线程调度器</strong>重新<strong>激活</strong>这个线程。具体细节取决于它是<strong>怎样到达非活动状态</strong>的</p>
<ul>
<li>当一个线程<strong>试图获取</strong>一个<strong>内部的对象锁（注意区别于<code>java.util.concurrent</code>库中的<code>Lock</code>）</strong>,而且这个锁（内部的对象锁）目前被<strong>其他线程占有</strong>，该线程就会<strong>被阻塞</strong>。
<ul>
<li>当所有的线程<strong>都释放</strong>了<strong>这个锁</strong>，并且<strong>线程调度器</strong>允许该线程持有这个锁，它将变成<strong>非阻塞状态</strong></li>
</ul>
</li>
<li>当线程<strong>等待</strong>另一个线程<strong>通知调度器</strong>出现一个<strong>条件</strong>时，这个线程会进入<strong>等待</strong>状态
<ul>
<li>调用<code>Object.wait</code>方法或<code>Thread.join</code>方法</li>
<li>或者是等待<code>java.util.concurrent</code>库中的<code>Lock</code>或<code>Condition</code>时</li>
</ul>
</li>
<li>调用有<strong>超时参数</strong>的<strong>方法</strong>会让线程进入**计时等待（timed waiting）**状态
<ul>
<li>这个状态一直保持到<strong>超时期满</strong>或者接收到适当的<strong>通知</strong></li>
<li>带有超时参数的方法
<ul>
<li><code>Thread.sleep</code></li>
<li>计时版的<code>Object.wait</code>、<code>Thread.join</code>、<code>Lock.trylock</code>以及<code>Condition.await</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>当一个线程处于<strong>阻塞或等待时（终止时）</strong>，就可以<strong>调度另一个</strong>线程运行。</p>
<p>当一个线程被<strong>重新激活</strong>（例如因为<strong>超时期满</strong>或<strong>成功获得了一个锁</strong>），<strong>调度器</strong>检查它是否具有比当前运行线程<strong>更高的优先级</strong>，如果有，调度器会<strong>剥夺</strong>某个<strong>当前运行</strong>线程的运行权，选择一个新线程运行。</p>
<p><strong>阻塞状态</strong>与<strong>等待状态</strong>并没有太大区别</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201211233334758.png" alt="image-20201211233334758"></p>
<h3 id="终止线程"><a class="header-anchor" href="#终止线程"> </a>终止线程</h3>
<p>线程会由于以下原因之一而终止</p>
<ol>
<li><code>run</code>方法<strong>正常退出</strong>，线程自然终止</li>
<li>因为一个<strong>没有捕获的异常</strong>终止了<code>run</code>方法，使线程意外终止</li>
</ol>
<p>可以调用线程的<code>stop</code>方法杀死线程，该方法会抛出<code>ThreadDeath</code>错误对象，但该方法已经弃用</p>
<h2 id="线程属性"><a class="header-anchor" href="#线程属性"> </a>线程属性</h2>
<h3 id="中断线程"><a class="header-anchor" href="#中断线程"> </a>中断线程</h3>
<p><u><strong>注意</strong></u></p>
<ul>
<li>区别**中断（interrupt）<strong>和</strong>终止（terminated）**两个概念
<ul>
<li>中断interrupt</li>
<li>我认为书上想表达的意思是，interrupt一个线程，不一定会使得该线程终止</li>
</ul>
</li>
</ul>
<p>线程终止的情况</p>
<ul>
<li>
<p>线程的**<code>run</code>方法<strong>执行方法体中的</strong>最后一条语句<strong>后再执行</strong><code>return</code><strong>语句</strong>返回时**</p>
</li>
<li>
<p>出现了方法中<strong>没有捕获的异常</strong>时</p>
</li>
<li>
<p><code>stop</code>方法，但是已经被废弃了。</p>
<ul>
<li>
<p>废弃原因如下</p>
</li>
<li>
<pre><code class="language-Java">* @deprecated This method is inherently unsafe.  Stopping a thread with
     *       Thread.stop causes it to unlock all of the monitors that it
     *       has locked (as a natural consequence of the unchecked
     *       &lt;code&gt;ThreadDeath&lt;/code&gt; exception propagating up the stack).  If
     *       any of the objects previously protected by these monitors were in
     *       an inconsistent state, the damaged objects become visible to
     *       other threads, potentially resulting in arbitrary behavior.  Many
     *       uses of &lt;code&gt;stop&lt;/code&gt; should be replaced by code that simply
     *       modifies some variable to indicate that the target thread should
     *       stop running.  The target thread should check this variable
     *       regularly, and return from its run method in an orderly fashion
     *       if the variable indicates that it is to stop running.  If the
     *       target thread waits for long periods (on a condition variable,
     *       for example), the &lt;code&gt;interrupt&lt;/code&gt; method should be used to
     *       interrupt the wait.
     *       For more information, see
     *       &lt;a href=&quot;&#123;@docRoot&#125;/../technotes/guides/concurrency/threadPrimitiveDeprecation.html&quot;&gt;Why
     *       are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.
     */
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 总而言之就是不安全</span><br><span class="line"></span><br><span class="line">`interrupt`方法可以**&lt;u&gt;请求&lt;/u&gt;终止**一个**线程**</span><br><span class="line"></span><br><span class="line">**`Thread.java`源码中有关`interrupt`的方法**</span><br><span class="line"></span><br><span class="line">```Java</span><br><span class="line">public void interrupt()</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentThread().isInterrupted(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isInterrupted(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">(<span class="type">boolean</span> ClearInterrupted)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>对一个线程调用<code>interrupt</code>方法时，会设置线程的<strong>中断状态</strong>。</li>
<li>每个线程都有个中断状态的<code>boolean</code>标志。</li>
<li>每个线程都应该不时地检查这个标志，判断线程是否被中断</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a reference to the currently executing thread object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  the currently executing thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title function_">currentThread</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>想要得出<strong>是否设置中断状态</strong>。</p>
<ul>
<li>
<p>调用静态的<code>Thread.currentThread()</code>方法获得当前线程，然后调用<code>isInterrupted</code>方法</p>
</li>
<li>
<pre><code class="language-Java">while(!Thread.currentThread().isInterrupt() &amp;&amp; more work to do)&#123;
    do more work
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">如果线程**被阻塞**，就**无法检查**中断状态，就需要引入`InterruptExcption`异常</span><br><span class="line"></span><br><span class="line">- 当一个被`sleep`或`wait`调用**阻塞**的线程上调用`interrupt`方法时，那个**阻塞调用（即sleep或wait调用）**将被一个`InterruptException`**异常中断**</span><br><span class="line"></span><br><span class="line">- 有一些阻塞I/O调用不能被中断，对此应该考虑选择可中断的调用</span><br><span class="line"></span><br><span class="line">没有要求被中断的线程应该终止。中断一个线程只是引起它的注意。</span><br><span class="line"></span><br><span class="line">被中断的线程可以决定如何响应中断。</span><br><span class="line"></span><br><span class="line">- 对于某些重要线程，应该处理这个异常，然后继续执行</span><br><span class="line"></span><br><span class="line">- 对于希望将中断解释为一个终止请求的线程，在其`run`方法有如下形式</span><br><span class="line"></span><br><span class="line">  - ```Java</span><br><span class="line">    Runnable r = () -&gt; &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            ...</span><br><span class="line">            while(!Thread.currentThread().isInterrupt() &amp;&amp; more work to do)&#123;</span><br><span class="line">                do more work</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch(InterruptException)&#123;</span><br><span class="line">            // thread was interrupted during sleep or wait</span><br><span class="line">        &#125;</span><br><span class="line">        finally&#123;</span><br><span class="line">            cleanup, if required</span><br><span class="line">        &#125;</span><br><span class="line">        //exiting the run method terminates the thread</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li>
<p>如果在每次工作迭代后都调用<code>sleep</code>方法，那么<code>isInterrupt</code>方法没有必要也没有用处。</p>
<ul>
<li>
<p>如果设置了中断状态，此时如果调用<code>sleep</code>，线程不会休眠（即不获得<code>sleep</code>效果），而是<strong>清除中断状态</strong>，并抛出<code>InterruptException</code></p>
</li>
<li>
<p>因此如果循环调用了<code>sleep</code>就不要检测中断状态，而应当捕获<code>InterruptException</code>异常</p>
</li>
<li>
<pre><code class="language-Java">Runnable r = () -&gt; &#123;
    try&#123;
        ...
        while(more work to do)&#123;
            do more work
            Thread.sleep(delay)
        &#125;
    &#125;
    catch(InterruptException)&#123;
        // thread was interrupted during sleep
    &#125;
    finally&#123;
        cleanup, if required
    &#125;
    //exiting the run method terminates the thread
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt; `interrupt`方法是一个静态方法，它**检查**当前线程**是否被中断**。而且调用`interrupted`方法会**清除**该线程的**中断状态**</span><br><span class="line"></span><br><span class="line">&gt; `isInterrupted`是一个实例方法，可以检查是否有线程被中断，调用这个方法不会改变中断状态</span><br><span class="line"></span><br><span class="line">**不要**在代码底层**抑制**`InterruptedException`**异常**</span><br><span class="line"></span><br><span class="line">合理方法</span><br><span class="line"></span><br><span class="line">- 在`catch`子句中调用`Thread.currentThread().interrupt()`来设置中断状态</span><br><span class="line"></span><br><span class="line">  - ```Java</span><br><span class="line">    void mySubTask()&#123;</span><br><span class="line">        ...</span><br><span class="line">        try&#123;sleep(delay);&#125;</span><br><span class="line">        catch(InterruptException e)&#123;Thread.currentThread().interrupt();&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<p>用<code>throws InterruptException</code>标记方法</p>
<ul>
<li>
<pre><code class="language-Java">void mySubTask() throws InterruptException&#123;
    ...
    sleep(delay);
    ...
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 守护线程 daemon thread</span><br><span class="line"></span><br><span class="line">守护线程的**唯一用途**是为**其他**线程**提供服务**</span><br><span class="line"></span><br><span class="line">通过调用</span><br><span class="line"></span><br><span class="line">```Java</span><br><span class="line">t.setDaemon(true);</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
<p>将一个线程转换成守护线程</p>
<p><strong>举例</strong></p>
<ul>
<li>计时器线程定时发送“计时器滴答”信号给其他线程，所以是守护线程</li>
<li>清空过时缓存项的线程也是守护线程</li>
</ul>
<p>只剩下守护线程时，虚拟机就会退出</p>
<h3 id="线程名"><a class="header-anchor" href="#线程名"> </a>线程名</h3>
<p>默认情况下，线程命名为&quot;Thread-0&quot;、“Thread-1”</p>
<p>通过<code>setName</code>方法为线程设置任何名字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">t.setName(<span class="string">&quot;Web crawler&quot;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在线程转储时可能很有用</p>
</blockquote>
<h3 id="未捕获异常的处理器"><a class="header-anchor" href="#未捕获异常的处理器"> </a>未捕获异常的处理器</h3>
<p>线程的<code>run</code>方法<strong>不能抛出</strong>任何<strong>检查型异常</strong>（检查型异常例如IOException），但是<strong>非检查型异常</strong>（派生于<code>Error</code>的例如系统资源耗尽，或派生于<code>RuntimeException</code>的例如数组访问越界）可能会导致线程终止，这种情况下，线程会死亡</p>
<p>对于<strong>可以传播</strong>的异常，并<strong>没有</strong>任何<strong>catch子句</strong>，实际上，线程死亡之前，会将异常传递到一个<strong>用于处理非捕获异常的处理器</strong></p>
<p>这个处理器必须属于一个实现了<code>Thread.UncaughtExceptionHandler</code>接口的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UncaughtExceptionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过<code>setUncaughtExceptionHandler</code>方法为任何线程安装一个处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler eh)</span> &#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    uncaughtExceptionHandler = eh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以用<code>Thread</code>类的静态方法<code>SetDefaultUncaughtExceptionHandler</code>为<strong>所有线程</strong>安装一个默认的处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setDefaultUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler eh)</span> &#123;</span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        sm.checkPermission(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RuntimePermission</span>(<span class="string">&quot;setDefaultUncaughtExceptionHandler&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    defaultUncaughtExceptionHandler = eh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// null unless explicitly set</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> UncaughtExceptionHandler uncaughtExceptionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// null unless explicitly set</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> UncaughtExceptionHandler defaultUncaughtExceptionHandler;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果<strong>没有</strong>安装<strong>默认处理器</strong>，则默认处理器为<code>null</code></li>
<li>没有为<strong>单个线程</strong>安装处理器，那么处理器就是该线程的<code>ThreadGroup</code>对象</li>
</ul>
<p><code>ThreadGroup</code>类实现了<code>Thread.UncaughtExceptionHandler</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadGroup</span> <span class="keyword">implements</span> <span class="title class_">Thread</span>.UncaughtExceptionHandler</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">        parent.uncaughtException(t, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Thread.<span class="type">UncaughtExceptionHandler</span> <span class="variable">ueh</span> <span class="operator">=</span></span><br><span class="line">            Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">        <span class="keyword">if</span> (ueh != <span class="literal">null</span>) &#123;</span><br><span class="line">            ueh.uncaughtException(t, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> ThreadDeath)) &#123;</span><br><span class="line">            System.err.print(<span class="string">&quot;Exception in thread \&quot;&quot;</span></span><br><span class="line">                             + t.getName() + <span class="string">&quot;\&quot; &quot;</span>);</span><br><span class="line">            e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ThreadGroup</code>的<code>uncaughtException</code>方法执行一下操作</p>
<ol>
<li>如果该线程组有父线程组，那么调用父线程组的<code>uncaughtException</code>方法</li>
<li>否则，如果<code>Thread.getDefaultExceptionHandler</code>方法返回一个非<code>null</code>处理器，则调用该处理器</li>
<li>否则，如果<code>Throwable</code>是一个<code>ThreadDeath</code>的一个实例，什么都不做</li>
<li>否则，将线程的名字以及<code>Throwable</code>的战轨迹输出到<code>System.err</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对于一个线程（victim thread）如果被stop方法调用，则会抛出ThreadDeath</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDeath</span> <span class="keyword">extends</span> <span class="title class_">Error</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">4417128565033088268L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>线程组</strong>是可以<strong>一起管理的线程的集合</strong>。</p>
<p>默认情况下，创建的所有线程都属于同一个线程组，但是也可以建立其他的组</p>
</blockquote>
<h3 id="线程优先级"><a class="header-anchor" href="#线程优先级"> </a>线程优先级</h3>
<blockquote>
<p>在没有使用操作系统线程的Java早期版本中，线程有优先级可能很有用。不过现在不要使用线程优先级了</p>
</blockquote>
<p>在Java中，每个线程有一个<strong>优先级</strong></p>
<p>默认情况下，一个线程会<strong>继承</strong>构造它的那个线程的<strong>优先级</strong></p>
<p>通过<code>setPriority</code>方法来提高或降低一个线程的优先级</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setPriority</span><span class="params">(<span class="type">int</span> newPriority)</span> &#123;</span><br><span class="line">    ThreadGroup g;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((g = getThreadGroup()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">            newPriority = g.getMaxPriority();</span><br><span class="line">        &#125;</span><br><span class="line">        setPriority0(priority = newPriority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The minimum priority that a thread can have.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MIN_PRIORITY</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default priority that is assigned to a thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NORM_PRIORITY</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum priority that a thread can have.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX_PRIORITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>每当<strong>线程调度器</strong>有机会选择新线程时，它首先选择具有<strong>较高优先级</strong>的线程</p>
<p>但是，<strong>线程优先级高度依赖于系统</strong>。当虚拟机依赖于宿主机平台的线程实现时，Java线程的优先级会映射到宿主机平台的优先级</p>
<h2 id="同步"><a class="header-anchor" href="#同步"> </a>同步</h2>
<p><strong>静态条件（race condition）</strong>：两个或两个以上的<strong>线程</strong>需要<strong>共享</strong>对<strong>同一数据</strong>进行<strong>存取</strong>，如果两个线程分别对这一共享数据进行<strong>修改</strong>，那么两个线程会相互覆盖，结果取决于两个线程访问的次序。</p>
<p>需要通过<strong>同步存取</strong>来避免<strong>多线程破坏共享数据</strong></p>
<p><strong>示例代码</strong></p>
<p><strong>Bank.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span>[] accounts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bank</span><span class="params">(<span class="type">int</span> n,<span class="type">double</span> initialBalance)</span>&#123;</span><br><span class="line">        accounts = <span class="keyword">new</span> <span class="title class_">double</span>[n];</span><br><span class="line">        Arrays.fill(accounts,initialBalance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">double</span> amount)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(accounts[from] &lt; amount) <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(Thread.currentThread());</span><br><span class="line">        accounts[from] -= amount;</span><br><span class="line">        System.out.printf(<span class="string">&quot; %10.2f from %d to %d&quot;</span>,amount,from,to);</span><br><span class="line">        accounts[to] += amount;</span><br><span class="line">        System.out.printf(<span class="string">&quot; Total Balance:%10.2f %n&quot;</span>,getTotalBalance());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getTotalBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">double</span> a : accounts) sum += a;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accounts.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UnsynchBankTest.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsynchBankTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NACCOUNTS</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">INITIAL_BALANCE</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">MAX_AMOUNT</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DELAY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Bank</span> <span class="variable">bank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>(NACCOUNTS,INITIAL_BALANCE);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; NACCOUNTS; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fromAccount</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span>  ()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">toAccount</span> <span class="operator">=</span> (<span class="type">int</span>) (bank.size()*Math.random());</span><br><span class="line">                        <span class="type">double</span> <span class="variable">amount</span> <span class="operator">=</span> MAX_AMOUNT*Math.random();</span><br><span class="line">                        bank.transfer(fromAccount,toAccount,amount);</span><br><span class="line">                        Thread.sleep((<span class="type">long</span>) (DELAY*Math.random()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;jingtai</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出结果</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">Thread[Thread-<span class="number">39</span>,<span class="number">5</span>,main]     <span class="number">729.42</span> from <span class="number">39</span> to <span class="number">81</span> Total Balance:  <span class="number">98631.98</span> </span><br><span class="line">Thread[Thread-<span class="number">96</span>,<span class="number">5</span>,main]     <span class="number">855.56</span> from <span class="number">96</span> to <span class="number">55</span> Total Balance:  <span class="number">98631.98</span> </span><br><span class="line">Thread[Thread-<span class="number">29</span>,<span class="number">5</span>,main]     <span class="number">205.14</span> from <span class="number">29</span> to <span class="number">61</span> Total Balance:  <span class="number">98631.98</span> </span><br><span class="line">     <span class="number">587.19</span> from <span class="number">99</span> to <span class="number">71</span> Total Balance:  <span class="number">99219.17</span> </span><br><span class="line">Thread[Thread-<span class="number">28</span>,<span class="number">5</span>,main]     <span class="number">970.45</span> from <span class="number">28</span> to <span class="number">87</span> Total Balance:  <span class="number">99219.17</span> </span><br><span class="line">       <span class="number">7.83</span> from <span class="number">6</span> to <span class="number">70</span> Total Balance:  <span class="number">99227.00</span> </span><br><span class="line">Thread[Thread-<span class="number">49</span>,<span class="number">5</span>,main]     <span class="number">346.56</span> from <span class="number">49</span> to <span class="number">35</span> Total Balance:  <span class="number">99227.00</span> </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以发现，对于<code>Total Balance</code>的值会发生改变（按道理应该保持100000）</p>
<h3 id="竞态条件详解"><a class="header-anchor" href="#竞态条件详解"> </a>竞态条件详解</h3>
<p>假设两个线程同时指令</p>
<p><code>accounts[to] += amount;</code></p>
<p>由于这条指令<strong>不是原子操作</strong>，可能如下处理</p>
<ol>
<li>将<code>accounts[to]</code>加载到寄存器</li>
<li>增加<code>amount</code></li>
<li>将结果写回<code>accounts[to]</code></li>
</ol>
<p>如果第一个线程在执行步骤1、2后，运行权被抢占，而第二个线程被<strong>唤醒</strong>，更新数组同一个元素后，第一个线程被唤醒完成第3步则可能出错</p>
<p>查看执行这个类中每一个语句的<strong>虚拟机字节码</strong>，以<code>Bank</code>类为例</p>
<ol>
<li>先将当前路径移动到<code>Bank.java</code>的位置</li>
<li>用<code>javac</code>命令对.java文件进行编译
<ul>
<li><code>javac .\UnsynchBankTest.java Bank.java</code></li>
</ul>
</li>
<li>用<code>javap</code>命令对.class文件进行反编译
<ul>
<li><code>javap -c -v Bank</code></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">21</span>: aload_0</span><br><span class="line"><span class="number">22</span>: getfield      #<span class="number">2</span>                  <span class="comment">// Field accounts:[D</span></span><br><span class="line"><span class="number">25</span>: iload_1</span><br><span class="line"><span class="number">26</span>: dup2</span><br><span class="line"><span class="number">27</span>: daload</span><br><span class="line"><span class="number">28</span>: dload_3</span><br><span class="line"><span class="number">29</span>: dsub</span><br><span class="line"><span class="number">30</span>: dastore</span><br></pre></td></tr></table></figure>
<p>可以看到一条命令由多条指令组成，而执行这些指令的线程可以在任何一条指令上被中断</p>
<p>对此，我们需要解决的问题是：能够确保线程失去控制之前，方法已经完成</p>
<h3 id="锁对象"><a class="header-anchor" href="#锁对象"> </a>锁对象</h3>
<p>有两种机制可<strong>防止并发访问代码块</strong></p>
<ul>
<li>Java提供<code>synchronized</code>关键字来达到这一目标</li>
<li>Java5引入<code>ReentrantLock</code>类</li>
</ul>
<p><code>synchronized</code>关键字会自动<strong>提供一个锁</strong>以及相关的<strong>条件</strong>，对于大多数需要<strong>显式锁</strong>，这种机制功能强</p>
<p><code>java.util.concurrent</code>框架为这些基础机制提供单独的类</p>
<h4 id="重入锁-reentrant"><a class="header-anchor" href="#重入锁-reentrant"> </a>重入锁 reentrant</h4>
<p>可重入锁有</p>
<ul>
<li><code>synchronized</code></li>
<li><code>ReentrantLock</code></li>
</ul>
<p>用<code>ReentrantLock</code>保护代码块的基本结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();  <span class="comment">// block until condition holds  a ReentrantLock object</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// critical section 临界区</span></span><br><span class="line">            <span class="comment">// ... method body</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock()<span class="comment">// make sure the lock is unlocked even if an exception is thrown</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这结构保证任何时刻<strong>只有一个线程</strong>进入<strong>临界区</strong>。一旦一个<strong>线程</strong><u>锁定</u>了<strong>锁对象</strong>（注意主语是<strong>线程</strong>），其他任何线程都无法通过<code>lock</code>语句。</p>
<p>当其他线程<strong>调用<code>lock</code><strong>时，它们会</strong>暂停</strong>，直到第一个线程释放这个<strong>锁对象（这里指myLock）</strong></p>
<p><u><strong>注意</strong></u></p>
<ul>
<li>要把<code>unclock</code>操作包括在<code>finally</code>子句中，这一点<strong>非常重要</strong>。
<ul>
<li>如果<strong>临界区的代码</strong>抛出一个<strong>异常</strong>，锁必须<strong>释放</strong>。否则其他线程将永远阻塞。</li>
</ul>
</li>
<li>使用锁时，<strong>不能</strong>使用<code>try-with-resources</code>语句。
<ul>
<li>首先，解锁的方法名不是<code>close</code>。（这句话的意思要和<code>try-with-resources</code>的特性，<code>try-with-resources</code>会自动释放资源，即调用对应资源的<code>close</code>方法，而可能会认为锁也是一个资源，是否可以用这个语句来自动释放呢？答案是不可以的）即使将锁的<code>unclock</code>方法重命名成<code>close</code>，<code>try-with-resources</code>语句也无法正常工作</li>
<li>它（<code>try-with-resources</code>）首部希望声明一个新变量。但是如果使用一个锁，你可能想使用多个线程共享那个变量（而不是新变量）
<ul>
<li>我对于这句话的理解是，<code>try-with-resources</code>语句在首部声明的变量都是只在这语句块中使用的，使用完就销毁的。而对于一个锁，我们希望的是多个线程，能够抢占这个锁，并且这个锁是同一个对象，而不是各自生成一个新的锁对象。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>加入可重入锁的Bank.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">banklock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">double</span> amount)</span>&#123;</span><br><span class="line">        banklock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(accounts[from] &lt; amount) <span class="keyword">return</span>;</span><br><span class="line">            System.out.print(Thread.currentThread());</span><br><span class="line">            accounts[from] -= amount;</span><br><span class="line">            System.out.printf(<span class="string">&quot; %10.2f from %d to %d&quot;</span>,amount,from,to);</span><br><span class="line">            accounts[to] += amount;</span><br><span class="line">            System.out.printf(<span class="string">&quot; Total Balance:%10.2f %n&quot;</span>,getTotalBalance());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            banklock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getTotalBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        banklock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">double</span> a : accounts) sum += a;</span><br><span class="line">            <span class="keyword">return</span> sum;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            banklock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>假设一个线程调用了<code>transfer</code>，但是在执行结束前被<strong>抢占（锁还是在该线程，所以还会继续执行指令）</strong>。再假设第二个线程也调用了<code>transfer</code>。由于第二个线程不能获得锁，将在调用<code>lock</code>方法时被阻塞。必须等待<strong>第一个线程</strong>执行完<code>transfer</code>方法，释放锁后，第二个线程才能开始运行。</li>
</ul>
<p>注意：</p>
<ul>
<li>每个<code>Bank</code>对象都有自己的<code>ReentrantLock</code>对象。
<ul>
<li>两个线程试图访问<strong>同一个<code>Bank</code>对象</strong>，那么<strong>锁</strong>可以用来保证<strong>串行化访问</strong></li>
<li>两个线程访问<strong>不同的<code>Bank</code>对象</strong>，每个线程会得到<strong>不同的锁对象</strong>，两个线程<strong>都不会阻塞</strong></li>
</ul>
</li>
</ul>
<p>**可重入锁  **</p>
<p><code>ReentrantLock</code>称为<strong>重入锁</strong>，因为线程可以<strong>反复获得已拥有的锁</strong>。</p>
<p>重入锁有一个<strong>持有计数（hold count）<strong>来</strong>跟踪</strong>对<code>lock</code>方法的<strong>嵌套调用</strong>。</p>
<p>线程每一次调用<code>lock</code>方法后都要调用<code>unlock</code>方法来<strong>释放锁</strong>（一一对应）。</p>
<p>根据这个特性，<strong>被一个锁保护的代码</strong>可以调用另一个使用**相同锁（这里相同的锁指的是同一个锁对象）**的方法。</p>
<ul>
<li>
<p>对这句话的理解，就是一个对象（例如一个<code>Bank</code>实例化的<code>bank</code>对象），这个对象只有维护<strong>一个锁对象</strong><code>banklock</code>。当这个锁对象被线程A给占用后（例如在调用<code>transfer</code>，而<code>transfer</code>被<code>banklock</code>给保护），如果这个<code>bank</code>对象中还有其他的方法（例如<code>getTotalBalance</code>）是被<code>banklock</code>这个锁对象给保护的话，那么现在只有线程A可以调用<code>getTotalBalance</code>（因为线程A有锁对象<code>banklock</code>）。即使这个线程A中没有调用<code>getTotalBalance</code>，只调用了<code>transfer</code>方法；其他线程也不能够调用<code>getTotalBalance</code>，必须等到线程A将调用的<code>banklock</code>都释放了，才能够调用<code>getTotalBalance</code>或者<code>transfer</code>。即调用几次释放几次。</p>
</li>
<li>
<p><code>transfer</code>方法中调用了<code>getTotalBalance</code>方法，此时会继续封锁<code>banklock</code>对象，<code>bankLock</code>对象的持有计数为2。当<code>getTotalBalance</code>方法退出时，持有计数变回1（因为<code>unlock</code>了一次）。当<code>transfer</code>方法退出的时候，持有计数变为0（因为又释放了一次），线程释放锁。</p>
</li>
</ul>
<blockquote>
<p>通常我们可能希望保护会<strong>更新</strong>或<strong>检查</strong>共享对象的代码块，从而能确信当前操作执行完之后其他线程才能使用同一对象</p>
</blockquote>
<p><u><strong>注意</strong></u></p>
<ul>
<li>应该确保临界区（即锁保护的代码块）中的代码不要因为<strong>抛出异常</strong>而跳出临界区。
<ul>
<li>如果在临界区代码块结束之前抛出了异常，<code>finally</code>子句将释放锁，但是对象可能处于<strong>被破坏的状态</strong>。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* &lt;p&gt;This lock supports a maximum of <span class="number">2147483647</span> recursive locks by</span><br><span class="line">* the same thread. Attempts to exceed <span class="built_in">this</span> limit result in</span><br><span class="line">* &#123;<span class="meta">@link</span> Error&#125; <span class="keyword">throws</span> from locking methods.</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ReentrantLock</code>允许的持有计数最大为2147483647。</li>
</ul>
<h5 id="公平锁"><a class="header-anchor" href="#公平锁"> </a>公平锁</h5>
<p>对于<code>ReentrantLock</code>对象的构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment"> * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment"> * given fairness policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>ReentrantLock(boolean fair)</code>构造一个采用<strong>公平策略</strong>的锁。一个公平锁<strong>倾向</strong>于<strong>等待时间最长的线程</strong>（队列先进先出）。不过这种公平保证可能<strong>严重影响性能</strong>。所以在默认情况下，不要求锁是公平的。</p>
<blockquote>
<p>公平锁比常规锁要<strong>慢很多</strong>。</p>
<p>对于要解决的问题有一个特定的理由确实要考虑公平性时，才应使用公平锁。</p>
<p>即使使用公平锁，也无法确保<strong>线程调度器</strong>是公平的。<strong>如果</strong>线程调度器选择<strong>忽略</strong>一个已经为锁等待很长时间的线程，它就没有机会得到公平处理</p>
</blockquote>
<p>这篇CSDN上的博客把<code>ReentrantLock</code>讲得很生动<a href="https://blog.csdn.net/yanyan19880509/article/details/52345422?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-6.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-6.control">轻松学习java可重入锁(ReentrantLock)的实现原理</a></p>
<p><strong>非公平锁</strong></p>
<p>非公平锁即每个线程在锁是空闲状态下，都有机会抢到锁，而不必照顾等待时间长的线程。例如线程A执行完任务后释放锁，而线程B本来在等待线程A的锁而被阻塞，现在正在被唤醒，在线程B唤醒的过程中，如果来了线程C，那么线程C也有可能获得锁</p>
<h3 id="条件对象"><a class="header-anchor" href="#条件对象"> </a>条件对象</h3>
<p><strong>情景</strong>：<strong>线程A</strong>（获得锁对象）进入<strong>临界区</strong>后，却发现只有<strong>满足某个条件</strong>之后它才能执行。而通过引入<strong>条件对象</strong>，让其他线程（线程B）可以获得这个锁对象去执行任务，同时可能线程B的操作能让线程A满足该条件，让线程A能够继续执行任务。</p>
<p>引入**条件对象（条件变量（conditional variable））**来管理那些已经获得一个锁却不能做有用工作的线程</p>
<p>举例：线程A要进行转账给其他账户，但是该账户的余额不足，因此进行了等待（<strong>不满足某个条件</strong>），等待其他账户给它进行转账</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">double</span> amount)</span>&#123;</span><br><span class="line">    banklock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(accounts[from] &lt; amount)&#123;</span><br><span class="line">            <span class="comment">//wait</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// transfer funds</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        banklock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于这个线程刚刚获得了对<code>banklock</code>的排他性访问权，因此别的线程没有存款机会，因此引入<strong>条件对象</strong></p>
<blockquote>
<p>一个<strong>锁对象</strong>可以有一个或多个相关联的<strong>条件对象</strong>。</p>
<p>用<code>newCondition</code>方法获得一个条件对象。</p>
<p>习惯上给每个条件对象一个合适的名字来反映它<strong>表示的条件</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> Condition sufficientFunds;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bank</span><span class="params">(<span class="type">int</span> n,<span class="type">double</span> initialBalance)</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        sufficientFunds = banklock.newCondition(); <span class="comment">//获得banklock的一个条件对象</span></span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到举例中：线程A中调用<code>transfer</code>发现了余额不够，因此调用<code>sufficientFunds.await();</code></p>
<ul>
<li>当前线程现在暂停，并<strong>放弃锁</strong>。这就<strong>允许另一个线程执行</strong>，同时我们希望这另一个线程能够增加放弃锁的线程的账户余额（使之满足条件）</li>
</ul>
<blockquote>
<p><u>等待获得锁的线程</u>和<u>已经调用了<code>await</code>方法的线程</u>有本质的不同</p>
<ul>
<li>一旦一个线程调用<code>await</code>方法就进入了这个条件的<strong>等待集（wait set）</strong>。当<strong>锁可用</strong>时，该线程并<strong>不会</strong>变为<strong>可运行状态</strong>。实际上，它仍保持<strong>非活动状态</strong>，直到另一个线程<strong>在同一条件</strong>调用<code>signalAll</code>方法
<ul>
<li>对这句话的理解时：一个线程调用了<code>await</code>方法后，只有其他的线程在<strong>同一条件</strong>上调用<code>signalAll</code>或<code>signal</code>方法才可能把这个线程从等待集中取出，否则它将一直处于非活动状态。</li>
<li>它渴望的是<code>siganlAll</code>或<code>signal</code>，而不是<code>unclock</code></li>
</ul>
</li>
</ul>
</blockquote>
<p>当另一个线程完成转账时，应该调用：<code>sufficientFunds.signalAll();</code></p>
<ul>
<li>
<p>这个调用会重新<strong>激活</strong>等待<strong>这个条件</strong>的<strong>所有线程</strong>。</p>
</li>
<li>
<p>当这些线程从<strong>等待集</strong>中移除，它们再次成为<strong>可运行的线程</strong>，<strong>调度器</strong>最终将再次将它们<strong>激活</strong>。同时它们会<strong>尝试重新进入该对象</strong>。一旦<strong>锁可用</strong>，它们中的某个线程将从**<code>await</code>调用返回**，<strong>得到</strong>这个<strong>锁</strong>，并从之前<strong>暂停的地方继续执行</strong></p>
<ul>
<li>对这句话的理解：<code>signalAll</code>方法会让所有在该条件下的等待集中的线程激活，但是不代表该线程就能立马执行，这些线程也是<strong>需要获得该锁对象</strong>，并从暂停的地方（await地方）继续执行</li>
</ul>
</li>
<li>
<p>线程应当<strong>再次测试条件</strong>。不能保证现在一定满足条件——<code>signalAll</code>方法仅仅是<strong>通知</strong>的线程：现在<strong>有可能满足</strong>条件，值得再次检查条件</p>
<ul>
<li>
<p>对这句话的理解：这里有可能满足条件的意思是：可能其他线程执行<code>signalAll</code>的这个操作时就根本没有使等待集的线程满足条件、也有可能是<code>signalAll</code>方法调用时的时候确实满足了，但是等到等待集的某个线程获得锁对象的时候，就又不满足了。</p>
</li>
<li>
<p>因为我们需要确保这个等待集的线程确实能够从<code>await</code>中解脱出来，因此我们需要将<code>await</code>调用放在循环中，来保证<code>signalAll</code>后能够再次检查</p>
</li>
<li>
<pre><code class="language-Java">while(!(OK to process))&#123;
    condition.await();
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">当一个线程调用`await`时，它没有办法重新自行激活。它寄希望于其他线程。如果没有其他线程来重新激活等待的线程，它就永远不在运行。</span><br><span class="line"></span><br><span class="line">因此最终需要**某个其他**线程调用`signalAll`方法</span><br><span class="line"></span><br><span class="line">**死锁（deadlock）**现象有可能发生：所有其他线程都被阻塞，最后一个活动线程调用了`await`方法，但没有先解除另外某个线程的阻塞。此时没有线程可以接触其他线程的阻塞状态，程序永远挂起。</span><br><span class="line"></span><br><span class="line">**调用`signalAll()`方法的时机**</span><br><span class="line"></span><br><span class="line">只要一个对象的状态有变化而且有利于等待的线程，就可以调用`signalAll`</span><br><span class="line"></span><br><span class="line">- 例如一个账户的余额发生改变时，就应该给等待线程一个机会来检查余额。</span><br><span class="line"></span><br><span class="line">- 在完成转账的时候，调用`signalAll`方法</span><br><span class="line"></span><br><span class="line">- ```Java</span><br><span class="line">  public void transfer(int from, int to, double amount)&#123;</span><br><span class="line">      banklock.lock();</span><br><span class="line">      try&#123;</span><br><span class="line">          while(accounts[from] &lt; amount)&#123;</span><br><span class="line">              sufficientFunds.await();</span><br><span class="line">          &#125;</span><br><span class="line">          // transfer funds</span><br><span class="line">          ...</span><br><span class="line">          // 转账完成</span><br><span class="line">          sufficientFunds.signalAll();//说不定给等待集的线程转了钱，都通知看看</span><br><span class="line">      &#125;</span><br><span class="line">      finally &#123;</span><br><span class="line">          banklock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>signalAll</code>调用<strong>不会立即激活</strong>一个等待线程，它只是<strong>解除</strong>等待线程的<strong>阻塞</strong>，使这些线程可以在当前线程<strong>释放锁</strong>之后<strong>竞争访问对象</strong></p>
</blockquote>
<p><strong>signal方法</strong></p>
<p><code>signal</code>方法只是<strong>随机选择</strong>等待集中的一个线程，并解除这个线程的阻塞状态。</p>
<p>这比解除所有线程的阻塞更高效，但也存在危险。</p>
<p>如果随机选择中的线程发现自己<strong>仍然不能运行</strong>，它就会<strong>再次阻塞</strong>。如果没有其他线程再次调用<code>signal</code>，系统就会进入<strong>死锁</strong></p>
<blockquote>
<p><strong><u>注意</u></strong></p>
<p>只有当线程<strong>拥有一个条件的锁</strong>时，它才能在这个条件上调用<code>await</code>、<code>signalAll</code>、<code>signal</code></p>
</blockquote>
<h4 id="锁和条件小结"><a class="header-anchor" href="#锁和条件小结"> </a>锁和条件小结</h4>
<ul>
<li><strong>锁</strong>用来<strong>保护代码片段</strong>，一次只能由<strong>一个线程</strong>执行被保护的代码。</li>
<li><strong>锁</strong>可以<strong>管理</strong>试图进入被保护代码段的<strong>线程</strong></li>
<li><strong>一个锁</strong>可以由一个或多个相关联的<strong>条件对象</strong></li>
<li>每个<strong>条件对象管理</strong>那些已经<strong>进入</strong>被保护<strong>代码段</strong>但<strong>不能运行</strong>的<strong>线程</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base of synchronization control for this lock. Subclassed</span></span><br><span class="line"><span class="comment">     * into fair and nonfair versions below. Uses AQS state to</span></span><br><span class="line"><span class="comment">     * represent the number of holds on the lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> ConditionObject <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">       	...	</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getHoldCount</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> isHeldExclusively() ? getState() : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">   		...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHoldCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.getHoldCount();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    ...</span><br><span class="line">     <span class="comment">/*      +------+  prev +-----+       +-----+</span></span><br><span class="line"><span class="comment">     * head |      | &lt;---- |     | &lt;---- |     |  tail</span></span><br><span class="line"><span class="comment">     *      +------+       +-----+       +-----+</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The synchronization state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>, java.io.Serializable &#123;</span><br><span class="line">        <span class="comment">/** First node of condition queue. */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">        <span class="comment">/** Last node of condition queue. */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>ReentrantLock</code>里面维护一个<code>Sync</code>类对象，而<code>Sync</code>对象维护一个先进先出（FIFO）的队列，用来管理线程</p>
<p>可以看到<code>ReentrantLock</code>的<code>newCondition</code>方法是调用<code>Sync</code>类的<code>newCondition</code>方法。</p>
<p>而<code>newCondition</code>方法实例化一个<code>Condition</code>对象，该对象里面也维护着一个队列。在<code>ConditionObject</code>中的<code>Node</code>类和<code>AbstractQueuedSynchronizer</code>中的<code>Node</code>类是一样的。</p>
<p>也可以看到持有计数（hold count）是通过整型变量<code>state</code>来记录的</p>
<h3 id="synchronized关键字"><a class="header-anchor" href="#synchronized关键字"> </a>synchronized关键字</h3>
<p>Java语言内置的一种机制</p>
<p>从1.0版本开始，Java中的<strong>每个对象</strong>都有一个<strong>内部锁</strong>。</p>
<p>如果一个方法声明时有<code>synchronized</code>关键字，那么对象的锁（内部对象锁）将保护整个方法。</p>
<ul>
<li>要调用这个方法，线程必须获得内部对象锁</li>
</ul>
<p>因此</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        method body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>等价于</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.intrinsicLock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        method body</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.intrinsicLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>内部对象锁</strong>只有一个<strong>关联条件</strong>。</p>
<ul>
<li><strong><code>wait</code>方法</strong>将一个线程增加到<strong>等待集</strong>中</li>
<li><code>notifyAll</code>和<code>notify</code>方法可以<strong>解除</strong>等待线程的<strong>阻塞</strong></li>
</ul>
<p>因此</p>
<p>调用<code>wait</code><strong>等价于</strong><code>intrinsicCondition.await();</code></p>
<p>调用<code>notifyAll</code><strong>等价于</strong><code>intrinsicCondition.signalAll();</code></p>
<blockquote>
<p><code>wait</code>、<code>notifyAll</code>以及<code>notify</code>方法是<code>Object</code>类的<code>final</code>方法。</p>
<p><code>Condition</code>方法必须命名为<code>await</code>、<code>signalAll</code>和<code>signal</code>，从而不会与那些方法发生冲突</p>
</blockquote>
<p>使用<code>synchronized</code>关键字实现<code>Bank</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span>[] accounts;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bank</span><span class="params">(<span class="type">int</span> n,<span class="type">double</span> initialBalance)</span>&#123;</span><br><span class="line">        accounts = <span class="keyword">new</span> <span class="title class_">double</span>[n];</span><br><span class="line">        Arrays.fill(accounts,initialBalance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">double</span> amount)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span>(accounts[from] &lt; amount)&#123;</span><br><span class="line">            wait(); <span class="comment">// wait on intrinsic object lock&#x27;s single conditon</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(Thread.currentThread());</span><br><span class="line">        accounts[from] -= amount;</span><br><span class="line">        System.out.printf(<span class="string">&quot; %10.2f from %d to %d&quot;</span>,amount,from,to);</span><br><span class="line">        accounts[to] += amount;</span><br><span class="line">        System.out.printf(<span class="string">&quot; Total Balance:%10.2f %n&quot;</span>,getTotalBalance());</span><br><span class="line">        notifyAll(); <span class="comment">// notify all threads waiting on the condition</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">double</span> <span class="title function_">getTotalBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">double</span> a : accounts) sum += a;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accounts.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释说明：</p>
<ul>
<li>每个对象都有一个内部锁，并且这个锁有一个内部条件。</li>
<li>这个锁会管理试图进入<code>synchronized</code>方法的线程。</li>
<li>这个条件可以管理调用<code>wait</code>的线程</li>
</ul>
<p>将<strong>静态方法</strong>声明为**同步（synchronized）**也是合法的</p>
<ul>
<li>如果调用这样一个方法，它会获得相关<strong>类对象</strong>的<strong>内部锁</strong>
<ul>
<li>例如<code>Bank</code>类有一个<strong>静态同步方法</strong>，调用这个方法时，**<code>Bank.class</code>**对象的锁会被锁定</li>
<li>因此<strong>没有其他线程</strong>可以调用这个类的该方法或<strong>任何其他同步静态方法</strong>
<ul>
<li>因为内部锁也是一个可重入锁，当一个线程获得该锁时，其他线程就不能调用被这个锁保护的代码段</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Object</span> &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">     <span class="comment">/* Only one thread at a time can own an object&#x27;s monitor.</span></span><br><span class="line"><span class="comment">     * @throws  IllegalMonitorStateException  if the current thread is not</span></span><br><span class="line"><span class="comment">     *               the owner of this object&#x27;s monitor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>; <span class="comment">//该方法只能在一个同步方法或同步块中调用</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">/* @throws  IllegalMonitorStateException  if the current thread is not</span></span><br><span class="line"><span class="comment">     *               the owner of this object&#x27;s monitor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>; <span class="comment">//该方法只能在同步方法或同步块中调用</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">/* @param      timeout   the maximum time to wait in milliseconds.</span></span><br><span class="line"><span class="comment">     * @throws  IllegalArgumentException      if the value of timeout is</span></span><br><span class="line"><span class="comment">     *               negative.</span></span><br><span class="line"><span class="comment">     * @throws  IllegalMonitorStateException  if the current thread is not</span></span><br><span class="line"><span class="comment">     *               the owner of the object&#x27;s monitor.</span></span><br><span class="line"><span class="comment">     * @throws  InterruptedException if any thread interrupted the</span></span><br><span class="line"><span class="comment">     *             current thread before or while the current thread</span></span><br><span class="line"><span class="comment">     *             was waiting for a notification.  The &lt;i&gt;interrupted</span></span><br><span class="line"><span class="comment">     *             status&lt;/i&gt; of the current thread is cleared when</span></span><br><span class="line"><span class="comment">     *             this exception is thrown.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException; <span class="comment">//该方法只能在一个同步方法或同步块中调用</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">/* @param      timeout   the maximum time to wait in milliseconds.</span></span><br><span class="line"><span class="comment">     * @param      nanos      additional time, in nanoseconds range</span></span><br><span class="line"><span class="comment">     *                       0-999999.</span></span><br><span class="line"><span class="comment">     * @throws  IllegalArgumentException      if the value of timeout is</span></span><br><span class="line"><span class="comment">     *                      negative or the value of nanos is</span></span><br><span class="line"><span class="comment">     *                      not in the range 0-999999.</span></span><br><span class="line"><span class="comment">     * @throws  IllegalMonitorStateException  if the current thread is not</span></span><br><span class="line"><span class="comment">     *               the owner of this object&#x27;s monitor.</span></span><br><span class="line"><span class="comment">     * @throws  InterruptedException if any thread interrupted the</span></span><br><span class="line"><span class="comment">     *             current thread before or while the current thread</span></span><br><span class="line"><span class="comment">     *             was waiting for a notification.  The &lt;i&gt;interrupted</span></span><br><span class="line"><span class="comment">     *             status&lt;/i&gt; of the current thread is cleared when</span></span><br><span class="line"><span class="comment">     *             this exception is thrown.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException &#123;...&#125; <span class="comment">//该方法只能在一个同步方法或同步块中调用 ， 导致一个线程进入等待状态，直到它得到通知或经过了指定的时间</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">/* @throws  IllegalMonitorStateException  if the current thread is not</span></span><br><span class="line"><span class="comment">     *               the owner of the object&#x27;s monitor.</span></span><br><span class="line"><span class="comment">     * @throws  InterruptedException if any thread interrupted the</span></span><br><span class="line"><span class="comment">     *             current thread before or while the current thread</span></span><br><span class="line"><span class="comment">     *             was waiting for a notification.  The &lt;i&gt;interrupted</span></span><br><span class="line"><span class="comment">     *             status&lt;/i&gt; of the current thread is cleared when</span></span><br><span class="line"><span class="comment">     *             this exception is thrown.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123; <span class="comment">//该方法只能在一个同步方法或同步块中调用</span></span><br><span class="line">        wait(<span class="number">0</span>);  <span class="comment">//导致一个线程进入等待状态，直到它得到通知</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>内部锁</strong>和<strong>条件</strong>存在一些限制</p>
<ul>
<li><strong>不能中断</strong>一个正在<strong>尝试</strong>获得该锁的<strong>线程</strong></li>
<li><strong>不能</strong>指定<strong>尝试获得锁</strong>时的<strong>超时时间</strong></li>
<li>每个锁<strong>仅有一个条件</strong>可能是不够的</li>
</ul>
<p><u><strong>建议</strong></u></p>
<ul>
<li>最好既不使用<code>Lock/Condition</code>，也步使用<code>synchronized</code>关键字
<ul>
<li>可以使用java.util.concurrent包中的某种机制，它会处理所有的锁定
<ul>
<li>例如：阻塞队列同步完成一个共同任务的线程、并行流</li>
</ul>
</li>
</ul>
</li>
<li>如果<code>synchronized</code>关键字适合，尽量使用这种</li>
<li>需要<code>Lock/Condition</code>结构提供的额外能力，则使用<code>Lock/Condition</code></li>
</ul>
<h3 id="同步块"><a class="header-anchor" href="#同步块"> </a>同步块</h3>
<p>每个Java对象都有一个锁。</p>
<ul>
<li>线程可以通过调用<strong>同步方法</strong>来获得锁</li>
<li>线程也可以通过进入一个<strong>同步块</strong>来获得锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj)&#123; <span class="comment">// this is the syntax for a synchronized block</span></span><br><span class="line">    critical section</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建<code>lock</code>对象，只是为了使用每个Java对象拥有的锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span>[] accounts;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock)&#123; <span class="comment">// an ad-hoc lock</span></span><br><span class="line">            accounts[from] -= amount;</span><br><span class="line">        	accounts[to] += amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户端锁定（client-side locking）</strong>：使用一个<strong>对象的锁</strong>来实现额外的原子操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Vector&lt;Double&gt; accounts, <span class="type">int</span> from, <span class="type">int</span> to, <span class="type">double</span> amount)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(accounts)&#123; <span class="comment">// an ad-hoc lock</span></span><br><span class="line">        accounts.set(from,accounts.get(from) - amount);</span><br><span class="line">        accounts.set(to,accounts.get(to) + amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端是非常脆弱的，通常不推荐使用</p>
<ul>
<li>上面这代码中，我们不能保证<code>Vector</code>内部类中，对所有更改方法都使用内部锁</li>
</ul>
<h3 id="监视器"><a class="header-anchor" href="#监视器"> </a>监视器</h3>
<p><strong>锁</strong>和<strong>条件</strong>是实现线程同步的强大工具，但严格来讲它们<strong>不是面向对象的</strong></p>
<p>**监视器（monitor）**具有如下特性（这里是监视器的概念，不是Java真实实现的监视器）</p>
<ul>
<li>监视器是<strong>只包含私有字段</strong>的类</li>
<li>监视器类的<strong>每个对象</strong>有一个关联的<strong>锁</strong></li>
<li><strong>所有的方法</strong>由这个锁<strong>锁定</strong>
<ul>
<li>如果客户端调用<code>obj.method()</code>那么<code>obj</code>对象的<strong>锁</strong>在方法调用<strong>开始</strong>时自动<strong>获得</strong>，并且当方法<strong>返回时</strong>自动<strong>释放</strong>该锁</li>
<li>因为所有的字段时私有的，这样的安排可以确保一个线程处理字段时，没有其他线程能够访问这些字段</li>
</ul>
</li>
<li>锁可以有任意<strong>多个</strong>相关联的<strong>条件</strong></li>
</ul>
<p>Java监视器的<strong>早期版本</strong>只有单一条件，而不使用任何显式的条件变量</p>
<p><code>await accounts[from] &gt;= amount</code></p>
<ul>
<li>盲目地重新测试条件是低效的</li>
<li>利用显式的条件变量解决这个问题：每个条件变量管理单独的一组线程</li>
</ul>
<p>Java以<strong>不太严格</strong>的方式采用监视器概念</p>
<ul>
<li>Java中的<strong>每一个对象</strong>都有一个内部锁和一个内部条件。</li>
<li>如果一个方法用<code>synchronized</code>关键字声明，则它表现得就像一个监视器方法</li>
<li>可以通过调用<code>await</code>、<code>notify</code>、<code>notifyAll</code>来访问条件变量</li>
</ul>
<p>Java对象不同于监视器的地方，削弱了线程的安全性</p>
<ul>
<li>字段不要求是<code>private</code></li>
<li>方法不要求是<code>synchronized</code></li>
<li>内部锁对客户是可用的</li>
</ul>
<h3 id="volatile字段"><a class="header-anchor" href="#volatile字段"> </a>volatile字段</h3>
<p>场景：只是为了读写一两个实例字段而使用同步，所带来的开销好像有些划不来</p>
<p><strong>出错地方问题</strong></p>
<ul>
<li>有<strong>多处理器</strong>的计算机能够暂时在<strong>寄存器</strong>或<strong>本地内存缓存</strong>中保存内存值
<ul>
<li>运行在不同处理器上的线程可能看到<strong>同一个内存位置</strong>有<strong>不同值</strong></li>
</ul>
</li>
<li>编译器可以<strong>改变指令的顺序</strong>以使吞吐量最大化
<ul>
<li>编译器不会选择可能改变<strong>代码语义</strong>的顺序。但编译器认为内存值，只有在代码中有显式的修改指令时才会改变。但是内存值可能被<strong>另一个线程</strong>改变</li>
</ul>
</li>
</ul>
<p>使用<strong>锁</strong>来保护可能被多个线程访问的代码，不存在上述问题。编译器被要求在必要的时候<strong>刷新本地缓存</strong>来支持锁</p>
<p><code>volatile</code>关键字为<strong>实例字段</strong>的<strong>同步访问</strong>提供一种<strong>免锁机制</strong></p>
<ul>
<li>如果声明一个字段为<code>volatile</code>，那么编译器和虚拟机就知道该字段可能被另一个线程并发更新</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> done;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span> &#123;<span class="keyword">return</span> done;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDone</span><span class="params">()</span> &#123;done = <span class="literal">true</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>编译器会插入适当的代码，以确保如果一个线程对<code>done</code>变量做了修改，这个修改对读取这个变量的所有<strong>其他线程都可见</strong></p>
<ul>
<li>线程对<code>volatile</code>关键字修饰的变量进行<strong>修改</strong>后，要立刻写回<strong>主内存</strong>中
<ul>
<li><code>volatile</code>使得该变量的每次修改后，增加了一个<strong>内存屏障</strong>，保证修改后的值必须刷新到<strong>主内存</strong>，才能进行内存屏障后续的指令操作</li>
</ul>
</li>
<li>线程对<code>volatile</code>关键字修饰的变量进行读取的时候，要从<strong>主内存</strong>中读，而不是缓存</li>
</ul>
<p><u><strong>注意</strong></u></p>
<p><code>volatile</code>变量不能提供原子性（不能保证原子性）</p>
<ul>
<li>不能确保翻转字段中的值。不能保证读取、翻转和写入不被中断</li>
</ul>
<p>例如 <code>i++</code>，对应指令可以分为load、increment、store、memory barries四个操作。</p>
<blockquote>
<p>内存屏障是线程安全的，但是内存屏障<strong>之前</strong>的指令<strong>不是线程安全</strong>的</p>
</blockquote>
<p>对于自增操作来说，<strong>寄存器</strong>保存<strong>中间值</strong>，在<strong>没有刷入主内存</strong>之前，可能被另外的线程打断，并读取同一个变量进行操作，从而出现了不一致的情况。</p>
<h3 id="final变量"><a class="header-anchor" href="#final变量"> </a>final变量</h3>
<p>使用锁和<code>volatile</code>修饰符，可以从多个线程安全地读取一个字段</p>
<p>将一个字段声明为<code>final</code>时，也可以安全地访问该共享字段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap&lt;String,Double&gt; accounts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p><strong>其他线程</strong>会在<strong>构造器完成构造</strong>之后<strong>才看到这个accounts变量</strong></p>
<p>如果不使用<code>final</code>，就不能保证其他线程看到的是<code>accounts</code>更新的值，它们可能只是看到<code>null</code>，而不是新构造的<code>HashMap</code></p>
<p>注意：final不保证map的操作（<code>put</code>，<code>get</code>方法）是线程安全的，如果有多个线程更改和读取这个映射（map），仍需要同步</p>
<h3 id="原子性"><a class="header-anchor" href="#原子性"> </a>原子性</h3>
<p>java.util.concurrent.atomic包中有很多类使用了很高效的机器级指令来保证其他操作的原子性</p>
<h3 id="死锁"><a class="header-anchor" href="#死锁"> </a>死锁</h3>
<p>锁和条件不能解决多线程中的死锁问题</p>
<h3 id="线程局部变量"><a class="header-anchor" href="#线程局部变量"> </a>线程局部变量</h3>
<p>使用<code>ThreadLocal</code>辅助类为<strong>各个线程</strong>提供<strong>各自的实例</strong></p>
<p>解决问题：例如<code>SimpleDateFormat</code>类不是线程安全的，如果多线程并发访问，其内部的数据结构可能会被破坏而结果错误</p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>多个线程同时调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">dateStamp</span> <span class="operator">=</span> dataFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></table></figure>
<p>则在同时访问dateFormat对象时可能出错</p>
<ul>
<li>可以通过使用同步，但是开销很大</li>
<li>在需要的时候构造一个局部<code>SimpleDateFormat</code>对象，但是太浪费</li>
</ul>
<p>解决办法：</p>
<p>为每个线程构造一个实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormat =</span><br><span class="line">    ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>要访问具体的格式化方法，可以调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">dateStamp</span> <span class="operator">=</span> dateFormat.get().format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></table></figure>
<ul>
<li>在一个给定线程中<strong>首次</strong>调用<code>get</code>时，会调用构造器中的<code>lambda</code>表达式。</li>
<li>此后的<code>get</code>方法返回属于当前线程的那个实例</li>
</ul>
<p>多个线程生成随机数问题：</p>
<p>java.util.Random类是线程安全，但多线程访问需要等待一个共享的随机数生成器，效率低</p>
<ul>
<li>
<p>可以使用<code>ThreadLocal</code>辅助类，为每个线程提供一个单独的生成器</p>
</li>
<li>
<p>Java7提供一个便利类</p>
<ul>
<li>
<pre><code class="language-Java">int random = ThreadLocalRandom.current().nextInt(upperBound);
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - `ThreadLocalRandom.current()`返回特定于当前线程的`Random`类的实例</span><br><span class="line"></span><br><span class="line">### 废弃`stop`和`suspend`方法的原因</span><br><span class="line"></span><br><span class="line">最初的`Java`版本定义</span><br><span class="line"></span><br><span class="line">- `stop`来终止线程</span><br><span class="line">- `suspend`方法来阻塞线程，直到另一个线程调用`resume`</span><br><span class="line"></span><br><span class="line">`stop`和`suspend`方法都试图控制一个给定线程，而没有线程的互操作</span><br><span class="line"></span><br><span class="line">#### stop方法</span><br><span class="line"></span><br><span class="line">该方法会终止所有未结束的方法，包括`run`方法。当线程被终止，它会立即释放被它锁定的所有对象的锁。</span><br><span class="line"></span><br><span class="line">这会导致对象处于不一致的状态</span><br><span class="line"></span><br><span class="line">因此：希望停止一个线程的时候应该中断（intterupt）该线程，被中断的线程可以在安全的时候终止</span><br><span class="line"></span><br><span class="line">&gt; 被停止（stop方法调用）的线程会抛出`ThreadDeath`异常，从而退出它调用的所有同步方法。因此这个线程会释放它持有的内部对象锁</span><br><span class="line"></span><br><span class="line">#### suspend方法</span><br><span class="line"></span><br><span class="line">`suspend`方法不会破坏对象，但是会导致**死锁**</span><br><span class="line"></span><br><span class="line">- 用`suspend`挂起一个持有锁的线程，那么在线程恢复运行之前这个锁是不可用的。</span><br><span class="line">- 如果调用`suspend`的方法线程试图获得同一个锁（被`suspend`的线程持有的锁），那么程序出现死锁</span><br><span class="line"></span><br><span class="line">**被挂起的线程等待恢复，将其挂起的线程等待获得锁**</span><br><span class="line"></span><br><span class="line">## 线程安全的集合</span><br><span class="line"></span><br><span class="line">可以通过提供**锁**来保护共享的数据结构，也可以选择**线程安全的实现**</span><br><span class="line"></span><br><span class="line">### 阻塞队列 blocking queue</span><br><span class="line"></span><br><span class="line">很多线程问题可以用**队列**描述</span><br><span class="line"></span><br><span class="line">- **生产者**线程向队列**插入**元素</span><br><span class="line">- **消费者**线程则**获取**元素</span><br><span class="line"></span><br><span class="line">**阻塞队列**：试图向队列**添加**元素而队列已**满**，或想从队列**移出**元素而队列为**空**时，阻塞队列将导致**线程阻塞**</span><br><span class="line"></span><br><span class="line">**阻塞队列方法**分成以下3种：根据当队列**满或空**时它们完成的动作</span><br><span class="line"></span><br><span class="line">- `put`、`take`</span><br><span class="line">  - 队列作为**线程管理工具**时，</span><br><span class="line">  - `put`如果队列满则阻塞</span><br><span class="line">  - `take`如果队列空则阻塞</span><br><span class="line">- `add`、`remove`、`element`</span><br><span class="line">  - 抛出异常</span><br><span class="line">  - `IllegalStateException`、`NoSuchElementException`</span><br><span class="line">- `offer`、`poll`、`peek`</span><br><span class="line">  - 给出一个错误提示而不会抛出异常</span><br><span class="line">  - 返回`false`或`null`</span><br><span class="line"></span><br><span class="line">&gt; `poll`和`peek`方法返回`null`来**指示失败**，因此，向这些队列中**插入**`null`值是**非法**的</span><br><span class="line"></span><br><span class="line">同时也有带超时时间的`offer`方法和`poll`方法</span><br><span class="line"></span><br><span class="line">`put`和`take`方法与不带超时参数的`offer`和`poll`方法等效</span><br><span class="line"></span><br><span class="line">java.util.concurrent包种提供了阻塞队列的几个变体</span><br><span class="line"></span><br><span class="line">```Java</span><br><span class="line">public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt; &#123;</span><br><span class="line">    boolean add(E e);</span><br><span class="line">    boolean offer(E e);</span><br><span class="line">    void put(E e) throws InterruptedException;</span><br><span class="line">    boolean offer(E e, long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException;</span><br><span class="line">    E take() throws InterruptedException;</span><br><span class="line">    E poll(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException;</span><br><span class="line">    int remainingCapacity();</span><br><span class="line">    boolean remove(Object o);</span><br><span class="line">    public boolean contains(Object o);</span><br><span class="line">    int drainTo(Collection&lt;? super E&gt; c);</span><br><span class="line">    int drainTo(Collection&lt;? super E&gt; c, int maxElements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlockingDeque</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">BlockingQueue</span>&lt;E&gt;, Deque&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">putFirst</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">putLast</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e, <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e, <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    E <span class="title function_">takeFirst</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    E <span class="title function_">takeLast</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    E <span class="title function_">pollFirst</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    E <span class="title function_">pollLast</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">removeFirstOccurrence</span><span class="params">(Object o)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">removeLastOccurrence</span><span class="params">(Object o)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e, <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    E <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">poll</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    E <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    E <span class="title function_">element</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">peek</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">    Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LinkedBlockingQueue</code>的容量没有上界，但是可以指定一个最大容量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedBlockingQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> putLock.newCondition();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LinkedBlockingDeque</code>是一个双端队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedBlockingDeque</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">BlockingDeque</span>&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/** Main lock guarding all access */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Condition for waiting takes */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Condition for waiting puts */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ArrayBlockingQueue</code>在构造时，需要<strong>指定容量</strong>，并且有一个可选的参数来指定是否需要<strong>公平性</strong></p>
<ul>
<li>设置了公平参数，那么等待了最长时间的线程会优先得到处理。</li>
<li>通常公平性会降低性能</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayBlockingQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line">    <span class="comment">/** The queued items */</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line">    <span class="comment">/** Main lock guarding all access */</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    <span class="comment">/** Condition for waiting takes */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">    <span class="comment">/** Condition for waiting puts */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(capacity, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">        lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(fair);</span><br><span class="line">        notEmpty = lock.newCondition();</span><br><span class="line">        notFull =  lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair,</span></span><br><span class="line"><span class="params">                              Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PriorityBlockingQueue</code>是一个<strong>优先队列</strong>，不是先进先出队列。</p>
<ul>
<li>元素按照它们的优先级顺序移除</li>
<li>队列没有容量上限</li>
<li>如果队列是空的，则获取元素操作会阻塞</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityBlockingQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Object[] queue;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The comparator, or null if priority queue uses elements&#x27;</span></span><br><span class="line"><span class="comment">     * natural ordering.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Comparator&lt;? <span class="built_in">super</span> E&gt; comparator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Lock used for all public operations</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Condition for blocking when empty</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spinlock for allocation, acquired via CAS.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> allocationSpinLock;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DelayQueue</code>包含实现了<code>Delayed</code>接口的对象</p>
<p>元素只有在延迟结束的情况，才能从<code>DelayQueue</code>移除</p>
<p>还需要实现<code>compareTo</code>方法，<code>DelayQueue</code>使用该方法对元素排序（不能通过构造器传入<code>comparator</code>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Delayed</span> <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Delayed&gt; &#123;</span><br><span class="line">    <span class="comment">// 返回对象的剩余延迟。0或负值表示延迟已经结束</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">getDelay</span><span class="params">(TimeUnit unit)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayQueue</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;E&gt;();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java7增加<code>TransferQueue</code>接口，允许生产者线程等待，直到消费者准备就绪就可以接收元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransferQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">BlockingQueue</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//传输成功返回true，否则false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryTransfer</span><span class="params">(E e)</span>;</span><br><span class="line">	<span class="comment">// 传输一个值，或者尝试在给定的超时时间传输这个值，这个调用将阻塞，直到另一个线程将元素删除</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryTransfer</span><span class="params">(E e, <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasWaitingConsumer</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getWaitingConsumerCount</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedTransferQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">TransferQueue</span>&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高效的映射、集和队列"><a class="header-anchor" href="#高效的映射、集和队列"> </a>高效的映射、集和队列</h3>
<p><code>ConcurrentHashMap</code>、<code>ConcurrentSkipListMap</code>、<code>ConcurrentSkipListSet</code>、<code>ConcurrentLinkedQueue</code></p>
<p>这些集合通过<strong>允许并发</strong>地访问数据结构的<strong>不同部分</strong>，尽可能<strong>减少竞争</strong></p>
<p>与大多数集合不同，这些类的 <code>size</code>方法不一定在常量时间内完成操作</p>
<ul>
<li>确定这些集合的当前大小通常需要遍历</li>
</ul>
<p>集合返回**弱一致性（weakly consistent）**的迭代器</p>
<ul>
<li>迭代器不一定能反映出它们构造之后的所有更改</li>
<li>但不会将同一个值返回两次</li>
<li>不会抛出<code>ConcurrentModificationException</code>异常
<ul>
<li>java.util包中的集合在迭代器构造后发生改变，会抛出异常</li>
</ul>
</li>
</ul>
<p><code>ConcurrentHashMap</code>可以高效的支持大量的<strong>阅读器</strong>和一定数量的<strong>书写器</strong>。</p>
<ul>
<li>默认情况下可以至多16个同时运行的书写器线程。</li>
<li>可以有更多的书写其线程，但是同一时间如果多于16个，其他线程将暂时阻塞</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">ConcurrentMap</span>&lt;K,V&gt;, Serializable &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>; <span class="comment">// 默认初是容量为16</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>; <span class="comment">// 装载银子默认值为0.75，如果每个桶的平均负载超过装载因子，表的大小会重新调整</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                             <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123; <span class="comment">// 并发级别是估计的并发书写器的线程数</span></span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">            initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">long</span>)(<span class="number">1.0</span> + (<span class="type">long</span>)initialCapacity / loadFactor);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> (size &gt;= (<span class="type">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">            MAXIMUM_CAPACITY : tableSizeFor((<span class="type">int</span>)size);</span><br><span class="line">        <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">mappingCount</span><span class="params">()</span> &#123;...&#125; <span class="comment">//如果映射操作20亿个条目，可以将大小作为long返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentSkipListMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">ConcurrentNavigableMap</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentSkipListSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableSet</span>&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="映射条目的原子更新"><a class="header-anchor" href="#映射条目的原子更新"> </a>映射条目的原子更新</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.compute(word,(k,v) -&gt; v == <span class="literal">null</span> ? <span class="number">1</span> : v + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>ConcurrentHashMap</code>中不允许有null值，因为很多方法都使用<code>null</code>值来指示映射中某个给定的键不存在</p>
</blockquote>
<p><code>computeIfPresent</code>只在已经有原值的情况下计算</p>
<p><code>computeIfAbsent</code>只在没有原值的情况下计算新值</p>
<p><code>map.merge(word,1L,(existingValue, newValue) -&gt; existingValue + newValue);</code></p>
<p>或</p>
<p><code>map.merge(word,1L,Long::sum)</code></p>
<blockquote>
<p>如果传入<code>merge</code>或<code>compute</code>的函数返回null，则将从映射中删除现有的条目</p>
</blockquote>
<h4 id="对并发散列映射的批操作"><a class="header-anchor" href="#对并发散列映射的批操作"> </a>对并发散列映射的批操作</h4>
<p>即使有其他线程在处理映射，这些操作也能安全地执行。</p>
<p>批操作会<strong>遍历</strong>映射，处理遍历过程中找到的元素</p>
<blockquote>
<p>要把结果看作是映射状态的一个近似</p>
</blockquote>
<p>有3种不同的操作：</p>
<ul>
<li>search（搜索）为每个键或值应用一个函数，直到函数生成一个非null的结果。然后搜索终止，返回这个函数的结果</li>
<li>reduce（归约）组合所有键或值，这里要使用所提供的一个累加哈桑农户</li>
<li>forEach为所有键或值应用一个函数</li>
</ul>
<p>每个操作有4个版本</p>
<ul>
<li>operationKeys：处理键</li>
<li>operationValues：处理值</li>
<li>operation：处理键和值</li>
<li>operationEntries：处理Map.Entry对象</li>
</ul>
<p>各个操作需要提供一个<strong>参数化阈值（paralelism threshold）</strong>。</p>
<ul>
<li>如果映射包含的元素多于这个阈值，就会并行完成批操作</li>
<li>希望批操作在一个线程运行，阈值Long.MAX_VALUE</li>
<li>希望使用尽可能多的线程运行批操作，阈值1</li>
</ul>
<h4 id="并发集视图"><a class="header-anchor" href="#并发集视图"> </a>并发集视图</h4>
<p><code>Set&lt;String&gt; words = ConcurrentHashMap.&lt;String&gt;newKeySet();</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@link</span> Set&#125; backed by a ConcurrentHashMap</span></span><br><span class="line"><span class="comment">     * from the given type to &#123;<span class="doctag">@code</span> Boolean.TRUE&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;K&gt; the element type of the returned set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the new set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K&gt; KeySetView&lt;K,Boolean&gt; <span class="title function_">newKeySet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeySetView</span>&lt;K,Boolean&gt;</span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;K,Boolean&gt;(), Boolean.TRUE);</span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Set&#125; view of the keys in this map, using the</span></span><br><span class="line"><span class="comment">     * given common mapped value for any additions (i.e., &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * Collection#add&#125; and &#123;<span class="doctag">@link</span> Collection#addAll(Collection)&#125;).</span></span><br><span class="line"><span class="comment">     * This is of course only appropriate if it is acceptable to use</span></span><br><span class="line"><span class="comment">     * the same value for all additions from this view.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mappedValue the mapped value to use for any additions</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the set view</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the mappedValue is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> KeySetView&lt;K,V&gt; <span class="title function_">keySet</span><span class="params">(V mappedValue)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mappedValue == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeySetView</span>&lt;K,V&gt;(<span class="built_in">this</span>, mappedValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写数组拷贝"><a class="header-anchor" href="#写数组拷贝"> </a>写数组拷贝</h3>
<p><code>CopyOnWriteArrayList</code>和<code>CopyOnWriteArraySet</code>是线程安全的集合</p>
<ul>
<li>所有更改器会建立底层数组的一个<strong>副本</strong>
<ul>
<li>如果迭代<strong>访问</strong>集合的线程数超过<strong>更改</strong>集合的线程数，是有用的</li>
<li>迭代器包含当前数组一个引用，数组被修改后，迭代器仍然引用旧的数组</li>
</ul>
</li>
<li>原来的迭代器可以访问一致但可能过时的视图，而且不存在任何同步开销</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并行数组算法"><a class="header-anchor" href="#并行数组算法"> </a>并行数组算法</h3>
<p><code>Arrays.parallelSort</code>方法可以对一个基本类型值或对象的数组进行排序，同时可提供构造器</p>
<p><code>Arrays.parallelPrefix</code>方法用一个给定结合操作和相应前缀的累加结果替换各个数组元素</p>
<p><code>Arrays.parallelSetAll</code>方法会用一个函数计算得到的值填充一个数组。这个函数接收元素索引，然后计算相应位置上的值</p>
<h3 id="较早线程安全集合"><a class="header-anchor" href="#较早线程安全集合"> </a>较早线程安全集合</h3>
<p><code>Vector</code>和<code>Hashtable</code>类提供了<strong>动态数组</strong>和<strong>散列表</strong>的<strong>线程安全</strong>的实现，但已过时，被<code>ArrayList</code>和<code>HashMap</code>取代（这两个不是线程安全的）</p>
<p>集合库提供一种机制：<strong>同步包装器（synchronization wrapper）<strong>将</strong>集合类</strong>变成<strong>线程安全</strong>的</p>
<p><code>List&lt;E&gt; syncArrayList = Collections.synchronizedList(new ArrayList&lt;E&gt;());</code></p>
<p><code>Map&lt;K, V&gt; synchHashMap = Collections.synchronizedMap(new HashMap&lt;K, V&gt;());</code></p>
<p>通过<strong>同步包装器</strong>，结果集合（例如这里的<code>syncArrayList </code>和<code>synchHashMap </code>）的方法使用<strong>锁</strong>加以保护，可以提供线程安全的访问</p>
<p>同时，应该确保<strong>没有任何线程</strong>通过<strong>原始</strong>的<strong>非同步方法</strong>访问数据结构。</p>
<ul>
<li>确保不保存原始对象的任何引用，简单地构造一个集合并立即传递给包装器</li>
</ul>
<p>最好使用java.util.concurrent包中定义的集合，而不是同步包装器</p>
<ul>
<li>例外：如果经常更改的数组列表。使用同步的<code>ArrayList</code>要胜过<code>CopyOnWriteArrayList</code></li>
</ul>
<p><u><strong>注意</strong></u></p>
<ul>
<li>这个是<strong>方法</strong>，不是构造器，不能<code>new</code></li>
<li>错误代码：<code>List&lt;String&gt; syncArrayList =  new Collections.synchronizedList(new ArrayList&lt;String&gt;());</code></li>
</ul>
<h2 id="任务和线程池"><a class="header-anchor" href="#任务和线程池"> </a>任务和线程池</h2>
<p>场景：<strong>构造</strong>一个<strong>新的线程开销</strong>有些<strong>大</strong>，因为涉及与<strong>操作系统的交互</strong>。如果程序中创建了<strong>大量的生命周期很短</strong>的线程，那么不应该把每个任务都映射到一个<strong>单独</strong>的<strong>线程</strong>，而应该使用<strong>线程池（thread pool）</strong></p>
<p>线程池中包含许多<strong>准备运行</strong>的线程。</p>
<p>为<strong>线程池</strong>提供一个<code>Runnable</code>，就会有一个线程调用<code>run</code>方法。当<code>run</code>方法<strong>退出</strong>时，该线程<strong>不会死亡</strong>，而是<strong>留在池</strong>中，为下一个请求提供服务</p>
<h3 id="Callable与Future"><a class="header-anchor" href="#Callable与Future"> </a>Callable与Future</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">//运行一个将产生结果的的任务</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Runnable</code>与<code>Callable</code>区别</p>
<ul>
<li><code>Runnable</code>没有参数，也有没返回值；<code>Callable</code>有返回值</li>
<li><code>Runnable</code>不抛出异常；<code>Callable</code>可以抛出异常</li>
<li><code>Callable</code>接口是一个<strong>参数化类型</strong>，只有一个方法<code>call</code></li>
</ul>
<p><code>Runnable</code>封装一个<strong>异步运行</strong>的任务，可以把它想象成一个<strong>没有参数</strong>和<strong>返回值</strong>的<strong>异步方法</strong>，<code>Callable</code>与<code>Runnable</code>类似。</p>
<p><code>Callable</code>和<code>Runnable</code>都是为那些类的实例可能被其他线程执行而设计的</p>
<p>对于<code>Callable</code>:</p>
<ul>
<li>类型参数是<strong>返回值类型</strong>
<ul>
<li>例如，<code>Callable&lt;Integer&gt;</code>表示一个最终返回<code>Integer</code>对象的<strong>异步计算</strong></li>
</ul>
</li>
<li>可能<strong>返回一个结果</strong>，也可能<strong>抛出异常</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试取消这个任务的运行</span></span><br><span class="line">    <span class="comment">//如果任务已经完成或已经取消或由于某些原因而不能取消，则返回false;</span></span><br><span class="line">    <span class="comment">//如果任务还没有开始，然后调用了cancel，则取消该任务就不会执行。</span></span><br><span class="line">    <span class="comment">//如果任务已经开始了，这是需要看mayInterruptIfRunning参数，来决定是否中断该任务</span></span><br><span class="line">    <span class="comment">//在调用cancel后调用isDone会返回true</span></span><br><span class="line">    <span class="comment">//如果cancel方法返回true,则调用isCancel返回true</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在任务完成前被取消，则返回true</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果任务结束，无论是正常完成、中途取消、还是发生异常，都返回true</span></span><br><span class="line">    <span class="comment">//如果任务还在进行，返回false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> CancellationException if the computation was cancelled</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException if the computation threw an</span></span><br><span class="line"><span class="comment">     * exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if the current thread was interrupted</span></span><br><span class="line"><span class="comment">     * while waiting</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//获取结果，这个方法会阻塞，直到计算完成</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout the maximum time to wait // 阻塞等待的最长时间，如果时间过来还没计算完，则抛出异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit of the timeout argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> CancellationException if the computation was cancelled</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException if the computation threw an</span></span><br><span class="line"><span class="comment">     * exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if the current thread was interrupted</span></span><br><span class="line"><span class="comment">     * while waiting</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> TimeoutException if the wait timed out</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//阻塞，直到结果可用或超过了指定时间</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Future</code>保存异步计算的结果。可以启动一个计算，将<code>Future</code>对象交给某个<strong>线程</strong>。这个<code>Future</code>对象的所有者在<strong>结果计算好</strong>之后就可以获得结果</p>
<p><strong>取消</strong>一个<strong>任务</strong>涉及<strong>两个步骤</strong></p>
<ul>
<li>必须<strong>找到</strong>并<strong>中断</strong>底层<strong>线程</strong>
<ul>
<li>如果<code>Future</code>对象不知道任务在哪个线程执行，则<strong>取消</strong>任务没有任何效果</li>
</ul>
</li>
<li>任务<strong>实现</strong>（在call方法中）必须<strong>感知</strong>到<strong>中断</strong>，并<strong>放弃</strong>它的工作
<ul>
<li>如果任务<strong>没有监视</strong>执行该任务的线程的<strong>中断状态</strong>，取消任务没有任何效果</li>
</ul>
</li>
</ul>
<p>执行<code>Callable</code>的一种方法是使用<code>FutureTask</code>，它实现了<code>Future</code>和<code>Runnable</code>接口，可以构造一个<strong>线程</strong>来运行这个<strong>任务</strong>。</p>
<ul>
<li>意思是把我们所要做的任务放在<code>FutureTask</code>中，然后创建一个线程，将<code>FutureTask</code>放进去来执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Callable&lt;Integer&gt; task = ...;</span><br><span class="line"><span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(task);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask); <span class="comment">// it&#x27;s Runnable</span></span><br><span class="line">t.start();</span><br><span class="line">...</span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> task.get(); <span class="comment">// it&#x27;s Future</span></span><br></pre></td></tr></table></figure>
<p>更常见的做法是，将一个<code>Callable</code>传递到一个<strong>执行器</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Runnable</span>, Future&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><u>注意</u></strong></p>
<ul>
<li>Java可以<strong>继承</strong>多个<strong>接口</strong>，可以<strong>实现</strong>多个<strong>接口</strong></li>
</ul>
<h3 id="执行器"><a class="header-anchor" href="#执行器"> </a>执行器</h3>
<p><strong>执行器</strong>（Executors）类有许多静态工厂方法，用来<strong>构造线程池</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Executors</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 池中包含固定数目的线程；空闲线程会一直保留</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一种适合“fork-join”任务的线程池，其中复杂的任务会分解为更简单的任务，空闲线程会密取较简单的任务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newWorkStealingPool</span><span class="params">(<span class="type">int</span> parallelism)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span></span><br><span class="line">            (parallelism,</span><br><span class="line">             ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">             <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a work-stealing thread pool using all</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Runtime#availableProcessors available processors&#125;</span></span><br><span class="line"><span class="comment">     * as its target parallelism level.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the newly created thread pool</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #newWorkStealingPool(int)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newWorkStealingPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span></span><br><span class="line">            (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">             ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">             <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ThreadFactory用于在需要的时候创建新的线程</span></span><br><span class="line">    <span class="comment">// 最多有nThreads个数量的线程线程处理任务。如果有多余任务在nThreads个线程都在工作时进入，该任务会进入队列直到线程可以利用</span></span><br><span class="line">    <span class="comment">// 如果在shutdown之前，有某个线程由于failure而终止，一个新的线程会取代它并执行剩余工作（如果需要的话）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只有一个线程的“池”，会顺序执行所提交的任务</span></span><br><span class="line">    <span class="comment">//注意，如果这个唯一的线程在shutdown之前,在执行的时候，由于failure而终止，会有新的线程代替它并执行剩余工作</span></span><br><span class="line">    <span class="comment">// 与newFixedThreadPool(1)区别在于：newSingleThreadExecutor的线程数保证不能改变</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//必要时创建新线程，空闲线程会一致保留60秒</span></span><br><span class="line">    <span class="comment">//该线程适用于有大量短存活时间的异步任务</span></span><br><span class="line">    <span class="comment">//会立即执行各个任务</span></span><br><span class="line">    <span class="comment">// 有空闲线程可用，就使用空闲线程执行任务</span></span><br><span class="line">    <span class="comment">// 没有可用的空闲线程，就创建一个新的线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a single-threaded executor that can schedule commands</span></span><br><span class="line"><span class="comment">     * to run after a given delay, or to execute periodically.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 用于调度执行的单线程“池”</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newSingleThreadScheduledExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DelegatedScheduledExecutorService</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newSingleThreadScheduledExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DelegatedScheduledExecutorService</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>, threadFactory));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a thread pool that can schedule commands to run after a</span></span><br><span class="line"><span class="comment">     * given delay, or to execute periodically.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//用于调度执行的固定线程池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a thread pool that can schedule commands to run after a</span></span><br><span class="line"><span class="comment">     * given delay, or to execute periodically.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 用于调度执行的固定线程池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="type">int</span> corePoolSize, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an object that delegates all defined &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * ExecutorService&#125; methods to the given executor, but not any</span></span><br><span class="line"><span class="comment">     * other methods that might otherwise be accessible using</span></span><br><span class="line"><span class="comment">     * casts. This provides a way to safely &quot;freeze&quot; configuration and</span></span><br><span class="line"><span class="comment">     * disallow tuning of a given concrete implementation.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executor the underlying implementation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an &#123;<span class="doctag">@code</span> ExecutorService&#125; instance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if executor null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">unconfigurableExecutorService</span><span class="params">(ExecutorService executor)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DelegatedExecutorService</span>(executor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an object that delegates all defined &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * ScheduledExecutorService&#125; methods to the given executor, but</span></span><br><span class="line"><span class="comment">     * not any other methods that might otherwise be accessible using</span></span><br><span class="line"><span class="comment">     * casts. This provides a way to safely &quot;freeze&quot; configuration and</span></span><br><span class="line"><span class="comment">     * disallow tuning of a given concrete implementation.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executor the underlying implementation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> ScheduledExecutorService&#125; instance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if executor null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">unconfigurableScheduledExecutorService</span><span class="params">(ScheduledExecutorService executor)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DelegatedScheduledExecutorService</span>(executor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a default thread factory used to create new threads.</span></span><br><span class="line"><span class="comment">     * This factory creates all new threads used by an Executor in the</span></span><br><span class="line"><span class="comment">     * same &#123;<span class="doctag">@link</span> ThreadGroup&#125;. If there is a &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * java.lang.SecurityManager&#125;, it uses the group of &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * System#getSecurityManager&#125;, else the group of the thread</span></span><br><span class="line"><span class="comment">     * invoking this &#123;<span class="doctag">@code</span> defaultThreadFactory&#125; method. Each new</span></span><br><span class="line"><span class="comment">     * thread is created as a non-daemon thread with priority set to</span></span><br><span class="line"><span class="comment">     * the smaller of &#123;<span class="doctag">@code</span> Thread.NORM_PRIORITY&#125; and the maximum</span></span><br><span class="line"><span class="comment">     * priority permitted in the thread group.  New threads have names</span></span><br><span class="line"><span class="comment">     * accessible via &#123;<span class="doctag">@link</span> Thread#getName&#125; of</span></span><br><span class="line"><span class="comment">     * &lt;em&gt;pool-N-thread-M&lt;/em&gt;, where &lt;em&gt;N&lt;/em&gt; is the sequence</span></span><br><span class="line"><span class="comment">     * number of this factory, and &lt;em&gt;M&lt;/em&gt; is the sequence number</span></span><br><span class="line"><span class="comment">     * of the thread created by this factory.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a thread factory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title function_">defaultThreadFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultThreadFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a thread factory used to create new threads that</span></span><br><span class="line"><span class="comment">     * have the same permissions as the current thread.</span></span><br><span class="line"><span class="comment">     * This factory creates threads with the same settings as &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * Executors#defaultThreadFactory&#125;, additionally setting the</span></span><br><span class="line"><span class="comment">     * AccessControlContext and contextClassLoader of new threads to</span></span><br><span class="line"><span class="comment">     * be the same as the thread invoking this</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> privilegedThreadFactory&#125; method.  A new</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> privilegedThreadFactory&#125; can be created within an</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> AccessController#doPrivileged AccessController.doPrivileged&#125;</span></span><br><span class="line"><span class="comment">     * action setting the current thread&#x27;s access control context to</span></span><br><span class="line"><span class="comment">     * create threads with the selected permission settings holding</span></span><br><span class="line"><span class="comment">     * within that action.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that while tasks running within such threads will have</span></span><br><span class="line"><span class="comment">     * the same access control and class loader settings as the</span></span><br><span class="line"><span class="comment">     * current thread, they need not have the same &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * java.lang.ThreadLocal&#125; or &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * java.lang.InheritableThreadLocal&#125; values. If necessary,</span></span><br><span class="line"><span class="comment">     * particular values of thread locals can be set or reset before</span></span><br><span class="line"><span class="comment">     * any task runs in &#123;<span class="doctag">@link</span> ThreadPoolExecutor&#125; subclasses using</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> ThreadPoolExecutor#beforeExecute(Thread, Runnable)&#125;.</span></span><br><span class="line"><span class="comment">     * Also, if it is necessary to initialize worker threads to have</span></span><br><span class="line"><span class="comment">     * the same InheritableThreadLocal settings as some other</span></span><br><span class="line"><span class="comment">     * designated thread, you can create a custom ThreadFactory in</span></span><br><span class="line"><span class="comment">     * which that thread waits for and services requests to create</span></span><br><span class="line"><span class="comment">     * others that will inherit its values.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a thread factory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AccessControlException if the current access control</span></span><br><span class="line"><span class="comment">     * context does not have permission to both get and set context</span></span><br><span class="line"><span class="comment">     * class loader</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title function_">privilegedThreadFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PrivilegedThreadFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Callable&#125; object that, when</span></span><br><span class="line"><span class="comment">     * called, runs the given task and returns the given result.  This</span></span><br><span class="line"><span class="comment">     * can be useful when applying methods requiring a</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Callable&#125; to an otherwise resultless action.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task the task to run</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result the result to return</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a callable object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if task null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="title function_">callable</span><span class="params">(Runnable task, T result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RunnableAdapter</span>&lt;T&gt;(task, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Callable&#125; object that, when</span></span><br><span class="line"><span class="comment">     * called, runs the given task and returns &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task the task to run</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a callable object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if task null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title function_">callable</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RunnableAdapter</span>&lt;Object&gt;(task, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Callable&#125; object that, when</span></span><br><span class="line"><span class="comment">     * called, runs the given privileged action and returns its result.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> action the privileged action to run</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a callable object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if action null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title function_">callable</span><span class="params">(<span class="keyword">final</span> PrivilegedAction&lt;?&gt; action)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> &#123; <span class="keyword">return</span> action.run(); &#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Callable&#125; object that, when</span></span><br><span class="line"><span class="comment">     * called, runs the given privileged exception action and returns</span></span><br><span class="line"><span class="comment">     * its result.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> action the privileged exception action to run</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a callable object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if action null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title function_">callable</span><span class="params">(<span class="keyword">final</span> PrivilegedExceptionAction&lt;?&gt; action)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; <span class="keyword">return</span> action.run(); &#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Callable&#125; object that will, when called,</span></span><br><span class="line"><span class="comment">     * execute the given &#123;<span class="doctag">@code</span> callable&#125; under the current access</span></span><br><span class="line"><span class="comment">     * control context. This method should normally be invoked within</span></span><br><span class="line"><span class="comment">     * an &#123;<span class="doctag">@link</span> AccessController#doPrivileged AccessController.doPrivileged&#125;</span></span><br><span class="line"><span class="comment">     * action to create callables that will, if possible, execute</span></span><br><span class="line"><span class="comment">     * under the selected permission settings holding within that</span></span><br><span class="line"><span class="comment">     * action; or if not possible, throw an associated &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * AccessControlException&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callable the underlying task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the callable&#x27;s result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a callable object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if callable null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="title function_">privilegedCallable</span><span class="params">(Callable&lt;T&gt; callable)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PrivilegedCallable</span>&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Callable&#125; object that will, when called,</span></span><br><span class="line"><span class="comment">     * execute the given &#123;<span class="doctag">@code</span> callable&#125; under the current access</span></span><br><span class="line"><span class="comment">     * control context, with the current context class loader as the</span></span><br><span class="line"><span class="comment">     * context class loader. This method should normally be invoked</span></span><br><span class="line"><span class="comment">     * within an</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> AccessController#doPrivileged AccessController.doPrivileged&#125;</span></span><br><span class="line"><span class="comment">     * action to create callables that will, if possible, execute</span></span><br><span class="line"><span class="comment">     * under the selected permission settings holding within that</span></span><br><span class="line"><span class="comment">     * action; or if not possible, throw an associated &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * AccessControlException&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callable the underlying task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the callable&#x27;s result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a callable object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if callable null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AccessControlException if the current access control</span></span><br><span class="line"><span class="comment">     * context does not have permission to both set and get context</span></span><br><span class="line"><span class="comment">     * class loader</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="title function_">privilegedCallableUsingCurrentClassLoader</span><span class="params">(Callable&lt;T&gt; callable)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PrivilegedCallableUsingCurrentClassLoader</span>&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Non-public classes supporting the public methods</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A callable that runs given task and returns given result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RunnableAdapter</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> Runnable task;</span><br><span class="line">        <span class="keyword">final</span> T result;</span><br><span class="line">        RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">            <span class="built_in">this</span>.task = task;</span><br><span class="line">            <span class="built_in">this</span>.result = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">            task.run();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A callable that runs under established access control settings</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">PrivilegedCallable</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Callable&lt;T&gt; task;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line"></span><br><span class="line">        PrivilegedCallable(Callable&lt;T&gt; task) &#123;</span><br><span class="line">            <span class="built_in">this</span>.task = task;</span><br><span class="line">            <span class="built_in">this</span>.acc = AccessController.getContext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">PrivilegedExceptionAction</span>&lt;T&gt;() &#123;</span><br><span class="line">                        <span class="keyword">public</span> T <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="keyword">return</span> task.call();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, acc);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PrivilegedActionException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.getException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A callable that runs under established access control settings and</span></span><br><span class="line"><span class="comment">     * current ClassLoader</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">PrivilegedCallableUsingCurrentClassLoader</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Callable&lt;T&gt; task;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader ccl;</span><br><span class="line"></span><br><span class="line">        PrivilegedCallableUsingCurrentClassLoader(Callable&lt;T&gt; task) &#123;</span><br><span class="line">            <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Calls to getContextClassLoader from this class</span></span><br><span class="line">                <span class="comment">// never trigger a security check, but we check</span></span><br><span class="line">                <span class="comment">// whether our callers have this permission anyways.</span></span><br><span class="line">                sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Whether setContextClassLoader turns out to be necessary</span></span><br><span class="line">                <span class="comment">// or not, we fail fast if permission is not available.</span></span><br><span class="line">                sm.checkPermission(<span class="keyword">new</span> <span class="title class_">RuntimePermission</span>(<span class="string">&quot;setContextClassLoader&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.task = task;</span><br><span class="line">            <span class="built_in">this</span>.acc = AccessController.getContext();</span><br><span class="line">            <span class="built_in">this</span>.ccl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">PrivilegedExceptionAction</span>&lt;T&gt;() &#123;</span><br><span class="line">                        <span class="keyword">public</span> T <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                            <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> t.getContextClassLoader();</span><br><span class="line">                            <span class="keyword">if</span> (ccl == cl) &#123;</span><br><span class="line">                                <span class="keyword">return</span> task.call();</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                t.setContextClassLoader(ccl);</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    <span class="keyword">return</span> task.call();</span><br><span class="line">                                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                    t.setContextClassLoader(cl);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, acc);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PrivilegedActionException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.getException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default thread factory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">poolNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">        DefaultThreadFactory() &#123;</span><br><span class="line">            <span class="type">SecurityManager</span> <span class="variable">s</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">            group = (s != <span class="literal">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                                  Thread.currentThread().getThreadGroup();</span><br><span class="line">            namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">                          poolNumber.getAndIncrement() +</span><br><span class="line">                         <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, r,</span><br><span class="line">                                  namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                                  <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">                t.setDaemon(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread factory capturing access control context and class loader</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PrivilegedThreadFactory</span> <span class="keyword">extends</span> <span class="title class_">DefaultThreadFactory</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader ccl;</span><br><span class="line"></span><br><span class="line">        PrivilegedThreadFactory() &#123;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">            <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Calls to getContextClassLoader from this class</span></span><br><span class="line">                <span class="comment">// never trigger a security check, but we check</span></span><br><span class="line">                <span class="comment">// whether our callers have this permission anyways.</span></span><br><span class="line">                sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Fail fast</span></span><br><span class="line">                sm.checkPermission(<span class="keyword">new</span> <span class="title class_">RuntimePermission</span>(<span class="string">&quot;setContextClassLoader&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.acc = AccessController.getContext();</span><br><span class="line">            <span class="built_in">this</span>.ccl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.newThread(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                        <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                            Thread.currentThread().setContextClassLoader(ccl);</span><br><span class="line">                            r.run();</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, acc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A wrapper class that exposes only the ExecutorService methods</span></span><br><span class="line"><span class="comment">     * of an ExecutorService implementation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DelegatedExecutorService</span> <span class="keyword">extends</span> <span class="title class_">AbstractExecutorService</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService e;</span><br><span class="line">        DelegatedExecutorService(ExecutorService executor) &#123; e = executor; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123; e.execute(command); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123; e.shutdown(); &#125;</span><br><span class="line">        <span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123; <span class="keyword">return</span> e.shutdownNow(); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span> &#123; <span class="keyword">return</span> e.isShutdown(); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span> &#123; <span class="keyword">return</span> e.isTerminated(); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="keyword">return</span> e.awaitTermination(timeout, unit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.submit(task);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> e.submit(task);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> e.submit(task, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="keyword">return</span> e.invokeAll(tasks);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                                             <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="keyword">return</span> e.invokeAll(tasks, timeout, unit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">            <span class="keyword">return</span> e.invokeAny(tasks);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                               <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line">            <span class="keyword">return</span> e.invokeAny(tasks, timeout, unit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">DelegatedExecutorService</span> &#123;</span><br><span class="line">        FinalizableDelegatedExecutorService(ExecutorService executor) &#123;</span><br><span class="line">            <span class="built_in">super</span>(executor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A wrapper class that exposes only the ScheduledExecutorService</span></span><br><span class="line"><span class="comment">     * methods of a ScheduledExecutorService implementation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DelegatedScheduledExecutorService</span></span><br><span class="line">            <span class="keyword">extends</span> <span class="title class_">DelegatedExecutorService</span></span><br><span class="line">            <span class="keyword">implements</span> <span class="title class_">ScheduledExecutorService</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService e;</span><br><span class="line">        DelegatedScheduledExecutorService(ScheduledExecutorService executor) &#123;</span><br><span class="line">            <span class="built_in">super</span>(executor);</span><br><span class="line">            e = executor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="type">long</span> delay, TimeUnit unit) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.schedule(command, delay, unit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> &lt;V&gt; ScheduledFuture&lt;V&gt; <span class="title function_">schedule</span><span class="params">(Callable&lt;V&gt; callable, <span class="type">long</span> delay, TimeUnit unit)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> e.schedule(callable, delay, unit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="type">long</span> initialDelay, <span class="type">long</span> period, TimeUnit unit) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.scheduleAtFixedRate(command, initialDelay, period, unit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="type">long</span> initialDelay, <span class="type">long</span> delay, TimeUnit unit) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.scheduleWithFixedDelay(command, initialDelay, delay, unit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cannot instantiate. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Executors</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果线程的生存期很短，或者大量时间都在阻塞，可以使用一个缓存线程池（<code>newCachedThreadPoll</code>）
<ul>
<li>如果线程工作量很大而且并不阻塞，就不要用缓存线程池了，会运行太多的线程</li>
</ul>
</li>
<li>为了得到最优的运行速度，并发线程数等于处理器的内核数，应当使用固定线程池(<code>newFixedThreadPoll</code>)</li>
<li>单线程执行器（<code>newSingleThreadExecutor</code>）对于性能分析很有帮助
<ul>
<li>临时用一个单线程池替换缓存或固定线程池，能测量<strong>不使用并发的情况</strong>下应用的<strong>运行速度会慢多少</strong></li>
</ul>
</li>
</ul>
<p><code>newCachedThreadPool</code>、<code>newFixedThreadPool</code>和<code>newSingleThreadExecutor</code>三个方法返回实现了<code>ExcutorService</code>接口的<code>ThreadPoolExecutor</code>类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given command at some time in the future.  The command</span></span><br><span class="line"><span class="comment">     * may execute in a new thread, in a pooled thread, or in the calling</span></span><br><span class="line"><span class="comment">     * thread, at the discretion of the &#123;<span class="doctag">@code</span> Executor&#125; implementation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command the runnable task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if this task cannot be</span></span><br><span class="line"><span class="comment">     * accepted for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if command is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExecutorService</span> <span class="keyword">extends</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法不会等待正在执行的任务到结束</span></span><br><span class="line">    List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span>;</span><br><span class="line"></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//提交一个Callable对象集合中的所有对象</span></span><br><span class="line">    <span class="comment">//这个方法会阻塞，直到所有任务都完成</span></span><br><span class="line">    <span class="comment">//返回表示所有任务答案的一个Future对象列表</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                                  <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given tasks, returning the result</span></span><br><span class="line"><span class="comment">     * of one that has completed successfully (i.e., without throwing</span></span><br><span class="line"><span class="comment">     * an exception), if any do. Upon normal or exceptional return,</span></span><br><span class="line"><span class="comment">     * tasks that have not completed are cancelled.</span></span><br><span class="line"><span class="comment">     * The results of this method are undefined if the given</span></span><br><span class="line"><span class="comment">     * collection is modified while this operation is in progress.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tasks the collection of tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the values returned from the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the result returned by one of the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if tasks or any element task</span></span><br><span class="line"><span class="comment">     *         subject to execution is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if tasks is empty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException if no task successfully completes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if tasks cannot be scheduled</span></span><br><span class="line"><span class="comment">     *         for execution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes the given tasks, returning the result</span></span><br><span class="line"><span class="comment">     * of one that has completed successfully (i.e., without throwing</span></span><br><span class="line"><span class="comment">     * an exception), if any do before the given timeout elapses.</span></span><br><span class="line"><span class="comment">     * Upon normal or exceptional return, tasks that have not</span></span><br><span class="line"><span class="comment">     * completed are cancelled.</span></span><br><span class="line"><span class="comment">     * The results of this method are undefined if the given</span></span><br><span class="line"><span class="comment">     * collection is modified while this operation is in progress.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tasks the collection of tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout the maximum time to wait</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit of the timeout argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the values returned from the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the result returned by one of the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if tasks, or unit, or any element</span></span><br><span class="line"><span class="comment">     *         task subject to execution is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> TimeoutException if the given timeout elapses before</span></span><br><span class="line"><span class="comment">     *         any task successfully completes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException if no task successfully completes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if tasks cannot be scheduled</span></span><br><span class="line"><span class="comment">     *         for execution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                    <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title class_">ExecutorService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title class_">AbstractExecutorService</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//返回该执行器生命周期中线程池的最大大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLargestPoolSize</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line">    <span class="comment">///...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<code>sumbit</code>方法，将<code>Runnable</code>或<code>Callable</code>对象提交给<code>ExecutorService</code>、</p>
<p>调用<code>sumbit</code>时，会得到一个<code>Future</code>对象，可用来得到结果或取消任务</p>
<ul>
<li><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</code></li>
<li><code>&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</code>
<ul>
<li>对于这个返回的<code>Future</code>对象，它的<code>get</code>方法在完成时返回指定的<code>result</code>对象</li>
</ul>
</li>
<li><code>Future&lt;?&gt; submit(Runnable task);</code>
<ul>
<li>返回<code>Future&lt;?&gt;</code>，可以使用这个对象调用<code>isDone</code>、<code>cancel</code>、<code>isCancelled</code></li>
<li>但是<code>get</code>方法只是简单返回<code>null</code></li>
</ul>
</li>
</ul>
<p>使用完一个<strong>线程池</strong>，调用<code>shutdown</code>。</p>
<ul>
<li>这个方法启动线程的<strong>关闭序列</strong>。</li>
<li>被关闭的<strong>执行器</strong>不再接受新的任务。</li>
<li>当<strong>所有任务都完成</strong>时，线程池中的<strong>线程死亡</strong>。</li>
</ul>
<p>另一个方法是调用<code>shutdownNow</code></p>
<ul>
<li>线程池会取消所有尚未开始的任务</li>
</ul>
<p>**总结：**使用连接池时所做的工作</p>
<ol>
<li>调用<code>Executors</code>类的静态方法<code>newCachedThreadPool</code>或<code>newFixedThreadPool</code></li>
<li>调用<code>sumbit</code>提交<code>Runnable</code>或<code>Callable</code>对象</li>
<li>保存好返回的<code>Future</code>对象，以便得到结果或者取消任务</li>
<li>当不想再提交任何任务时，调用<code>shutdown</code></li>
</ol>
<p><code>Executors</code>类中的<code>newScheduledThreadPool</code>和<code>newSingleThreadScheduledExecutor</code>方法返回实现<code>ScheduledExecutorService</code>接口</p>
<ul>
<li><code>ScheduledExecutorService</code>接口为调度执行或重复执行任务提供一些方法
<ul>
<li>这是对支持建立线程池的java.util.Timer的泛化</li>
<li>可以调度<code>Runnable</code>或<code>Callable</code>在一个初始延迟之后运行一次</li>
<li>也可以调度<code>Runnable</code>定期运行</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DelegatedScheduledExecutorService</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">DelegatedExecutorService</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ScheduledExecutorService</span> &#123;</span><br><span class="line">	<span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ScheduledExecutorService</span> <span class="keyword">extends</span> <span class="title class_">ExecutorService</span> &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">//调度在指定的时间之后执行任务</span></span><br><span class="line">    <span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line">                                       <span class="type">long</span> delay, TimeUnit unit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;V&gt; ScheduledFuture&lt;V&gt; <span class="title function_">schedule</span><span class="params">(Callable&lt;V&gt; callable,</span></span><br><span class="line"><span class="params">                                           <span class="type">long</span> delay, TimeUnit unit)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调度在初始延迟之后，周期性地运行给定的任务，周期长度时period个单位</span></span><br><span class="line">    <span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                                  <span class="type">long</span> initialDelay,</span><br><span class="line">                                                  <span class="type">long</span> period,</span><br><span class="line">                                                  TimeUnit unit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调度在初始延迟之后，周期性地运行给定的任务，在一次调用完成和下次调用开始之前有长度为delay个单位的延迟</span></span><br><span class="line">    <span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                     <span class="type">long</span> initialDelay,</span><br><span class="line">                                                     <span class="type">long</span> delay,</span><br><span class="line">                                                     TimeUnit unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="控制任务组"><a class="header-anchor" href="#控制任务组"> </a>控制任务组</h3>
<p>使用线程池来控制一组相关的任务</p>
<ul>
<li>例如在执行器中使用<code>shutdownNow</code>方法取消所有任务</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Callable&lt;T&gt;&gt; tasks = ...;</span><br><span class="line">List&lt;Future&lt;T&gt;&gt; results = executor.invokeAll(tasks);</span><br><span class="line"><span class="keyword">for</span>(Future&lt;T&gt; result : results)&#123;</span><br><span class="line">    processFuture(result.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在第一个<code>result.get()</code>调用会阻塞</li>
</ul>
<p>利用<code>ExecutorCompletionService</code>来管理计算结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorCompletionService&lt;T&gt; service = <span class="keyword">new</span> <span class="title class_">ExecutorCompletionService</span>&lt;&gt;(executor);</span><br><span class="line"><span class="keyword">for</span>(Callable&lt;T&gt; task : tasks) service.submit(task);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tasks.size(); i++)</span><br><span class="line">    	processFuture(service.take().get());</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorCompletionService</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">CompletionService</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AbstractExecutorService aes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue; <span class="comment">//管理Future对象的阻塞队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * FutureTask extension to enqueue upon completion</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">QueueingFuture</span> <span class="keyword">extends</span> <span class="title class_">FutureTask</span>&lt;Void&gt; &#123;</span><br><span class="line">        QueueingFuture(RunnableFuture&lt;V&gt; task) &#123;</span><br><span class="line">            <span class="built_in">super</span>(task, <span class="literal">null</span>);</span><br><span class="line">            <span class="built_in">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">done</span><span class="params">()</span> &#123; completionQueue.add(task); &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Future&lt;V&gt; task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RunnableFuture&lt;V&gt; <span class="title function_">newTaskFor</span><span class="params">(Callable&lt;V&gt; task)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (aes == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;V&gt;(task);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> aes.newTaskFor(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RunnableFuture&lt;V&gt; <span class="title function_">newTaskFor</span><span class="params">(Runnable task, V result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (aes == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;V&gt;(task, result);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> aes.newTaskFor(task, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造一个执行器完成服务来手机给定执行器的结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExecutorCompletionService</span><span class="params">(Executor executor)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="built_in">this</span>.executor = executor;</span><br><span class="line">        <span class="built_in">this</span>.aes = (executor <span class="keyword">instanceof</span> AbstractExecutorService) ?</span><br><span class="line">            (AbstractExecutorService) executor : <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.completionQueue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Future&lt;V&gt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExecutorCompletionService</span><span class="params">(Executor executor,</span></span><br><span class="line"><span class="params">                                     BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor == <span class="literal">null</span> || completionQueue == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="built_in">this</span>.executor = executor;</span><br><span class="line">        <span class="built_in">this</span>.aes = (executor <span class="keyword">instanceof</span> AbstractExecutorService) ?</span><br><span class="line">            (AbstractExecutorService) executor : <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.completionQueue = completionQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交一个任务给底层的执行器</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;V&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;V&gt; task)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        RunnableFuture&lt;V&gt; f = newTaskFor(task);</span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">QueueingFuture</span>(f));</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Future&lt;V&gt; <span class="title function_">submit</span><span class="params">(Runnable task, V result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        RunnableFuture&lt;V&gt; f = newTaskFor(task, result);</span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">QueueingFuture</span>(f));</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除下一个已完成的结果，如果没有可用的已完成结果，则阻塞</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;V&gt; <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> completionQueue.take();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Future&lt;V&gt; <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> completionQueue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 移除并返回下一个已完成的结果，如果没有可以用的已完成结果，则返回null，</span></span><br><span class="line">   	<span class="comment">// 这个方法会等待给定的时间</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;V&gt; <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> completionQueue.poll(timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fork-join框架"><a class="header-anchor" href="#fork-join框架"> </a>fork-join框架</h3>
<p>将任务分解成子任务</p>
<h3 id="异步计算"><a class="header-anchor" href="#异步计算"> </a>异步计算</h3>
<p><code>CompletableFuture</code></p>
<h2 id="进程"><a class="header-anchor" href="#进程"> </a>进程</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Process</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ProcessBuilder</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Process</code>类在一个单独的操作系统进程中执行一个命令
<ul>
<li>允许与标准输入、输出和错误流交互</li>
</ul>
</li>
<li><code>ProcessBuilder</code>类允许我们配置<code>Process</code>对象
<ul>
<li>该类可以取代<code>Runtime.exec</code>调用，更加灵活</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java核心技术</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术—继承</title>
    <url>/2020/11/14/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%80%94%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="Java核心技术——第五章-继承"><a class="header-anchor" href="#Java核心技术——第五章-继承"> </a>Java核心技术——第五章 继承</h1>
<h3 id="类、超类和子类"><a class="header-anchor" href="#类、超类和子类"> </a>类、超类和子类</h3>
<ul>
<li>
<p>继承(inheritance)</p>
<ul>
<li>&quot;is-a&quot;关系是继承的一个明显特征</li>
</ul>
</li>
<li>
<p>Java用关键字<code>extends</code>表示继承</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    added methods and fields</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- more -->
</li>
<li>
<p>Java中所有继承都是公共继承，没有C++中的私有继承和保护继承</p>
<ul>
<li>
<p>新类派生于一个已存在的类</p>
<ul>
<li>已存在的类称为
<ul>
<li>超类 superclass</li>
<li>基类 base class</li>
<li>父类 parent class</li>
</ul>
</li>
<li>新类称为
<ul>
<li>子累 subclass</li>
<li>派生类 derived class</li>
<li>孩子类 child class</li>
</ul>
</li>
</ul>
</li>
<li>
<p>通过扩展超类定义子类的时候，只需要支出子类与超类的不同之处。</p>
</li>
</ul>
</li>
<li>
<p>覆盖(override)方法</p>
<ul>
<li>超类中的有些方法对于子类不适用需要提供新的方法覆盖
<ul>
<li>
<p>注意：子类不能直接访问超类的私有字段(<code>private</code>)，因此可以通过访问器来获取，但是如果我们重写的方法就是访问器的话，需要加上<code>super</code>，否则会一直循环调用自身以致程序崩溃</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span> <span class="variable">baseSalary</span> <span class="operator">=</span> <span class="built_in">super</span>.getSalary();</span><br><span class="line">  <span class="keyword">return</span> baseSalary + bonus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>super</code>和<code>this</code>概念不同</p>
<ul>
<li><code>this</code>是对象的引用(隐式参数)</li>
<li><code>super</code>不是对象的引用
<ul>
<li>不能将值<code>super</code>赋给另一个对象变量</li>
<li><code>super</code>只是一个指示编译器调用超类方法的特殊关键字</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>子类构造器</p>
<ul>
<li>由于子类的构造器不能访问父类的私有字段，所以必须通过一个构造器来初始化私有字段</li>
<li>利用<code>super</code>语法来调用父类的构造器
<ul>
<li>注意：<strong>使用<code>super</code>调用构造器的语句必须是子类构造器的第一条语句</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String n, <span class="type">int</span> s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        salary = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String n, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(n,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果子类构造器没有显示地调用超类的构造器，将自动调用超类的无参数构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String n, <span class="type">int</span> s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        salary = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类无参数构造器被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String n, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//父类无参数构造器被调用</span></span><br><span class="line"><span class="comment">//子类构造器</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果超类<strong>没有</strong>无参数构造器，并且子类的构造器没有显示地调用超类的其他构造器，Java编译器会报错</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String n, <span class="type">int</span> s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        salary = s;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//删除下面的无参数构造器，会报错</span></span><br><span class="line"><span class="comment">//    public Employee()</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;父类无参数构造器被调用&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String n, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>this</code>与<code>super</code>
<ul>
<li><code>this</code>两个含义
<ol>
<li>指示隐式参数的引用</li>
<li>调用该类的其他构造器</li>
</ol>
</li>
<li><code>super</code>
<ol>
<li>调用超类的方法</li>
<li>调用超类的其他构造器</li>
</ol>
</li>
</ul>
</li>
<li><strong>调用构造器的语句只能作为另外一个构造器的第一条语句出现</strong></li>
<li>多态与动态绑定
<ul>
<li>一个对象变量(例如下面代码中的<code>e</code>)可以指示多种实际类型的现象叫做多态(polymorphism)</li>
<li>在运行时能够自动地选择适当的方法，称为动态绑定(dynamic binding)</li>
<li>虽然下面的for each循环中的<code>e</code>声明为<code>Employee</code>,但是<code>e</code>既可以引用<code>Employee</code>类型的对象，也可以引用<code>Manager</code>类型的对象</li>
<li>虚拟机知道<code>e</code>实际引用的对象类型，因此能够正确地调用相应的方法</li>
<li>Java中，动态绑定时默认的行为</li>
<li>如果不希望让一个方法是虚拟的，可以将它标记为<code>final</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee[] staff = <span class="keyword">new</span> <span class="title class_">Employee</span>[<span class="number">3</span>];</span><br><span class="line"><span class="type">Employee</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;bad&quot;</span>,<span class="number">10</span>);</span><br><span class="line"><span class="type">Employee</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;good&quot;</span>,<span class="number">20</span>);</span><br><span class="line"><span class="type">Manager</span> <span class="variable">m1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;xixi&quot;</span>,<span class="number">300</span>);</span><br><span class="line">staff[<span class="number">0</span>] = e1;</span><br><span class="line">staff[<span class="number">1</span>] = e2;</span><br><span class="line">staff[<span class="number">2</span>] = m1;</span><br><span class="line"><span class="keyword">for</span>(Employee e : staff)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(e.getName() + <span class="string">&quot;  &quot;</span> + e.getSalary());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>继承层次(inheritance hierarchy)：由一个公共超类派生出来的所有类的集合</p>
</li>
<li>
<p>Java不支持多重继承</p>
</li>
<li>
<p>多态</p>
<ul>
<li>
<p>&quot;is-a&quot;规则可以用来判断是否应该将数据设计为继承关系，其指出子类的每个对象也是超类的对象(经理都是员工)，但是反之则不然</p>
</li>
<li>
<p>&quot;is-a&quot;规则另一种表述：替换原则(substitution principle)</p>
<ul>
<li>出现超类对象的任何地方都能用子类对象替换</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee e;</span><br><span class="line">e = <span class="keyword">new</span> <span class="title class_">Employee</span>(...);</span><br><span class="line">e = <span class="keyword">new</span> <span class="title class_">Manager</span>(...);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Java对象变量是多态(polymorphic)的</p>
<ul>
<li>一个Employee(超类)类型的<em>变量</em>既可以<strong>引用</strong>一个Employee类型的<em>对象</em>，也可以<strong>引用</strong>Employee类的任何一个子类的<em>对象</em>(Manager, Executive…)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Manager</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(...);</span><br><span class="line">Employee[] staff = <span class="keyword">new</span> <span class="title class_">Employee</span>[<span class="number">3</span>];</span><br><span class="line">staff[<span class="number">0</span>] = boss; <span class="comment">//将Employee变量引用一个Manager对象</span></span><br></pre></td></tr></table></figure>
<p>变量staff[0]与boss都引用同一个对象，但是编译器<em>只将</em>staff[0]看成一个<em>Employee对象</em></p>
<p>意味着<br>
<code>boss.setBonus(5000);//boss是Manager类型的，有setBonus的方法</code>是可以的</p>
<p>但是<br>
<code>staff[0].setBonus(5000); // ERROR</code>是不行的，因为staff[0]声明的类型是Employee，但是setBonus不是Employee类的方法</p>
<p>同时<br>
<code>Manager m = staff[i]; //ERROR</code>也是不行的。因为m有可能引用一个不是经理的Employee对象，如果调用Manager才有的方法(例如<code>m.setBonus(...)</code>),就会发生运行时错误。</p>
</li>
<li>
<p>Java中，子类引用的数组可以转换成超类引用的数组</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Manager[] managers = <span class="keyword">new</span> <span class="title class_">Manager</span>[<span class="number">10</span>]; <span class="comment">//子类引用的数组</span></span><br><span class="line">Employee[] staff = managers; <span class="comment">//超类引用的数组，是可以的</span></span><br></pre></td></tr></table></figure>
<p>但切记不要进行这种操作<code>staff[0] = new Employee(...);</code>，因为staff数组里面都是managers对象，我运行会报错<code>java.lang.ArrayStoreException</code>（书上说“虽然编译器接纳这种赋值操作，但是由于managers和staff都引用同一个manager对象数组，如果进行<code>managers[0].setBonus(1000);</code>将会试图调用一个不存在的实例字段”)</p>
</li>
</ul>
</li>
<li>
<p>可协变的返回类型</p>
<ul>
<li>方法的名字和参数列表称为方法的<em>签名</em>，如果在子类中定义了一个与超类签名相同的方法，那么子类中这个方法就会覆盖超类中这个相同签名的方法</li>
<li>返回类型<strong>不是</strong>签名的一部分，但是在覆盖超类的方法时，需要保证返回类型的兼容性
<ul>
<li>
<p>允许子类覆盖方法的返回类型改为原返回类型的子类型，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//超类方法</span></span><br><span class="line"><span class="keyword">public</span> Employee <span class="title function_">getBuddy</span><span class="params">()</span>&#123;....&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类方法</span></span><br><span class="line"><span class="keyword">public</span> Manager <span class="title function_">getBuddy</span><span class="params">()</span>&#123;...&#125; <span class="comment">//这是可以的，Manager是Employee的子类</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不允许子类覆盖的方法的返回类型是超类的方法返回类型的超类,例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//超类方法</span></span><br><span class="line"><span class="keyword">public</span> Manager <span class="title function_">getBuddy</span><span class="params">()</span>&#123;....&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类方法</span></span><br><span class="line"><span class="keyword">public</span> Employee <span class="title function_">gerBuddy</span><span class="params">()</span>&#123;...&#125; <span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不允许子类覆盖的方法的返回类型和超类的方法返回类型不兼容,例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//超类方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBuddy</span><span class="params">()</span>&#123;....&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">gerBuddy</span><span class="params">()</span>&#123;...&#125; <span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>子类覆盖超类方法</p>
<ul>
<li>子类方法不能低于超类方法的可见性
<ul>
<li>如果<strong>超类</strong>方式是<code>public</code>，那么<strong>子类</strong>的方法必须也要声明为<code>public</code>。如果子类方法遗漏掉了<code>public</code>修饰符，则编译器会报错</li>
</ul>
</li>
</ul>
</li>
<li>
<p>方法调用过程</p>
<ul>
<li>调用<code>x.f(args)</code>,其中<code>x</code>为<code>C</code>类的一个对象
<ol>
<li>编译器查看对象的<em>声明类型</em>和<em>方法名</em>。编译器会一一列举<code>C</code>类中所有方法名为<code>f</code>的方法和其超类中所有名为<code>f</code>且可访问的方法</li>
<li>编译器确定方法调用中提供的参数类型。在所有名为<code>f</code>的方法中，如果存在一个与所提供参数类型完全匹配的方法，就调用该方法。这个过程称为<em>重载解析(overloading resolution)</em>。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，编译器会报错。</li>
<li><em>静态绑定(static binding)</em>:如果是<code>private</code>方法,<code>static</code>方法,<code>final</code>方法或构造器，则编译器可以准确知道应该调用哪一个方法；<em>动态绑定</em>:要调用的方法依赖于隐式参数的实际类型，必须要运行时使用动态绑定</li>
<li>假设程序运行并采用动态绑定调用方法，则虚拟机调用与<code>x</code>所引用对象的实际类型对应的那个方法。如果该类没有定义这个方法，则在父类中找。虚拟机预先为<em>每个类</em>计算了一个<em>方法表(method table)</em>，其中列出了所有方法的签名和要调用的实际方法。在真正调用方法时，虚拟机仅查找该表、</li>
</ol>
</li>
</ul>
</li>
<li>
<p>final类</p>
<ul>
<li>
<p>需求：如果想阻止人们用某个类来定义子类</p>
</li>
<li>
<p>不允许扩展的类称为<code>final</code>类(定义类的时候使用final修饰符)</p>
</li>
<li>
<p>例如阻止人们派生<code>Executive</code>类的子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Executive</span> <span class="keyword">extends</span> <span class="title class_">Manager</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>final方法</p>
<ul>
<li>类中的某个特定的方法也可以声明为<code>final</code></li>
<li>子类不能覆盖这个方法</li>
<li><strong><code>final</code>类中的所有方法自动成为final方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>字段也能声明为final，final字段表示构造对象后就不能再改变值了。<em>final类</em>只有其中的方法自动成为final，不包括字段</p>
</li>
<li>
<p>将方法或类声明为<code>final</code>的主要原因是确保它们在子类不会改变语义</p>
<ul>
<li><code>Calendar</code>类中的<code>getTime()</code>和<code>setTime()</code>方法声明为final。意味着<code>Calendar</code>类设计者负责实现<code>Date</code>类与日历状态的转换，不允许子类添乱</li>
<li><code>String</code>类为<code>final</code>类，如果有一个<code>String</code>引用，则它引用一定是<code>String</code>对象</li>
</ul>
</li>
<li>
<p>内联(inlining)</p>
</li>
<li>
<p>如果一个方法没有被覆盖(重写)而且很短，则编译器能够对它进行优化处理</p>
</li>
<li>
<p>类的对象引用的强制类型转换</p>
<ul>
<li>
<p>用一对圆括号将目标类括起来，并放置在需要转换的对象引用之前</p>
</li>
<li>
<p>使用对象引用的强制类型转换的唯一原因： 要在，暂时忽视对象的实际类型之后，使用对象的全部功能</p>
<ul>
<li>暂时忽视的情况：在<code>staff</code>中，某些元素是普通员工(<code>Employee</code>)，因此经理元素(<code>Manager</code>)需要暂时忽视它的实际类型</li>
<li>要使用对象全部功能： 将<code>staff</code>数组中引用<code>Manager</code>对象的元素复原成<code>Manager</code>对象</li>
</ul>
</li>
<li>
<p>每个对象变量都有一个类型</p>
<ul>
<li>类型描述这个变量<em>所引用</em>的以及<em>能够引用的对象类型</em></li>
</ul>
</li>
<li>
<p>一个值存入变量时，编译器会检查是否承诺过多</p>
<ul>
<li>子类的引用赋值给超类的变量，是允许的</li>
</ul>
</li>
<li>
<p>超类的引用赋值给子类变量时，是不可以的，承诺过多，必须进行强制类型转换</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Manager m2 = staff[2]; //不能通过运行时检查</span></span><br><span class="line"><span class="type">Manager</span> <span class="variable">m2</span> <span class="operator">=</span> (Manager) staff[<span class="number">2</span>]; <span class="comment">//能够通过运行时检查</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果试图在继承链上，进行向下的强制类型转换，并且谎报对象内容，会产生<code>ClassCastException</code>的异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Manager</span> <span class="variable">boss</span> <span class="operator">=</span> (Manager)staff[<span class="number">0</span>]; <span class="comment">//staff[0]存的真实类型Employee,不是Manager，会抛出异常</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在强制类型转换之前，先查看是否能够转换成功，使用<code>instanceof</code>操作符来判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(staff[<span class="number">2</span>] <span class="keyword">instanceof</span> Manager)</span><br><span class="line">&#123;</span><br><span class="line">  boss = (Manager)staff[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>String c = (String) staff[1];</code>会产生编译错误</p>
</li>
<li>
<p>总之</p>
<ul>
<li>只能在继承层次内进行强制类型转换</li>
<li>在超类强制转换成子类之前，应该使用<code>instanceof</code>进行检查</li>
</ul>
</li>
<li>
<p>因为实现多态性的动态绑定机制，能够自动找到正确的方法，很多情况不需要进行强制类型转换</p>
</li>
<li>
<p>只有在使用子类(如<code>Manager</code>)中特有的方法才需要进行强制类型转换</p>
</li>
</ul>
</li>
<li>
<p>抽象类</p>
<ul>
<li>
<p>包含一个或多个<strong>抽象方法</strong>的类，类本身必须声明为抽象的</p>
</li>
<li>
<p>抽象类还可以包含字段和具体方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通过引用一个公共超类，将方法放在继承层次结构中更高层</p>
</li>
<li>
<p>而当高层的类中的方法需要根据实际情况实现时(例如这里的<code>getDescription()</code>)，可以定义成抽象方法，就不需要实现这个方法，留到继承它的类去实现。</p>
</li>
<li>
<p>扩展抽象类的两种情况</p>
<ul>
<li>子类保留抽象类的部分方法，或者是所有抽象方法都仍未定义，因此子类也应该标记为抽象类</li>
<li>子类实现定义的全部方法，那么子类就不是抽象的了</li>
</ul>
</li>
<li>
<p>即使不含有抽象方法，也可以将类声明称抽象类</p>
</li>
<li>
<p>抽象类不能实例化</p>
</li>
<li>
<p>可以创建具体子类的对象(父类是抽象的，但是本身不是抽象的)、</p>
</li>
<li>
<p>可以定义抽象类的对象变量</p>
<ul>
<li><code>Person p = new Student(&quot;dog&quot;,&quot;math&quot;)</code></li>
<li>这个定义为抽象类的对象变量只能引用<strong>非抽象子类</strong>的对象</li>
</ul>
</li>
<li>
<p>使用抽象类一个应用就是能够通过直接访问子类中实现抽象类的方法，方便处理</p>
<ul>
<li>如果这里将Person超类中的<code>getDescription</code>省略掉的话，就不能在变量<code>p</code>上调用<code>getDescription</code>方法了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person[] people = <span class="keyword">new</span> <span class="title class_">Person</span>[<span class="number">2</span>];</span><br><span class="line">people[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Dog&quot;</span>,<span class="number">20</span>);</span><br><span class="line">people[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Cat&quot;</span>,<span class="string">&quot;math&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Person p : people)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(p.getDescription());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>受保护访问 protected</p>
<ul>
<li>希望限制超类中的某个方法只允许子类访问</li>
<li>希望允许子类的方法能够访问超类的某个字段</li>
<li>Java中，保护字段只能由同一个包中的类访问
<ul>
<li>避免滥用保护机制，不能通过派生子类来访问受保护字段</li>
</ul>
</li>
</ul>
</li>
<li>
<p>访问控制修饰符</p>
<ul>
<li>仅对本类可见——private</li>
<li>对外部完全可见——public</li>
<li>对本包和所有子类可见——protected</li>
<li>对本包可见——默认，不需要修饰符</li>
</ul>
</li>
<li>
<p>Object:所有类的超类</p>
<ul>
<li>
<p>Java中每个类都扩展了Object</p>
</li>
<li>
<p>可以使用Object类型的<em>变量</em>引用任何类型的对象</p>
</li>
<li>
<p>Java中只有基本类型(primitive type)不是对象</p>
<ul>
<li>数值、字符、布尔类型都不是对象</li>
</ul>
</li>
</ul>
</li>
<li>
<p>所有的数组类型，不管是<em>对象数组</em>还是<em>基本类型的数组</em>都扩展了Object类</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(...);</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>equals方法</p>
<ul>
<li><code>Object</code>类中的<code>equals</code>方法用于检测一个对象是否等于另一个对象</li>
<li><code>Object</code>类实现的<code>equals</code>方法是判断两个对象引用是否相等</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object类实现的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>有时候需要基于状态检测对象的相等性，如果两个对象有相同的<em>状态</em>，才认为对象是否相等</p>
</li>
<li>
<p>需要重写<code>equals</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object otherObject)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//看这个对象引用是否相等  identical</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">this</span> == otherObject) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//如果为空，则肯定不相等</span></span><br><span class="line">  <span class="keyword">if</span>(otherObject == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//类不匹配，肯定不相等</span></span><br><span class="line">    <span class="keyword">if</span>(getClass() != otherObject.getClass())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//该类是非空的Employee类，接下来比较对象的状态是否相等</span></span><br><span class="line">    <span class="type">Employee</span> <span class="variable">other</span> <span class="operator">=</span> (Employee)otherObject;</span><br><span class="line">    <span class="type">return</span> <span class="variable">salary</span> <span class="operator">=</span>= other.salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>注意，如果一个变量是<code>null</code>,则不可以调用equals方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">e.equals(e);  <span class="comment">//ERROR  java.lang.NullPointerException</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>这时候可以调用<code>Objects.equals(o1,o2)</code></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">System.out.println(Objects.equals(e,e));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Objects.equals实现如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object a, Object b)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (a == b) || (a != <span class="literal">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>如果子类可以有自己的相等性概念，则对称性需求将强制使用<code>getClass</code>检测</p>
</li>
</ul>
</li>
<li>
<p>如果由超类决定相等性的概念，那么就可以使用<code>instanceof</code>检测，这样就可以在不同子类的对象之间进行相等性比较</p>
<ul>
<li>
<p>编写equals方法的建议</p>
<ul>
<li>显示参数命名为<code>otherObject</code>，稍后需要将它强制转换程另一个名为<code>other</code>的变量</li>
</ul>
</li>
<li>
<p>检测<code>this</code>与<code>otherObject</code>是否相等</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">this</span> == otherObject) <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>检测<code>otherObject</code>是否为<code>null</code>，如果为<code>null</code>，返回<code>false</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(otherObject == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>比较<code>this</code>和<code>otherObject</code>的类</p>
</li>
<li>
<p>如果<code>equals</code>的语义可以在子类中改变(意思就是两种不同类的子类，是不一样的)，就使用<code>getClass</code>检测</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(getClass() != otherObject.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果所有的子类都有相同的相等性语义(意思是继承同一个超类的，两个不同类的子类，认为它们类型是一样的)，可以使用<code>instanceof</code>检测</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(otherObject <span class="keyword">instanceof</span> ClassName)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>根据相等性的要求来比较字段</p>
<ul>
<li>使用<code>==</code>比较基本类型字段</li>
<li>使用<code>Objects.equals()</code>比较对象字段</li>
</ul>
</li>
<li>
<p>如果所有字段都匹配，返回true;否则返回false</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">return</span> <span class="variable">field1</span> <span class="operator">=</span> other.field1</span><br><span class="line">    &amp;&amp; Objects.equals(field2,other.field2)</span><br><span class="line">    &amp;&amp; ...;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果在子类中重新定义equals,就要在子类新定义的equals方法中包含一个<code>super.equals(other)</code>的调用</p>
</li>
<li>
<p>实现equals方法常见错误：参数类型不是<code>Object</code></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Employee other)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> other != <span class="literal">null</span></span><br><span class="line">          &amp;&amp; getClass() == other.getClass()</span><br><span class="line">          &amp;&amp; Objects.equals(name,other.name)</span><br><span class="line">          &amp;&amp; ...;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>避免发生错误，可以使用<code>@override</code>标记要覆盖超类的那些子类方法，如果出现错误，编译器会报错</li>
</ul>
</li>
<li>
<p>hashCode方法</p>
<ul>
<li>散列码(hash code)是由对象导出的一个整型值(可正可负)</li>
<li>如果x和y是两个不同的对象，x.hashCode()与y.hashCode()基本上不会相同</li>
</ul>
</li>
<li>
<p>String类通过下列方法计算散列码 <code>s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</code></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">  <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">char</span> val[] = value;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">          h = <span class="number">31</span> * h + val[i];</span><br><span class="line">      &#125;</span><br><span class="line">      hash = h;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>每个对象(没有重写的情况下)都有一个默认的散列码(Object类实现的)，其值由对象的储存地址得出</p>
</li>
<li>
<p>如果重新定义了equals方法，就必须为用用户可能插入散列表的对象重新定义hashCode方法</p>
<ul>
<li>要合理地组合示例字段的散列码，以便能够让不同对象产生的散列码分布均匀</li>
</ul>
</li>
</ul>
</li>
<li>
<p>null安全的方法Objects.hashCode</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> o != <span class="literal">null</span> ? o.hashCode() : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>自己写一个hashCode()</p>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">7</span>* Objects.hashCode(name)</span><br><span class="line">      + <span class="number">11</span> * Double.hashCode(salary)</span><br><span class="line">      + <span class="number">13</span> * Objects.hashCode(hireDay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li>
<p><code>Objects.hash()</code>方法能够对传入各个参数调用Objects.hashCode,并组合</p>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> Objects.hash(name,salary,hireDay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li>其底层用的是<code>Arrays.hashCode()</code>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object... values)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Arrays.hashCode(values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：<strong>equals与hashCode的定义必须相容</strong>，如果x.equals(y)返回true,那么x.hashCode()就必须与y.hashCode()返回相同的值</li>
</ul>
</li>
<li>
<p>toString方法</p>
</li>
<li>
<p>绝大多数的toString方法遵循格式: 类的名字， 随后是一对方括号括起来的字段值</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Employee[name=&quot;</span>+name</span><br><span class="line">          +<span class="string">&quot;,salary=&quot;</span>+salary</span><br><span class="line">          +<span class="string">&quot;,hireDay=&quot;</span>+hireDay</span><br><span class="line">          +<span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>Employee</code>可以不使用硬编码的方式，而是调用getClass().getName()获得类名的字符串</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName()</span><br><span class="line">          +<span class="string">&quot;[name=&quot;</span>+name</span><br><span class="line">          +<span class="string">&quot;,salary=&quot;</span>+salary</span><br><span class="line">          +<span class="string">&quot;,hireDay=&quot;</span>+hireDay</span><br><span class="line">          +<span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类重新定义toString方法时候，可以调用<code>super.toString</code>再加上子类自己的字段</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.toString()</span><br><span class="line">          +<span class="string">&quot;[bonus=&quot;</span>+bonus</span><br><span class="line">          +<span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对象与字符串通过操作符<code>+</code>连接起来，编译器会自动调用该对象的toString方法来获得该对象的字符串描述</li>
</ul>
</li>
<li>
<p><code>&quot;&quot;+x</code></p>
</li>
<li>
<p>Object类定义的toString方法，打印出对象的类名和散列码</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(people[<span class="number">1</span>]); <span class="comment">// test.Student@14ae5a5</span></span><br><span class="line">System.out.println(people[<span class="number">1</span>].hashCode()); <span class="comment">// 21685669</span></span><br><span class="line">System.out.println(System.out); <span class="comment">// java.io.PrintStream@14ae5a5</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + 		Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>数组类型继承了Object类的toString方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person[] people = <span class="keyword">new</span> <span class="title class_">Person</span>[<span class="number">3</span>];</span><br><span class="line">people[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Dog&quot;</span>,<span class="number">20</span>);</span><br><span class="line">people[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Cat&quot;</span>,<span class="string">&quot;math&quot;</span>);</span><br><span class="line">people[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Cat&quot;</span>,<span class="string">&quot;math&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(people); <span class="comment">//[Ltest.Person;@14ae5a5</span></span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>+people); <span class="comment">//[Ltest.Person;@14ae5a5</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>+nums); <span class="comment">//[I@7f31245a</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>[I</code>前缀表明是一个整型数组，这种打印看不出里面具体的元素的值</p>
</li>
<li>
<p>可以使用<code>Arrays.toString()</code>来打印一维数组</p>
</li>
<li>
<p><code>Arrays.deepToString()</code>打印多维数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person[] people = <span class="keyword">new</span> <span class="title class_">Person</span>[<span class="number">3</span>];</span><br><span class="line">people[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Dog&quot;</span>,<span class="number">20</span>);</span><br><span class="line">people[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Cat&quot;</span>,<span class="string">&quot;math&quot;</span>);</span><br><span class="line">people[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Cat&quot;</span>,<span class="string">&quot;math&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(people));<span class="comment">// [test.Employee@14ae5a5, test.Student@7f31245a, test.Student@6d6f6e28]</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(nums)); <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span>[][] manNums = &#123;</span><br><span class="line">          &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">          &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">          &#125;;</span><br><span class="line">System.out.println(Arrays.deepToString(manNums));<span class="comment">// [[1, 2, 3], [2, 3, 4]]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>泛型数组列表</p>
<ul>
<li>Java允许在运行时确定数组的大小</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">actualSize</span> <span class="operator">=</span> ...;</span><br><span class="line">Employee[] staff = <span class="keyword">new</span> <span class="title class_">Employee</span>[actualSize];</span><br></pre></td></tr></table></figure>
<p>但是声明这种数组不能在运行的时候动态改变数组的大小，一旦确定了数组的大小，就不容易改变它</p>
<ul>
<li>
<p>ArrayList  数组列表</p>
<ul>
<li>
<p>类似数组，但是能够在添加或删除元素时，自动地调整数组容量</p>
</li>
<li>
<p>ArrayList是一个有<em>类型参数(type parameter)<em>的</em>泛型类(generic class)</em></p>
<ul>
<li>用一对<em>尖括号</em>将<em>类名</em>括起来追加到ArrayList后面来指定数组列表保存的元素对象的类型</li>
</ul>
</li>
<li>
<p>声明和构造</p>
<ul>
<li><code>ArrayList&lt;Employee&gt; staff = new ArrayList&lt;Employee&gt;();</code></li>
<li>可以省去右边的类型参数：<code>ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;();</code></li>
</ul>
</li>
<li>
<p>菱形语法 <code>&lt;&gt;</code></p>
<ul>
<li>结合new操作符使用菱形语法
<ul>
<li>编译器检查新值要做什么
<ul>
<li>赋值给一个变量</li>
<li>传递给某个方法</li>
<li>从某个方法返回</li>
</ul>
</li>
<li>编译器检查这个变量、参数、方法的泛型类型，将这个类型放在<code>&lt;&gt;</code>上</li>
</ul>
</li>
<li>例如 <code>new ArrayList&lt;&gt;()</code>将赋值给一个类型为<code>ArrayList&lt;Employee&gt;</code>的变量，泛型类型为<code>Employee</code></li>
</ul>
</li>
<li>
<p>add方法 将元素添加到数组中</p>
<ul>
<li><code>staff.add(new Employee(...));</code></li>
<li>数组列表(ArrayList)管理着一个内部的对象引用数组
<ul>
<li>调用add而内部数组已经满的时候，ArrayList会自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中</li>
</ul>
</li>
</ul>
</li>
<li>
<p>ensureCapacity方法</p>
<ul>
<li>已经知道或能够估计出数组可能存储的元素数量，可以在填充之前调用<code>ensureCapacity</code>
<ul>
<li><code>staff.ensureCapacity(100)</code></li>
<li>这样就不会带来开销很大的重新分配控件</li>
</ul>
</li>
</ul>
</li>
<li>
<p>初是容量传递给ArrayList</p>
</li>
</ul>
</li>
<li>
<p><code>ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;(100);</code></p>
<ul>
<li>数组列表(ArrayList)和数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Person&gt; staff = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">100</span>); <span class="comment">// capacity is 100</span></span><br><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>]; <span class="comment">// size is 100</span></span><br><span class="line">System.out.println(staff.size()); <span class="comment">// 0</span></span><br><span class="line">System.out.println(a.length); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>trimToSize</p>
<ul>
<li>将储存块的大小调整为当前保存当前元素数量所需要的储存空间。垃圾回收器将回收多余的储存空间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Java中的ArrayList与C<ins>的vector区别<br>
- C</ins>的vector模板为便于访问元素重载了<code>[]</code>运算符<br>
- Java中没有运算符重载，必须调用显示的方法<br>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   ArrayList&lt;Person&gt; staff = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">   staff.add(...);</span><br><span class="line">   staff.add(...);</span><br><span class="line">   staff.add(...);</span><br><span class="line"><span class="comment">//Person p = staff[1]; //Error 不允许这样做</span></span><br><span class="line">   <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> staff.get(<span class="number">1</span>); <span class="comment">//Right 显式调用</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>
<p>C++的vector是按值拷贝<br>
- 如果<code>a</code>和<code>b</code>是两个vector<br>
- 赋值操作<code>a = b</code>将会构造一个与b长度相同的新向量a，并将所有的元素由b拷贝到a</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">   vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">   v2 = v1;</span><br><span class="line">v2[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line">   cout &lt;&lt; v1[<span class="number">2</span>] &lt;&lt; <span class="string">&quot;  &quot;</span>&lt;&lt;v2[<span class="number">2</span>]; <span class="comment">// 3  5</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Java中对于该赋值语句的操作结果是让<code>a</code>和<code>b</code>引用同一个数组列表(ArrayList)</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   ArrayList&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">   a.add(<span class="number">1</span>);</span><br><span class="line">   a.add(<span class="number">2</span>);</span><br><span class="line">   a.add(<span class="number">3</span>);</span><br><span class="line">   ArrayList&lt;Integer&gt; b = a;</span><br><span class="line">b.set(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">   System.out.println(<span class="string">&quot;&quot;</span>+a.get(<span class="number">2</span>) + <span class="string">&quot;  &quot;</span> + b.get(<span class="number">2</span>)); <span class="comment">//5 5</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>访问ArrayList元素</p>
<ul>
<li><em><strong>不能用[]的语法格式来访问或改变数组的元素</strong></em></li>
<li>改变第i个元素 set
<ul>
<li><code>staff.set(i,harry);</code></li>
<li>必须第i的元素存在才能用set,否则得使用add</li>
</ul>
</li>
<li>得到元素
<ul>
<li><code>staff.get(i);</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>在指定位置插入元素 <code>void add(int index, E obj)</code></p>
<ul>
<li>后移元素，并将obj插入指定索引位置</li>
</ul>
</li>
<li>
<p>从指定位置删除元素 <code>E remove(int index)</code></p>
</li>
</ul>
</li>
<li>
<p>删除索引位置的元素，并将后面的所有元素前移，返回所删除元素</p>
<ul>
<li>注意ArrayList在中间插入和删除元素的效率很低</li>
<li>for each 循环遍历数组列表内容</li>
<li>虚拟机中没有类型参数</li>
<li><code>SuppressWarnings(&quot;&quot;)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Employee e: staff)</span><br><span class="line">  <span class="keyword">do</span> something with e</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>对象包装器和自动装箱</p>
<ul>
<li>
<p>所有的基本类型都有一个与之对应的类(包装器 wrapper)</p>
<ul>
<li>Integer</li>
<li>Long</li>
<li>Float</li>
<li>Double</li>
<li>Short</li>
<li>Byte</li>
<li>Character</li>
<li>Boolean</li>
</ul>
</li>
<li>
<p>包装器类是不可变的</p>
<ul>
<li>里面储存的字段声明为final</li>
<li><code>private final int value;</code></li>
</ul>
</li>
<li>
<p>包装器类是final类，不能派生它们的子类</p>
<ul>
<li><code>public final class Integer extends Number implements Comparable&lt;Integer&gt;</code></li>
</ul>
</li>
<li>
<p>尖括号中的类型参数不允许是基本类型</p>
</li>
</ul>
</li>
<li>
<p><code>ArrayList&lt;Integer&gt;</code>的效率远远低于<code>int[]</code>数组</p>
<ul>
<li>
<p>自动装箱（autoboxing)</p>
<ul>
<li>
<p><code>list.add(3)</code> 自动变成<code>list.add(Integer.valueOf(3))</code></p>
</li>
<li>
<p>将Integer对象赋给int值时，会自动地拆箱</p>
</li>
<li>
<p><code>int n = list.get(i)</code> 自动转换成 <code>int n = list.get(i).intValue()</code></p>
</li>
</ul>
</li>
<li>
<p>算术表达式自动装箱和拆箱</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">n++</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>包装器比较</p>
<ul>
<li><code>==</code>运算符可以应用于包装器对象，但是是检测是否是相同的内存位置</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="type">Integer</span> <span class="variable">a</span>  <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">  System.out.println(a==b); <span class="comment">//true</span></span><br><span class="line">System.out.println(c==d); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<pre><code>自动装箱规范要求boolean、byte、char &lt;= 127，介于-128和127之间的short和int会被包装到固定的对象中，因此小于等于127的包装器的==比较是true
</code></pre>
</li>
<li>
<p>表达式中混用Integer和Double类型，Integer值会拆箱，提升到double，再装箱为Double</p>
<ul>
<li>
<p>装箱和拆箱是编译器的工作</p>
</li>
<li>
<p><code>int intValue()</code> 返回Integer对象的值作为int</p>
</li>
<li>
<p><code>static String toString(int i)</code></p>
</li>
<li>
<p><code>static String toString(int i, int radix)</code></p>
</li>
<li>
<p><code>static int parseInt(String s)</code></p>
</li>
<li>
<p><code>static int parseInt(String s, int radix)</code></p>
</li>
</ul>
</li>
<li>
<p><code>static Integer valueOf(String s)</code></p>
<ul>
<li><code>static Integer valueOf(String s, int radix)</code></li>
</ul>
</li>
<li>
<p>参数数量可变的方法</p>
<ul>
<li>
<p>提供参数数量可变的方法(变参(varargs)方法)</p>
</li>
<li>
<p><code>System.out.printf(&quot;%d&quot;,n);</code></p>
</li>
<li>
<p><code>System.out.printf(&quot;%d %s&quot;,n, &quot;widgets&quot;);</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> PrintStream <span class="title function_">printf</span><span class="params">(String format, Object ... args)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> format(format, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>...</code>是Java代码的一部分，表明这个方法可以接受任意数量的对象,除<code>format</code>外</p>
<p><code>Object ... args</code>其实是一个Object[] 数组，保存所有其他参数，如果调用者提供的是基本类型的值，则会自动装箱</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span> ... values)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">largest</span> <span class="operator">=</span> Double.NEGATIVE_INFINITY;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">double</span> value : values)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(value &gt; largest)&#123;</span><br><span class="line">            largest = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> largest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>枚举类</p>
<ul>
<li><code>public enum Size &#123;SAMLL, MEDIUM, LARGE, EXTRA_LARGE&#125;</code>
<ul>
<li>声明定义的类型是一个类，它有四个实例，只有这四个实例，所以不可能再构造新的对象</li>
</ul>
</li>
<li>比较两个枚举类型的值，直接使用<code>==</code>就可以</li>
<li>可以为枚举类型添加构造器，方法，字段</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Size</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">//这里生成四个Size的实例，同时初始化调用构造函数，参数即为括号里面的字符串</span></span><br><span class="line">      SMALL(<span class="string">&quot;S&quot;</span>),MEDIEUM(<span class="string">&quot;M&quot;</span>),LARGE(<span class="string">&quot;L&quot;</span>),EXTRA_LARGE(<span class="string">&quot;XL&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> String abbreviation;</span><br><span class="line">      <span class="comment">//枚举类的构造器总是私有的，可以省略private修饰符</span></span><br><span class="line">      <span class="comment">//如果声明一个enum构造器为public或protected，会出现语法错误</span></span><br><span class="line">      Size(String abbreviation) &#123;</span><br><span class="line">          <span class="built_in">this</span>.abbreviation = abbreviation;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">getAbbreviation</span><span class="params">()</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> abbreviation;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>所有枚举类型都是Enum类的子类，继承了很多方法
<ul>
<li>
<p>toString</p>
<ul>
<li><code>Size.SMALL.toString()</code>  返回<code>&quot;SMALL&quot;</code></li>
</ul>
</li>
<li>
<p>toString的逆方法是静态方法valueOf</p>
<ul>
<li><code>Size s = Enum.valueOf(Size.class,&quot;SMALL&quot;);</code></li>
</ul>
</li>
<li>
<p>values()方法返回一个包含全部枚举值的数组</p>
<ul>
<li><code>System.out.println(Arrays.toString(Size.values())); //[SMALL, MEDIEUM, LARGE, EXTRA_LARGE]</code></li>
</ul>
</li>
<li>
<p>ordinal()方法返回声明中枚举常量的位置，位置从0开始计数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Size.SMALL.ordinal()); <span class="comment">// 0</span></span><br><span class="line">  System.out.println(Size.LARGE.ordinal()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>int compareTo(E other)</code></p>
<ul>
<li>返回结果是 <code>self.ordinal - other.ordinal</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>反射</p>
<ul>
<li>反射库(reflection library)提供丰富且精巧的工具集，可以用来编写能够动态操纵Java代码的程序</li>
<li>反射(reflective) 能够分析类能力的程序</li>
<li>反射机制
<ul>
<li>在运行时候分析类的能力</li>
<li>在运行时检查对象，例如编写一个适用于所有类的toString方法</li>
<li>实现泛型数组操作代码</li>
<li>利用Method对象，这个对象类似C++的函数指针</li>
</ul>
</li>
<li>Class类
<ul>
<li>
<p>Java运行时，系统始终为<em>所有对象</em>维护一个<em>运行时类型标识</em>。这个信息会跟踪每个对象所属的类</p>
<ul>
<li>保存这个信息的是Class类</li>
</ul>
</li>
<li>
<p><code>Object</code>类中<code>getClass()</code>方法返回一个<code>Class</code>类型的实例</p>
<ul>
<li><code>Class</code>对象描述一个特定类的属性
<ul>
<li><code>getName()</code>方法返回类的名字，会带上包名</li>
<li><code>System.out.println(new Random().getClass().getName()); // java.util.Random</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>静态方法<code>forName()</code>获得类名对应的Class对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.util.Random&quot;</span>);</span><br><span class="line">    System.out.println(cl.getName());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>`forName`方法会抛出一个*检查型异常(checked exception)*,因此需要提供一个*异常处理器(exception handler)*
</code></pre>
<ul>
<li>在启动时，包含main方法的类被加载，它会加载所有需要的类，这些被加载的类又要加载它们需要的类。对于大型应用程序将会花费很长时间</li>
<li>如果T是任意的Java类型(或void关键字)，则T.class代表匹配的类对象</li>
</ul>
</li>
<li>
<p>Class对象实际上表示的是一个<strong>类型</strong>，可能是类，也可能不是类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cl1</span> <span class="operator">=</span> Random.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">cl2</span> <span class="operator">=</span> <span class="type">int</span>.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">cl3</span> <span class="operator">=</span> Double[].class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">cl4</span> <span class="operator">=</span> <span class="keyword">void</span>.class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">cl5</span> <span class="operator">=</span> Integer.class;</span><br><span class="line">System.out.println(cl1.getName()); <span class="comment">// java.util.Random</span></span><br><span class="line">System.out.println(cl2.getName()); <span class="comment">// int</span></span><br><span class="line">System.out.println(cl3.getName()); <span class="comment">// [Ljava.lang.Double;</span></span><br><span class="line">System.out.println(cl4.getName()); <span class="comment">// void</span></span><br><span class="line">System.out.println(cl5.getName()); <span class="comment">// java.lang.Integer</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>虚拟机为每个<em>类型</em>管理一个<em>唯一</em>的Class对象，因此可以用==运算符实现两个类对象的比较</p>
<ul>
<li><code>if(e.getClass() == Employee.class)</code></li>
<li>与<code>e instanceof Employee</code>不同，如果是某个子类的话，测试失败</li>
</ul>
</li>
<li>
<p>Class类型的对象，可以用它来构造类的实例</p>
<ul>
<li>用<code>getConstructor</code>方法得到<code>Constructor</code>类型的对象</li>
</ul>
</li>
<li>
<p>使用<code>newInstance</code>方法来构造一个实例</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;java.util.Random&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cl.getConstructor().newInstance();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>异常
<ul>
<li>非检查型(unchecked)异常,例如越界错误、访问null引用</li>
<li>检查型(checked)异常</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>继承的设计技巧</p>
<ul>
<li>将公共操作和字段放在超类</li>
<li>不要使用受保护的字段</li>
<li>使用继承实现&quot;is-a&quot;关系
<ul>
<li>如果不满足这种关系，就不要使用，例如父类有的某些字段和方法，在子类中不允许存在</li>
</ul>
</li>
<li>除非所有继承的方法都有意义，否则不要使用继承</li>
<li>在覆盖方法时，不要改变预期的行为</li>
<li>使用多态，而不要使用类型信息</li>
<li>不要滥用反射</li>
</ul>
</li>
</ul>
<h3 id="问题与发现"><a class="header-anchor" href="#问题与发现"> </a>问题与发现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee[] staff = <span class="keyword">new</span> <span class="title class_">Employee</span>[<span class="number">3</span>];</span><br><span class="line">System.out.println(staff[<span class="number">0</span>].getName());</span><br></pre></td></tr></table></figure>
<p>这里会报错<code>java.lang.NullPointerException</code>，因为这里没有初始化</p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee[] staff = <span class="keyword">new</span> <span class="title class_">Employee</span>[<span class="number">3</span>];</span><br><span class="line"><span class="type">Employee</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;bad&quot;</span>,<span class="number">10</span>);</span><br><span class="line"><span class="type">Employee</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;good&quot;</span>,<span class="number">20</span>);</span><br><span class="line"><span class="type">Manager</span> <span class="variable">m1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;xixi&quot;</span>,<span class="number">300</span>);</span><br><span class="line">staff[<span class="number">0</span>] = e1;</span><br><span class="line">staff[<span class="number">1</span>] = e2;</span><br><span class="line">staff[<span class="number">2</span>] = m1;</span><br><span class="line">System.out.println(staff[<span class="number">0</span>] <span class="keyword">instanceof</span> Manager); <span class="comment">// false</span></span><br><span class="line">System.out.println(staff[<span class="number">0</span>] <span class="keyword">instanceof</span> Employee); <span class="comment">// true</span></span><br><span class="line">System.out.println(staff[<span class="number">2</span>] <span class="keyword">instanceof</span> Manager); <span class="comment">// true</span></span><br><span class="line">System.out.println(staff[<span class="number">2</span>] <span class="keyword">instanceof</span> Employee); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArrayList&lt;int&gt; a = new ArrayList&lt;int&gt;(); //ERROR</span></span><br></pre></td></tr></table></figure>
<p>Type argument cannot be of primitive type,类型参数不能是基本类型</p>
<hr>
<p>父类定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;method Father&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="comment">//ERROR</span></span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;method Son&quot;</span>);w</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于签名相同的方法，子类的实现的方法提供的访问权限比父类更严格是不允许的</p>
<p>相反，如果子类提供的访问权限比父类弱是允许的。</p>
<p>父类定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;method Father&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="comment">// OK</span></span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;method Son&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java核心技术</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术—集合</title>
    <url>/2020/12/07/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%80%94%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="Java集合框架"><a class="header-anchor" href="#Java集合框架"> </a>Java集合框架</h2>
<h3 id="接口和实现分离"><a class="header-anchor" href="#接口和实现分离"> </a>接口和实现分离</h3>
<p>Java集合类库将**接口（interface）<strong>与</strong>实现（implementation）**分离。</p>
<ul>
<li>Java中定义了相应的接口
<ul>
<li><code>public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123;...&#125;</code></li>
</ul>
</li>
<li>具体的实现类继承了该接口</li>
<li>循环数组队列可以使用<code>ArrayDeque</code>类</li>
<li>链表队列使用<code>LinkedList</code>类</li>
</ul>
<!-- more -->
<p>可以使用<strong>接口类型</strong>存放集合引用。</p>
<p>只有在构造集合对象的时候才会使用具体的类，在使用的时候不需要关心是何种方式实现的</p>
<p>有一组名字以<code>Abstract</code>开头的类，例如<code>AbstractQueue</code>，这些类是为<strong>类库实现者</strong>设计的</p>
<h3 id="Collection接口"><a class="header-anchor" href="#Collection接口"> </a>Collection接口</h3>
<p>集合类的基本接口是<code>Collection</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;E&gt; &#123;</span><br><span class="line">    Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>add方法用于向集合 添加元素
<ul>
<li>添加元素改变了集合返回true；如果集合没有发生变化，返回false。</li>
<li>集（set）如果对象已存在则返回false</li>
</ul>
</li>
<li>iterator方法返回一个实现了<code>Iterator</code>接口的对象，该迭代器对象依次访问集合中的元素</li>
</ul>
<h3 id="迭代器"><a class="header-anchor" href="#迭代器"> </a>迭代器</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the next element in the iteration.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the next element in the iteration</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException if the iteration has no more elements</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@implSpec</span></span></span><br><span class="line"><span class="comment">     * The default implementation throws an instance of</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> UnsupportedOperationException&#125; and performs no other action.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if the &#123;<span class="doctag">@code</span> remove&#125;</span></span><br><span class="line"><span class="comment">     *         operation is not supported by this iterator</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalStateException if the &#123;<span class="doctag">@code</span> next&#125; method has not</span></span><br><span class="line"><span class="comment">     *         yet been called, or the &#123;<span class="doctag">@code</span> remove&#125; method has already</span></span><br><span class="line"><span class="comment">     *         been called after the last call to the &#123;<span class="doctag">@code</span> next&#125;</span></span><br><span class="line"><span class="comment">     *         method</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;remove&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>返回调用<code>next</code>方法可以逐个访问集合中的每个元素</p>
<p>到达了<strong>集合末尾</strong>，next方法会抛出<code>NoSuchElementException</code></p>
<p>在调用<code>next</code>之前调用<code>hasNext</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; c = ...;</span><br><span class="line">Iterator&lt;String&gt; iter = c.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> iter.next();</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“for each”循环转换为带有迭代器的循环</p>
<p>因此&quot;for each&quot;循环可以处理任何<strong>实现了<code>Iterable</code>接口的对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(String element : c)&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>Collection</code>接口扩展了<code>Iterable</code>接口，因此标准类库的任何集合都可以使用for each循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="built_in">this</span>) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> Spliterator&lt;T&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>调用<code>forEachRemaining</code>方法并提供lambda表达式来处理每一个元素，直到没有元素为止</p>
<p><code>iterator.forEachRemaing(element -&gt; do something with element);</code></p>
<p><strong>访问元素的顺序取决于集合类型</strong></p>
<ul>
<li>HashSet会按照基本上随机的顺序获得元素</li>
</ul>
<blockquote>
<p>Iterator接口的next和hasNext方法和Enumeration接口的nextElement和hasMoreElements方法作用一样</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Enumeration</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasMoreElements</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    E <span class="title function_">nextElement</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java迭代器的<strong>查找操作</strong>和<strong>位置变更</strong>紧密<strong>耦合</strong></p>
<ul>
<li>查找一个元素的唯一方法是调用<code>next</code>，查找操作的同时，迭代器的位置就会随之向前移动</li>
<li>可以认为Java迭代器位于两个元素之间，调用<code>next</code>时，迭代器就越过下一个元素。并返回刚刚越过的那个元素的引用</li>
</ul>
<p>next方法和remove方法调用之间存在<strong>依赖性</strong></p>
<ul>
<li>
<p>Iterator接口的 remove方法将会删除上次调用<code>next</code>方法时<strong>返回的元素</strong></p>
<ul>
<li>
<p>如果想删除指定位置上的元素，仍然需要越过这个元素</p>
</li>
<li>
<p>如果调用remove之前没有调用next，将是不合法的</p>
</li>
<li>
<pre><code class="language-JAVA">it.remove();
if.remove();//ERROR
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 泛型实用方法</span><br><span class="line"></span><br><span class="line">Collection和Iterator是泛型接口</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;</span><br><span class="line">    int size();</span><br><span class="line">    boolean isEmpty();</span><br><span class="line">    boolean contains(Object o);</span><br><span class="line">    Iterator&lt;E&gt; iterator();</span><br><span class="line">    Object[] toArray();</span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br><span class="line">    boolean add(E e);</span><br><span class="line">    boolean remove(Object o);</span><br><span class="line">    boolean containsAll(Collection&lt;?&gt; c);</span><br><span class="line">    boolean addAll(Collection&lt;? extends E&gt; c);</span><br><span class="line">    boolean removeAll(Collection&lt;?&gt; c);</span><br><span class="line">    default boolean removeIf(Predicate&lt;? super E&gt; filter) &#123;</span><br><span class="line">        Objects.requireNonNull(filter);</span><br><span class="line">        boolean removed = false;</span><br><span class="line">        final Iterator&lt;E&gt; each = iterator();</span><br><span class="line">        while (each.hasNext()) &#123;</span><br><span class="line">            if (filter.test(each.next())) &#123;</span><br><span class="line">                each.remove();</span><br><span class="line">                removed = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return removed;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean retainAll(Collection&lt;?&gt; c);</span><br><span class="line">    void clear();</span><br><span class="line">    boolean equals(Object o);</span><br><span class="line">    int hashCode();</span><br><span class="line">    @Override</span><br><span class="line">    default Spliterator&lt;E&gt; spliterator() &#123;</span><br><span class="line">        return Spliterators.spliterator(this, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default Stream&lt;E&gt; stream() &#123;</span><br><span class="line">        return StreamSupport.stream(spliterator(), false);</span><br><span class="line">    &#125;</span><br><span class="line">    default Stream&lt;E&gt; parallelStream() &#123;</span><br><span class="line">        return StreamSupport.stream(spliterator(), true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
<p>还有一个叫做<code>public abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; </code>类，实现了大部分<code>Collection</code>接口的方法，来方便实现者</p>
<p>但是可以在Collection添加默认方法，也可以达到同样的效果</p>
<h2 id="集合框架的接口"><a class="header-anchor" href="#集合框架的接口"> </a>集合框架的接口</h2>
<p>Java集合框架中接口的关系，其中箭头表示继承关系（<code>extends</code>）</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201207164318982.png" alt="image-20201207164318982"></p>
<h3 id="集合基本接口"><a class="header-anchor" href="#集合基本接口"> </a>集合基本接口</h3>
<h4 id="Collection和Map"><a class="header-anchor" href="#Collection和Map"> </a>Collection和Map</h4>
<p>集合有两个基本接口<code>Collection</code>（集合）和<code>Map</code>（映射）</p>
<ul>
<li>集合插入元素<code>boolean add(E element)</code></li>
<li>集合读取元素，可以用迭代器访问元素</li>
<li>映射（Map）包含键/值对
<ul>
<li>用<code>put</code>方法插入 :   <code>V put(K key, V value);</code></li>
<li>用<code>get</code>方法读取值:   <code>V get(K key)</code></li>
</ul>
</li>
</ul>
<h4 id="List"><a class="header-anchor" href="#List"> </a>List</h4>
<p><code>List</code>是一个<strong>有序集合（ordered collection）</strong>。</p>
<p>元素会增加到容器中的特定位置</p>
<p>访问元素方式</p>
<ul>
<li>迭代器方法
<ul>
<li>必须<strong>按顺序访问</strong>元素</li>
</ul>
</li>
<li>整数索引方法
<ul>
<li>又称<strong>随机访问（random access）</strong>，可以<strong>任意顺序</strong>访问元素</li>
</ul>
</li>
</ul>
<p><code>List</code>中随机访问的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span></span><br></pre></td></tr></table></figure>
<h4 id="ListIterator"><a class="header-anchor" href="#ListIterator"> </a>ListIterator</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ListIterator</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterator</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>
<p><code>ListIterator</code>接口是<code>Iterator</code>的一个子接口。它定义了一个方法用于在迭代器位置前面增加一个元素<code>void add(E element)</code></p>
<p>两种有序集合</p>
<ul>
<li>
<p>数组支持的有序集合</p>
<ul>
<li>可以快速地随机访问</li>
<li>适合使用List方法并提供一个整数索引访问</li>
</ul>
</li>
<li>
<p>链表支持的有序集合</p>
<ul>
<li>
<p>随机访问很慢</p>
</li>
<li>
<p>最好使用迭代器遍历</p>
</li>
<li>
<p>但是<code>LinkedList</code>仍然继承了<code>List</code>接口</p>
</li>
<li>
<pre><code class="language-JAVA">public class LinkedList&lt;E&gt;
    extends AbstractSequentialList&lt;E&gt;
    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### Set</span><br><span class="line"></span><br><span class="line">集（Set）接口等同于`Collection`接口。但是集的方法的行为有更严谨的定义</span><br><span class="line"></span><br><span class="line">- `add`方法不允许增加重复元素</span><br><span class="line">- `equals`方法：只要两个集包含同样到元素就是相等，而不要求元素需要有同样的顺序</span><br><span class="line">- `hashCode`方法定义要保证包含相同元素的两个集会得到相同的散列码</span><br><span class="line"></span><br><span class="line">#### SortedSet和SortedMap</span><br><span class="line"></span><br><span class="line">`SortedSet`和`SortedMap`接口提供用于排序的比较器对象。定义了可以得到集合子集视图的方法。</span><br><span class="line"></span><br><span class="line">#### NavigableSet和NavigableMap</span><br><span class="line"></span><br><span class="line">Java6引入了`NavigableSet`和`NavigableMap`接口，包含一些用于搜索和遍历有序集和映射的方法。</span><br><span class="line"></span><br><span class="line">`TreeSet`和`TreeMap`类实现了这些接口。</span><br><span class="line"></span><br><span class="line">## 具体集合</span><br><span class="line"></span><br><span class="line">除了以`Map`结尾的类之外，其他类都实现了`Collection`接口。以`Map`结尾的类实现了`Map`接口</span><br><span class="line"></span><br><span class="line">| 集合类型        | 描述                                             |</span><br><span class="line">| --------------- | ------------------------------------------------ |</span><br><span class="line">| ArrayList       | 可以**动态**增加和缩减的一个**索引**序列         |</span><br><span class="line">| LinkedList      | 可以在任何位置**高效插入和删除**的一个有序序列   |</span><br><span class="line">| ArrayDeque      | 实现为**循环数组**的一个**双端队列**             |</span><br><span class="line">| HashSet         | 没有重复元素的一个**无序**集合                   |</span><br><span class="line">| TreeSet         | 一个**有序**集                                   |</span><br><span class="line">| EnumSet         | 一个包含**枚举类型**值的集                       |</span><br><span class="line">| LinkedHashSet   | 一个可以**记住元素插入次序**的集                 |</span><br><span class="line">| PriorityQueue   | 允许高效**删除最小元素**的一个集合               |</span><br><span class="line">| HashMap         | 存储键/值关联的一个数据结构                      |</span><br><span class="line">| TreeMap         | **键有序**的一个映射                             |</span><br><span class="line">| EnumMap         | 键属于**枚举类型**的一个映射                     |</span><br><span class="line">| LinkedHashMap   | 可以**记住键/值项添加次序**的一个映射            |</span><br><span class="line">| WeakHashMap     | 值不会再别处使用时就可以被**垃圾回收**的一个映射 |</span><br><span class="line">| IdentityHashMap | 用`==`而不是用equals比较键的一个映射             |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 集合框架中的类</span><br><span class="line"></span><br><span class="line">![image-20201207213253315](http://algorithm-image.qibinaoe.top/image-20201207213253315.png)</span><br><span class="line"></span><br><span class="line">![image-20201207215131415](http://algorithm-image.qibinaoe.top/image-20201207215131415.png)</span><br><span class="line"></span><br><span class="line">书上P376页图9-5中，对于`ArrayQueue`的位置有些偏差</span><br><span class="line"></span><br><span class="line">```Java</span><br><span class="line">public class ArrayQueue&lt;T&gt; extends AbstractList&lt;T&gt;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="链表-LinkedList"><a class="header-anchor" href="#链表-LinkedList"> </a>链表 LinkedList</h3>
<p>数组和数组列表（ArrayList）缺点：从中间删除或插入元素的开销大</p>
<p>Java中，所有链表实际上都是**双向链接（doubly linked）**的。每个链接存放着其前驱的引用。</p>
<p><code>LinkedList.add</code>方法将对象添加到链表的<strong>尾部</strong></p>
<p>对于插入链表中间，由于迭代器描述集合的位置，可以通过迭代器完成该操作</p>
<ul>
<li>只有对自然有序的集合使用迭代器添加元素才有实际意义</li>
<li>set数据类型是无序的，因此<code>Iterator</code>接口中没有<code>add</code>方法</li>
</ul>
<p><code>ListIterator</code>继承<code>Iterator</code>，包含了<code>add</code>方法</p>
<p>这里<code>add</code>方法与<code>Collection.add</code>不同，不返回<code>boolean</code>类型，假定add操作总会改变链表</p>
<p>同时<code> E previous();</code>和<code>boolean hasPrevious();</code>可以反向遍历链表</p>
<ul>
<li><code>previous</code>方法返回<strong>跨越</strong>过的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ListIterator</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    E <span class="title function_">previous</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">previousIndex</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LinkedList</code>类的<code>listIterator</code>方法返回一个实现了<code>ListIterator</code>接口的迭代器对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> listIterator(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ListIterator</code>的<code>add</code>方法在迭代器位置<strong>之前</strong>添加一个新的对象，注意可以认为迭代器的位置在两个元素之间</p>
<p>一个刚由<code>listIterator</code>方法返回并指向链表表头的迭代器调用<code>add</code>，新添加的元素成为链表的新表头</p>
<p>在迭代器越过链表的最后一个元素（即hasNext()返回false），添加元素称为链表新的表尾</p>
<p>如果链表有n个元素，则有n+1的位置可以 添加新元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">|ABC</span><br><span class="line">A|BC</span><br><span class="line">AB|C</span><br><span class="line">ABC|</span><br></pre></td></tr></table></figure>
<p>如果一个迭代器在修改集合，另一个在遍历集合，则会出现混乱</p>
<ul>
<li><code>ListIterator</code>可以检测到这种修改</li>
<li>如果一个迭代器发现它的集合被另一个迭代器修改了，或是该集合自身的某个方法修改了（就是集合变了的意思），就会抛出<code>ConcurrentModificationException</code>异常</li>
<li>集合可以跟踪更改操作（添加或删除元素）的次数，每个迭代器都会为它负责的更改操作<strong>维护</strong>一个<strong>单独</strong>的<strong>更改操作数</strong>。
<ul>
<li>在迭代器被调用方法的开始，迭代器会检查它自己的更改操作数是否和集合的更改操作数相等。不一致就抛出<code>ConcurrentModificationException</code></li>
<li>链表只跟踪对列表的<strong>结构性修改</strong>，例如添加和删除<strong>链接</strong>
<ul>
<li><code>set</code>方法不被视为结构性修改</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><code>contains</code>方法检测某个元素是否出现在链表中</p>
<p><strong>链表不支持快速随机访问</strong></p>
<ul>
<li>如果要查看链表中的第n个元素，就得从头开始，越过n-1个元素（<code>get</code>方法进行优化：如果索引大于<code>size()/2</code>，则从列表后端向前搜索元素）</li>
</ul>
<p><strong><u>划重点</u></strong>：不要用下面这种虚假的效率极低的随机访问遍历列表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++)</span><br><span class="line">    <span class="keyword">do</span> something with list.get(i);</span><br></pre></td></tr></table></figure>
<p>列表迭代器能够告诉当前位置的索引：由于Java迭代器指向两个元素之间的位置，所以有两个索引</p>
<ul>
<li><code>nextIndex</code>返回下一次调用<code>next</code>方法时返回元素的整数索引</li>
<li><code>previousIndex</code>返回下一次调用<code>previous</code>方法时返回元素的整数索引</li>
<li><code>list.listIterator(n).next()</code>和<code>list.get(n)</code>会产生同一个元素</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>
<p>区别迭代器<code>ListIterator</code>的<code>add</code>和集合本身的<code>add</code>的区别</p>
</li>
<li>
<p>迭代器的<code>add</code>是在迭代器<strong>之前</strong>的位置添加的</p>
<ul>
<li>原本<code>A|BCD</code></li>
<li>调用add后（新增个P）</li>
<li><code>AP|BCD</code>注意迭代器的位置</li>
</ul>
</li>
<li>
<p>调用迭代器的<code>remove</code>方法是删除<code>next</code>方法或者<code>previous</code>方法返回的那个元素</p>
<ul>
<li>因此调用next()后，remove方法删除的是迭代器左侧的元素</li>
<li>调用previous后，remove方法删除的是迭代器右侧的元素</li>
</ul>
</li>
<li>
<p>同<code>remove</code>一样，迭代器的<code>set</code>方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;String&gt; a = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">a.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">a.add(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">a.add(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">ListIterator&lt;String&gt; iterator = a.listIterator();</span><br><span class="line">System.out.println(a);<span class="comment">//[one, two, three]</span></span><br><span class="line">iterator.next();</span><br><span class="line">iterator.remove();</span><br><span class="line">System.out.println(a);<span class="comment">//[two, three]</span></span><br><span class="line">iterator.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(a);<span class="comment">//[aaa, two, three]</span></span><br><span class="line">iterator.previous();</span><br><span class="line">iterator.remove();</span><br><span class="line">System.out.println(a);<span class="comment">//[two, three]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;String&gt; a = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">a.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">a.add(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">a.add(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">ListIterator&lt;String&gt; iterator = a.listIterator();</span><br><span class="line">System.out.println(a);<span class="comment">//[one, two, three]</span></span><br><span class="line">iterator.next();</span><br><span class="line">iterator.set(<span class="string">&quot;yi&quot;</span>);</span><br><span class="line">System.out.println(a);<span class="comment">//[yi, two, three]</span></span><br><span class="line">iterator.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(a);<span class="comment">//[yi, aaa, two, three]</span></span><br><span class="line">iterator.previous();</span><br><span class="line">iterator.set(<span class="string">&quot;ooo&quot;</span>);</span><br><span class="line">System.out.println(a);<span class="comment">//[yi, ooo, two, three]</span></span><br></pre></td></tr></table></figure>
<h3 id="数组列表-ArrayList"><a class="header-anchor" href="#数组列表-ArrayList"> </a>数组列表 ArrayList</h3>
<p><code>List</code>接口用于描述一个有序集合，并且集合中每个元素的位置很重要。</p>
<p>访问元素的协议</p>
<ul>
<li>通过迭代器</li>
<li>通过<code>get</code>和<code>set</code>方法随机地访问每个元素</li>
</ul>
<p><code>ArrayList</code>封装了一个动态再分配的对象数组</p>
<h4 id="ArrayList与Vector"><a class="header-anchor" href="#ArrayList与Vector"> </a><code>ArrayList</code>与<code>Vector</code></h4>
<ul>
<li>Vetor类的所有方法都是同步的
<ul>
<li>可以安全地从两个线程发访问一个Vector对象</li>
<li>只从一个线程访问Vector的话，代码会在同步操作浪费大量时间</li>
</ul>
</li>
<li>ArrayList方法不是同步的</li>
</ul>
<h3 id="HashMap"><a class="header-anchor" href="#HashMap"> </a>HashMap</h3>
<ul>
<li>链表和数组允许指定元素次序，但是不知道具体位置则需要访问所有元素</li>
</ul>
<p>如果不在意元素顺序，能够快速查找元素（缺点就是无法控制元素出现的次序）</p>
<ul>
<li>散列表（hash table）
<ul>
<li>为每个<strong>对象</strong>计算一个整数</li>
</ul>
</li>
<li>散列码（hash code）
<ul>
<li>对象的实例字段得出的整数</li>
</ul>
</li>
</ul>
<p>在Java中，散列表用链表数组实现。每个<strong>列表</strong>被称为<strong>桶（bucket）</strong></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201208100844986.png" alt="image-20201208100844986"></p>
<p>要查找表中对象的位置</p>
<ul>
<li>先计算出该对象的散列码</li>
<li>散列码与<strong>桶的总数取余</strong></li>
<li>得到结果为保存该元素的桶的索引</li>
</ul>
<p>**散列冲突（hash collision）**要插入元素时，桶已经被填充了。这时需要将新对象与桶中所有对象进行比较，查看这个对象是否存在。</p>
<ul>
<li>如果散列码合理地随机分布，桶的数目足够大，需要比较的次数就会少</li>
</ul>
<p>在Java8中，桶满时会从<strong>链表</strong>变成<strong>平衡二叉树</strong>。</p>
<ul>
<li>散列函数选择不好，发生很多冲突。</li>
<li>恶意代码试图在散列表中填充多个相同散列码的值</li>
<li>这种情况下，改成平衡二叉树能提高性能</li>
</ul>
<p><strong>桶数</strong>是用于收集有<strong>相同散列值</strong>的桶的<strong>数目</strong>（相同散列值的对象放在同一个桶中）（散列表的索引即为桶的索引）</p>
<p>可以指定一个初始的桶数</p>
<p>桶数设置为预计元素个数的75%~150%，标准类库使用的桶数试试2的幂，默认是16</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HashMap.java</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment">     * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment">     * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashMap.java</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment">     * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment">     * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment">     * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">//HashMap内部维护一个Node数组，同时该数组长度为2的幂</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HashMap.java</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment">     * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next; <span class="comment">// 可以看到这是一条链表</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>再散列（reshashed）</strong></p>
<ul>
<li>如果散列太慢，就需要再散列</li>
<li>创建一个桶数更多的表，将所有元素插入到新表，然后丢弃原来的表</li>
<li>装填因子（load factor）：确定何时对散列表进行再散列
<ul>
<li>如果装填因子为0.75（默认值），说明表中已经填满了75%以上，就会<strong>自动</strong>再散列，新表的桶数是原来的<strong>两倍</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashMap.java</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashMap.java</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment">     * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">     * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">     * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">     * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">        <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="literal">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong><u>注意</u></strong></p>
<ul>
<li>HashMap和HashTable区别？</li>
</ul>
<h4 id="散列集-HashSet"><a class="header-anchor" href="#散列集-HashSet"> </a>散列集 HashSet</h4>
<p>集是没有重复元素的</p>
<p>集允许快速地查找现有的元素。但是要查找一个元素，需要有所要查找的那个元素的<strong>准确副本</strong></p>
<ul>
<li>集的add方法要先在集中查找要添加的对象，如果不存在，就添加这个对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map; <span class="comment">// HashSet内部维护一个HashMap</span></span><br><span class="line">     </span><br><span class="line">    ...</span><br><span class="line">         </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line">   	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>contains</code>方法用来快速查找某个元素是否已经在，它只查看<strong>一个桶</strong>中的元素，不必查看集合中的所有元素</p>
<p><strong>散列集迭代器</strong>会依次访问所有的桶</p>
<p><u><strong>注意</strong></u></p>
<ul>
<li>HashSet是一个Set，存的是对象，而不是键值对（虽然HashSet里维护着一个HashMap）</li>
</ul>
<h3 id="TreeSet-树集"><a class="header-anchor" href="#TreeSet-树集"> </a>TreeSet 树集</h3>
<p>树集是一个有序集合（sorted collection）。</p>
<p>可以以<strong>任意顺序</strong>将元素<strong>插入</strong>到集合中。在对集合进行遍历时，值将自动地按照<strong>排序后的顺序</strong>呈现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableSet</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet&lt;String&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">ts.add(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">ts.add(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">ts.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">System.out.println(ts); <span class="comment">// [apple, cat, dog]</span></span><br><span class="line"><span class="keyword">for</span>(String s : ts) System.out.println(s); <span class="comment">//apple cat dog</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>要使用树集TreeSet，<strong>必须</strong>能够比较元素。</p>
<p>这些元素必须实现Comparable接口，或者构造集时，必须提供一个Comparator</p>
</blockquote>
<p>错误示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeSet&lt;Who&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        ts.add(<span class="keyword">new</span> <span class="title class_">Who</span>(<span class="string">&quot;cool&quot;</span>)); <span class="comment">//ERROR java.lang.ClassCastException : CollectionTest.Who cannot be cast to java.lang.Comparable</span></span><br><span class="line">        ts.add(<span class="keyword">new</span> <span class="title class_">Who</span>(<span class="string">&quot;good&quot;</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> <span class="title class_">Who</span>(<span class="string">&quot;bad&quot;</span>));</span><br><span class="line">        System.out.println(ts);</span><br><span class="line">        <span class="keyword">for</span>(Who s : ts) System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Who</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Who</span><span class="params">(String n)</span>&#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Who&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提供 <code>Comparator</code></p>
<ul>
<li><code>TreeSet&lt;Who&gt; ts = new TreeSet&lt;&gt;((Who w1,Who w2) -&gt;w1.getName().compareTo(w2.getName()) );</code></li>
</ul>
<p><code>TreeSet</code>中的排序时用**红黑树（red-black tree）**实现的。</p>
<p>每次将一个元素添加到树中时，都会将其放置在正确的排序位置上。因此迭代器总是以有序的顺序访问每个元素。</p>
<p>将一个元素添加到树中要比<strong>添加</strong>到散列表中<strong>慢</strong>。</p>
<p>与<strong>检查</strong>数组或链表中的<strong>重复元素</strong>相比，使用树会<strong>快很多</strong>。</p>
<p>查找新元素的正确位置平均需要logn次比较。</p>
<p>如果不需要数据是有序的，就没有必要付出排序的开销。</p>
<h3 id="队列-Queue-和-双端队列-Deque"><a class="header-anchor" href="#队列-Queue-和-双端队列-Deque"> </a>队列 Queue 和  双端队列 Deque</h3>
<ul>
<li>
<p>队列允许高效地在尾部添加元素，并在头部删除元素。</p>
</li>
<li>
<p>双端队列允许在头部和尾部都高效地添加或删除元素</p>
</li>
<li>
<p>队列不支持在中间添加元素</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Deque</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Queue</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable			</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDeque</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;E&gt;</span><br><span class="line">                           <span class="keyword">implements</span> <span class="title class_">Deque</span>&lt;E&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>
<p>Queue中定义的方法</p>
<ul>
<li><code>boolean add(E element)</code></li>
<li><code>boolean offer(E element)</code>
<ul>
<li>如果队列没满，给定的元素添加到队列的队尾，并返回true。</li>
<li>如果队列已满，<code>add</code>方法将抛出<code>IllegalStateException</code>；<code>offer</code>方法返回false</li>
</ul>
</li>
<li><code>E remove()</code></li>
<li><code>E poll()</code>
<ul>
<li>如果队列不为空，删除并返回这个队列队头元素</li>
<li>如果队列为空，<code>remove</code>方法抛出<code>NoSuchElementException</code>；<code>poll</code>方法返回<code>null</code></li>
</ul>
</li>
<li><code>E element()</code></li>
<li><code>E peek()</code>
<ul>
<li>如果队列不为空，返回这个队列队头的元素，但不删除</li>
<li>如果队列为空，<code>element</code>方法抛出<code>NoSuchElementException</code>；<code>peek</code>方法返回<code>null</code></li>
</ul>
</li>
</ul>
<p>Deque中定义的方法也类似Queue定义的一样，也是成对出现的，同时分别为头位置和位位置定义方法</p>
<ul>
<li><code>void addFirst(E e)</code></li>
<li><code>void addLast(E e)</code></li>
<li><code>boolean offerFirst(E e)</code></li>
<li><code>boolean offerLast(E e)</code></li>
<li><code>E removeFirst()</code></li>
<li><code>E removeLast()</code></li>
<li><code>E pollFirst()</code></li>
<li><code>E pollLast()</code></li>
<li><code>E getFirst()</code></li>
<li><code>E getLast()</code></li>
<li><code>E peekFirst()</code></li>
<li><code>E peekLast()</code></li>
</ul>
<h3 id="优先队列-PriorityQueue"><a class="header-anchor" href="#优先队列-PriorityQueue"> </a>优先队列 PriorityQueue</h3>
<p>优先队列中的元素可以按<strong>任意顺序插入</strong>，但是会按照<strong>有序的顺序</strong>进行<strong>检索</strong></p>
<p>即调用<code>remove</code>方法，总会获得当前优先队列中<strong>最小的元素</strong></p>
<p>优先队列并没有对所有元素进行排序。</p>
<p>如果迭代处理这些元素，并不需要对它进行排序（看下方代码）</p>
<p>优先队列使用了堆（heap）（堆是自组织的二叉树），在添加（add）或删除（remove）操作可以让最小元素移动到根，而不必花费时间对元素进行排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;LocalDate&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">pq.add(LocalDate.of(<span class="number">1902</span>,<span class="number">12</span>,<span class="number">9</span>));</span><br><span class="line">pq.add(LocalDate.of(<span class="number">1804</span>,<span class="number">12</span>,<span class="number">29</span>));</span><br><span class="line">pq.add(LocalDate.of(<span class="number">1992</span>,<span class="number">2</span>,<span class="number">7</span>));</span><br><span class="line">pq.add(LocalDate.of(<span class="number">1202</span>,<span class="number">2</span>,<span class="number">9</span>));</span><br><span class="line"><span class="keyword">for</span>(LocalDate date : pq) System.out.println(date);<span class="comment">// 1202-02-09 1804-12-29 1992-02-07 1902-12-09</span></span><br><span class="line"><span class="keyword">while</span> (!pq.isEmpty()) System.out.println(pq.remove()); <span class="comment">// 1202-02-09 1804-12-29 1902-12-09 1992-02-07</span></span><br></pre></td></tr></table></figure>
<p>代码可以发现，add操作后，堆顶总是最小元素。而remove操作的时候，堆顶也总是最小元素</p>
<p>优先队列的典型用法是任务调度。每个任务都有一个优先级，任务以随机顺序添加到队列中。每次启动一个新的任务时，都将优先级最高的任务从队列中删除。</p>
<p><strong><u>注意</u></strong></p>
<ul>
<li>与TreeSet一样，优先队列既可以保存实现<code>Comparable</code>接口的类对象，也可以保存构造器中提供的<code>Comparator</code>对象
<ul>
<li>实践发现，如果没有实现这些接口，优先队列添加一个元素，还是能够正常保存，但是添加两个元素就抛出<code>java.lang.ClassCastException: CollectionTest.Who cannot be cast to java.lang.Comparable</code></li>
</ul>
</li>
</ul>
<h2 id="映射-map"><a class="header-anchor" href="#映射-map"> </a>映射 map</h2>
<h3 id="基本操作"><a class="header-anchor" href="#基本操作"> </a>基本操作</h3>
<p>映射用来存放<strong>键/值对</strong></p>
<p>Java类库位映射提供了两个通用的实现<code>HashMap</code>和<code>TreeMap</code>。这两个类都实现了<code>Map</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取与键关联的值；返回与键关联的对象，如果映射中没有这个对象，则返回null。</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得与键关联的值；返回与键关联的对象，如果未在映射中找到这个键，则返回defaultValue</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? defaultValue : e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将关联的一对键和值放入映射中，如果这个键已经存在，新的对象将取代与这个键关联的旧对象。这个方法将返回键关联的旧值。如果之前没有这个键，则返回null。</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        putMapEntries(m, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getNode(hash(key), key) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对这个映射中的所有键/值对应用这个动作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> K, ? <span class="built_in">super</span> V&gt; action)</span> &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableMap</span>&lt;K,V&gt;, Cloneable, java.io.Serializable&#123;</span><br><span class="line">	</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">()</span> &#123;</span><br><span class="line">        comparator = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        comparator = <span class="literal">null</span>;</span><br><span class="line">        putAll(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        comparator = m.comparator();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            buildFromSorted(m.size(), m.entrySet().iterator(), <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">firstKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key(getFirstEntry());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">lastKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key(getLastEntry());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>散列映射（HashMap）对<strong>键</strong>进行<strong>散列</strong></p>
<p>树映射（TreeMap）根据键的顺序将元素组织为一个搜索树</p>
<p><strong>散列</strong>或<strong>比较函数</strong>只应用于<strong>键</strong>，与键关联的值不进行散列或比较</p>
<ul>
<li>这句话的意思是，对于HashMap，散列只对key键进行散列，value是什么不会影响到散列</li>
<li>对于TreeMap，里面元素的比较，只会比较键。</li>
</ul>
<p>散列稍微快些，如果<strong>不需要</strong>按照<strong>有序</strong>的顺序<strong>访问键</strong>，最好选择<strong>散列映射</strong>。</p>
<p>要想检索一个对象，必须<strong>使用键</strong></p>
<p>迭代处理映射的键和值，使用<code>forEach</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.forEach((k,v)-&gt;</span><br><span class="line">           System.out.println(<span class="string">&quot;key=&quot;</span> + k + <span class="string">&quot;, valaue=&quot;</span> + v));</span><br></pre></td></tr></table></figure>
<p><u><strong>注意</strong></u>：</p>
<ul>
<li>TreeMap同TreeSet和PriorityQueue一样，需要要么存入的Key实现<code>Comparable</code>接口或者提供<code>Comparator</code>给构造器</li>
</ul>
<h3 id="更新映射条目"><a class="header-anchor" href="#更新映射条目"> </a>更新映射条目</h3>
<p>对于一个映射进行更新value操作：<code>counts.put(word,counts.get(word)+1)</code>。如果是第一次放入word，则会返回null而报出空指针异常。</p>
<p>解决办法</p>
<ul>
<li>
<pre><code class="language-java">counts.put(word,counts.getOrDefault(word,0)+1);
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  counts.putIfAbsent(word,0);</span><br><span class="line">  counts.put(word,counts.get(word)+1);</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li>
<pre><code class="language-java">counts.merge(word,1,Integer::sum); // 如果键原先不存在，则存入(word,1)，否则使用Integer::sum函数组合原值和1
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 映射视图</span><br><span class="line"></span><br><span class="line">映射的视图（view）是实现了`Collection`接口或某个子接口的对象</span><br><span class="line"></span><br><span class="line">有3种视图：键集、值集合（由于值元素不一定唯一，所以不是集）、键/值对集。</span><br><span class="line"></span><br><span class="line">方法：</span><br><span class="line"></span><br><span class="line">```Java</span><br><span class="line">Set&lt;K&gt; keySet()</span><br><span class="line">Collection&lt;V&gt; values()</span><br><span class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()    </span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<p>枚举一个映射的所有键</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; keys = map.keySet();</span><br><span class="line"><span class="keyword">for</span>( String key : keys)&#123;</span><br><span class="line">	<span class="keyword">do</span> something wwith key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, Employee&gt; entry : staff.entrySet())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">k</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">v</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    <span class="keyword">do</span> something with k, v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.forEach((k,v))</span><br></pre></td></tr></table></figure>
<p>声明的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line">        Set&lt;K&gt; ks = keySet;</span><br><span class="line">        <span class="keyword">if</span> (ks == <span class="literal">null</span>) &#123;</span><br><span class="line">            ks = <span class="keyword">new</span> <span class="title class_">KeySet</span>();</span><br><span class="line">            keySet = ks;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span> &#123;</span><br><span class="line">    Collection&lt;V&gt; vs = values;</span><br><span class="line">    <span class="keyword">if</span> (vs == <span class="literal">null</span>) &#123;</span><br><span class="line">        vs = <span class="keyword">new</span> <span class="title class_">Values</span>();</span><br><span class="line">        values = vs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="literal">null</span> ? (entrySet = <span class="keyword">new</span> <span class="title class_">EntrySet</span>()) : es;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在<strong>键集视图</strong>上调用<strong>迭代器</strong>的<code>remove</code>方法，实际上会从映射中删除这个<strong>键</strong>和与它<strong>关联的值</strong></p>
<p><strong>不能</strong>向<strong>键集视图</strong>中<strong>添加元素</strong></p>
<ul>
<li>试图调用<code>add</code>方，会抛出一个<code>UnsupportedOperationException</code></li>
</ul>
<p><strong>映射条目集视图</strong>也有同样的限制</p>
<p>三种视图都可以删除元素，但是不可以添加元素</p>
<p>对于<code>Map.Entry</code></p>
<ul>
<li><code>K getKey()</code></li>
<li><code>V getValue()</code></li>
<li><code>V setValue(V newValue)</code>
<ul>
<li>将相关映射中的值改为新值，并返回原来的值</li>
</ul>
</li>
</ul>
<h3 id="弱散列映射-WeakHashMap"><a class="header-anchor" href="#弱散列映射-WeakHashMap"> </a>弱散列映射 WeakHashMap</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakHashMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt; &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reference queue for cleared WeakEntries</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Expunges stale entries from the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">expungeStaleEntries</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object x; (x = queue.poll()) != <span class="literal">null</span>; ) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, table.length);</span><br><span class="line"></span><br><span class="line">                Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">                Entry&lt;K,V&gt; p = prev;</span><br><span class="line">                <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">                    Entry&lt;K,V&gt; next = p.next;</span><br><span class="line">                    <span class="keyword">if</span> (p == e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (prev == e)</span><br><span class="line">                            table[i] = next;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            prev.next = next;</span><br><span class="line">                        <span class="comment">// Must not null out e.next;</span></span><br><span class="line">                        <span class="comment">// stale entries may be in use by a HashIterator</span></span><br><span class="line">                        e.value = <span class="literal">null</span>; <span class="comment">// Help GC</span></span><br><span class="line">                        size--;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;Object&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakReference</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Reference</span>&lt;T&gt;</span><br></pre></td></tr></table></figure>
<p><code>WeakHashMap</code>解决的问题：在映射中的一个值，它对应的键已经不在程序中的任何地方使用，即对于某个键的最后一个引用已经消失，那么不再有任何途径可以引用这个值的对象了。<strong>但是</strong>，由于程序中的没有这个<strong>键</strong>，就无法从映射中删除这个键/值对了。</p>
<p>而垃圾回收器会<strong>跟踪</strong>活动的对象。只要<strong>映射对象</strong>是活动的，则其中所有的桶都是活动的，所以它们不能被回收。</p>
<p><code>WeakHashMap</code>：当对<strong>键</strong>的唯一引用来自散列表映射条目时，这个数据结构将于垃圾回收器协同工作一起删除键/值对</p>
<h4 id="工作原理"><a class="header-anchor" href="#工作原理"> </a>工作原理</h4>
<p><code>WeakHashMap</code>使用**弱引用（weak references）**保存键。</p>
<p><code>WeakReference</code>对象将包含<strong>另一个对象的引用</strong>（这里时一个散列表的键）。</p>
<p>垃圾回收器采用一种特有的方式处理这种类型对象。</p>
<ul>
<li>正常情况下，如果垃圾回收器发现某个对象已经没有他人引用了，就将其回收。</li>
<li>如果一个对象只能由<code>WeakReference</code>引用，垃圾回收器也会将其回收，但会将引用这个对象的弱引用放入一个队列。
<ul>
<li><code>WeakHashMap</code>周期性的检查队列，以便找出新添加的弱引用。</li>
<li>一个弱引用进入队列意味着这个<strong>键</strong>不再被他人使用，并且已经回收，<code>WeakHashMap</code>将删除先关联的映射条目</li>
</ul>
</li>
</ul>
<h3 id="链接散列集与映射-LinkedHashSet-LinkedHashMap"><a class="header-anchor" href="#链接散列集与映射-LinkedHashSet-LinkedHashMap"> </a>链接散列集与映射 LinkedHashSet LinkedHashMap</h3>
<p><code>LinkedHashSet</code>和<code>LinkedHashSMap</code>类会记住插入<strong>元素项</strong>的顺序，避免散列表中的项看起来顺序是随机的。</p>
<p>在表中插入元素项时，就会并入到双向链表中</p>
<p>链接散列表映射可以使用访问呢顺序，而不是插入顺序来迭代处理映射条目。</p>
<ul>
<li>每次调用<code>get</code>或<code>put</code>时，收到影响的项将从当前的位置删除，并放到项链表的尾部。
<ul>
<li><strong>只影响</strong>项在<strong>链表</strong>中的<strong>位置</strong>，而<strong>散列表的桶不会受影响</strong>。映射条目总是在键散列码对应的桶中。</li>
</ul>
</li>
</ul>
<p>访问顺序对实现缓存的“最近最少使用”原则十分重要。</p>
<ul>
<li>将访问频率高的元素放入内存，而访问频率低的元素从数据库中读取</li>
<li>当表中找不到元素项而且表相当满时，可以得到迭代器并删除它，枚举的前几个元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可重写<code>removeEldestEntry</code>来实现自动删除eldest项</p>
<h3 id="枚举集与映射-EnumSet-EnumMap"><a class="header-anchor" href="#枚举集与映射-EnumSet-EnumMap"> </a>枚举集与映射 EnumSet EnumMap</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">EnumSet</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Cloneable</span>, java.io.Serializable</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumMap</span>&lt;K <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;K&gt;, V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K, V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Cloneable</span><br></pre></td></tr></table></figure>
<p><code>EnumSet</code>是一个枚举类型元素集的高效实现。</p>
<p>由于枚举类型只有有限个实例i，所以<code>EnumSet</code>内部用<strong>位序列</strong>实现。如果对应的值在集中，则相应的位置为1</p>
<p><code>EnumSet</code>类没有公共构造器，用<strong>静态工厂方法</strong>构造集</p>
<p>注意：Java8不允许在定义局部枚举类，即在方法内定义内</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">WeekDay</span> &#123;MONDAY ,TUESDAY, WEDENESDAY,  THURSDAY, FRIDAY,SATURDAY, SUNDAY&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EnumSet&lt;WeekDay&gt; always = EnumSet.allOf(WeekDay.class);</span><br><span class="line">EnumSet&lt;WeekDay&gt; mever = EnumSet.noneOf(WeekDay.class);</span><br><span class="line">EnumSet&lt;WeekDay&gt; workday = EnumSet.range(WeekDay.MONDAY,WeekDay.FRIDAY);</span><br><span class="line">EnumSet&lt;WeekDay&gt; mwf = EnumSet.of(WeekDay.MONDAY,WeekDay.WEDENESDAY,WeekDay.FRIDAY);</span><br><span class="line">System.out.println(always);<span class="comment">//[MONDAY, TUESDAY, WEDENESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY]</span></span><br><span class="line">System.out.println(mever);<span class="comment">//[]</span></span><br><span class="line">System.out.println(workday);<span class="comment">//[MONDAY, TUESDAY, WEDENESDAY, THURSDAY, FRIDAY]</span></span><br><span class="line">System.out.println(mwf);<span class="comment">//[MONDAY, WEDENESDAY, FRIDAY]</span></span><br></pre></td></tr></table></figure>
<p><code>EnumMap</code>是一个键类型位枚举类型的映射。需要在构造器中指定键类型。</p>
<blockquote>
<p>E extends Enum<E>意思是E是一个枚举类型</p>
</blockquote>
<h3 id="标识散列映射-IdentityHashMap"><a class="header-anchor" href="#标识散列映射-IdentityHashMap"> </a>标识散列映射 IdentityHashMap</h3>
<p>键的散列值不是用hashCode函数计算的，而是用<code>System.identityHashCode</code>计算。这是<code>Object.hashCode</code>根据对象的<strong>内存地址</strong>计算散列码时所使用的方法。</p>
<p>两对象比较的时候，<code>IdentityHashMap</code>类使用<code>==</code>，而不使用<code>equals</code></p>
<p><strong>不同键</strong>对象即使内容相同，也被视为不同对象。</p>
<p>在实现对象遍历算法（如对象串行化），可以用来跟踪哪些对象已经遍历过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdentityHashMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, java.io.Serializable, Cloneable&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object x, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> System.identityHashCode(x);</span><br><span class="line">        <span class="comment">// Multiply by -127, and left-shift to use least bit as part of hash</span></span><br><span class="line">        <span class="keyword">return</span> ((h &lt;&lt; <span class="number">1</span>) - (h &lt;&lt; <span class="number">8</span>)) &amp; (length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="视图与包装器"><a class="header-anchor" href="#视图与包装器"> </a>视图与包装器</h2>
<p>可以使用视图（view）来获得其他实现了<code>Collection</code>接口或<code>Map</code>接口的对象。</p>
<p><code>KeySet</code>方法返回一个实现了<code>Set</code>接口的类对象，由这个类方法操纵原映射。这种集合称为视图</p>
<h3 id="子范围"><a class="header-anchor" href="#子范围"> </a>子范围</h3>
<p>为集合建立子范围（subrange）视图</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//public interface List&lt;E&gt; extends Collection&lt;E&gt;</span></span><br><span class="line">List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//public interface SortedSet&lt;E&gt; extends Set&lt;E&gt;</span></span><br><span class="line">SortedSet&lt;E&gt; <span class="title function_">subSet</span><span class="params">(E fromElement, E toElement)</span>;</span><br><span class="line">SortedSet&lt;E&gt; <span class="title function_">headSet</span><span class="params">(E toElement)</span>;</span><br><span class="line">SortedSet&lt;E&gt; <span class="title function_">tailSet</span><span class="params">(E fromElement)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//public interface SortedMap&lt;K,V&gt; extends Map&lt;K,V&gt; 、</span></span><br><span class="line">SortedMap&lt;K,V&gt; <span class="title function_">subMap</span><span class="params">(K fromKey, K toKey)</span>;</span><br><span class="line">SortedMap&lt;K,V&gt; <span class="title function_">headMap</span><span class="params">(K toKey)</span>;</span><br><span class="line">SortedMap&lt;K,V&gt; <span class="title function_">tailMap</span><span class="params">(K fromKey)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//public interface NavigableSet&lt;E&gt; extends SortedSet&lt;E&gt; </span></span><br><span class="line">NavigableSet&lt;E&gt; <span class="title function_">subSet</span><span class="params">(E fromElement, <span class="type">boolean</span> fromInclusive,</span></span><br><span class="line"><span class="params">                           E toElement,   <span class="type">boolean</span> toInclusive)</span>;</span><br><span class="line">NavigableSet&lt;E&gt; <span class="title function_">headSet</span><span class="params">(E toElement, <span class="type">boolean</span> inclusive)</span>;</span><br><span class="line">NavigableSet&lt;E&gt; <span class="title function_">tailSet</span><span class="params">(E fromElement, <span class="type">boolean</span> inclusive)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="不可修改视图"><a class="header-anchor" href="#不可修改视图"> </a>不可修改视图</h3>
<p><code>Collections</code>类中，有方法可以生成集合的<strong>不可修改视图（unmodifiable view）</strong></p>
<p>这些视图对现有集合增加了一个运行时检查，如果发现试图对集合修改，就抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//public class Collections </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">unmodifiableCollection</span><span class="params">(Collection&lt;? extends T&gt; c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UnmodifiableCollection</span>&lt;&gt;(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="title function_">unmodifiableSet</span><span class="params">(Set&lt;? extends T&gt; s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UnmodifiableSet</span>&lt;&gt;(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; SortedSet&lt;T&gt; <span class="title function_">unmodifiableSortedSet</span><span class="params">(SortedSet&lt;T&gt; s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UnmodifiableSortedSet</span>&lt;&gt;(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; NavigableSet&lt;T&gt; <span class="title function_">unmodifiableNavigableSet</span><span class="params">(NavigableSet&lt;T&gt; s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UnmodifiableNavigableSet</span>&lt;&gt;(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">unmodifiableList</span><span class="params">(List&lt;? extends T&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (list <span class="keyword">instanceof</span> RandomAccess ?</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">UnmodifiableRandomAccessList</span>&lt;&gt;(list) :</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">UnmodifiableList</span>&lt;&gt;(list));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title function_">unmodifiableMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UnmodifiableMap</span>&lt;&gt;(m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; SortedMap&lt;K,V&gt; <span class="title function_">unmodifiableSortedMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UnmodifiableSortedMap</span>&lt;&gt;(m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; NavigableMap&lt;K,V&gt; <span class="title function_">unmodifiableNavigableMap</span><span class="params">(NavigableMap&lt;K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UnmodifiableNavigableMap</span>&lt;&gt;(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>视图只是<strong>包装</strong>了<strong>接口</strong>而不是具体的集合对象，所以<strong>只能访问接口中定义的方法</strong>。</p>
<p>例如<code>LinkedList</code>类的<code>addFirst</code>和<code>addList</code>由于不是<code>List</code>接口的方法，不能通过不可修改的视图访问这些方法</p>
<p>如果将集或列表转换成集合，就再也无法检测其内容是否相同（而是判断是否为同一个对象）。视图采用这种工作方式</p>
<p><code>unmodifiableSet</code>和<code>unmodifiableList</code>方法使用底层集合的<code>equals</code>方法和<code>hashCode</code>方法</p>
<h3 id="同步视图"><a class="header-anchor" href="#同步视图"> </a>同步视图</h3>
<p>通过视图机制来确保常规集合是线程安全的，而没有实现线程安全的集合类。</p>
<ul>
<li><code>Collections</code>类的静态<code>synchhronizedMap</code>方法可以将任何一个映射转换成有同步访问方法的Map</li>
</ul>
<h3 id="检查型视图"><a class="header-anchor" href="#检查型视图"> </a>检查型视图</h3>
<p>检查型视图对泛型类型可能出现的问题提供调试支持。</p>
<ul>
<li>将错误类型的元素混入泛型集合中</li>
</ul>
<p><code>List&lt;String&gt; safeStrings = Collections.checkedList(strings,String.class)</code></p>
<blockquote>
<p>检查型视图受限于虚拟机可以完成的运行时检查。对于ArrayList&lt;Pair<String>&gt;，无法阻止插入Pair<Date></p>
</blockquote>
<h2 id="算法"><a class="header-anchor" href="#算法"> </a>算法</h2>
<h3 id="泛型算法"><a class="header-anchor" href="#泛型算法"> </a>泛型算法</h3>
<p>通过接口（interface）</p>
<p>考虑高效地执行这个算法所需要的<strong>最小集合接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; T <span class="title function_">max</span><span class="params">(Collection&lt;T&gt; c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(c.isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    Iterator&lt;T&gt; iter = c.iterator();</span><br><span class="line">    <span class="type">T</span> <span class="variable">largest</span> <span class="operator">=</span> iter.next();</span><br><span class="line">    <span class="keyword">while</span>(iter.hasNext())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">next</span> <span class="operator">=</span> iter.next();</span><br><span class="line">        <span class="keyword">if</span>(largest.compareTo(next) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            largest = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> largest;z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序"><a class="header-anchor" href="#排序"> </a>排序</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(staff);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">staff.sort(Comparator.comparingDouble(Employee::getSalary));</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">staff.sort(Comparator.reverseOrder())</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">staff.sort(Comparator.comparingDouble(Employee::getSalary).reversed());</span><br></pre></td></tr></table></figure>
<p>Java是将所有元素转入一个<strong>数组</strong>，将<strong>数组进行排序</strong>，然后再将排序后的序列<strong>复制回列表</strong></p>
<p>Java使用归并排序，因为其稳定</p>
<p>要排序的列表，列表必须是<strong>可修改</strong>的，但不一定可以改变大小</p>
<ul>
<li>如果列表支持<code>set</code>方法，则是可修改的（modifiable）</li>
<li>如果列表支持<code>add</code>和<code>remove</code>方法，则是可改变大小的（resizable）</li>
</ul>
<h3 id="二分查找"><a class="header-anchor" href="#二分查找"> </a>二分查找</h3>
<p><code>Collections</code>类的<code>binarySearch</code>要求</p>
<ul>
<li>集合<strong>必须</strong>是有序的。</li>
<li>要查找某个元素，必须提供集合（集合要实现<code>List</code>接口）以及要查找的元素</li>
<li>如果集合没有采用<code>Comparable</code>接口，那么还要提供比较器对象</li>
<li>只有采用随机访问，二分查找才有意义。如果提供链表，则退化为线性查找</li>
</ul>
<h3 id="集合与数组的转换"><a class="header-anchor" href="#集合与数组的转换"> </a>集合与数组的转换</h3>
<p><code>toArray</code>方法得到的结果是对象（Object）数组</p>
<p><code>Object[] values = staff.toArray()</code>;</p>
<p>而强制类型转换是不允许的</p>
<p><code>String[] values = (String[]) staff.toArray(); // ERROR</code></p>
<p>可以使用<code>toArray</code>方法的变体，提供一个指定类型且长度为0的数组。返回的数组就会创建为相同的数组类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//public interface List&lt;E&gt; extends Collection&lt;E&gt;</span></span><br><span class="line">Object[] toArray();</span><br><span class="line">&lt;T&gt; T[] toArray(T[] a);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span></span><br><span class="line"><span class="comment">//        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span></span><br><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="comment">// Make a new array of a&#x27;s runtime type, but my contents:</span></span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; words = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">words.add(<span class="string">&quot;cool&quot;</span>);</span><br><span class="line">words.add(<span class="string">&quot;bad&quot;</span>);</span><br><span class="line">words.add(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">String[] values = words.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p><strong><u>注意</u></strong></p>
<p>以下是<strong>不允许</strong>的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">ans.add(<span class="number">1</span>);</span><br><span class="line">ans.add(<span class="number">2</span>);</span><br><span class="line">ans.add(<span class="number">3</span>);</span><br><span class="line"><span class="type">int</span>[] result = ans.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>]); <span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>
<p>报错原因</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Required type: T[]</span><br><span class="line">Provided: <span class="type">int</span>[]</span><br><span class="line">reason: no <span class="title function_">instance</span><span class="params">(s)</span> of type <span class="title function_">variable</span><span class="params">(s)</span> T exist so that <span class="type">int</span>[] conforms to T[]</span><br><span class="line">即基本类型不能转换成类型变量</span><br></pre></td></tr></table></figure>
<p>同时也可以构造一个大小正确的数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] values = words.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[words.size()]);</span><br></pre></td></tr></table></figure>
<h2 id="遗留的集合"><a class="header-anchor" href="#遗留的集合"> </a>遗留的集合</h2>
<h3 id="HashTable类"><a class="header-anchor" href="#HashTable类"> </a>HashTable类</h3>
<ul>
<li><code>HashTable</code>类和<code>HashMap</code>类的作用一样，接口也基本相同。</li>
<li><code>HashTable</code>类和<code>Vector</code>类的方法都是同步的</li>
</ul>
<p>应该使用<code>HashMap</code></p>
<p>如果需要并发访问，使用<code>ConcurrentHashMap</code></p>
<h3 id="枚举-Enumeration"><a class="header-anchor" href="#枚举-Enumeration"> </a>枚举 Enumeration</h3>
<p>遗留的结合使用Enumeration接口遍历元素序列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Enumeration</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasMoreElements</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    E <span class="title function_">nextElement</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似<code>Iterator</code>接口的<code>hasNext</code>方法和<code>next</code>方法</p>
<h3 id="属性映射-Properties"><a class="header-anchor" href="#属性映射-Properties"> </a>属性映射 Properties</h3>
<p>属性映射（property map）是一个特殊类型的映射结构</p>
<ul>
<li>键和值都是字符串</li>
<li>这个映射可以很容易保存到文件以及从人间加载</li>
<li>有一个<strong>二级表</strong>存放<strong>默认值</strong></li>
</ul>
<p>属性映射的类名为<code>Properties</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Properties</span> <span class="keyword">extends</span> <span class="title class_">Hashtable</span>&lt;Object,Object&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">settings</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">settings.setProperty(<span class="string">&quot;width&quot;</span>,<span class="string">&quot;600.0&quot;</span>);</span><br><span class="line">settings.setProperty(<span class="string">&quot;filename&quot;</span>,<span class="string">&quot;/home/qibin/cool.txt&quot;</span>);</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;program.properties&quot;</span>);</span><br><span class="line">settings.store(fileOutputStream,<span class="string">&quot;Program Properties&quot;</span>); <span class="comment">//第二个参数为文件中的注释</span></span><br></pre></td></tr></table></figure>
<p>program.properties文件内容</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">#Program Properties</span><br><span class="line">#Wed Dec 09 21:48:06 CST 2020</span><br><span class="line">filename=/home/qibin/cool.txt</span><br><span class="line">width=600.0</span><br></pre></td></tr></table></figure>
<p><code>System.getProperties()</code></p>
<p>如果要储存复杂的配置信息，应该使用<code>Preferences</code>类</p>
<h3 id="栈-Stack"><a class="header-anchor" href="#栈-Stack"> </a>栈 Stack</h3>
<p><code>Stack</code>类扩展了<code>Vector</code>类，但是可以使用非栈操作<code>insert</code>和<code>remove</code>方法在任何地方插入和删除值，而不只是在栈顶</p>
<h3 id="位集-BitSet"><a class="header-anchor" href="#位集-BitSet"> </a>位集 BitSet</h3>
<p><code>BitSet</code>类用于储存一个<strong>位序列</strong>（不是数学意义上的集，更恰当说法为<strong>位向量</strong>或<strong>位数组</strong>）</p>
<p>高效地储存位序列（如标志）就可以使用位集。使用位集要比使用<code>Boolean</code>对象的<code>ArrayList</code>高效多</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BitSet</span> <span class="variable">bucketOfBits</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitSet</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">//第i位处于”开“状态返回true,否则返回false</span></span><br><span class="line">System.out.println(bucketOfBits.get(i));<span class="comment">//false</span></span><br><span class="line"><span class="comment">//将第i位 置为”开“状态</span></span><br><span class="line">bucketOfBits.set(i);</span><br><span class="line">System.out.println(bucketOfBits.get(i));<span class="comment">//true</span></span><br><span class="line"><span class="comment">//将第i位 置为”关“状态</span></span><br><span class="line">bucketOfBits.clear(i);</span><br><span class="line">System.out.println(bucketOfBits.get(i));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//public class BitSet implements Cloneable, java.io.Serializable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回位集的逻辑长度，即1+位集最高位的索引</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (wordsInUse == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BITS_PER_WORD * (wordsInUse - <span class="number">1</span>) +</span><br><span class="line">            (BITS_PER_WORD - Long.numberOfLeadingZeros(words[wordsInUse - <span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//与另一个位集进行逻辑与</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">and</span><span class="params">(BitSet set)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">or</span><span class="params">(BitSet set)</span> &#123; <span class="comment">//逻辑或</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">xor</span><span class="params">(BitSet set)</span> &#123;<span class="comment">//异或</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">andNot</span><span class="params">(BitSet set)</span> &#123; <span class="comment">//对应另一个位集中设置为1的所有位，将这个位集中相应的位清楚为0</span></span><br><span class="line">    <span class="comment">// Perform logical (a &amp; !b) on words in common</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java核心技术</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术—泛型程序设计</title>
    <url>/2020/12/01/Java%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E2%80%94%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="Java核心技术-第八章-泛型程序设计"><a class="header-anchor" href="#Java核心技术-第八章-泛型程序设计"> </a>Java核心技术 第八章 泛型程序设计</h1>
<h2 id="泛型程序设计"><a class="header-anchor" href="#泛型程序设计"> </a>泛型程序设计</h2>
<p><strong>泛型设计(generic programming)</strong> : 编写的代码可以对多种不同类型的对象重用</p>
<p><strong>类型参数(type parameter)</strong> <code>ArrayList&lt;String&gt; files = new ArrayList&lt;&gt;();</code></p>
<!-- more -->
<p>在Java增加泛型类之前，泛型程序设计是用<strong>继承</strong>实现的，存在两个问题</p>
<ul>
<li>当获取一个值时，必须进行强制类型转换</li>
<li>没有错误检查，可以向数组列表中添加任何类的值</li>
</ul>
<p>在使用泛型类和类型参数后</p>
<ul>
<li>编译器可以通过类型参数来知道返回值的类型，因此不需要进行强制类型转换</li>
<li>在添加元素（<code>ArrayList</code>中的<code>add()</code>）时，编译器知道插入元素的类型，比<code>Object</code>类型安全。编译器可以检查，防止插入错误类型的对象</li>
</ul>
<p>通配符类型(wildcard type)</p>
<h2 id="泛型类"><a class="header-anchor" href="#泛型类"> </a>泛型类</h2>
<p><strong>泛型类(generic class)</strong> :有一个或多个类型变量的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">()</span> &#123;first = <span class="literal">null</span>; second = <span class="literal">null</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T second)</span>&#123;<span class="built_in">this</span>.first = first; <span class="built_in">this</span>.second = second;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span>&#123;<span class="keyword">return</span> first;&#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getSecond</span><span class="params">()</span>&#123;<span class="keyword">return</span> second;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(T newValue)</span>&#123;<span class="built_in">this</span>.first = newValue;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(T newValue)</span>&#123;<span class="built_in">this</span>.second = newValue;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>类型变量</strong> T ，用尖括号(&lt;&gt;)括起来，放在类名后面</p>
</li>
<li>
<p>泛型类可以有多个类型变量 <code>public class Pair&lt;T,U&gt; &#123;...&#125;</code></p>
</li>
<li>
<p>类型变量在整个类定义中，用于</p>
<ul>
<li>指定方法的返回类型</li>
<li>字段的类型</li>
<li>局部变量的类型</li>
</ul>
</li>
</ul>
<p>类型变量使用大写字母</p>
<ul>
<li>变量E表示集合的元素类型</li>
<li>K和V分别表示表的键和值的类型</li>
<li>T（和相邻的字母U和S）表示”任意类型“</li>
</ul>
<p>泛型类相当于普通类的工厂</p>
<ul>
<li>用具体的类型替换类型变量来**实例化(instantiate)**泛型类型</li>
</ul>
<h2 id="泛型方法"><a class="header-anchor" href="#泛型方法"> </a>泛型方法</h2>
<p><strong>泛型方法</strong>可以在<strong>普通类</strong>中定义也可以在<strong>泛型类</strong>中定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayAlg</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getMiddle</span><span class="params">(T... a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a[a.length/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**类型变量<T>**的位置</p>
<ul>
<li>放在修饰符（这里指<code>public static</code>）的后面</li>
<li>放在返回类型的前面（这里的返回类型是<code>T</code>）</li>
</ul>
<p>调用一个泛型方法</p>
<ul>
<li>可以把具体类型包为在尖括号中，放在方法名前面
<ul>
<li><code>String middle = ArrayAlg.&lt;String&gt;getMiddle(&quot;Jogn&quot;,&quot;CAt&quot;,&quot;Dog&quot;);</code></li>
</ul>
</li>
<li>大多数情况下，编译器有足够信息推断出想法，将参数的类型和泛型类型T进行匹配进行推断，可以省略<code>&lt;String&gt;</code>类型参数
<ul>
<li><code>String middle = ArrayAlg.getMiddle(&quot;Jogn&quot;,&quot;CAt&quot;,&quot;Dog&quot;);</code></li>
</ul>
</li>
</ul>
<h2 id="类型变量的限定"><a class="header-anchor" href="#类型变量的限定"> </a>类型变量的限定</h2>
<p>有时，类或方法需要对<strong>类型变量</strong>加以<strong>约束</strong>(例如保证方法中的某些方法能够正常调用)，可以通过对类型变量T设置一个**限定(bound)**来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; Pair&lt;T&gt; <span class="title function_">minmax</span><span class="params">(T[] a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="literal">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">T</span> <span class="variable">min</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">    <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(min.compareTo(a[i])&gt;<span class="number">0</span>) min = a[i];</span><br><span class="line">        <span class="keyword">if</span>(max.compareTo(a[i])&lt;<span class="number">0</span>) max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(min,max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用关键字<code>extends</code></p>
<p>记法 <code>&lt;T extends BoundingType&gt;</code></p>
<ul>
<li><code>T</code>表示限定类型（BoundingType）的子类型（subtype）</li>
<li>T和限定类型可以是<strong>类</strong>也可以是<strong>接口</strong></li>
<li>一个类型变量(<code>T</code>)或通配符可以有多个限定(Bound)
<ul>
<li><code>T extends Comparable &amp; Serializable</code></li>
<li>限定类型（BoundingType）用&quot;&amp;&quot;分隔</li>
<li>类型变量（T)用逗号分隔</li>
</ul>
</li>
<li>在限定类型中可以拥有多个接口作为超类型，但最多有一个限定可以是类。
<ul>
<li>如果一个类作为限定，它必须是限定列表中的第一个限定</li>
</ul>
</li>
</ul>
<h2 id="泛型代码与虚拟机"><a class="header-anchor" href="#泛型代码与虚拟机"> </a>泛型代码与虚拟机</h2>
<ul>
<li>虚拟机没有泛型类型对象，所有对象都属于普通类</li>
</ul>
<h3 id="类型擦除"><a class="header-anchor" href="#类型擦除"> </a>类型擦除</h3>
<ul>
<li>无论何时定义一个<strong>泛型类型</strong>，都会自动提供一个相应的<strong>原始类型（raw type）</strong>。
<ul>
<li>原始类型的名字就是去掉<strong>类型参数</strong>后<strong>泛型类型名</strong></li>
</ul>
</li>
<li><strong>类型变量</strong>会被<strong>擦除（erased）</strong>，并<strong>替换</strong>为其<strong>限定类型（对于无限定的变量替换成<code>Object</code>）</strong></li>
</ul>
<p><code>Pair&lt;T&gt;</code>的<strong>原始类型（raw type）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Object first;</span><br><span class="line">    <span class="keyword">private</span> Object second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">()</span> &#123;first = <span class="literal">null</span>; second = <span class="literal">null</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(Object first, Object second)</span>&#123;<span class="built_in">this</span>.first = first; <span class="built_in">this</span>.second = second;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getFirst</span><span class="params">()</span>&#123;<span class="keyword">return</span> first;&#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getSecond</span><span class="params">()</span>&#123;<span class="keyword">return</span> second;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(Object newValue)</span>&#123;<span class="built_in">this</span>.first = newValue;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(Object newValue)</span>&#123;<span class="built_in">this</span>.second = newValue;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，<code>T</code>是无限定的变量，所以直接用Object替换</p>
<blockquote>
<p>C++会为每个模板的实例化产生不同的类型，这一现象叫做“模板代码膨胀”。Java不存在这个问题</p>
</blockquote>
<p>原始类型用第一个<strong>限定</strong>来替换<strong>类型变量</strong>。如果没有给定限定，则替换为<code>Object</code></p>
<p>举例</p>
<p>声明一个类型:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interval</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span> &amp; Serializable&gt; <span class="keyword">implements</span> <span class="title class_">Serializable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T lower;</span><br><span class="line">    <span class="keyword">private</span> T upper;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Interval</span><span class="params">(T first, T second)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(first.compareTo(second) &lt;= <span class="number">0</span>) &#123; lower = first; upper = second;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; lower = second; upper = first;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>原始类型（raw type）<code>Interval</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interval</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Comparable lower;</span><br><span class="line">    <span class="keyword">private</span> Comparable upper;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Interval</span><span class="params">(Comparable first, Comparable second)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(first.compareTo(second) &lt;= <span class="number">0</span>) &#123; lower = first; upper = second;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; lower = second; upper = first;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>注：如果声明的类型变量的限定顺序是这样的<code>&lt;T extends Comparable &amp; Serializable&gt;</code>。则原始类型会用<code>Serializable</code>替换<code>T</code>。编译器在必要时向<code>Comparable</code>插入强制类型转换。</p>
<p>为提高效率，应该将<strong>标签（tagging）接口（即没有方法的接口）<strong>放在</strong>限定列表的末尾</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="转换泛型表达式"><a class="header-anchor" href="#转换泛型表达式"> </a>转换泛型表达式</h3>
<p>编写一个<strong>泛型方法</strong>调用时，如果<strong>擦除</strong>了<strong>返回类型</strong>，编译器会插入<strong>强制类型转换</strong>。例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Employee&gt; buddies = ...;</span><br><span class="line"><span class="type">Employee</span> <span class="variable">buddy</span> <span class="operator">=</span> buddies.getFirst();</span><br></pre></td></tr></table></figure>
<p><code>getFirst()</code>在擦除类型后，返回类型是<code>Object</code>，编译器自动<strong>插入</strong>转换到<code>Employee</code>的<strong>强制类型转换</strong></p>
<p>编译器将这个方法调用转换成两条虚拟机指令</p>
<ol>
<li>对<strong>原始方法</strong><code>Pair.getFirst()</code>的调用（这里已经被转换成原始类型）</li>
<li>将返回的<code>Object</code>类型强制转换为 <code>Employee</code>类型</li>
</ol>
<p>访问<strong>泛型字段</strong>时，也要插入强制类型转换。假设<code>Pair</code>类中的<code>first</code>字段是<code>public</code>的</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Employee</span> <span class="variable">buddy</span> <span class="operator">=</span> buddies.first;</span><br></pre></td></tr></table></figure>
<p>也会在结果字节码中插入强制类型转换</p>
<h3 id="转换泛型方法"><a class="header-anchor" href="#转换泛型方法"> </a>转换泛型方法</h3>
<p>泛型方法<code>public static &lt;T extends Comparable&gt; T min(T[] a)</code></p>
<p>擦除类型后</p>
<p><code>public static Comparable min(Comparable[] a)</code></p>
<p>方法擦除的两个问题：</p>
<ul>
<li>类型擦除与多态发生冲突</li>
</ul>
<p>例如继承泛型类的子类中，重写父类的方法。再类型擦除后，会有一个从父类继承来的方法，一个自己重写的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DateInterval</span> <span class="keyword">extends</span> <span class="title class_">Pair</span>&lt;LocalDate&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(LocalDate second)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DateInterval</span> <span class="variable">interval</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DateInterval</span>(...);</span><br><span class="line">Pair&lt;LocalDate&gt; pair = interval;</span><br><span class="line">pair.setSecond(aDate);</span><br></pre></td></tr></table></figure>
<p>在类型擦除后，有两个同名方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(LocalDate second)</span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(Object second)</span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>第二个是从父类继承来的。</p>
<p>解决办法是在子类中（这里指<code>DateInterval</code>类）生成<strong>桥方法（bridge method）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(Object second)</span>&#123;setSeond((LocalDate) second);&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>类型擦除后，子类会有两个方法名和参数类型相同，但是返回类型不相同的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate <span class="title function_">getSecond</span><span class="params">()</span></span><br><span class="line">Object <span class="title function_">getSecond</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>在虚拟机中，会有<strong>参数类型</strong>和<strong>返回类型</strong>共同制定一个方法，因此编译器可以为两个仅返回类型不同的方法生成字节码，虚拟机能够正确处理这种情况</p>
<blockquote>
<p>桥方法也用在有协变的返回类型（convariant return type）：一个方法覆盖另一个方法时，可以指定一个更严格的返回类型。</p>
</blockquote>
<ul>
<li>虚拟机没有泛型，只有普通的类和方法</li>
<li>所有的类型参数都会替换为它们的限定类型</li>
<li>会合成桥方法来保持多态</li>
<li>为保持类型安全性，必要时会插入强制类型转换</li>
</ul>
<p>使用注解（annotation）来消除警告</p>
<ul>
<li>给局部变量加注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SupperssWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">Dictionary&lt;Integer, Components&gt; labelTable = slider.getLabelTable();</span><br></pre></td></tr></table></figure>
<ul>
<li>给整个方法加注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarning(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureSlider</span><span class="params">()</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型的限制与局限性"><a class="header-anchor" href="#泛型的限制与局限性"> </a>泛型的限制与局限性</h2>
<ul>
<li>
<p><strong>不能</strong>用<strong>基本类型</strong>实例化<strong>类型参数</strong></p>
<ul>
<li>没有<code>Pair&lt;double&gt;</code>，只有<code>Pair&lt;Double&gt;</code></li>
<li>类型擦除后，<code>Object</code>类型的字段不能储存<code>double</code>值</li>
</ul>
</li>
<li>
<p>运行时<strong>类型查询</strong>只适用于<strong>原始类型</strong></p>
<ul>
<li>
<p>虚拟机对象总有一个特定的非泛型类型，所有的类型查询只产生原始类型</p>
</li>
<li>
<p>试图查询一个对象是否属于某个泛型类型(<code>instanceof</code>)，会得到编译器错误</p>
</li>
<li>
<p>试图强制类型转换成泛型类型时，会得到的警告</p>
</li>
<li>
<pre><code class="language-java">if(a instanceof Pair&lt;String&gt;) // ERROR

if(a instanceof Pair&lt;T&gt;) //ERROR
    
Pair&lt;String&gt; p = (Pair&lt;String&gt;) a; // warning

Pair&lt;String&gt; stringPair = ...;
Pair&lt;Employee&gt; employeePair = ...;
if(stringPair.getClass() == employeePair.getClasss()) // equal 因为返回的都是原始类型
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">- 不能创建参数化类型的数组</span><br><span class="line"></span><br><span class="line">  - `Pair&lt;String&gt;[] table = new Pair&lt;String&gt;[10]; //ERROR 不允许这样` </span><br><span class="line">  - 因为**擦除**之后，编译器不能保证存入数组的值都为`String`</span><br><span class="line">  - `Pair&lt;String&gt;[] table = (Pair&lt;String&gt;[]) new Pair&lt;?&gt;[10];`</span><br><span class="line">    - 可以这样写，但是不安全</span><br><span class="line"></span><br><span class="line">- Varargs警告对于泛型类型数组</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public static &lt;T&gt; void addAll(Collection&lt;T&gt; coll, T... ts)</span><br><span class="line">    &#123;</span><br><span class="line">        for (T t : ts) coll.add(t);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;Pair&lt;String&gt;&gt; table = ...;</span><br><span class="line">Pair&lt;String&gt; pair1 = ...;</span><br><span class="line">Pair&lt;String&gt; pair2 = ...;</span><br><span class="line">addAll(table, pair1, pair2);</span><br></pre></td></tr></table></figure>

- 在向参数个数可变的方法传递一个泛型类型的实例时，Java虚拟机必须建立一个泛型数组。相对于上一条&quot;不能创建参数化类型的数组&quot;而言，这种情况会有所放松，会得到一个警告而不是错误
- 抑制警告的方法有
  - 方法增加注解`SuppressWarnings(&quot;unchecked&quot;)`
  - 或方法增加注解`SafeVaragrs`
    - `SafeVarargs`注解只能用于声明为`static`、`final`的方法（其他方法可能被覆盖，使得注解没有意义）

</code></pre>
</li>
</ul>
</li>
<li>
<p>不能实例化类型变量</p>
<ul>
<li>
<p>不能在类似 <code>new T()</code>的表达式中使用类型变量</p>
<ul>
<li><code>public Pair() &#123;first = new T(); second = new T();&#125; // ERROR</code></li>
</ul>
</li>
<li>
<p>解决办法1：提供一个构造器表达式</p>
<ul>
<li>
<pre><code class="language-java">Pair&lt;String&gt; p = Pair.makePair(String::new);
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static &lt;T&gt; Pair&lt;T&gt; makePair(Supplies&lt;T&gt; constr)</span><br><span class="line">&#123;</span><br><span class="line">    return new Pair&lt;&gt;(constr.get(),constr.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<p>解决办法2：反射</p>
<ul>
<li>
<pre><code class="language-java">public static &lt;T&gt; Pair&lt;T&gt; makePair(Class&lt;T&gt; cl)
&#123;
    try&#123;
    	return new Pair&lt;&gt;(cl.getConstructor().newInstance(),cl.getConstructor().newInstance());
    &#125;
    catch(Exception e) &#123;return null;&#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">Pair&lt;String&gt; p = Pair.makePair(String.class);</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>不能构造泛型数组</p>
<ul>
<li>
<pre><code class="language-java">String[] names = ArrayAlg.minmax(String[]:: new,&quot;Tom&quot;,&quot;Dick&quot;,&quot;Harry&quot;);
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static &lt;T extends Comparable&gt; T[] minmax(InFunction&lt;T[]&gt; constr, T...a)</span><br><span class="line">&#123;</span><br><span class="line">    T[] result = constr.apply(2);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li>
<pre><code class="language-java">public static &lt;T extends Comparable&gt; T[] minmax(T... a)
&#123;
    T[] result = (T[]) Array.newInstance(a.getClass().getComponentType(),2);
    ...
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 泛型类的静态上下文中类型变量无效</span><br><span class="line"></span><br><span class="line">  - 我对这句话的理解是：1.不能声明类型变量是静态的（static）。2.不能在静态方法中使用类型变量</span><br><span class="line"></span><br><span class="line">  - 错误示例</span><br><span class="line"></span><br><span class="line">    ```JAVA</span><br><span class="line">    public class Singleton&lt;T&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        private static T singleInstance; // ERROR</span><br><span class="line">        public static T getSingleInstance() // ERROR</span><br><span class="line">        &#123;</span><br><span class="line">            if (singleInstance == null) construct new instance of T</span><br><span class="line">            return singleInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<p>不能抛出或捕获泛型类的实例</p>
<ul>
<li>
<p>泛型类扩展<code>Throwable</code>是不合法的</p>
<ul>
<li>
<p>不能定义一个泛型类，该类继承<code>Throwable</code>’</p>
</li>
<li>
<pre><code class="language-java">public class Problem&lt;T&gt; extends Exception&#123;...&#125; //ERROR
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- catch子句中不能使用类型变量</span><br><span class="line"></span><br><span class="line">  - 错误示例</span><br><span class="line"></span><br><span class="line">  - ```Java</span><br><span class="line">    public static &lt;T extends Throwable&gt; void doWork(Class&lt;T&gt; t)</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            do work;</span><br><span class="line">        &#125;</span><br><span class="line">        catch(T e)  // ERROR 不能去捕获类型变量</span><br><span class="line">        &#123;</span><br><span class="line">            Logger.global.info(...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<p>在异常规范中使用类型变量是允许的</p>
<ul>
<li>
<p>我理解是在 try-catch语句中，可以出现类型变量。但是不能在catch后面的小括号声明异常类型是<code>T</code>(类型变量)，也不能throw出一个是类型变量的异常的实例</p>
</li>
<li>
<p>合法示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">(Class&lt;T&gt; t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> work;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Throwable realCause)  </span><br><span class="line">    &#123;</span><br><span class="line">        t.initCause(realCause);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>可以取消对检查型异常的检查</p>
<ul>
<li>
<p>Java异常处理的基本原则：必须为所有<strong>检查型异常</strong>提供一个<strong>处理器（try-catch）</strong></p>
</li>
<li>
<p>通过泛型可以取消这种机制</p>
</li>
<li>
<p>实现一个<code>Task</code>到<code>Runnable</code>的适配器，不过<code>Runnable</code>接口的类的<code>run</code>方法不允许抛出检查型异常，而我们要实现<code>Task</code>中的<code>run</code>可以抛出任何异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Task</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SupressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; <span class="keyword">void</span> <span class="title function_">throwAs</span><span class="params">(Throwable t)</span> <span class="keyword">throws</span> T</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span>(T) t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> Runnable <span class="title function_">asRunnable</span><span class="params">(Task task)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                task.run();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                Task.&lt;RuntimeException&gt;throwAs(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> vodi <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(Task.asRunnable()-&gt;</span><br><span class="line">                                   &#123;</span><br><span class="line">                                       Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                                       System.out.println(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">                                       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;Check this out&quot;</span>);</span><br><span class="line">                                   &#125;));</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>注意擦除后的冲突</p>
<ul>
<li>
<p>擦除后，方法的参数类型变成<code>Object</code>，可能会和产生相同签名的方法</p>
<ul>
<li>解决办法是修改方法名</li>
</ul>
</li>
<li>
<p>泛型规范说明原则之一</p>
<ul>
<li>
<p>为了支持擦除转换，施加一个限制：倘若两个接口类型是同一接口的不同参数化，一个类或类型变量就不能同时作为这两个接口类型的子类</p>
</li>
<li>
<p>非法示例</p>
<ul>
<li><code>class Employee implements Comparable&lt;Employee&gt; &#123;...&#125;</code></li>
<li><code>class Manager extends Employee implements Comparable&lt;Manager&gt;&#123;...&#125; // ERROR </code>
<ul>
<li>因为<code>Comparable&lt;Employee&gt;</code>和<code>Comparable&lt;Manager&gt;</code>是同一接口的不同参数化</li>
</ul>
</li>
</ul>
</li>
<li>
<p>非泛型版本的合法示例</p>
<ul>
<li><code>class Employee implements Comparable &#123;...&#125;</code></li>
<li><code>class Manager extends Employee implements Comparable&#123;...&#125; </code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="泛型类型的继承规则"><a class="header-anchor" href="#泛型类型的继承规则"> </a>泛型类型的继承规则</h2>
<p><code>Employee</code>和<code>Manager</code>的关系是父类和子类，<strong>但是</strong><code>Pair&lt;Manager&gt;</code>不是<code>Pair&lt;Employee&gt;</code>的子类。</p>
<p>通常<code>Pair&lt;Employee&gt;</code>和<code>Pair&lt;Manager&gt;</code>没有任何关系</p>
<p>泛型类型不能够转换但是<strong>Java数组</strong>可以转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Manager[] managerBuddies = &#123;ceo, cfo&#125;;</span><br><span class="line">Employee[] employeeBuddies = managerBuddies; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<p><strong>泛型类</strong>可以<strong>扩展</strong>或<strong>实现</strong>其他的<strong>泛型类</strong></p>
<ul>
<li><code>ArrayList&lt;T&gt;</code>类实现了<code>List&lt;T&gt;</code>接口</li>
<li><code>ArrayList&lt;Manager&gt;</code>可以转换成一个<code>List&lt;Manager&gt;</code></li>
</ul>
<h2 id="通配符类型"><a class="header-anchor" href="#通配符类型"> </a>通配符类型</h2>
<p>在上面“<strong>泛型类型的继承规则</strong>”中，说到“<code>Pair&lt;Employee&gt;</code>和<code>Pair&lt;Manager&gt;</code>没有任何关系”</p>
<p>因此对于下面代码段，不能将<code>Pair&lt;Manager&gt;</code>传递给这个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printBuddies</span><span class="params">(Pair&lt;Employee&gt; p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">second</span> <span class="operator">=</span> p.getSecond();</span><br><span class="line">    System.out.println(first.getName() + <span class="string">&quot; and &quot;</span> + second.getName() + <span class="string">&quot; are buddies.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而通过<strong>通配符</strong>能够解决Java这种严格的泛型类型系统</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printBuddies</span><span class="params">(Pair&lt;? extends Employee&gt; p)</span></span><br></pre></td></tr></table></figure>
<p>类型<code>Pair&lt;Manager&gt;</code>是<code>Pair&lt;? extends Employee&gt;</code>的子类型</p>
<h3 id="通配符的超类型限定"><a class="header-anchor" href="#通配符的超类型限定"> </a>通配符的超类型限定</h3>
<p><strong>通配符限定</strong>与<strong>类型变量限定</strong>类似，但不一样</p>
<p>通配符限定可以指定一个<strong>超类型限定（supertype bound）</strong></p>
<ul>
<li><code>? super Managers</code></li>
<li>这个通配符限制为<code>Manager</code>的<strong>所有超类型</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">minmaxBonus</span><span class="params">(Manager[] a,Pair&lt;? <span class="built_in">super</span> Manager&gt; result)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">Manager</span> <span class="variable">min</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">    <span class="type">Manager</span> <span class="variable">max</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(min.getBonus() &gt; a[i].getBonus()) min = a[i];</span><br><span class="line">        <span class="keyword">if</span>(max.getBonus() &lt; a[i].getBonus()) max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    result.setFirst(min);</span><br><span class="line">    result.setSecond(max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这个代码示例，可以传入<code>Pair&lt;Employee&gt;</code>也可以传入<code>Pair&lt;Object&gt;</code></p>
<ul>
<li>带有<strong>超类型限定</strong>的通配符允许<strong>写入</strong>一个泛型对象</li>
<li>带有<strong>子类型限定</strong>的通配符允许你<strong>读取</strong>一个泛型对象</li>
</ul>
<p>对于上面这两句话的理解可以看下面的代码。</p>
<p>超类型限定允许写入的意思是，由于超类变量可以引用其子类对象。因此我们可以声明我们要储存的位置为我们要真实要存放元素的超类。即<code>generateCouple</code>方法中体现的。想想如果我们改成<code>Couple&lt;? extends Human&gt; c</code>会发生什么情况。我们不能保证我们存进去<code>c</code>的元素就是<code>Human</code>类型，如果是<code>Human</code>的子类就会出错。</p>
<blockquote>
<p><code>Human</code>子类会出错的原因在于，我们不能保证是存进去的<code>Human</code>子类就是我们想要的类型。即<code>Human</code>可能有多个子类，例如<code>Man</code>和<code>Woman</code>，假如实际上我们声明的<code>Couple</code>中<code>T</code>的为<code>Man</code>，但是运行时候被传入一个<code>Woman</code>，就会出错。</p>
</blockquote>
<p>同样的，对于子类型限定允许读取的意思是，在<code>printLove</code>方法中，我们能够保证我们要读取的元素<code>c</code>肯定有<code>c.getHusband().getName()</code>和<code>c.getWife().getName()</code>两种方法。因为子类会继承父类的所有可以继承的方法和实例。而如果改成超类型限定就不能够保证。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> TongpeifuTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tongpeifu</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printLove</span><span class="params">(Couple&lt;? extends Animal&gt; c)</span>&#123;</span><br><span class="line">        System.out.println(c.getHusband().getName() + <span class="string">&quot;  &quot;</span> + c.getWife().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">generateCouple</span><span class="params">(Human[] human, Couple&lt;? <span class="built_in">super</span> Human&gt; c)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(human.length != <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        c.setHusband(human[<span class="number">0</span>]);</span><br><span class="line">        c.setWife(human[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> life;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(<span class="type">int</span> age, <span class="type">int</span> life, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.life = life;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLife</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> life;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLife</span><span class="params">(<span class="type">int</span> life)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.life = life;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span> <span class="keyword">extends</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String girlFriend;</span><br><span class="line">    <span class="keyword">private</span> String boyFriend;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Human</span><span class="params">(<span class="type">int</span> age, <span class="type">int</span> life, String name, String girlFriend, String boyFriend)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(age, life, name);</span><br><span class="line">        <span class="built_in">this</span>.girlFriend = girlFriend;</span><br><span class="line">        <span class="built_in">this</span>.boyFriend = boyFriend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGirlFriend</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> girlFriend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGirlFriend</span><span class="params">(String girlFriend)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.girlFriend = girlFriend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBoyFriend</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> boyFriend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBoyFriend</span><span class="params">(String boyFriend)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.boyFriend = boyFriend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Woman</span> <span class="keyword">extends</span> <span class="title class_">Human</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Human</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Couple</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T husband;</span><br><span class="line">    <span class="keyword">private</span> T wife;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Couple</span><span class="params">(T husband, T wife)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.husband = husband;</span><br><span class="line">        <span class="built_in">this</span>.wife = wife;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getHusband</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> husband;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHusband</span><span class="params">(T husband)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.husband = husband;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getWife</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> wife;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWife</span><span class="params">(T wife)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.wife = wife;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> T&gt;&gt; T <span class="title function_">min</span><span class="params">(T[] a)</span></span><br></pre></td></tr></table></figure>
<p><strong>子类型限定</strong>另一个常见用法是作为一个函数式接口的参数类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeIf</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> E&gt; filter)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; staff = ...;</span><br><span class="line">Predicate&lt;Object&gt; oddHashcode = obj -&gt; obj.hashCode() % <span class="number">2</span> != <span class="number">0</span>;</span><br><span class="line">staff.removeIf(oddHashcode);</span><br></pre></td></tr></table></figure>
<h3 id="无限定通配符"><a class="header-anchor" href="#无限定通配符"> </a>无限定通配符</h3>
<p>无限定的通配符</p>
<p><code>Pair&lt;?&gt;</code></p>
<p><code>Pair&lt;?&gt;</code>和<code>Pair</code>本质的不同在于：可以用任意<code>Object</code>对象调用原始<code>Pair</code>类的<code>setFirst</code>方法</p>
<p>不需要实际类型的时候</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasNulls</span><span class="params">(Pair&lt;?&gt; p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> p.getFirst() == <span class="literal">null</span> || p.getSecond() == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通配符捕获"><a class="header-anchor" href="#通配符捕获"> </a>通配符捕获</h3>
<p>通配符<strong>不是类型变量</strong>，不能在编码中使用&quot;?&quot;作为一种类型</p>
<p>错误示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">? t = p.getFirst(); <span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>
<p>情景：在交换的时候必须临时保存一个元素</p>
<p>解决方案</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">swapHelper</span><span class="params">(Pair&lt;T&gt; p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line">    p.setFirst(p.getSecond());</span><br><span class="line">    p.setSecond(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Pair&lt;?&gt; p)</span> &#123; swapHelper(p);&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>swapHelper</code>是一个泛型方法，<code>swap</code>不是</p>
</blockquote>
<p><code>swapHelper</code>方法的参数<code>T</code>捕获通配符</p>
<p>编译器必须能够保证通配符表示单个确定的类型。例如<code>ArrayList&lt;Pair&lt;T&gt;&gt;</code>中的<code>T</code>永远不能捕获<code>ArrayList&lt;Pair&lt;?&gt;&gt;</code>中的通配符。<code>ArrayList</code>可以保存两个<code>Pair&lt;?&gt;</code>，其中<code>?</code>分别有不同的类型。</p>
<h2 id="反射和泛型"><a class="header-anchor" href="#反射和泛型"> </a>反射和泛型</h2>
<p>反射可以获得泛型类的哪些信息呢？</p>
<h3 id="泛型Class类型"><a class="header-anchor" href="#泛型Class类型"> </a>泛型Class类型</h3>
<p><code>T newInstance()</code>  返回无参数构造器构造的一个新实例</p>
<p><code>T cast(Object obj)</code> 如果obj为null或有可能转换成类型T，则返回obj；否则抛出一个<code>BadCastException</code>异常</p>
<p><code>T[] getEnumConstants()</code> 如果T是枚举类型，则返回所有值组成的数组，否则返回<code>null</code></p>
<p><code>Class&lt;? super T&gt; getSuperclass</code> 返回这个类的超类。如果T不是一个类或<code>Object</code>类，则返回null</p>
<p><code>Constructor&lt;T&gt; getConstructor(Class... paraameterTypes)</code></p>
<p><code>Constructor&lt;T&gt; getDeclaredConstructor(Class... parameterTypes)</code> 获得公共构造器，或者有给定参数类型的构造器</p>
<p><code>T newInstance(Object... parameters)</code> 返回用指定参数构造的新实例</p>
<h3 id="使用Class-T-参数进行类型匹配"><a class="header-anchor" href="#使用Class-T-参数进行类型匹配"> </a>使用<code>Class&lt;T&gt;</code>参数进行类型匹配</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Pair&lt;T&gt; <span class="title function_">makePair</span><span class="params">(Class&lt;T&gt; c)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(c.newInstance(),c.newInstance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">makePair(Employee.class);</span><br></pre></td></tr></table></figure>
<p>这里<code>Employee</code>会和<code>T</code>匹配</p>
<h3 id="虚拟机中的泛型类型信息"><a class="header-anchor" href="#虚拟机中的泛型类型信息"> </a>虚拟机中的泛型类型信息</h3>
<p>反射API确定</p>
<ul>
<li>这个泛型方法有一个名为<code>T</code>的类型参数</li>
<li>这个类型参数有一个子类型限定，其自身又是一个泛型类型</li>
<li>这个限定类型有一个通配符参数</li>
<li>这个通配符参数有一个超类型限定</li>
<li>这个泛型方法有一个泛型数组参数</li>
</ul>
<h3 id="类型字面量"><a class="header-anchor" href="#类型字面量"> </a>类型字面量</h3>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java核心技术</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven学习笔记</title>
    <url>/2021/01/19/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>这是一篇在maven学习过程中的笔记</p>
<p><strong>学习资料参考</strong></p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1dp4y1Q7Hf?p=3">2020最新Maven教程-Maven基础篇之Maven实战入门</a></li>
<li><a href="https://www.runoob.com/maven/maven-pom.html">菜鸟教程-maven</a></li>
<li><a href="http://maven.apache.org/">maven官网</a></li>
</ul>
<!-- more -->
<h2 id="maven作用"><a class="header-anchor" href="#maven作用"> </a>maven作用</h2>
<h3 id="开发和管理"><a class="header-anchor" href="#开发和管理"> </a>开发和管理</h3>
<ul>
<li>管理jar文件</li>
<li>自动下载jar文件及其相关文档、源代码</li>
<li>管理jar直接的依赖
<ul>
<li>即该jar中所会用到的其他jar</li>
</ul>
</li>
<li>编译程序：将java编译成class</li>
<li>测试代码</li>
<li>打包文件：打包成jar或war</li>
<li>部署项目</li>
</ul>
<h3 id="项目的构建"><a class="header-anchor" href="#项目的构建"> </a>项目的构建</h3>
<blockquote>
<p>构建是面向过程的，即完成项目代码的编译、测试、运行、打包、部署等步骤</p>
</blockquote>
<h4 id="maven支持的构建包括"><a class="header-anchor" href="#maven支持的构建包括"> </a>maven支持的构建包括</h4>
<ol>
<li>清理
<ul>
<li>将之前项目编译的东西删掉，为新编译的代码做准备</li>
</ul>
</li>
<li>编译
<ul>
<li>把程序源代码编译成执行代码：java -&gt; class文件</li>
<li>批量：maven可同时编译多个文件，而javac一次编译一个文件</li>
</ul>
</li>
<li>测试
<ul>
<li>maven可执行测试程序代码</li>
<li>批量：maven可同时执行多个测试代码，同时测试多个功能</li>
</ul>
</li>
<li>报告
<ul>
<li>生成测试结果的文件</li>
</ul>
</li>
<li>打包
<ul>
<li>将项目中所有的class文件，配置文件等所有资源放在一个压缩文件中</li>
<li>java程序生成jar扩展名</li>
<li>web应用生成war扩展名</li>
</ul>
</li>
<li>安装
<ul>
<li>把打包生成的文件（jar、war）安装到本机仓库</li>
</ul>
</li>
<li>部署
<ul>
<li>把程序安装好可以执行</li>
<li>一般不用maven进行部署，会更麻烦</li>
</ul>
</li>
</ol>
<h2 id="maven核心概念"><a class="header-anchor" href="#maven核心概念"> </a>maven核心概念</h2>
<ul>
<li>POM(Project Object Model)项目对象模型
<ul>
<li>文件名为pom.xml</li>
<li>包含项目的基本信息，用于描述项目如何构建，声明项目依赖（如jar）等</li>
</ul>
</li>
<li>约定的目录结构
<ul>
<li>maven项目的目录和文件的位置都是规定的</li>
</ul>
</li>
<li>坐标
<ul>
<li>唯一的字符串，用来表示资源</li>
</ul>
</li>
<li>依赖管理
<ul>
<li>管理项目可以使用的jar文件</li>
</ul>
</li>
<li>仓库管理
<ul>
<li>资源存放的位置</li>
</ul>
</li>
<li>生命周期
<ul>
<li>maven工具构建项目的过程</li>
</ul>
</li>
<li>插件和目标
<ul>
<li>执行maven构建的时候用的工具</li>
</ul>
</li>
<li>继承</li>
<li>聚合</li>
</ul>
<h2 id="maven环境配置"><a class="header-anchor" href="#maven环境配置"> </a>maven环境配置</h2>
<h3 id="官网下载"><a class="header-anchor" href="#官网下载"> </a>官网下载</h3>
<p><a href="http://maven.apache.org/">maven官网</a></p>
<p>在download页面中点击archives可选择下载历史版本</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210115215031149.png" alt="image-20210115215031149"></p>
<p>这里我根据视频的版本下载<code>3.3.9</code></p>
<h3 id="解压"><a class="header-anchor" href="#解压"> </a>解压</h3>
<p>解压压缩包并放在一个不包含中文的路径下。</p>
<p>例如我放在<code>D:\Program Files\Environment</code>下</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210116150933064.png" alt="image-20210116150933064"></p>
<h3 id="环境配置"><a class="header-anchor" href="#环境配置"> </a>环境配置</h3>
<p>大前提是配置好java环境，以及<code>JAVA_HOME</code>等</p>
<h4 id="第一步"><a class="header-anchor" href="#第一步"> </a>第一步</h4>
<p>在系统变量中添加</p>
<p>变量名：<code>M2_HOME</code></p>
<p>变量值：<code>D:\Program Files\Environment\apache-maven-3.3.9</code></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210116151519988.png" alt="image-20210116151519988"></p>
<blockquote>
<p>对于MAVEN_HOME和M2_HOME的区别，网上这样解释的：</p>
<p><code>MAVEN_HOME</code>适用于<code>Maven 1</code>，<code>M2_HOME</code>适用于<code>Maven 2</code>及更高版本</p>
<p>同时也说</p>
<p>从Maven 3.5.0开始M2_HOME的用法被移除且不再被支持</p>
</blockquote>
<h4 id="第二步"><a class="header-anchor" href="#第二步"> </a>第二步</h4>
<p>将maven的<code>bin</code>目录添加到<code>path</code>中</p>
<p><code>%M2_HOME%\bin</code></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210116151917778.png" alt="image-20210116151917778"></p>
<h4 id="第三步"><a class="header-anchor" href="#第三步"> </a>第三步</h4>
<p>验证</p>
<p><code>mvn -v</code></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210116152123525.png" alt="image-20210116152123525"></p>
<h2 id="maven约定的目录结构"><a class="header-anchor" href="#maven约定的目录结构"> </a>maven约定的目录结构</h2>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">my-app</span><br><span class="line">|-- pom.xml            # maven的核心文件（maven项目必须有）</span><br><span class="line">`-- src</span><br><span class="line">    |-- main           #放主程序java代码和配置文件</span><br><span class="line">    |   `-- resources   #放java程序中要使用到的配置文件    </span><br><span class="line">    |   `-- java       #放程序包和包中的java文件</span><br><span class="line">    |       `-- com</span><br><span class="line">    |           `-- mycompany</span><br><span class="line">    |               `-- app</span><br><span class="line">    |                   `-- App.java</span><br><span class="line">    `-- test		   #放测试程序代码和配置文件 （可以没有）</span><br><span class="line">        `-- resources   #测试程序中要使用到的配置文件    </span><br><span class="line">        `-- java       #放测试程序包和包中的java文件</span><br><span class="line">            `-- com</span><br><span class="line">                `-- mycompany</span><br><span class="line">                    `-- app</span><br><span class="line">                        `-- AppTest.java</span><br></pre></td></tr></table></figure>
<p>来自<a href="http://maven.apache.org/guides/getting-started/maven-in-five-minutes.html">Maven in 5 Minutes</a></p>
<h2 id="手动尝试maven"><a class="header-anchor" href="#手动尝试maven"> </a>手动尝试maven</h2>
<h3 id="创建目录及源文件"><a class="header-anchor" href="#创建目录及源文件"> </a>创建目录及源文件</h3>
<p>创建如下的文件夹层级</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210116154005457.png" alt="image-20210116154005457"></p>
<p>在与<code>src</code>同级，创建一个<code>pom.xml</code>文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>创建目录<code>src/main/java/com/example</code>文件夹，同时在<code>example</code>文件夹中创建<code>HelloMaven.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloMaven</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n1+n2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">HelloMaven</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloMaven</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> hello.add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1+2=&quot;</span>+res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编译"><a class="header-anchor" href="#编译"> </a>编译</h3>
<p>到与<code>pom.xml</code>同级的目录下（即<code>my-app/</code>）下</p>
<p>执行<code>mvn compile</code></p>
<p>这样会自动编译：<code>src/main/java</code>目录下的所有java文件</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210116155333154.png" alt="image-20210116155333154"></p>
<p>😔不幸的是，没有视频那么顺利，这里报错了<code>BUILD FAILURE</code></p>
<p>根据我用<code>Android Studio</code>写android程序时，在gradle下载第三方库也疯狂报错的经验下，我认为这八成是网络问题，<strong>毕竟在国内</strong>。而我当时解决办法是疯狂重试（<strong>或许可以更换镜像</strong>，但我有时候更换镜像也失败了）</p>
<p>所以在命令行中多试几遍<code>mvn compile</code>，奇迹就出现了</p>
<p>（当然，从默认的中央仓库下载是很慢的，可以从阿里云镜像等下载）</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210116160400885.png" alt="image-20210116160400885"></p>
<blockquote>
<p>也有可能是刚刚的<code>pom.xml</code>文件内容是错的，注意检查一下</p>
</blockquote>
<p>下载编译完成后</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210116164913210.png" alt="image-20210116164913210"></p>
<h4 id="编译过程中下载东西解释"><a class="header-anchor" href="#编译过程中下载东西解释"> </a>编译过程中下载东西解释</h4>
<p>下载原因：maven工具执行的操作需要很多插件（java类-jar文件）</p>
<p>这些插件下载的地址就是：<strong>中央仓库</strong>（<a href="https://repo.maven.apache.org/%EF%BC%89">https://repo.maven.apache.org/）</a></p>
<p>而下载的这些东西存放在默认仓库（<strong>本机仓库</strong>）</p>
<p>在：<code>C:\Users\用户名\.m2\repository</code></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210116161136206.png" alt="image-20210116161136206"></p>
<h4 id="编译结果"><a class="header-anchor" href="#编译结果"> </a>编译结果</h4>
<p>在项目的根目录会生成<code>target</code>目录，用于存放编译结果</p>
<p>可以看到生成了对应的class文件</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210116164953475.png" alt="image-20210116164953475"></p>
<p>我们可以用java命令进行运行</p>
<p>先切换到<code>D:\CODE\maven-test\my-app\target\classes\</code>目录下（即与<code>com</code>同级）</p>
<p>命令行执行<code>java com.example.HelloMaven</code></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210116165202888.png" alt="image-20210116165202888"></p>
<h2 id="修改本地仓库地址"><a class="header-anchor" href="#修改本地仓库地址"> </a>修改本地仓库地址</h2>
<p>来到maven文件的目录</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210116165324295.png" alt="image-20210116165324295"></p>
<p>其中<code>conf</code>文件夹中存放的是配置文件</p>
<p>修改<code>conf</code>文件夹中的<code>settings.xml</code></p>
<p>修改前可以先备份一下<code>settings.xml</code></p>
<p>在<code>settings.xml</code>文件中第53行左右</p>
<p>有一段被注释掉的代码</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&lt;!-- localRepository</span><br><span class="line"> | The path to the local repository maven will use to store artifacts.</span><br><span class="line"> |</span><br><span class="line"> | Default: $&#123;user.home&#125;/.m2/repository</span><br><span class="line">&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>
<p>在注释外面添加本地仓库地址</p>
<p>我们可以自己选择要修改的本地仓库地址，比如创建一个存放仓库的地址“D:\Program Files\Environment\apache-maven-3.3.9\repo”</p>
<p>然后在<code>settings.xml</code>中添加这行,<strong>注意不要使用中文目录</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:/Program Files/Environment/apache-maven-3.3.9/repo<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210116165906481.png" alt="image-20210116165906481"></p>
<h2 id="修改仓库镜像"><a class="header-anchor" href="#修改仓库镜像"> </a>修改仓库镜像</h2>
<p>刚刚用默认的中央仓库下载了四十多分钟，实在太慢了，所以这里记录一下修改中央仓库镜像为阿里云镜像</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210116170026083.png" alt="image-20210116170026083"></p>
<p>这里列出几个maven镜像地址的官网</p>
<ul>
<li><a href="http://mirrors.163.com/.help/maven.html">网易Maven镜像使用帮助</a></li>
<li><a href="https://maven.aliyun.com/mvn/guide?spm=a2c6h.13651104.0.0.435836a4Jjd8w9">阿里云云效 Maven</a></li>
</ul>
<blockquote>
<p>可能镜像下载的仓库没有官网的全</p>
</blockquote>
<h3 id="镜像配置"><a class="header-anchor" href="#镜像配置"> </a>镜像配置</h3>
<p>同样打开<code>conf/settings.xml</code></p>
<p>在147行左右的位置找到修改镜像的位置</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210116170730020.png" alt="image-20210116170730020"></p>
<p>根据<a href="https://maven.aliyun.com/mvn/guide?spm=a2c6h.13651104.0.0.435836a4Jjd8w9">阿里云maven镜像</a>的配置指南</p>
<p>在<code>&lt;mirrors&gt;&lt;/mirrors&gt;</code>标签中添加 mirror 子节点:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云公共仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210116171039571.png" alt="image-20210116171039571"></p>
<p>现在我们尝试一下镜像</p>
<p>先把刚刚生成的target文件删了，然后在与<code>pom.xml</code>同级目录执行</p>
<p><code>mvn compile</code>让它去中央仓库下载东西</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210116171544450.png" alt="image-20210116171544450"></p>
<p>很好，还是报错了😔，又是<code>BUILD FAILURE</code></p>
<p>但是别灰心，多按几次&quot;⬆&quot;和&quot;Enter&quot;，多执行几次<code>mvn compile</code></p>
<p>大概失败了七八次以后就成功了，确实快了几百倍</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210116171738168.png" alt="image-20210116171738168"></p>
<p>同时在修改的本地仓库里面也能够看到从阿里云仓库下载下来的。</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210116171832949.png" alt="image-20210116171832949"></p>
<h2 id="仓库"><a class="header-anchor" href="#仓库"> </a>仓库</h2>
<p>仓库用于存放maven使用的各种插件jar包与我们项目中使用到的jar（第三方工具）</p>
<h3 id="仓库分类"><a class="header-anchor" href="#仓库分类"> </a>仓库分类</h3>
<ul>
<li>本地仓库：个人计算机文件夹中</li>
<li>远程仓库：互联网上的
<ul>
<li>中央仓库：最权威的：<a href="https://repo.maven.apache.org">https://repo.maven.apache.org</a></li>
<li>中央仓库的镜像：中央仓库的备份</li>
<li>私服：公司内部，在局域网中使用，不对外开发</li>
</ul>
</li>
</ul>
<h3 id="仓库使用"><a class="header-anchor" href="#仓库使用"> </a>仓库使用</h3>
<p>例如需要mysql驱动则</p>
<p>maven查找该驱动的顺序为</p>
<ol>
<li>查找本地仓库</li>
<li>私服</li>
<li>镜像</li>
<li>中央仓库</li>
</ol>
<h2 id="pom文件"><a class="header-anchor" href="#pom文件"> </a>pom文件</h2>
<p>pom（project object model）:项目对象模型，是一个pom.xml文件</p>
<table>
<thead>
<tr>
<th>基本信息</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>modelVersion</td>
<td>maven模型的版本，对于maven2和maven3来说，只能是4.0.0</td>
</tr>
<tr>
<td>groupId</td>
<td>组织id，一般为公司域名的倒写，例如 1.域名倒写：com.baidu 2.域名倒写+项目名：com.baidu.appolo</td>
</tr>
<tr>
<td>artifactId</td>
<td>项目名称、模块名称，对应groupId的子项目</td>
</tr>
<tr>
<td>version</td>
<td>项目的版本号。如果项目还在开发，是不稳定版本，通常在版本后带-SNAPSHOT。version使用三位数字标识，例如1.1.0。例子<version>0.0.1-SNAPSHOT</version></td>
</tr>
<tr>
<td>packaging</td>
<td>项目打包的类型，可以是jar,war,rar,ear,pom。默认是jar</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>依赖</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>dependencies和dependency</td>
<td>maven通过dependency进行jar包的管理。项目构建运行中，使用到的其他jar包称为依赖。使用标签<dependency></dependency>进行配置，而依赖的配置通过坐标来定位</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>配置属性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>properties</td>
<td>properties是用来定义一些配置属性的</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>构建</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>build</td>
<td>表示与构建相关的配置，例如编译插件的jdk版本</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>继承</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>parent</td>
<td>在maven中，如果多个模块都需要声明相同的配置，例如groupId,version,有相同的依赖，或相同的组件配置等，可用parent声明要继承的父工程的pom配置</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>聚合</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>modules</td>
<td>在maven的多模块开发中，为统一构建整个项目的所有模块，可以提供一个额外的模块，该模块的打包方式为pom，并且在其中使用modules聚合的其他模块，这样通过本模块就可以一键自动识别模块间的依赖关系来构建所有模块，叫maven的聚合</td>
</tr>
</tbody>
</table>
<h3 id="坐标"><a class="header-anchor" href="#坐标"> </a>坐标</h3>
<p>坐标是一个唯一值：在互联网中唯一标识一个项目</p>
<ul>
<li><groupId>公司域名的倒写</groupId></li>
<li><artifactId>自定义项目名称</artifactId></li>
<li><version>自定义版本号</version></li>
</ul>
<p>搜索使用的中央仓库地址：<a href="https://mvnrepository.com">https://mvnrepository.com</a></p>
<ul>
<li>根据groupId或artifactId作为搜索条件</li>
</ul>
<h4 id="例如搜索mysql"><a class="header-anchor" href="#例如搜索mysql"> </a>例如搜索mysql</h4>
<p>输入关键字<code>mysql</code></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210118153016909.png" alt="image-20210118153016909"></p>
<p>点击mysql驱动 <a href="https://mvnrepository.com/artifact/mysql/mysql-connector-java">MySQL Connector/J</a></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210118153124070.png" alt="image-20210118153124070"></p>
<p>点击某一版本号例如<a href="https://mvnrepository.com/artifact/mysql/mysql-connector-java/5.1.9">5.1.9</a></p>
<p><img src="Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210118153503072.png" alt="image-20210118153503072"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210118153527628.png" alt="image-20210118153527628"></p>
<p>Files点击下载对应的jar包</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210118153708237.png" alt="image-20210118153708237"></p>
<p>下方Maven显示的是mysql驱动的pom坐标</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210118153742086.png" alt="image-20210118153742086">、</p>
<h3 id="依赖"><a class="header-anchor" href="#依赖"> </a>依赖</h3>
<p>项目中使用的各种资源说明</p>
<p>dependencies</p>
<p>dependency</p>
<h4 id="例如使用mysql驱动"><a class="header-anchor" href="#例如使用mysql驱动"> </a>例如使用mysql驱动</h4>
<p>首先在pom.xml的<project></project>标签<strong>内</strong>,新加标签（如果没有的话）<dependencies></dependencies>。</p>
<p>在<dependenies></dependencies>中添加mysql驱动的坐标</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210118155732723.png" alt="image-20210118155732723"></p>
<p>其中groupId,artifactId,version都对应一个文件夹</p>
<p>例如maven会先去查找本地仓库</p>
<p>这里本地仓库之前没有下载这个mysql驱动，所以仓库找不到。因此这里在pom.xml中添加mysql驱动的依赖，再重新编译一下</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210118160343547.png" alt="image-20210118160343547"></p>
<p>下载过程也是疯狂失败，我们疯狂重试即可</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210118160418763.png" alt="image-20210118160418763"></p>
<p>下载成功后，在本地仓库的目录下，就出现了<code>mysql\mysql-connector-java\5.1.9</code></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210118160521675.png" alt="image-20210118160521675"></p>
<h3 id="pom-xml文件"><a class="header-anchor" href="#pom-xml文件"> </a>pom.xml文件</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">jave.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="maven的常用命令"><a class="header-anchor" href="#maven的常用命令"> </a>maven的常用命令</h2>
<p>maven的命令就对应于maven的生命周期：编译，测试，报告，打包，安装，部署</p>
<p>maven的命令执行依赖于插件，即一些jar文件</p>
<h3 id="Junit单元测试"><a class="header-anchor" href="#Junit单元测试"> </a>Junit单元测试</h3>
<p>junit测试类中的方法，每一个方法都是独立测试的</p>
<h4 id="操作步骤"><a class="header-anchor" href="#操作步骤"> </a>操作步骤</h4>
<ol>
<li>在pom.xml加入单元测试依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在maven项目中的<code>src/test/java</code>目录下，创建测试程序</li>
</ol>
<ul>
<li>测试类命名为：Test+要被测试的类名</li>
<li>测试方法命名为：test+方法名称</li>
</ul>
<p>例如测试HelloMaven，则创建测试类TestHelloMaven</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//测试HelloMaven的add方法是否正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试方法定义规则</strong></p>
<ul>
<li>方法是public</li>
<li>方法没有返回值</li>
<li>方法名称是自定义的，但推荐为test+方法名称</li>
<li>在方法上面加入<code>@Test</code></li>
</ul>
<h3 id="命令说明"><a class="header-anchor" href="#命令说明"> </a>命令说明</h3>
<blockquote>
<p>maven命令的执行必须在pom.xml所在的目录</p>
</blockquote>
<ul>
<li><code>mvn clean</code> 清理
<ul>
<li>会删除原来编译和测试的目录，即target目录，但是已经install到仓库的包不会删除</li>
</ul>
</li>
<li><code>mvn compile</code> 编译<code>main/java</code>下的java程序
<ul>
<li>会在当前目录下生成一个target，里边存放编译主程序之后生成的字节码文件</li>
</ul>
</li>
<li><code>mvn test-compile</code> 编译<code>test/java</code>下的java程序
<ul>
<li>会在当前目录下生成一个target，里边存放编译测试程序之后生成的字节码文件</li>
</ul>
</li>
<li><code>mvn test </code>测试
<ul>
<li>会生成一个目录surefire-reports，保存测试结果</li>
</ul>
</li>
<li><code>mvn package</code> 打包
<ul>
<li>会编译、编译测试、测试，并且按照pom.xml配置把主程序打包生成jar包或者war包</li>
</ul>
</li>
<li><code>mvn install</code> 安装
<ul>
<li>会把本工程打包，并且按照本工程的坐标保存到本地仓库中</li>
</ul>
</li>
<li><code>mvn deploy</code> 部署
<ul>
<li>会把本工程打包，按照本工程的坐标保存到本地库中，并且还会保存到私服仓库中，还会自动把项目部署到web容器中</li>
</ul>
</li>
</ul>
<h3 id="操作步骤-v2"><a class="header-anchor" href="#操作步骤-v2"> </a>操作步骤</h3>
<h4 id="编写测试代码"><a class="header-anchor" href="#编写测试代码"> </a>编写测试代码</h4>
<p>在<code>src/test/java</code>中创建我们要测试的类的相同包名</p>
<p>例如我们要测试<code>src/main/java/com/example</code>的<code>HelloMaven.java</code>的<code>add</code>方法。</p>
<p>这个<code>HelloMaven</code>类属于<code>com.example</code>包</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210118174002190.png" alt="image-20210118174002190"></p>
<p>所以我们在<code>src/test/java</code>一样创建文件夹目录<code>src/test/java/com/example</code>和对应的测试类java文件<code>TestHelloMaven.java</code></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210118174214242.png" alt="image-20210118174214242"></p>
<p>其中<code>TestHelloMaven.java</code>注意几点</p>
<ul>
<li>所属的包与被测试的类一致，即都为<code>package com.example;</code></li>
<li>测试方法为<code>public void</code>，名字为test+被测试方法名。即<code>TestAdd</code>。同时增加注解<code>@Test</code></li>
<li>调用Junit的方法<code>Assert.assertEquals(期待值，实际值)</code></li>
<li>导junit的包</li>
</ul>
<p>TestHelloMaven.java文件内容如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHelloMaven</span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TestAdd</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==== TestHelloMaven ====&quot;</span>);</span><br><span class="line">        <span class="type">HelloMaven</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloMaven</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> hello.add(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">30</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="清理之前编译结果"><a class="header-anchor" href="#清理之前编译结果"> </a>清理之前编译结果</h4>
<p>切换到与<code>pom.xml</code>同级的目录下，可发现之前编译留下的<code>target</code>目录</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210118175344245.png" alt="image-20210118175344245"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210118175357688.png" alt="image-20210118175357688">··</p>
<p>我们在’pom.xml’同级目录下执行</p>
<p><code>mvn clean</code></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210118214851924.png" alt="image-20210118214851924"></p>
<p>可以看到target目录被删除了</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210118214913979.png" alt="image-20210118214913979"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="编译-v2"><a class="header-anchor" href="#编译-v2"> </a>编译</h4>
<p>为了更全面的体现maven的compile作用，我们先在<code>src\main\resources\</code>这个目录中，创建一个config.txt文件</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210118215323382.png" alt="image-20210118215323382"></p>
<p>然后同样，在与<code>pom.xml</code>同级目录下执行<code>mvn compile</code></p>
<ul>
<li>出错一：这种情况就多试几次<code>mvn compile</code>就可以了</li>
</ul>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210118215726674.png" alt="image-20210118215726674"></p>
<ul>
<li>出错二：
<ul>
<li><img src="http://algorithm-image.qibinaoe.top/image-20210118215845261.png" alt="image-20210118215845261"></li>
<li>这是因为<properties></properties>指定java版本的问题</li>
<li>原来出错的时候我是这样写的<img src="http://algorithm-image.qibinaoe.top/image-20210118220631510.png" alt="image-20210118220631510"></li>
<li>改过来后<img src="http://algorithm-image.qibinaoe.top/image-20210118220646491.png" alt="image-20210118220646491"></li>
</ul>
</li>
</ul>
<p>编译成功的结果</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210118220709023.png" alt="image-20210118220709023"></p>
<p>可以看到编译过程使用了两个插件</p>
<p><code> maven-resources-plugin:2.6:resources</code></p>
<p><code>maven-compiler-plugin:3.1:compile</code></p>
<p>编译结果是将<code>main/java</code>目录下的所有java文件编译成class文件，并拷贝到<code>target/classes</code>下</p>
<p>将<code>main/resources</code>目录下的所有资源文件拷贝到<code>target/classes</code>目录下</p>
<p>看到生成了<code>target</code>目录</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210118220816016.png" alt="image-20210118220816016"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210118220854450.png" alt="image-20210118220854450"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210118220915334.png" alt="image-20210118220915334"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210118220926898.png" alt="image-20210118220926898"></p>
<h4 id="编译测试"><a class="header-anchor" href="#编译测试"> </a>编译测试</h4>
<p>之前编译的是编译<code>main/java</code>的java文件，并没有编译测试代码，所以我们执行编译测试的代码</p>
<p><code>mvn test-compile</code></p>
<p>同样，还是可能会报那个错，多试几次就可以</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210118221409019.png" alt="image-20210118221409019"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210118221451489.png" alt="image-20210118221451489"></p>
<p>这里编译的是<code>src/test/java</code>的java文件</p>
<p>根据输出信息<code>[INFO] Compiling 1 source file to D:\CODE\maven-test\my-app\target\test-classes</code></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210118221542389.png" alt="image-20210118221542389"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210118221641992.png" alt="image-20210118221641992"></p>
<h4 id="测试"><a class="header-anchor" href="#测试"> </a>测试</h4>
<p>执行<code>mvn test</code>命令</p>
<p>（此过程可能会出现<code>PluginResolutionException</code>的异常，一样的，多执行几遍<code>mvn test</code>即可）</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119121035364.png" alt="image-20210119121035364"></p>
<p>在INFO中，其又重新执行编译java代码，编译测试代码过程</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ demo ---</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ demo ---</span><br><span class="line">[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ demo ---</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ demo ---</span><br><span class="line">[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ demo ---</span><br><span class="line">[INFO] Surefire report directory: D:\CODE\maven-test\my-app\target\surefire-reports</span><br></pre></td></tr></table></figure>
<p>因此，在maven中，执行生命周期的其中一个命令时，会把其之前的命令也执行一遍</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">-------------------------------------------------------</span><br><span class="line"> T E S T S</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">Running com.example.TestHelloMaven</span><br><span class="line">==== TestHelloMaven ====</span><br><span class="line">Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.08 sec</span><br><span class="line"></span><br><span class="line">Results :</span><br><span class="line"></span><br><span class="line">Tests run: 1, Failures: 0, Errors: 0, Skipped: 0</span><br><span class="line"></span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 2.615 s</span><br><span class="line">[INFO] Finished at: 2021-01-19T12:10:17+08:00</span><br><span class="line">[INFO] Final Memory: 9M/245M</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>同时<code>BUILD SUCCESS</code>意味着测试通过</p>
<p>这是测试完生成的文件</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119121438268.png" alt="image-20210119121438268"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119121451351.png" alt="image-20210119121451351"></p>
<h5 id="测试不通过"><a class="header-anchor" href="#测试不通过"> </a>测试不通过</h5>
<p>现在来修改一起使其测试不通过</p>
<p>修改<code>TestHelloMaven.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHelloMaven</span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TestAdd</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==== TestHelloMaven ====&quot;</span>);</span><br><span class="line">        <span class="type">HelloMaven</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloMaven</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> hello.add(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">30</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TestAdd2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==== TestHelloMaven2 ====&quot;</span>);</span><br><span class="line">        <span class="type">HelloMaven</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloMaven</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> hello.add(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">50</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，<code>TestAdd2</code>肯定报错</p>
<p>现在重新执行<code>mvn test</code></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119124712512.png" alt="image-20210119124712512"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119124722771.png" alt="image-20210119124722771"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119124733245.png" alt="image-20210119124733245"></p>
<p>可以看到，意料之中的抛出错误了，同时显示的是<code>BUILD FAILURE</code></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Results :</span><br><span class="line">Failed tests:   TestAdd2(com.example.TestHelloMaven): expected:&lt;50&gt; but was:&lt;30&gt;</span><br><span class="line">Tests run: 2, Failures: 1, Errors: 0, Skipped: 0</span><br></pre></td></tr></table></figure>
<p>在<code>target\surefire-reports\com.example.TestHelloMaven.txt</code>中的测试报告保存了测试结果</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119124941616.png" alt="image-20210119124941616"></p>
<h4 id="打包"><a class="header-anchor" href="#打包"> </a>打包</h4>
<p>将刚刚错误代码改正或者删掉后，进行打包操作</p>
<p>执行命令<code>mvn package</code></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119142459278.png" alt="image-20210119142459278"></p>
<p>打包成功后，在<code>target</code>目录下，会生成一个jar包</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119142555543.png" alt="image-20210119142555543"></p>
<p>这个jar包的命令是根据pom.xml文件中的<code>artifactId</code>和<code>version</code></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119142716700.png" alt="image-20210119142716700"></p>
<p>对于jar包里面的内容，只打包<code>src/main</code>下的内容，不打包<code>src/test</code>的内容</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119142915389.png" alt="image-20210119142915389"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119142931290.png" alt="image-20210119142931290"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119143013485.png" alt="image-20210119143013485"></p>
<h4 id="安装"><a class="header-anchor" href="#安装"> </a>安装</h4>
<p>执行命令<code>mvn install</code></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119143448979.png" alt="image-20210119143448979"></p>
<p>根据这条信息，这个项目jar包已经被保存到本地仓库中去</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[INFO] --- maven-install-plugin:2.4:install (default-install) @ demo ---</span><br><span class="line">[INFO] Installing D:\CODE\maven-test\my-app\target\demo-0.0.1-SNAPSHOT.jar to D:\Program Files\Environment\apache-maven-3.3.9\repo\com\example\demo\0.0.1-SNAPSHOT\demo-0.0.1-SNAPSHOT.jar[INFO] Installing D:\CODE\maven-test\my-app\pom.xml to D:\Program Files\Environment\apache-maven-3.3.9\repo\com\example\demo\0.0.1-SNAPSHOT\demo-0.0.1-SNAPSHOT.pom</span><br></pre></td></tr></table></figure>
<p>定位到我们本地仓库的路径</p>
<p>其中生成的目录文件夹是根据pom.xml中的坐标进行创建，同时如果坐标中包含点，例如<code>com.example</code>，则生成<code>com/example</code></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119143604064.png" alt="image-20210119143604064"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119143658604.png" alt="image-20210119143658604"></p>
<h4 id="部署"><a class="header-anchor" href="#部署"> </a>部署</h4>
<p>部署就不使用maven进行</p>
<h4 id="在其他项目的使用"><a class="header-anchor" href="#在其他项目的使用"> </a>在其他项目的使用</h4>
<p>现在如果要在其他项目中使用刚刚安装到本地仓库的<code>HelloMaven</code>，只需要在新项目的pom.xml中添加依赖，其中坐标即为<code>HelloMaven</code>那个项目的坐标</p>
<p>例如我们新建一个demo2的项目</p>
<p>其中pom.xml中的<code>dependencies</code>标签中添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样maven就会自动到本地仓库中寻找刚刚的项目的jar包</p>
<h2 id="插件"><a class="header-anchor" href="#插件"> </a>插件</h2>
<p>在maven构建项目构成中，可以在输出信息看到maven使用了许多插件</p>
<p>例如</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ demo ---</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ demo ---</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ demo ---</span><br><span class="line">[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ demo ---</span><br></pre></td></tr></table></figure>
<p>而这些插件信息也可以在pom.xml进行修改</p>
<p>在pom.xml中的<project></project>标签内新建一个子标签<build></build>（如果没有的话）</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">	&lt;groupId&gt;com.example&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;demo&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">		&lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class="line">		&lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br><span class="line">	&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">	&lt;/dependencies&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">				&lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class="line">				&lt;configuration&gt;</span><br><span class="line">                    &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">                    &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">				&lt;/configuration&gt;</span><br><span class="line">			&lt;/plugin&gt;</span><br><span class="line">		&lt;/plugins&gt;</span><br><span class="line">	&lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再进行重新编译，可以看到maven在本地仓库没有找到该插件对应的版本，所以从中央仓库下载，并且使用</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119151439329.png" alt="image-20210119151439329"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 控制配置 maven构建项目的参数设置， 设置jdk版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置插件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置具体插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 插件名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 插件版本 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置插件的信息 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 写的代码是在jdk1.8上编译 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 程序应该运行在jdk1.8上--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="maven在idea的配置"><a class="header-anchor" href="#maven在idea的配置"> </a>maven在idea的配置</h2>
<p>idea有内置maven，但是我们要使用我们自己下载的，所以需要修改idea中的maven</p>
<p>需要修改的地方有两个</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119153536756.png" alt="image-20210119153536756"></p>
<ol>
<li>Settings
<ul>
<li>配置当前工程的设置</li>
</ul>
</li>
<li>New Projects Settings（在旧的版本叫做Other Settings）
<ul>
<li>配置以后新建工程的设置</li>
</ul>
</li>
</ol>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119153802622.png" alt="image-20210119153802622"></p>
<p>Maven home directory：maven的安装目录</p>
<p>User settings file：maven安装目录conf/settings.xml配置文件</p>
<p>Local repository：本地仓库的目录</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119154052518.png" alt="image-20210119154052518"></p>
<p>记得勾选Override才能选择文件夹。Local repository在选择settings.xml后会自动定位</p>
<p>接着修改Runner中的VM  Options和JRE（如果不正确的话）</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119154607046.png" alt="image-20210119154607046"></p>
<p>VM Options: -DarchetypeCatalog=internal</p>
<p>这样配置的意义在于，原本maven项目创建时会联网下载模板文件，而是用这行命令就不用下载</p>
<blockquote>
<p>视频里的用户<a href="https://space.bilibili.com/9259676">HIMSONCHAN</a>的评论这样解释的</p>
<p>IDEA根据maven archetype的本质，执行mvn archetype:generate命令，该命令执行时，需要指定一个archetype-catalog.xml文件，该命令的参数-DarchetypeCatalog，可选值为：remote，internal  ，local等，用来指定archetype-catalog.xml文件从哪里获取。</p>
<p>默认为remote，即从 <a href="http://repo1.maven.org/maven2/archetype-catalog.xml%E8%B7%AF%E5%BE%84%E4%B8%8B%E8%BD%BDarchetype-catalog.xml%E6%96%87%E4%BB%B6%E3%80%82">http://repo1.maven.org/maven2/archetype-catalog.xml路径下载archetype-catalog.xml文件。</a><br>
该文件约为3-4M，下载速度很慢，导致创建过程卡住。</p>
<p>所以改成了internal使用内置的xml配置文件，这样以下子就能进到项目。</p>
</blockquote>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119155200347.png" alt="image-20210119155200347"></p>
<blockquote>
<p>Settings和New Projects Setttings操作一样</p>
</blockquote>
<h2 id="idea创建maven项目普通Java项目"><a class="header-anchor" href="#idea创建maven项目普通Java项目"> </a>idea创建maven项目普通Java项目</h2>
<h3 id="新建maven项目"><a class="header-anchor" href="#新建maven项目"> </a>新建maven项目</h3>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119160333131.png" alt="image-20210119160333131"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119160401157.png" alt="image-20210119160401157"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119160419722.png" alt="image-20210119160419722"></p>
<p>如果创建<strong>失败</strong></p>
<p>则目录结构都没有创建成功，像下图</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119160511400.png" alt="image-20210119160511400"></p>
<p>这里报错的原因</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119160713520.png" alt="image-20210119160713520"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&quot;C:\Program Files\Java\jdk1.8.0_201\bin\java.exe&quot; -Dmaven.multiModuleProjectDirectory=C:\Users\admin\AppData\Local\Temp\archetype1tmp -DarchetypeCatalog=internal &quot;-Dmaven.home=D:\Program Files\JetBrains\IntelliJ IDEA 2020.2.3\plugins\maven\lib\maven3&quot; &quot;-Dclassworlds.conf=D:\Program Files\JetBrains\IntelliJ IDEA 2020.2.3\plugins\maven\lib\maven3\bin\m2.conf&quot; &quot;-Dmaven.ext.class.path=D:\Program Files\JetBrains\IntelliJ IDEA 2020.2.3\plugins\maven\lib\maven-event-listener.jar&quot; &quot;-javaagent:D:\Program Files\JetBrains\IntelliJ IDEA 2020.2.3\lib\idea_rt.jar=14099:D:\Program Files\JetBrains\IntelliJ IDEA 2020.2.3\bin&quot; -Dfile.encoding=UTF-8 -classpath &quot;D:\Program Files\JetBrains\IntelliJ IDEA 2020.2.3\plugins\maven\lib\maven3\boot\plexus-classworlds-2.6.0.jar;D:\Program Files\JetBrains\IntelliJ IDEA 2020.2.3\plugins\maven\lib\maven3\boot\plexus-classworlds.license&quot; org.codehaus.classworlds.Launcher -Didea.version=2020.2.3 -s &quot;D:\Program Files\Environment\apache-maven-3.3.9\conf\settings.xml&quot; -DinteractiveMode=false -DgroupId=org.example -DartifactId=maven-practice -Dversion=1.0-SNAPSHOT -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=RELEASE org.apache.maven.plugins:maven-archetype-plugin:RELEASE:generate</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">Downloading from aliyunmaven: https://maven.aliyun.com/repository/public/org/apache/maven/plugins/maven-archetype-plugin/maven-metadata.xml</span><br><span class="line">[WARNING] Could not transfer metadata org.apache.maven.plugins:maven-archetype-plugin/maven-metadata.xml from/to aliyunmaven (https://maven.aliyun.com/repository/public): Transfer failed for https://maven.aliyun.com/repository/public/org/apache/maven/plugins/maven-archetype-plugin/maven-metadata.xml</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD FAILURE</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  2.016 s</span><br><span class="line">[INFO] Finished at: 2021-01-19T16:06:48+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[ERROR] Plugin org.apache.maven.plugins:maven-archetype-plugin:RELEASE or one of its dependencies could not be resolved: Failed to read artifact descriptor for org.apache.maven.plugins:maven-archetype-plugin:jar:RELEASE: Failed to resolve version for org.apache.maven.plugins:maven-archetype-plugin:jar:RELEASE: Could not find metadata org.apache.maven.plugins:maven-archetype-plugin/maven-metadata.xml in local (D:\Program Files\Environment\apache-maven-3.3.9\repo) -&gt; [Help 1]</span><br><span class="line">[ERROR] </span><br><span class="line">[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.</span><br><span class="line">[ERROR] Re-run Maven using the -X switch to enable full debug logging.</span><br><span class="line">[ERROR] </span><br><span class="line">[ERROR] For more information about the errors and possible solutions, please read the following articles:</span><br><span class="line">[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/PluginResolutionException</span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Could not transfer metadata org.apache.maven.plugins:maven-archetype-plugin/maven-metadata.xml from/to aliyunmaven (https://maven.aliyun.com/repository/public): Transfer failed for https://maven.aliyun.com/repository/public/org/apache/maven/plugins/maven-archetype-plugin/maven-metadata.xml</span><br></pre></td></tr></table></figure>
<p>这里的解决办法也是“<strong>疯狂重试</strong>”，类似之前在命令行对maven项目构建一样的道理</p>
<p>左边绿色的箭头点一下它就重新构建了，重新下载，这样就成功了</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119161058218.png" alt="image-20210119161058218"></p>
<p>可是显示<code>BUILD SUCCESSS</code>后也没有显示maven项目该有的目录结构</p>
<p>解决办法就是跑去idea的工作目录，把项目删了，重新创一个就有了</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119161645348.png" alt="image-20210119161645348"></p>
<p>但是下面又一大堆显示下载插件报错</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Cannot resolve plugin org.apache.maven.plugins:maven-jar-plugin:3.0.2</span><br><span class="line">Cannot resolve plugin org.apache.maven.plugins:maven-compiler-plugin:3.8.0</span><br><span class="line">Cannot resolve plugin org.apache.maven.plugins:maven-surefire-plugin:2.22.1</span><br><span class="line">Cannot resolve plugin org.apache.maven.plugins:maven-install-plugin:2.5.2</span><br><span class="line">Cannot resolve plugin org.apache.maven.plugins:maven-deploy-plugin:2.8.2</span><br><span class="line">Cannot resolve plugin org.apache.maven.plugins:maven-site-plugin:3.7.1</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119161814418.png" alt="image-20210119161814418"></p>
<p>但是这里疯狂点几次也还是出错，所以我们修改一下pom.xml文件</p>
<p>这是idea自己生成的pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-practice<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>maven-practice<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- FIXME change it to the project&#x27;s website --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.example.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span><span class="comment">&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- clean lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-clean-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- default lifecycle, jar packaging: see https://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.22.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-install-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- site lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-site-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-project-info-reports-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>显然，我们java是1.8的版本，这里<strong>修改</strong>一下</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119162258957.png" alt="image-20210119162258957"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119162601126.png" alt="image-20210119162601126"></p>
<p>同时把<build>标签全删了</p>
<p>再点击reload即可</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119173154947.png" alt="image-20210119173154947"></p>
<p>修改后的pom.xml</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">  &lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;maven-practice&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">  &lt;name&gt;maven-practice&lt;/name&gt;</span><br><span class="line">  &lt;!-- FIXME change it to the project&#x27;s website --&gt;</span><br><span class="line">  &lt;url&gt;http://www.example.com&lt;/url&gt;</span><br><span class="line"></span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class="line">    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到目录结构中没有<code>resources</code>，我们可以手动创建</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119172312270.png" alt="image-20210119172312270"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119172353020.png" alt="image-20210119172353020"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119172426755.png" alt="image-20210119172426755"></p>
<h3 id="构建maven项目"><a class="header-anchor" href="#构建maven项目"> </a>构建maven项目</h3>
<p><code>App</code>和<code>AppTest</code>是默认生成的文件，可以删掉</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119173920867.png" alt="image-20210119173920867"></p>
<p>然后分别创建<code>HelloMaven</code>和<code>TestHelloMaven</code></p>
<p>HelloMaven.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloMaven</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n1+n2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HelloMaven</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloMaven</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> hello.add(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;10+20=&quot;</span>+res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TestHelloMaven.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHelloMaven</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====TestHelloMaven=====&quot;</span>);</span><br><span class="line">        <span class="type">HelloMaven</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloMaven</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> hello.add(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">30</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAdd2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====TestHelloMaven2=====&quot;</span>);</span><br><span class="line">        <span class="type">HelloMaven</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloMaven</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> hello.add(<span class="number">50</span>,<span class="number">20</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">70</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119174431147.png" alt="image-20210119174431147"></p>
<p>右侧的lifecycle中，双击某一个即可执行</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119174443747.png" alt="image-20210119174443747"></p>
<h2 id="idea创建maven项目web项目"><a class="header-anchor" href="#idea创建maven项目web项目"> </a>idea创建maven项目web项目</h2>
<h3 id="创建新项目"><a class="header-anchor" href="#创建新项目"> </a>创建新项目</h3>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119175246729.png" alt="image-20210119175246729"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119175304318.png" alt="image-20210119175304318"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119175315334.png" alt="image-20210119175315334"></p>
<p>很好，又报新的<strong>错误</strong></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119175414947.png" alt="image-20210119175414947"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119175432171.png" alt="image-20210119175432171"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Could not transfer metadata org.apache.maven.archetypes:maven-archetype-webapp/maven-metadata.xml from/to aliyunmaven (https://maven.aliyun.com/repository/public): sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target</span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Failed to execute goal org.apache.maven.plugins:maven-archetype-plugin:3.2.0:generate (default-cli) on project standalone-pom: The desired archetype does not exist (org.apache.maven.archetypes:maven-archetype-webapp:RELEASE)</span><br></pre></td></tr></table></figure>
<p>如果出现这种错误，不要怀疑，疯狂重试即可</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119175626858.png" alt="image-20210119175626858"></p>
<p>这样，idea把该下载的包都下载后，删掉这个项目重新建一个即可</p>
<p>接下来报插件错误</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119180448339.png" alt="image-20210119180448339"></p>
<p>把pom.xml的 <build>标签删了即可，同时修改以下jdk版本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>同时对于这个项目的结构不够完整，这里手动创建</p>
<p>创建前</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119180612099.png" alt="image-20210119180612099"></p>
<p>创建后</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119180651307.png" alt="image-20210119180651307"></p>
<h3 id="依赖配置"><a class="header-anchor" href="#依赖配置"> </a>依赖配置</h3>
<p>这里需要用到servlet等依赖，可以直接通过pom.xml配置，就不用导入jar包了</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119181708371.png" alt="image-20210119181708371"></p>
<p>输入正确的情况下，标红意味还没下载，sycn一下就可以</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/jsp-api --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="编译代码"><a class="header-anchor" href="#编译代码"> </a>编译代码</h3>
<p>创建一个servlet</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119182518136.png" alt="image-20210119182518136"></p>
<p>web.xml中映射配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">web-app</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span></span><br><span class="line"><span class="meta"> <span class="string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.example.controller.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>网页index.jsp编写</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;Hello World!&lt;/h2&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;hello&quot;</span>&gt;访问servlet&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>HelloServlet.java编写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        writer.println(<span class="string">&quot;你好！Hello&quot;</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="部署tomcat"><a class="header-anchor" href="#部署tomcat"> </a>部署tomcat</h3>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119184249256.png" alt="image-20210119184249256"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119184331838.png" alt="image-20210119184331838"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119184343468.png" alt="image-20210119184343468"></p>
<p>改成短点的名字</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119184448122.png" alt="image-20210119184448122"></p>
<p>点击ok，然后运行</p>
<p>启动完毕后 ，浏览器进行访问http://localhost:8080/maven_web_war</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119184632770.png" alt="image-20210119184632770"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119184649355.png" alt="image-20210119184649355"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119184901180.png" alt="image-20210119184901180"></p>
<h3 id="打包-v2"><a class="header-anchor" href="#打包-v2"> </a>打包</h3>
<p>通过maven生命周期界面点击package进行打包</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119184936121.png" alt="image-20210119184936121"></p>
<p>在target目录下生成了war包</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119185025327.png" alt="image-20210119185025327"></p>
<p>把war包复制到tomcat的安装目录中的<code>webapps</code>中</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119185201885.png" alt="image-20210119185201885"></p>
<p>同时把war包改个简单点的名字</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119185234304.png" alt="image-20210119185234304"></p>
<p>这时候在bin目录下双击<code>startup.bat</code>启动tomcat</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119185319770.png" alt="image-20210119185319770"></p>
<p>启动成功后，可以看到在webapps目录下，自动解压了war文件</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119185536599.png" alt="image-20210119185536599"></p>
<p>启动成功即可看到项目部署上去了，访问http://localhost:8080/mavenweb/</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119185456512.png" alt="image-20210119185456512"></p>
<h2 id="依赖范围"><a class="header-anchor" href="#依赖范围"> </a>依赖范围</h2>
<p>依赖范围有</p>
<ul>
<li>compile</li>
<li>test</li>
<li>provided</li>
</ul>
<p>默认采用的是compile</p>
<table>
<thead>
<tr>
<th></th>
<th>compile</th>
<th>test</th>
<th>provided</th>
</tr>
</thead>
<tbody>
<tr>
<td>对主程序是否有效</td>
<td>是</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>对测试程序是否有效</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>是否参与打包</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>是否参与部署</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>依赖范围使用<scope></scope>标签</p>
<p>表示的是依赖使用的范围，即该依赖（jar包）在maven构建项目的哪些阶段其作用使用到</p>
<p>maven构建项目：编译、测试、打包、安装、部署等过程</p>
<h3 id="举例test"><a class="header-anchor" href="#举例test"> </a>举例test</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>junit的<code>&lt;scope&gt;test&lt;/scope&gt;</code>表示junit只有在测试这一步骤中会使用到，它不会参与编译主程序，打包等过程</p>
<h3 id="举例provided"><a class="header-anchor" href="#举例provided"> </a>举例provided</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于servlet的这两个依赖，<code>&lt;scope&gt;provided&lt;/scope&gt;</code>说明这些jar包只有在编译主程序和测试的过程中使用到，在打包的时候，不会添加到压缩文件当中，就servlet而言，tomcat环境已经提供了这些jar包，所以不需要打包进去。</p>
<p>可以看到在tomcat的lib文件中，已经包含这些jar包了</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119203326590.png" alt="image-20210119203326590"></p>
<h3 id="举例compile"><a class="header-anchor" href="#举例compile"> </a>举例compile</h3>
<p>对于没有写<scope></scope>标签的依赖，默认为compile。compile的意味着该依赖（jar包）在项目的每个过程中都会使用到并且打包的时候也会添加进压缩文件中去。</p>
<p>这里我们对项目进行打包，打开压缩文件<code>maven-web-1.0-SNAPSHOT.war</code></p>
<p>压缩文件长这样的</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119203644272.png" alt="image-20210119203644272"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119203718168.png" alt="image-20210119203718168"></p>
<p>现在，我们将servlet的依赖范围改成compile并重新清理打包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>打开新生成的<code>maven-web-1.0-SNAPSHOT.war</code></p>
<p>压缩文件内长这样，比之前多了lib文件夹，同时servlet用到的两个jar包也一同打包进去了</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119203915580.png" alt="image-20210119203915580"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119203933455.png" alt="image-20210119203933455"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119203949803.png" alt="image-20210119203949803"></p>
<h2 id="maven属性设置"><a class="header-anchor" href="#maven属性设置"> </a>maven属性设置</h2>
<p>在pom.xml中的<properties></properties>标签中定义maven的属性</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- maven构建项目使用的编码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 编译代码使用的jdk版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 运行程序使用的jdk版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="全局变量"><a class="header-anchor" href="#全局变量"> </a>全局变量</h3>
<p>maven的全局变量也是在pom.xml中的<properties></properties>标签内进行定义</p>
<p>其中标签名为变量名，标签中的值即为变量的值，通过${标签名}进行引用变量的值</p>
<p>自定义的全局变量一般是定义依赖的版本号，当项目中使用多个相同的版本号，可以定义变量，便于统一管理</p>
<p>例如定义一个spring.version的变量名，其中值为5.3.3</p>
<p>那在properties标签中这样编写</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.3.3<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>而在依赖中这样引用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>即可</p>
<h2 id="指定资源位置"><a class="header-anchor" href="#指定资源位置"> </a>指定资源位置</h2>
<p>在compile阶段，会将<code>src/main/java</code>的所有<code>*.java</code>文件和<code>src/main/resources</code>放在<code>target/classes</code>目录</p>
<p>在test-compile阶段，会将<code>src/test/java</code>的所有<code>*.java</code>文件和<code>src/test/resources</code>放在<code>target/test-classes</code>目录</p>
<p>但是在<code>src/main/java</code>目录下的所有非java文件和<code>src/test/java</code>目录下的所有非java文件不作处理，不拷贝到<code>target/classes</code>目录中。</p>
<p>例如我们创建三个非java文件，然后执行<code>test-compile</code></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119210941647.png" alt="image-20210119210941647"></p>
<p>在生成的target的目录中，testfile.txt和myapp.txt被拷贝过来，而app.properties没有拷贝过来</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119211039417.png" alt="image-20210119211039417"></p>
<p>而有时候我们又需要<code>src/main/java</code>目录下的非java文件</p>
<p>那么我们在pom.xml的<build>标签内添加<resources>标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 需要添加文件的目录 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 包含的文件 ，这里表示properites和xml后缀的文件都会包括--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- filtering选项 false 不启用过滤器， 上面通配符已经起到过滤作用--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>**/*.xml</code>这种写法是保证各级子目录下的资源都能被打包</p>
</blockquote>
<p>重新编译测试</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119212041832.png" alt="image-20210119212041832"></p>
<p>可以看到target目录下中，app.properties被包含进来了，但是发现myapp.txt不见了</p>
<p>再增加一条<resource>标签把<code>res/main/resources</code>下的文件也添加进去</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.txt<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样子该有的文件都有了</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210119213417913.png" alt="image-20210119213417913"></p>
<p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.3.3<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/jsp-api --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 需要添加文件的目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 包含的文件 ，这里表示properites和xml后缀的文件都会包括--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- filtering选项 false 不启用过滤器， 上面通配符已经起到过滤作用--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.txt<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>THAT’S ALL</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习</title>
    <url>/2020/11/15/Linux%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Linux学习笔记"><a class="header-anchor" href="#Linux学习笔记"> </a>Linux学习笔记</h1>
<!-- more -->
<p>Linux入门我通过学习<a href="https://www.linuxprobe.com/">Linux就该这么学</a>这个网站进行学习。书上的老师推荐的是Redhat7.0。由于Centos下载方便，我下载了Centos7.0,下载地址<a href="http://mirrors.aliyun.com/centos/7/isos/x86_64/">阿里云镜像</a>.</p>
<h2 id="基础知识笔记"><a class="header-anchor" href="#基础知识笔记"> </a>基础知识笔记</h2>
<p>Linux系统的<em>内核</em>负责对硬件资源的分配、调度等管理任务。</p>
<ul>
<li>系统内核对计算机正常运行具有重要作用</li>
<li>用户应该通过系统调用接口开发出的程序或服务来管理计算机</li>
</ul>
<h3 id="Linux系统关系"><a class="header-anchor" href="#Linux系统关系"> </a>Linux系统关系</h3>
<ul>
<li>程序或服务
<ul>
<li>系统调用接口
<ul>
<li>内核
<ul>
<li>硬件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="shell-壳或终端"><a class="header-anchor" href="#shell-壳或终端"> </a>shell 壳或终端</h3>
<p>shell是一个命令行工具，用户借助shell来与内核(硬件)进行通信。通过用户的命令去调用相应的程序服务去完成工作</p>
<p>许多主流默认使用的终端是Bash(Bourne-Again Shell)解释器</p>
<h3 id="命令"><a class="header-anchor" href="#命令"> </a>命令</h3>
<p>Linux命令格式</p>
<blockquote>
<p><strong>命令名称</strong> <strong>[命令参数]</strong> <strong>命令对象</strong></p>
</blockquote>
<p>之间用空格隔开</p>
<h3 id="命令对象"><a class="header-anchor" href="#命令对象"> </a>命令对象</h3>
<p>要处理的文件、目录、用户等资源</p>
<h3 id="命令参数"><a class="header-anchor" href="#命令参数"> </a>命令参数</h3>
<ul>
<li>长格式
<ul>
<li>使用完整选项名称</li>
<li><code>man --help</code></li>
</ul>
</li>
<li>短格式
<ul>
<li>单个字母缩写</li>
<li><code>man -h</code></li>
</ul>
</li>
</ul>
<h2 id="常用系统工作命令"><a class="header-anchor" href="#常用系统工作命令"> </a>常用系统工作命令</h2>
<h3 id="man"><a class="header-anchor" href="#man"> </a>man</h3>
<blockquote>
<p><code>man man</code></p>
</blockquote>
<p>查看<code>man</code>命令自身的帮助信息</p>
<ul>
<li><code>/</code> 从上至下搜索某个关键字, <code>/linux</code></li>
<li><code>?</code> 从下至上搜索某个关键字, <code>?linux</code></li>
<li><code>n</code> 定位到下一个关键字</li>
<li><code>N</code> 定位到上一个关键字</li>
</ul>
<p>echo</p>
<p>echo命令用于在终端输出<em>字符串</em>或<em>变量提取后的值</em></p>
<blockquote>
<p>echo [字符串|$变量]</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@qibin ~]<span class="comment"># echo hello world</span></span><br><span class="line">hello world</span><br><span class="line">[root@qibin ~]<span class="comment"># echo &quot;hello world&quot;</span></span><br><span class="line">hello world</span><br><span class="line">[root@qibin ~]<span class="comment"># echo $PATH</span></span><br><span class="line">/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/root/bin</span><br><span class="line">[root@qibin ~]<span class="comment"># echo $SHELL</span></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>
<h3 id="date"><a class="header-anchor" href="#date"> </a>date</h3>
<p>date命名用于显示及设置系统的时间或日期</p>
<blockquote>
<p>date [选项][+指定的格式]</p>
</blockquote>
<p>以+号开头的参数，可以按照指定格式输出系统的时间或日期</p>
<ul>
<li>%%     a literal %  %的转义</li>
<li><strong>%a</strong>     locale’s abbreviated weekday name (e.g., Sun) 缩写的工作日名称</li>
<li><strong>%A</strong>     locale’s full weekday name (e.g., Sunday) 完整的工作日名称</li>
<li><strong>%b</strong>     locale’s abbreviated month name (e.g., Jan) 月份的缩写</li>
<li><strong>%B</strong>     locale’s full month name (e.g., January) 完整的月份名称</li>
<li>%c     locale’s date and time (e.g., Thu Mar  3 23:05:25 2005)</li>
<li>%C     century; like %Y, except omit last two digits (e.g., 20)</li>
<li><strong>%d</strong>     day of month (e.g., 01) 本月中的第几天</li>
<li>%D     date; same as %m/%d/%y 输出月/日/年</li>
<li>%F     full date; same as %Y-%m-%d 输出年-月-日</li>
<li>%h     same as %b 缩写月份</li>
<li><strong>%H</strong>     hour (00…23) 小时 24小时制</li>
<li><strong>%I</strong>     hour (01…12) 小时 12小时制</li>
<li><strong>%j</strong>     day of year (001…366) 今年的第几天</li>
<li><strong>%m</strong>     month (01…12) 月份</li>
<li><strong>%M</strong>     minute (00…59) 分钟</li>
<li><strong>%n</strong>     a newline 换行符</li>
<li><strong>%p</strong>     locale’s equivalent of either AM or PM; blank if not known</li>
<li>%P     like %p, but lower case</li>
<li>%r     locale’s 12-hour clock time (e.g., 11:11:04 PM)</li>
<li>%R     24-hour hour and minute; same as %H:%M (e.g. 21:54)</li>
<li>%s     seconds since 1970-01-01 00:00:00 UTC</li>
<li><strong>%S</strong>     second (00…60) 秒</li>
<li><strong>%t</strong>     a tab 跳格</li>
<li>%T     time; same as %H:%M:%S (e.g., 21:55:48 PM)</li>
<li>%u     day of week (1…7); 1 is Monday</li>
<li>%U     week number of year, with Sunday as first day of week (00…53)</li>
<li>%w     day of week (0…6); 0 is Sunday</li>
<li>%W     week number of year, with Monday as first day of week (00…53)</li>
<li>%x     locale’s date representation (e.g., 12/31/99)</li>
<li>%X     locale’s time representation (e.g., 23:13:48)</li>
<li><strong>%y</strong>     last two digits of year (00…99) 简写年份</li>
<li><strong>%Y</strong>     year 完整年份</li>
</ul>
<p>按照默认格式查看当前系统时间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@qibin ~]# date</span><br><span class="line">Fri Nov 20 11:15:32 CST 2020</span><br></pre></td></tr></table></figure>
<p>按照年-月-日 小时:分钟:秒”的格式查看当前系统时间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@qibin ~]# date &quot;+%Y-%m-%d %H:%M:%S&quot;</span><br><span class="line">2020-11-20 11:17:27</span><br></pre></td></tr></table></figure>
<p>将系统时间修改成2020年1月1日 5点30分0秒</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@qibin ~]# date -s &quot;20200101 5:30:00&quot;</span><br><span class="line">Wed Jan  1 05:30:00 CST 2020</span><br></pre></td></tr></table></figure>
<p>查看硬件的时间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@qibin ~]# hwclock</span><br><span class="line">Fri 20 Nov 2020 11:22:23 AM CST  -0.699921 seconds</span><br></pre></td></tr></table></figure>
<p>将系统时间修改成硬件的时间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@qibin ~]# hwclock --hctosys</span><br></pre></td></tr></table></figure>
<h3 id="reboot"><a class="header-anchor" href="#reboot"> </a>reboot</h3>
<p>重启系统，默认只有root管理员能够重启</p>
<h3 id="poweroff"><a class="header-anchor" href="#poweroff"> </a>poweroff</h3>
<p>关闭系统，默认只有root管理员能关机</p>
<h3 id="wget"><a class="header-anchor" href="#wget"> </a>wget</h3>
<p>在终端下载网络文件</p>
<blockquote>
<p>wget [参数]  下载地址</p>
</blockquote>
<ul>
<li><strong>-b</strong> 后台下载</li>
<li><strong>-P</strong> 下载到指定地址  (默认为<code>.</code>，即当前目录)</li>
<li><strong>-t</strong> 最大尝试次数 (默认为20次)</li>
<li><strong>-c</strong> 断点续传</li>
<li><strong>-p</strong> 下载页面内所有资源，包括图片、视频等</li>
<li><strong>-r</strong> 递归下载，默认最大深度为5</li>
</ul>
<h3 id="ps"><a class="header-anchor" href="#ps"> </a>ps</h3>
<p>ps命令用于查看进程信息</p>
<ul>
<li><strong>-a</strong> 显示所有进程</li>
<li><strong>-u</strong> 显示用户以及其他详细信息</li>
<li><strong>-x</strong> 显示没有控制终端的进程？？？</li>
</ul>
<p>进程状态</p>
<ul>
<li>D    uninterruptible sleep (usually IO)  不可中断</li>
<li>R    running or runnable (on run queue) 正在运行的或者是在运行队列中等待的</li>
<li>S    interruptible sleep (waiting for an event to complete) 中断</li>
<li>T    stopped by job control signal 停止</li>
<li>t    stopped by debugger during the tracing</li>
<li>W    paging (not valid since the 2.6.xx kernel)</li>
<li>X    dead (should never be seen)</li>
<li>Z    defunct (“zombie”) process, terminated but not reaped by its parent 僵死</li>
</ul>
<h3 id="top"><a class="header-anchor" href="#top"> </a>top</h3>
<p>top命令用于动态监视进程的活动与系统负载信息</p>
<h3 id="pidof"><a class="header-anchor" href="#pidof"> </a>pidof</h3>
<p>pidof命令用于查看一个正在运行的程序的进程ID(PID)</p>
<blockquote>
<p>pidof [参数] [服务名称]</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@qibin ~]<span class="comment"># pidof sshd</span></span><br><span class="line">1112</span><br></pre></td></tr></table></figure>
<h3 id="kill"><a class="header-anchor" href="#kill"> </a>kill</h3>
<p>kill命令用于终止<strong>指定PID</strong>的服务进程</p>
<blockquote>
<p>kill [参数] [进程PID]</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@qibin ~]<span class="comment"># kill 1112</span></span><br></pre></td></tr></table></figure>
<h3 id="killall"><a class="header-anchor" href="#killall"> </a>killall</h3>
<p>killall用于终止某个<strong>指定名称</strong>的服务所对应的<strong>全部进程</strong></p>
<blockquote>
<p>killall [参数] [服务名称]</p>
</blockquote>
<p>通常一个复杂的服务程序会有多个进程协同工作，因此想要同时终止该服务程序的所有进程，通过<code>killall</code>指令代替<code>kill</code>命令，就不需要逐个输入每个pid去终止</p>
<p>在系统终端执行一个命令想要立即终止，用<code>ctrl + C</code> (有时候<code>ctrl + Z</code>?),就可以立即终止该命令。</p>
<p>如果不想显示命令屏幕的信息，可以在执行命令的末尾加上一个<code>&amp;</code>，这样命令就在系统后台执行</p>
<h2 id="系统状态检测命令"><a class="header-anchor" href="#系统状态检测命令"> </a>系统状态检测命令</h2>
<h3 id="ifconfig"><a class="header-anchor" href="#ifconfig"> </a>ifconfig</h3>
<p>ifconfig命令用于获取网卡配置与网络状态等信息</p>
<blockquote>
<p>ifconfig [网络设备] [参数]</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@qibin ~]<span class="comment"># ifconfig</span></span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.192.141  netmask 255.255.255.0  broadcast 192.168.192.255</span><br><span class="line">        inet6 fe80::eca9:ec1e:58ac:ac80  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether 00:0c:29:5d:b1:6e  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 70599  bytes 93326961 (89.0 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 23218  bytes 1661695 (1.5 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>
<p>其中，<code>inet</code>后面的参数是ipv4的地址，ether参数后面的是网卡物理地址(MAC地址)，RX是接收数据包信息，TX是发送数据包信息</p>
<h3 id="uname"><a class="header-anchor" href="#uname"> </a>uname</h3>
<p>uname命令用于查看系统信息，系统内核信息</p>
<p>系统内核名称、主机名、内核发行版本、节点名、系统时间、硬件名称、硬件平台、处理器类型、操作系统名称</p>
<blockquote>
<p>uname [参数]</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@qibin ~]<span class="comment"># uname -a</span></span><br><span class="line">Linux qibin.com 3.10.0-1127.el7.x86_64 <span class="comment">#1 SMP Tue Mar 31 23:36:51 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure>
<p>查看当前系统的详细信息，通过查看<code>centos-release</code>文件（redhat操作系统则查看<code>redhat-release</code>）</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[root@qibin ~]# cat /etc/centos-release</span><br><span class="line">CentOS Linux release 7.8.2003 (Core)</span><br></pre></td></tr></table></figure>
<h3 id="uptime"><a class="header-anchor" href="#uptime"> </a>uptime</h3>
<p>uptime用于查看系统负载信息</p>
<p>显示当前系统时间、系统已运行时间、启用终端数量（当前登录的用户数量）以及平均负载值</p>
<ul>
<li>
<p>平均负载值指系统在最近1分钟、5分钟和15分钟以内的压力情况</p>
</li>
<li>
<p>负载值越低越好， 不要长期超过1。生产环境不要长期超过5</p>
</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[root@qibin run]# uptime</span><br><span class="line"> 23:41:06 up  7:28,  3 users,  load average: 0.48, 0.29, 0.19</span><br></pre></td></tr></table></figure>
<p>对于文件<code>/var/run/utmp</code>储存着当前登录的用户信息</p>
<ul>
<li>这个文件不是通常的文本文件，而是二进制文件</li>
</ul>
<p>对于文件夹<code>/proc</code>储存着进程信息</p>
<h3 id="free"><a class="header-anchor" href="#free"> </a>free</h3>
<p>free命令用于显示当前系统中内存的使用量</p>
<blockquote>
<p>free [-h]</p>
</blockquote>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[root@qibin proc]# free</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:         995684      564644       93660       36120      337380      250096</span><br><span class="line">Swap:       2097148      168704     1928444</span><br><span class="line">[root@qibin proc]# free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           972M        551M         91M         35M        329M        244M</span><br><span class="line">Swap:          2.0G        164M        1.8G</span><br></pre></td></tr></table></figure>
<ul>
<li>total  内存总量</li>
<li>used  已用量</li>
<li>free 空闲量</li>
<li>shared  进程共享的内存量</li>
<li>buff/cache 缓存的内存量</li>
<li>available  可用量</li>
</ul>
<p>内存信息储存在<code>/proc/meminfo</code>文件中</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[root@qibin proc]# cat /proc/meminfo</span><br><span class="line">MemTotal:         995684 kB</span><br><span class="line">MemFree:           87764 kB</span><br><span class="line">MemAvailable:     248396 kB</span><br><span class="line">Buffers:              36 kB</span><br><span class="line">Cached:           307280 kB</span><br><span class="line">SwapCached:         9068 kB</span><br><span class="line">Active:           272516 kB</span><br><span class="line">Inactive:         403176 kB</span><br><span class="line">...</span><br><span class="line">DirectMap1G:           0 kB</span><br></pre></td></tr></table></figure>
<h3 id="who"><a class="header-anchor" href="#who"> </a>who</h3>
<p>who命令用于查看当前登入主机的用户终端信息</p>
<blockquote>
<p>who [参数]</p>
</blockquote>
<p>显示登入本机的用户的名称、终端设备、登录到系统的时间</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[root@qibin ~]# who</span><br><span class="line">root     :0           2020-11-21 14:57 (:0)</span><br><span class="line">root     pts/0        2020-11-22 09:00 (:0)</span><br><span class="line">root     pts/1        2021-01-15 23:34 (:0)</span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[root@qibin proc]# who -a</span><br><span class="line">           system boot  2020-11-21 14:56</span><br><span class="line">           run-level 5  2020-11-21 14:56</span><br><span class="line">root     ? :0           2020-11-21 14:57   ?          1861 (:0)</span><br><span class="line">root     + pts/0        2020-11-22 09:00 00:01       11663 (:0)</span><br><span class="line">root     + pts/1        2021-01-15 23:34   .         11663 (:0)</span><br></pre></td></tr></table></figure>
<h3 id="last"><a class="header-anchor" href="#last"> </a>last</h3>
<p>last用于查看所有系统的登录记录</p>
<blockquote>
<p>last [参数]</p>
</blockquote>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[root@qibin proc]# last</span><br><span class="line">root     pts/1        :0               Fri Jan 15 23:34   still logged in   </span><br><span class="line">root     pts/0        :0               Sun Nov 22 09:00   still logged in   </span><br><span class="line">root     pts/0        :0               Sun Nov 22 08:56 - 08:56  (00:00)    </span><br><span class="line">root     pts/0        :0               Sun Nov 22 08:22 - 08:55  (00:33)    </span><br><span class="line">root     pts/1        :0               Sat Nov 21 19:29 - 21:26  (01:57)    </span><br><span class="line">root     pts/0        :0               Sat Nov 21 14:59 - 21:26  (06:27)    </span><br><span class="line">root     :0           :0               Sat Nov 21 14:57   still logged in   </span><br><span class="line">reboot   system boot  3.10.0-1127.el7. Sat Nov 21 14:56 - 19:26 (56+04:29)  </span><br><span class="line">root     pts/0        :0               Tue Nov 17 10:27 - 14:56 (4+04:29)   </span><br><span class="line">root     :0           :0               Tue Nov 17 10:25 - crash (4+04:30)   </span><br><span class="line">reboot   system boot  3.10.0-1127.el7. Tue Nov 17 10:24 - 19:26 (60+09:02)  </span><br><span class="line">qibin    pts/0        :0               Tue Nov 17 10:23 - 10:23  (00:00)    </span><br><span class="line">qibin    pts/0        :0               Sun Nov 15 14:57 - 10:23 (1+19:25)   </span><br><span class="line">qibin    :0           :0               Sun Nov 15 09:52 - down  (2+00:31)   </span><br><span class="line">reboot   system boot  3.10.0-1127.el7. Sun Nov 15 09:47 - 10:23 (2+00:36) </span><br></pre></td></tr></table></figure>
<p>last记录根据于<code>/var/log/wtmp</code></p>
<blockquote>
<p>使用last命令可以查看本机的登录记录。但是，由于这些信息都是以<strong>日志文件</strong>的形式保存在系统中，因此黑客可以很容易地对内容进行篡改。千万不要单纯以该命令的输出信息而判断系统有无被恶意入侵！</p>
</blockquote>
<h3 id="lastb"><a class="header-anchor" href="#lastb"> </a>lastb</h3>
<p>lastb类似于last命令，只不过是查看所有尝试不正确登陆的记录</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[root@qibin /]# lastb</span><br><span class="line">root     :0           :0               Tue Nov 17 10:25 - 10:25  (00:00)    </span><br><span class="line">root     :0           :0               Tue Nov 17 10:25 - 10:25  (00:00)    </span><br><span class="line"></span><br><span class="line">btmp begins Tue Nov 17 10:25:44 2020</span><br></pre></td></tr></table></figure>
<p>lastb取决于文件<code>/var/log/btmp</code></p>
<p>last和lastb的记录都是从文件生成开始的</p>
<hr>
<h3 id="history"><a class="header-anchor" href="#history"> </a>history</h3>
<p>history命令用于显示历史执行过的命令</p>
<blockquote>
<p>history [-c]</p>
</blockquote>
<p>使用参数<code>-c</code>会清空所有的命令历史记录</p>
<p>使用<code>!数字</code>方式来重复执行某一次命令</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[root@qibin /]# history</span><br><span class="line">    1  pwd</span><br><span class="line">    2  ls</span><br><span class="line">    3  man man</span><br><span class="line">    4  man ls</span><br><span class="line">    5  echo hello world</span><br><span class="line">    6  echo &quot;hello world&quot;</span><br><span class="line">    7  echo $PATH</span><br><span class="line">    8  echo $SHELL</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[root@qibin ~]# !2</span><br><span class="line">ls</span><br><span class="line">anaconda-ks.cfg  Documents  initial-setup-ks.cfg  Pictures  Templates</span><br><span class="line">Desktop          Downloads  Music                 Public    Videos</span><br></pre></td></tr></table></figure>
<p>可以通过修改文件<code>/etc/profile</code>的HISTSIZE变量值来记录命令的条数</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210116194750201.png" alt="image-20210116194750201"></p>
<p>历史命令保存在用户家目录的<code>.bash_history</code>文件中</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[root@qibin /]# cat ~/.bash_history</span><br><span class="line">pwd</span><br><span class="line">ls</span><br><span class="line">man man</span><br><span class="line">man ls</span><br><span class="line">echo hello world</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="sosreport"><a class="header-anchor" href="#sosreport"> </a>sosreport</h3>
<p>sosreport命令用于收集系统配置及架构信息并输出诊断文档，格式为sosreport</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[root@qibin /]# sosreport</span><br><span class="line"></span><br><span class="line">sosreport (version 3.8)</span><br><span class="line"></span><br><span class="line">This command will collect diagnostic and configuration information from</span><br><span class="line">this CentOS Linux system and installed applications.</span><br><span class="line"></span><br><span class="line">An archive containing the collected information will be generated in</span><br><span class="line">/var/tmp/sos.9PR5Yw and may be provided to a CentOS support</span><br><span class="line">representative.</span><br><span class="line"></span><br><span class="line">Any information provided to CentOS will be treated in accordance with</span><br><span class="line">the published support policies at:</span><br><span class="line"></span><br><span class="line">  https://wiki.centos.org/</span><br><span class="line"></span><br><span class="line">The generated archive may contain data considered sensitive and its</span><br><span class="line">content should be reviewed by the originating organization before being</span><br><span class="line">passed to any third party.</span><br><span class="line"></span><br><span class="line">No changes will be made to system configuration.</span><br><span class="line"></span><br><span class="line">Press ENTER to continue, or CTRL-C to quit.</span><br><span class="line"></span><br><span class="line">Please enter the case id that you are generating this report for []: </span><br><span class="line"></span><br><span class="line"> Setting up archive ...</span><br><span class="line"> Setting up plugins ...</span><br><span class="line">[plugin:networking] skipped command &#x27;ip -s macsec show&#x27;: required kernel modules or services not present (kmods=[macsec] services=[]). Use &#x27;--allow-system-changes&#x27; to enable collection.</span><br><span class="line">[plugin:networking] skipped command &#x27;ss -peaonmi&#x27;: required kernel modules or services not present (kmods=[tcp_diag,udp_diag,inet_diag,unix_diag,netlink_diag,af_packet_diag] services=[]). Use &#x27;--allow-system-changes&#x27; to enable collection.</span><br><span class="line"> Running plugins. Please wait ...</span><br><span class="line"></span><br><span class="line">  Starting 1/103 abrt            [Running: abrt]                                  Starting 2/103 alternatives    [Running: abrt alternatives]                     Starting 3/103 anaconda        [Running: abrt alternatives anaconda]           </span><br><span class="line">  ....</span><br><span class="line">Creating compressed archive...</span><br><span class="line"></span><br><span class="line">Your sosreport has been generated and saved in:</span><br><span class="line">  /var/tmp/sosreport-qibin-2021-01-16-noswgvs.tar.xz</span><br><span class="line"></span><br><span class="line">The checksum is: 65e2990052e65e9ce1546fa390b27e54</span><br><span class="line"></span><br><span class="line">Please send this file to your support representative.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中生成文件在/var/tmp中</p>
<p>同时还有校验码checksum</p>
<h2 id="工作目录切换命令"><a class="header-anchor" href="#工作目录切换命令"> </a>工作目录切换命令</h2>
<p>工作目录指用户当前在系统中所处的位置</p>
<h3 id="pwd"><a class="header-anchor" href="#pwd"> </a>pwd</h3>
<p>pwd命令显示用户当前所处的工作目录</p>
<h3 id="cd"><a class="header-anchor" href="#cd"> </a>cd</h3>
<p>cd命令用于切换工作路径</p>
<blockquote>
<p>cd [目录名称]</p>
</blockquote>
<ul>
<li><code>cd -</code> 切换到上一次所处的目录</li>
<li><code>cd ..</code> 切换到上级目录</li>
<li><code>cd ~</code>切换到当前用户的家目录</li>
<li><code>cd ~用户名</code> 切换到其他用户的家目录</li>
</ul>
<h3 id="ls"><a class="header-anchor" href="#ls"> </a>ls</h3>
<p>ls显示目录中的文件信息</p>
<blockquote>
<p>ls [选项] [文件]</p>
</blockquote>
<ul>
<li><code>-a</code> 参数用于查看所有文件（包括隐藏文件）</li>
<li><code>-l</code>参数可以查看文件的属性、大小等详细信息</li>
</ul>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210219181849865.png" alt="image-20210219181849865"></p>
<h2 id="文本文件编辑命令"><a class="header-anchor" href="#文本文件编辑命令"> </a>文本文件编辑命令</h2>
<h3 id="cat"><a class="header-anchor" href="#cat"> </a>cat</h3>
<p>cat命令用于查看纯文本文件（内容较少的）</p>
<blockquote>
<p>cat [选项] [文件]</p>
</blockquote>
<ul>
<li>参数<code>-n</code>显示行号
<ul>
<li><img src="http://algorithm-image.qibinaoe.top/image-20210219182451420.png" alt="image-20210219182451420"></li>
</ul>
</li>
<li><code>cat 文件1 &gt; 文件2</code> 将文件1的内容覆盖到文件2</li>
<li><code>cat -n 文件1 &gt; 文件2</code> 将文件1的内容添加行号后覆盖到文件2
<ul>
<li><img src="http://algorithm-image.qibinaoe.top/image-20210219184106757.png" alt="image-20210219184106757"></li>
</ul>
</li>
<li><code>cat /dev/null &gt; hello.txt</code>：清空<code>hello.txt</code>
<ul>
<li><img src="http://algorithm-image.qibinaoe.top/image-20210219184208274.png" alt="image-20210219184208274"></li>
</ul>
</li>
<li>向文本中添加信息
<ul>
<li><img src="http://algorithm-image.qibinaoe.top/image-20210219184307219.png" alt="image-20210219184307219"></li>
</ul>
</li>
</ul>
<h3 id="more"><a class="header-anchor" href="#more"> </a>more</h3>
<p>more命令用于查看纯文本文件（内容较多）</p>
<blockquote>
<p>more [选项] 文件</p>
</blockquote>
<p>使用空格或回车向下翻页</p>
<h3 id="head"><a class="header-anchor" href="#head"> </a>head</h3>
<p>查看纯文本文件的前N行</p>
<blockquote>
<p>head [选项] [文件]</p>
</blockquote>
<ul>
<li><code>head -n 数字 文件</code>
<ul>
<li><img src="http://algorithm-image.qibinaoe.top/image-20210219185022243.png" alt="image-20210219185022243"></li>
</ul>
</li>
</ul>
<h3 id="tail"><a class="header-anchor" href="#tail"> </a>tail</h3>
<p>查看纯文本文件的后N行（类似<code>head</code>）</p>
<p>查看持续刷新的文件内容</p>
<ul>
<li><code>tail -n 数字 文件名</code> :查看后N行
<ul>
<li><img src="http://algorithm-image.qibinaoe.top/image-20210219185322475.png" alt="image-20210219185322475"></li>
</ul>
</li>
<li><code>tail -f 文件名</code> ：持续查看刷新的文件</li>
</ul>
<h3 id="tr"><a class="header-anchor" href="#tr"> </a>tr</h3>
<p>tr命令用于替换纯文本文件中的字符</p>
<blockquote>
<p>tr [原始字符] [目标字符]</p>
</blockquote>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210219190454296.png" alt="image-20210219190454296"></p>
<h3 id="wc"><a class="header-anchor" href="#wc"> </a>wc</h3>
<p>wc命令用于统计指定文本的行数，字数，字节数</p>
<blockquote>
<p>wc [参数] 文本</p>
</blockquote>
<ul>
<li><code>-c</code>只显示字节数</li>
<li><code>-l</code>只显示行数</li>
<li><code>-w</code>只显示单词数</li>
</ul>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210219190843839.png" alt="image-20210219190843839"></p>
<h3 id="stat"><a class="header-anchor" href="#stat"> </a>stat</h3>
<p>stat命令用于查看文件的具体储存信息和时间信息</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210220221616510.png" alt="image-20210220221616510"></p>
<h3 id="cut"><a class="header-anchor" href="#cut"> </a>cut</h3>
<p>cut命令能够按列提取文本</p>
<blockquote>
<p>cut [参数] 文本</p>
</blockquote>
<ul>
<li><code>-d</code>后加分隔符。例如<code>-d:</code></li>
<li><code>-f</code>代表<code>fields</code>，即后面加需要查看被分割的第几部分</li>
</ul>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210220222101844.png" alt="image-20210220222101844"></p>
<h3 id="diff"><a class="header-anchor" href="#diff"> </a>diff</h3>
<p>diff命令用于查看多个文件内容的差异</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210220222606926.png" alt="image-20210220222606926"></p>
<h2 id="文件目录管理命令"><a class="header-anchor" href="#文件目录管理命令"> </a>文件目录管理命令</h2>
<h3 id="touch"><a class="header-anchor" href="#touch"> </a>touch</h3>
<p>touch命令可以用来创建空白文件，以及设置文件的时间（修改时间（modification time），文件读取时间（access time））</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210226235406806.png" alt="image-20210226235406806"></p>
<h3 id="mkdir"><a class="header-anchor" href="#mkdir"> </a>mkdir</h3>
<p>mkdir用于创建空白目录，加参数<code>-p</code>用于创建出嵌套关系的文件目录</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210226235648590.png" alt="image-20210226235648590"></p>
<h3 id="cp"><a class="header-anchor" href="#cp"> </a>cp</h3>
<p>cp用于复制文件或者目录</p>
<blockquote>
<p>cp [选项] 源文件 目标文件</p>
</blockquote>
<ul>
<li>
<p>如果目标文件是目录，则将源文件复制到该目录</p>
<ul>
<li><img src="http://algorithm-image.qibinaoe.top/image-20210228204115125.png" alt="image-20210228204115125"></li>
</ul>
</li>
<li>
<p>如果目标文件也是普通文件，则覆盖它</p>
<ul>
<li><img src="http://algorithm-image.qibinaoe.top/image-20210228204229682.png" alt="image-20210228204229682"></li>
</ul>
</li>
<li>
<p>如果目标文件不存在，则执行正常复制操作</p>
</li>
<li>
<p><code>-p</code>，保留文件的属性</p>
<ul>
<li><img src="http://algorithm-image.qibinaoe.top/image-20210228204415482.png" alt="image-20210228204415482"></li>
</ul>
</li>
<li>
<p><code>-d</code>，若文件对象为链接文件，则保留该链接文件的属性</p>
</li>
<li>
<p><code>-r</code>，递归持续复制（用于目录）</p>
<ul>
<li><img src="http://algorithm-image.qibinaoe.top/image-20210228205218766.png" alt="image-20210228205218766"></li>
</ul>
</li>
<li>
<p><code>-i</code>，若目标文件存在，则询问是否覆盖</p>
<ul>
<li><img src="http://algorithm-image.qibinaoe.top/image-20210228204703717.png" alt="image-20210228204703717"></li>
</ul>
</li>
<li>
<p><code>-a</code>，相当于<code>-pdr</code></p>
</li>
</ul>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210228204018513.png" alt="image-20210228204018513"></p>
<h3 id="mv"><a class="header-anchor" href="#mv"> </a>mv</h3>
<p>mv用于剪切文件或者文件重命名</p>
<blockquote>
<p>mv [选项] 源文件 [目标路径|重命名后的文件名]</p>
</blockquote>
<p>源文件会被删除</p>
<h3 id="rm"><a class="header-anchor" href="#rm"> </a>rm</h3>
<p>rm用于删除文件或目录</p>
<blockquote>
<p>rm [选项] 文件</p>
</blockquote>
<ul>
<li><code>-r</code>递归删除，用于删除目录</li>
<li><code>-f</code>强制删除</li>
</ul>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210228205339443.png" alt="image-20210228205339443"></p>
<h3 id="dd"><a class="header-anchor" href="#dd"> </a>dd</h3>
<p>dd命令用于复制文件或者转化并格式化文件</p>
<blockquote>
<p>dd [选项]</p>
</blockquote>
<blockquote>
<p>/dev/zero的设备文件不占用系统储存空间，但是可以提供无穷的数据</p>
</blockquote>
<ul>
<li><code>if=FILE</code> 从FILE中读取数据而不是从标准输入读取</li>
<li><code>of=FILE</code>输出到FILE中，而不是标准输出</li>
<li><code>by=BYTES</code>一次性读写BYTES大小的数据</li>
<li><code>count=N</code>复制N块输入块</li>
</ul>
<p>同时dd命令可以制作光盘镜像文件iso</p>
<h3 id="file"><a class="header-anchor" href="#file"> </a>file</h3>
<p>file命令用于查看文件类型</p>
<blockquote>
<p>file 文件名</p>
</blockquote>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210228212901921.png" alt="image-20210228212901921"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210228210733905.png" alt="image-20210228210733905"></p>
<h2 id="打包压缩与搜索命令"><a class="header-anchor" href="#打包压缩与搜索命令"> </a>打包压缩与搜索命令</h2>
<h3 id="tar"><a class="header-anchor" href="#tar"> </a>tar</h3>
<p>tar命令用于对文件的打包压缩或解压</p>
<blockquote>
<p>tar [选项] [文件]  …</p>
</blockquote>
<ul>
<li>
<p><code>-c</code>：创建压缩文件</p>
</li>
<li>
<p><code>-x</code>：解压文件</p>
</li>
<li>
<p><code>-t</code>：查看压缩包有哪些文件</p>
</li>
<li>
<p><code>-z</code>：用gzip压缩或解压文件</p>
</li>
<li>
<p><code>-j</code>：用bzip2压缩或解压文件</p>
</li>
<li>
<p><code>-v</code>：显示压缩或解压过程</p>
</li>
<li>
<p><code>-f</code>： 目标文件名</p>
</li>
<li>
<p><code>-p</code>：保留原始的权限和属性</p>
</li>
<li>
<p><code>-P</code>：使用绝对路径来压缩</p>
</li>
<li>
<p><code>-C</code>：指定解压到的目录</p>
</li>
<li>
<p><code>-c</code>和<code>-x</code>不能同时使用</p>
</li>
<li>
<p><code>-f</code>必须放在参数的最后一位</p>
</li>
</ul>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210228221028051.png" alt="image-20210228221028051"></p>
<h3 id="grep"><a class="header-anchor" href="#grep"> </a>grep</h3>
<p>用于在文本中执行关键词搜索</p>
<blockquote>
<p>grep [选项] patterns [文件]</p>
</blockquote>
<ul>
<li><code>-n</code>显示行号</li>
<li><code>-v</code>反向选择，即不包含关键词patterns的行</li>
<li><code>-i</code>忽略大小写</li>
<li><code>-c</code>仅显示找到的行数</li>
<li><code>-b</code>将可执行文件bianry当作文本文件text搜索</li>
</ul>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210228221317677.png" alt="image-20210228221317677"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210228221518342.png" alt="image-20210228221518342"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210228221606705.png" alt="image-20210228221606705"></p>
<h3 id="find"><a class="header-anchor" href="#find"> </a>find</h3>
<p>find命令用于按照指定条件查找文件</p>
<blockquote>
<p>find [查找路径] 寻找条件 操作</p>
<p>find [-H] [-L] [-P] [-Olevel] [-D debugopts] [path…] [expression]</p>
</blockquote>
<p>搜索可以根据文件不同的特性：文件名，大小，修改时间，权限等</p>
<p>默认的expression是<code>-print</code></p>
<p>参数太多了，俺直接复制了</p>
<p><img src="Linux%E5%AD%A6%E4%B9%A0/image-20210228222757877.png" alt="image-20210228222757877"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210228222915513.png" alt="image-20210228222915513"></p>
<h2 id="其他"><a class="header-anchor" href="#其他"> </a>其他</h2>
<h3 id="配置centos网络"><a class="header-anchor" href="#配置centos网络"> </a>配置centos网络</h3>
<p>参考资料<a href="https://www.bilibili.com/video/BV1bA411b7vs">羊哥视频</a>，但是做完还是联不通，原因找到了，在于网关没有配置正确</p>
<p>又参考了<a href="https://www.cnblogs.com/passer101/p/9899202.html">博客园博客</a></p>
<p>在Windows下，如果使用VMWare,首先在上方菜单栏点击 编辑-&gt;虚拟网络编辑器-&gt;选择VMnet8的NAT设置，记录下上方的子网掩码和网关IP</p>
<p><img src="http://algorithm-image.qibinaoe.top/%E6%9F%A5%E7%9C%8B%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE.jpg" alt="VMWARE网络配置"></p>
<p>首先是切换到root 权限</p>
<blockquote>
<p>su root</p>
</blockquote>
<p>输入密码后</p>
<p>可以先查看当前网络情况</p>
<blockquote>
<p>ifconfig</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@qibin linuxpra]<span class="comment"># ifconfig</span></span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        ether 00:0c:29:5d:b1:6e  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 724  bytes 49922 (48.7 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到没有ip地址</p>
<p>输入</p>
<blockquote>
<p>dhclient</p>
</blockquote>
<p>可以看到已经分配了一个ip地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@qibin linuxpra]<span class="comment"># dhclient</span></span><br><span class="line">[root@qibin linuxpra]<span class="comment"># ifconfig</span></span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.192.141  netmask 255.255.255.0  broadcast 192.168.192.255</span><br><span class="line">        ether 00:0c:29:5d:b1:6e  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 1354  bytes 90634 (88.5 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 50  bytes 5872 (5.7 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ip地址为192.168.192.141，这时候将这个IP地址固定下来</p>
<p>编辑文件</p>
<blockquote>
<p>vim /etc/sysconfig/network-scripts/ifcfg-ens33</p>
</blockquote>
<p><code>[root@qibin linuxpra]# vim /etc/sysconfig/network-scripts/ifcfg-ens33</code></p>
<p>原本内容长这样</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">UUID=b2fca141-6809-45c2-9093-a3362e8c4de2</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=no</span><br></pre></td></tr></table></figure>
<p>修改<code>BOOTPROTO=dhcp</code>为<code>BOOTPROTO=static</code></p>
<p>修改<code>ONBOOT=no</code>为<code>ONBOOT=yes</code></p>
<p>在末尾根据刚刚<code>ifconfig</code>获得的ip地址进行填写</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">IPADDR=192.168.192.141</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.192.2</span><br><span class="line">DNS1=8.8.8.8</span><br><span class="line">DNS2=8.8.8.4</span><br></pre></td></tr></table></figure>
<p>这里的ip地址，子网掩码，网关根据实际情况填写</p>
<p>最终设置后，整个文本显示如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">UUID=b2fca141-6809-45c2-9093-a3362e8c4de2</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPADDR=192.168.192.141</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.192.2</span><br><span class="line">DNS1=8.8.8.8</span><br><span class="line">DNS2=8.8.8.4</span><br></pre></td></tr></table></figure>
<p>接着重启网卡，在命令行输入</p>
<blockquote>
<p>systemctl restart network.service</p>
</blockquote>
<p>这时候查看是否能够成功联网</p>
<blockquote>
<p>ping <a href="http://www.baidu.com">www.baidu.com</a></p>
</blockquote>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Thrift</title>
    <url>/2021/06/12/Thrift/</url>
    <content><![CDATA[<h1 id="Thrift学习笔记"><a class="header-anchor" href="#Thrift学习笔记"> </a>Thrift学习笔记</h1>
<!-- more -->
<h2 id="参考资料"><a class="header-anchor" href="#参考资料"> </a>参考资料</h2>
<ol>
<li><a href="https://zh.wikipedia.org/zh-hans/Thrift">Thrift - 维基百科，自由的百科全书</a></li>
<li><a href="https://thrift.apache.org/">Apache Thrift - Home</a></li>
<li><a href="https://github.com/apache/thrift">Apache Thrift - github</a></li>
<li><a href="https://www.infoq.cn/article/get-to-know-rpc">体系化认识 RPC</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/85033562">Thrift入门 | RPC基础&amp;&amp;Thrift概念</a></li>
<li><a href="https://diwakergupta.github.io/thrift-missing-guide/">Thrift: The Missing Guide</a></li>
</ol>
<h2 id="Thrift简介"><a class="header-anchor" href="#Thrift简介"> </a>Thrift简介</h2>
<p><strong>Thrift</strong>是一种<a href="https://zh.wikipedia.org/wiki/%E6%8E%A5%E5%8F%A3%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80">接口描述语言</a>和<strong>二进制通讯协议</strong>，它被用来定义和创建<strong>跨语言</strong>的服务。它被当作一个<a href="https://zh.wikipedia.org/wiki/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8">远程过程调用</a>（<strong>RPC</strong>）框架来使用，是由<a href="https://zh.wikipedia.org/wiki/Facebook">Facebook</a>为“大规模<strong>跨语言服务开发</strong>”而开发的。它通过一个代码生成引擎联合了一个软件栈，来创建不同程度的、无缝的<a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E5%B9%B3%E5%8F%B0">跨平台</a>高效服务，现在是<a href="https://zh.wikipedia.org/wiki/Apache%E8%BD%AF%E4%BB%B6%E5%9F%BA%E9%87%91%E4%BC%9A">Apache软件基金会</a>的<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%BA%90">开源</a>项目。</p>
<blockquote>
<p>The Apache Thrift software framework, for scalable cross-language services development, combines a software stack with a code generation engine to build services that work efficiently and seamlessly between C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, OCaml and Delphi and other languages.</p>
</blockquote>
<!-- more -->
<h3 id="Thrift架构"><a class="header-anchor" href="#Thrift架构"> </a>Thrift架构</h3>
<p>Thrift包含一套完整的<strong>栈</strong>来创建<strong>客户端</strong>和<strong>服务端</strong>程序。</p>
<ul>
<li>顶层部分是由Thrift定义生成的代码。而服务则由这个文件客户端和处理器代码生成。在生成的代码里会创建不同于内建类型的数据结构，并将其作为结果发送。</li>
<li>协议和<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82">传输层</a>是<a href="https://zh.wikipedia.org/wiki/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BA%93">运行时库</a>的一部分。有了Thrift，就可以定义一个服务或改变通讯和传输协议，而无需重新编译代码。除了客户端部分之外，Thrift还包括服务器基础设施来集成协议和传输，如阻塞、非阻塞及多线程服务器。</li>
<li>栈中作为I/O基础的部分对于不同的语言则有不同的实现</li>
</ul>
<p><img src="http://algorithm-image.qibinaoe.top/400px-Apache_Thrift_architecture.png" alt="Apache Thrift API CS架构"></p>
<p><img src="http://algorithm-image.qibinaoe.top/thrift-thrift-layers.png" alt="Apache Thrift Layered Architecture"></p>
<blockquote>
<p>Thrift支持的通信通信协议</p>
</blockquote>
<ul>
<li>TBinaryProtocol – 一种简单的二进制格式，简单，但没有为空间效率而优化。比文本协议处理起来更快，但更难于<a href="https://zh.wikipedia.org/wiki/%E8%B0%83%E8%AF%95">调试</a>。</li>
<li>TCompactProtocol – 更紧凑的二进制格式，处理起来通常同样高效。</li>
<li>TDebugProtocol – 一种人类可读的文本格式，用来协助调试。</li>
<li>TDenseProtocol – 与TCompactProtocol类似，将传输数据的元信息剥离。</li>
<li>TJSONProtocol – 使用<a href="https://zh.wikipedia.org/wiki/JSON">JSON</a>对数据编码。</li>
<li>TSimpleJSONProtocol – 一种只写协议，它不能被Thrift解析，因为它使用JSON时丢弃了元数据。适合用脚本语言来解析</li>
</ul>
<blockquote>
<p>支持的传输协议有：</p>
</blockquote>
<ul>
<li>TFileTransport – 该传输协议会写文件。</li>
<li>TFramedTransport – 当使用一个非阻塞服务器时，要求使用这个传输协议。它按帧来发送数据，其中每一帧的开头是长度信息。</li>
<li>TMemoryTransport – 使用<a href="https://zh.wikipedia.org/wiki/%E5%AD%98%E5%82%A8%E5%99%A8%E6%98%A0%E5%B0%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">存储器映射输入输出</a>。（Java的实现使用了一个简单的<code>ByteArrayOutputStream</code>。）</li>
<li>TSocket – 使用阻塞的套接字I/O来传输。</li>
<li>TZlibTransport – 用<a href="https://zh.wikipedia.org/wiki/Zlib">zlib</a>执行压缩。用于连接另一个传输协议。</li>
</ul>
<blockquote>
<p>提供的服务器：</p>
</blockquote>
<ul>
<li>TNonblockingServer – 一个多线程服务器，它使用非阻塞I/O（Java的实现使用了<a href="https://zh.wikipedia.org/wiki/Java_NIO">NIO</a>通道）。TFramedTransport必须跟这个服务器配套使用。</li>
<li>TSimpleServer – 一个单线程服务器，它使用标准的阻塞I/O。测试时很有用。</li>
<li>TThreadPoolServer – 一个多线程服务器，它使用标准的阻塞I/O。</li>
</ul>
<h3 id="Thrift论文"><a class="header-anchor" href="#Thrift论文"> </a>Thrift论文</h3>
<p><a href="https://thrift.apache.org/static/files/thrift-20070401.pdf">Thrift: Scalable Cross-Language Services Implementation</a></p>
<h2 id="安装配置Thrift环境"><a class="header-anchor" href="#安装配置Thrift环境"> </a>安装配置Thrift环境</h2>
<h3 id="Windows"><a class="header-anchor" href="#Windows"> </a>Windows</h3>
<p>从官网下载exe文件<a href="https://thrift.apache.org/download">地址</a>，将其放在一个合适文件目录下，将其改名为<code>thrift.exe</code>，并加入系统环境变量中</p>
<p><img src="http://algorithm-image.qibinaoe.top/thrift-image-20210611084119745.png" alt="image-20210611084119745"></p>
<blockquote>
<p>其他方式可通过源码编译，具体参考官方文档</p>
</blockquote>
<h2 id="Tutorial"><a class="header-anchor" href="#Tutorial"> </a>Tutorial</h2>
<p>官方文档在<a href="https://github.com/apache/thrift/tree/master/tutorial">github -tutorial</a>上</p>
<h3 id="阅读tutorial文档"><a class="header-anchor" href="#阅读tutorial文档"> </a>阅读tutorial文档</h3>
<p>以下内容包括</p>
<ul>
<li><a href="https://github.com/apache/thrift/blob/master/tutorial/tutorial.thrift">tutorial.thrift</a></li>
<li><a href="https://diwakergupta.github.io/thrift-missing-guide">Thrift: The Missing Guide</a></li>
</ul>
<blockquote>
<p>以下翻译是我凭感觉翻译，专业术语不对还请参照官方教程</p>
</blockquote>
<h4 id="Thrift类型"><a class="header-anchor" href="#Thrift类型"> </a>Thrift类型</h4>
<p>在Thrift中，有以下11种类型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool</td>
<td>Boolean, one byte</td>
</tr>
<tr>
<td>i8 (byte)</td>
<td>Signed 8-bit integer</td>
</tr>
<tr>
<td>i16</td>
<td>Signed 16-bit integer</td>
</tr>
<tr>
<td>i32</td>
<td>Signed 32-bit integer</td>
</tr>
<tr>
<td>i64</td>
<td>Signed 64-bit integer</td>
</tr>
<tr>
<td>double</td>
<td>64-bit floating point value</td>
</tr>
<tr>
<td>string</td>
<td>String</td>
</tr>
<tr>
<td>binary</td>
<td>Blob (byte array)</td>
</tr>
<tr>
<td>map&lt;t1,t2&gt;</td>
<td>Map from one type to another</td>
</tr>
<tr>
<td>list&lt;t1&gt;</td>
<td>Ordered list of one type（可能包含重复项）</td>
</tr>
<tr>
<td>set&lt;t1&gt;</td>
<td>Set of unique elements of one type</td>
</tr>
</tbody>
</table>
<p>Thrift中不支持<strong>无符号整型</strong>，因为在很多Thrift的目标语言中，没有对应的基本类型（primitive types）</p>
<p><strong>Containers:</strong></p>
<p>Thrift的容器类型由三种<code>map&lt;t1,t2&gt;</code>，<code>list&lt;t1&gt;</code>，<code>set&lt;t1&gt;</code>。同时类似Java的泛型</p>
<h4 id="引用"><a class="header-anchor" href="#引用"> </a>引用</h4>
<p>Thrift files可以引用其他的 Thrift files来包含（include）一些共用的结构（struct）和服务定义（service definitions）。这些文件将在当前路径下寻找，或者通过<code>-I</code>的编译器标记（compiler flag）来指定相对路径。</p>
<p>被引用的对象以<code>.thrift</code>文件的名字为前缀来访问，例如<code>shared.SharedObject</code></p>
<figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line">include <span class="string">&quot;shared.thrift&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line">include <span class="string">&quot;tweet.thrift&quot;</span>           </span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TweetSearchResult</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="type">list</span>&lt;tweet.Tweet&gt; tweets;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>文件名需要用双引号包含</li>
<li>语句结尾没有分号</li>
<li>需要thrift后缀</li>
</ul>
<h4 id="命名空间"><a class="header-anchor" href="#命名空间"> </a>命名空间</h4>
<p>Thrift 的namespace类似C++中的namespace或者Java中的package。</p>
<p><strong>作用:</strong></p>
<ul>
<li>便于组织代码</li>
<li>便于隔离代码，来避免在不同的类型定义（type definitions）发生命名冲突（name clashes）</li>
</ul>
<figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cl tutorial</span><br><span class="line"><span class="keyword">namespace</span> cpp tutorial</span><br><span class="line"><span class="keyword">namespace</span> d tutorial</span><br><span class="line"><span class="keyword">namespace</span> dart tutorial</span><br><span class="line"><span class="keyword">namespace</span> java tutorial</span><br><span class="line"><span class="keyword">namespace</span> php tutorial</span><br><span class="line"><span class="keyword">namespace</span> perl tutorial </span><br><span class="line"><span class="keyword">namespace</span> haxe tutorial</span><br><span class="line"><span class="keyword">namespace</span> netstd tutorial</span><br></pre></td></tr></table></figure>
<h4 id="重命名类型"><a class="header-anchor" href="#重命名类型"> </a>重命名类型</h4>
<p>Thrift通过<code>typedef 原类型名 自定义类型名</code>的方式来给类型起别名</p>
<figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">i32</span> MyInteger</span><br><span class="line"><span class="keyword">typedef</span> Tweet ReTweet</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><code>typedef</code>语句后面没有分号</li>
<li><code>typedef</code>也可用于struct</li>
</ul>
<h4 id="定义常量"><a class="header-anchor" href="#定义常量"> </a>定义常量</h4>
<p>thrift可定义跨语言的常量类型。</p>
<p>如果是复杂结构的常量可以使用json</p>
<figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="type">i32</span> INT32CONSTANT = <span class="number">9853</span></span><br><span class="line"><span class="keyword">const</span> <span class="type">map</span>&lt;<span class="type">string</span>,<span class="type">string</span>&gt; MAPCONSTANT = &#123;&#x27;hello&#x27;:&#x27;world&#x27;, &#x27;goodnight&#x27;:&#x27;moon&#x27;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="枚举类型"><a class="header-anchor" href="#枚举类型"> </a>枚举类型</h4>
<p>可自定义枚举类型，每个枚举类型是一个32bit整型。</p>
<p>如果枚举值没有指定的话，以<code>0</code>开始增加，每个常量值必须是非负的</p>
<p>枚举常量值也支持十六进制</p>
<p>后面是没有分号的</p>
<figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">  ADD = <span class="number">1</span>,</span><br><span class="line">  SUBTRACT = <span class="number">2</span>,</span><br><span class="line">  MULTIPLY = <span class="number">3</span>,</span><br><span class="line">  DIVIDE = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TweetType</span> </span>&#123;</span><br><span class="line">    TWEET,      </span><br><span class="line">    RETWEET = <span class="number">2</span>,</span><br><span class="line">    DM = <span class="number">0</span>xa,   </span><br><span class="line">    REPLY</span><br><span class="line">&#125;               </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="keyword">required</span> <span class="type">i32</span> userId;</span><br><span class="line">    <span class="number">2</span>: <span class="keyword">required</span> <span class="type">string</span> userName;</span><br><span class="line">    <span class="number">3</span>: <span class="keyword">required</span> <span class="type">string</span> text;</span><br><span class="line">    <span class="number">4</span>: <span class="keyword">optional</span> Location loc;</span><br><span class="line">    <span class="number">5</span>: <span class="keyword">optional</span> TweetType tweetType = TweetType.TWEET <span class="comment">// 5</span></span><br><span class="line">    <span class="number">16</span>: <span class="keyword">optional</span> <span class="type">string</span> language = <span class="string">&quot;english&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>对于enum默认从多少开始呢？</p>
<p>在<a href="https://github.com/apache/thrift/blob/master/tutorial/tutorial.thrift">tutorial.thrift</a>中这样写的</p>
<p><img src="http://algorithm-image.qibinaoe.top/thrift-image-20210611142834298.png" alt="image-20210611142834298"></p>
<p>在<a href="https://thrift.apache.org/docs/idl#enum">官方网站</a>上这样介绍的</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210611142921624.png" alt="image-20210611142921624"></p>
<p>在<a href="https://diwakergupta.github.io/thrift-missing-guide/#_enums">Thrift: The Missing Guide</a></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210611143059120.png" alt="image-20210611143059120"></p>
<h4 id="结构体"><a class="header-anchor" href="#结构体"> </a>结构体</h4>
<p>Thrift struct 类似 C strcut，将多个相关的项目（item）组合封装在一起，能够转换成面向对象语言中类的概念。</p>
<p>异常（Exception）在语法和功能上等同于struct。它们的区别在于：</p>
<ol>
<li>异常(exception)用关键字<code>exception</code>，而结构体（struct）用关键字<code>struct</code>
<ol>
<li>语义上不同：当定义RPC服务（PRC services），开发人员可能在声明远程方法（remote method）时抛出异常（ throws an exception）</li>
</ol>
</li>
</ol>
<p>结构体（<code>Structs</code>）是最基本的复杂数据结构。结构体由域（fields）组成，每个域由五部分组成</p>
<ol>
<li>整型标识符（integer identifier）：必须为唯一的、正整数</li>
<li>required 或者  optional</li>
<li>类型（type）</li>
<li>象征性名字（symbolic name）</li>
<li>可选默认值（ optional default value）</li>
</ol>
<p>域（fields）还可以被声明为<code>optional</code>。这意味着如果该域没有被赋值（set），那么不会包含在序列化输出（serialized output）结果中。但是对于一个<code>optional</code>声明的域，如果被赋上默认值，那么如果没有显式的赋值给该域，在序列化的过程中会以默认值输出</p>
<p>对于一个域，如果声明成<code>required</code>后，就应该一直是<code>required</code>。因为如果突然对于一个<code>required</code>域不进行写入数据或传输数据，那么接收方会认为该消息（message）是不完整的，从而拒绝该信息。</p>
<p>同时struct中也能够包含其他struct，但是struct不能继承于另一个struct</p>
<p>这特性在某些编程语言中需要手动做些处理操作。</p>
<figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Work</span> </span>&#123;</span><br><span class="line">  <span class="number">1</span>: <span class="type">i32</span> num1 = <span class="number">0</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="type">i32</span> num2,</span><br><span class="line">  <span class="number">3</span>: Operation op,</span><br><span class="line">  <span class="number">4</span>: <span class="keyword">optional</span> <span class="type">string</span> comment,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Location</span> </span>&#123;                           </span><br><span class="line">    <span class="number">1</span>: <span class="keyword">required</span> <span class="type">double</span> latitude;</span><br><span class="line">    <span class="number">2</span>: <span class="keyword">required</span> <span class="type">double</span> longitude;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="keyword">required</span> <span class="type">i32</span> userId;                  </span><br><span class="line">    <span class="number">2</span>: <span class="keyword">required</span> <span class="type">string</span> userName;             </span><br><span class="line">    <span class="number">3</span>: <span class="keyword">required</span> <span class="type">string</span> text;</span><br><span class="line">    <span class="number">4</span>: <span class="keyword">optional</span> Location loc;                </span><br><span class="line">    <span class="number">16</span>: <span class="keyword">optional</span> <span class="type">string</span> language = <span class="string">&quot;english&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，结构体（<code>Structs</code>）也可以是一种异常类型（<code>exceptions</code>）</p>
<figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">exception</span> <span class="title">InvalidOperation</span> </span>&#123;</span><br><span class="line">  <span class="number">1</span>: <span class="type">i32</span> whatOp,</span><br><span class="line">  <span class="number">2</span>: <span class="type">string</span> why</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定义服务（Service）"><a class="header-anchor" href="#定义服务（Service）"> </a>定义服务（Service）</h4>
<p>对于服务（service）的定义，在语义上等同于面向对象语言的接口（interface）或者纯虚类（pure virtual abstract class）。</p>
<p>Thrift编译器会生成实现该接口的客户端（client）和服务端（server ）</p>
<p>定义一个服务（service），需要一个<u>名字</u>，同时可以<strong>可选的</strong>继承另外一个服务，通过关键字<code>extends</code></p>
<p>Thrift编译器会所选择的编程语言生成对应的服务接口代码（ service interface code (for the server)）和对应的客户端代码（stubs (for the client)）</p>
<p>对于服务中方法（method）的定义，是类C语言的代码。需要</p>
<ol>
<li>一个返回类型（return type）：返回类型可以是基本数据类型（primitive type）也可以是结构体（structs）或void</li>
<li>方法名</li>
<li>参数（arguments）：参数可以是基本数据类型（primitive type）也可以是结构体（structs）</li>
<li>一系列异常（exceptions），如果该方法可能抛出的话</li>
</ol>
<p>**注意：**方法中的参数列表和异常列表使用相同的语法（<code>identity: structName name</code>）</p>
<p>对于<code>oneway</code>修饰的方法，这意味着当客户端向服务端发送一个request请求后，不会等待接收（listen for）服务端的任何响应（response）。因此<code>oneway</code>修饰的方法必须为<code>void</code></p>
<figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Calculator</span> extends shared.SharedService </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> ping(),</span><br><span class="line"></span><br><span class="line">   <span class="type">i32</span> add(<span class="number">1</span>:<span class="type">i32</span> num1, <span class="number">2</span>:<span class="type">i32</span> num2),</span><br><span class="line"></span><br><span class="line">   <span class="type">i32</span> calculate(<span class="number">1</span>:<span class="type">i32</span> logid, <span class="number">2</span>:Work w) throws (<span class="number">1</span>:InvalidOperation ouch),</span><br><span class="line"></span><br><span class="line">   <span class="keyword">oneway</span> <span class="keyword">void</span> zip()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注释"><a class="header-anchor" href="#注释"> </a>注释</h4>
<p>thrift注释支持shell-style, C-style multi-line，single-line Java/C++ style</p>
<figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line"># This is a valid comment.</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is a multi-line comment.</span></span><br><span class="line"><span class="comment"> * Just like in C.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++/Java style single-line comments work just as well.</span></span><br></pre></td></tr></table></figure>
<h4 id="Thrift-networdk-stack"><a class="header-anchor" href="#Thrift-networdk-stack"> </a>Thrift networdk stack</h4>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">+-------------------------------------------+</span><br><span class="line">| cGRE                                      |</span><br><span class="line">| Server                                    |</span><br><span class="line">| (single-threaded, event-driven etc)       |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">| cBLU                                      |</span><br><span class="line">| Processor                                 |</span><br><span class="line">| (compiler generated)                      |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">| cGRE                                      |</span><br><span class="line">| Protocol                                  |</span><br><span class="line">| (JSON, compact etc)                       |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">| cGRE                                      |</span><br><span class="line">| Transport                                 |</span><br><span class="line">| (raw TCP, HTTP etc)                       |</span><br><span class="line">+-------------------------------------------+</span><br></pre></td></tr></table></figure>
<p><strong>Transport 运输</strong></p>
<p>运输层（The Transport layer）为网络读写提供一层简单的抽象，使得Thrift里，底层传输与系统的其他部分（例如序列化、反序列）解耦。</p>
<p><code>Transport</code>接口方法：</p>
<ul>
<li><code>open</code></li>
<li><code>close</code></li>
<li><code>read</code></li>
<li><code>write</code></li>
<li><code>flush</code></li>
</ul>
<p>Thrift还使用<code>ServerTransport</code>接口来接收（accept）或者创建（create）基本传输对象（primitive transport objects.）。<code>ServerTransport</code>主要用于服务端（on the server side ）为新建立的连接（incoming connections）创建传输对象（create new Transport objects）</p>
<ul>
<li><code>open</code></li>
<li><code>listen</code></li>
<li><code>accpet</code></li>
<li><code>close</code></li>
</ul>
<p>Thrift支持的语言中，主要传输方式有：</p>
<ol>
<li>file: read/write to/from a file on disk</li>
<li>http: as the name suggests</li>
</ol>
<p><strong>Protocol 协议</strong></p>
<p>协议层定义了将内存中数据结构映射到网络传输形式数据的机制。换句话说，协议指定了数据类型如何使用底层传输去编码和解码它们自身数据。因此协议层管理编码方式，并且负责序列化和反序列化。从这方面将，协议包括JSON、XML、纯文本和压缩二进制（compact binary）</p>
<p>协议接口（Protocol interface）:</p>
<figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line">writeMessageBegin(name, type, seq)</span><br><span class="line">writeMessageEnd()</span><br><span class="line">writeStructBegin(name)</span><br><span class="line">writeStructEnd()</span><br><span class="line">writeFieldBegin(name, type, id)</span><br><span class="line">writeFieldEnd()</span><br><span class="line">writeFieldStop()</span><br><span class="line">writeMapBegin(ktype, vtype, size)</span><br><span class="line">writeMapEnd()</span><br><span class="line">writeListBegin(etype, size)</span><br><span class="line">writeListEnd()</span><br><span class="line">writeSetBegin(etype, size)</span><br><span class="line">writeSetEnd()</span><br><span class="line">writeBool(<span class="type">bool</span>)</span><br><span class="line">writeByte(<span class="type">byte</span>)</span><br><span class="line">writeI16(<span class="type">i16</span>)</span><br><span class="line">writeI32(<span class="type">i32</span>)</span><br><span class="line">writeI64(<span class="type">i64</span>)</span><br><span class="line">writeDouble(<span class="type">double</span>)</span><br><span class="line">writeString(<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">name, type, seq = readMessageBegin()</span><br><span class="line">                  readMessageEnd()</span><br><span class="line">name = readStructBegin()</span><br><span class="line">       readStructEnd()</span><br><span class="line">name, type, id = readFieldBegin()</span><br><span class="line">                 readFieldEnd()</span><br><span class="line">k, v, size = readMapBegin()</span><br><span class="line">             readMapEnd()</span><br><span class="line">etype, size = readListBegin()</span><br><span class="line">              readListEnd()</span><br><span class="line">etype, size = readSetBegin()</span><br><span class="line">              readSetEnd()</span><br><span class="line"><span class="type">bool</span> = readBool()</span><br><span class="line"><span class="type">byte</span> = readByte()</span><br><span class="line"><span class="type">i16</span> = readI16()</span><br><span class="line"><span class="type">i32</span> = readI32()</span><br><span class="line"><span class="type">i64</span> = readI64()</span><br><span class="line"><span class="type">double</span> = readDouble()</span><br><span class="line"><span class="type">string</span> = readString()</span><br></pre></td></tr></table></figure>
<p>由于协议（Thrift Protocols）是面向流（stream oriented）设计的，因此不需要任何显式约束或规定。比如我们在开始序列化数据之前，不需要知道一个字符串的长度或者一个列表中的元素个数</p>
<p>在Thrift支持的语言中，可以使用以下协议：</p>
<ul>
<li>binary：将一个域的长度和类型编码成字节，并在后面跟着该域的值</li>
<li>compact</li>
<li>json</li>
</ul>
<p><strong>processor 处理器</strong></p>
<p>处理器（processor）封装了从输入流中读取数据和向输出流写数据的能力。输入输出流用Protocol objects来表示</p>
<figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line">interface TProcessor &#123;</span><br><span class="line">    <span class="type">bool</span> process(TProtocol in, TProtocol out) throws TException</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用于服务端的处理器实现（Service-specific processor）由编译器生成。处理器通过输入协议从网线（wire）中读取数据，将处理数据的操作交给由用户实现的handler，再通过输出协议，将响应（response）写入网线（wire）</p>
<h4 id="Server"><a class="header-anchor" href="#Server"> </a>Server</h4>
<p>一个服务器（Server）整合了上述的network stack。</p>
<ul>
<li>创建一个传输（transport）</li>
<li>为传输创建输入输出协议</li>
<li>基于输入输出协议创建处理器（processor）</li>
<li>等待进入的连接（incoming connection），并将请求交给处理器处理</li>
</ul>
<p><strong>IDL示例</strong></p>
<figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cpp thrift.example</span><br><span class="line"><span class="keyword">namespace</span> java thrift.example</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TweetType</span> </span>&#123;</span><br><span class="line">    TWEET,</span><br><span class="line">    RETWEET = <span class="number">2</span>,</span><br><span class="line">    DM = <span class="number">0</span>xa,</span><br><span class="line">    REPLY</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Location</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="keyword">required</span> <span class="type">double</span> latitude;</span><br><span class="line">    <span class="number">2</span>: <span class="keyword">required</span> <span class="type">double</span> longitude;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="keyword">required</span> <span class="type">i32</span> userId;</span><br><span class="line">    <span class="number">2</span>: <span class="keyword">required</span> <span class="type">string</span> userName;</span><br><span class="line">    <span class="number">3</span>: <span class="keyword">required</span> <span class="type">string</span> text;</span><br><span class="line">    <span class="number">4</span>: <span class="keyword">optional</span> Location loc;</span><br><span class="line">    <span class="number">5</span>: <span class="keyword">optional</span> TweetType tweetType = TweetType.TWEET;</span><br><span class="line">    <span class="number">16</span>: <span class="keyword">optional</span> <span class="type">string</span> language = <span class="string">&quot;english&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">list</span>&lt;Tweet&gt; TweetList</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TweetSearchResult</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: TweetList tweets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">exception</span> <span class="title">TwitterUnavailable</span> </span>&#123;</span><br><span class="line">    <span class="number">1</span>: <span class="type">string</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="type">i32</span> MAX_RESULTS = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Twitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> ping(),</span><br><span class="line">    <span class="type">bool</span> postTweet(<span class="number">1</span>:Tweet tweet) throws (<span class="number">1</span>:TwitterUnavailable unavailable),</span><br><span class="line">    TweetSearchResult searchTweets(<span class="number">1</span>:<span class="type">string</span> query);</span><br><span class="line">    <span class="keyword">oneway</span> <span class="keyword">void</span> zip()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Java"><a class="header-anchor" href="#Java"> </a>Java</h3>
<h4 id="生成的文件"><a class="header-anchor" href="#生成的文件"> </a>生成的文件</h4>
<ul>
<li>单个文件（Constans.java）包含所有常量的定义</li>
<li>一个文件一个结构体（struct），一个文件一个枚举（enum），一个文件一个服务（service）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree gen-java</span></span><br><span class="line">`-- thrift</span><br><span class="line">    `-- example</span><br><span class="line">        |-- Constants.java</span><br><span class="line">        |-- Location.java</span><br><span class="line">        |-- Tweet.java</span><br><span class="line">        |-- TweetSearchResult.java</span><br><span class="line">        |-- TweetType.java</span><br><span class="line">        `-- Twitter.java</span><br></pre></td></tr></table></figure>
<p>Java语言不支持<code>typedef</code></p>
<p>That’s all for tutorial</p>
<h3 id="编译tutorial-thrift文件"><a class="header-anchor" href="#编译tutorial-thrift文件"> </a>编译tutorial.thrift文件</h3>
<p>在tutorial.thrift所在目录下，执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">thrift -r --gen cpp tutorial.thrift</span><br></pre></td></tr></table></figure>
<p>在当前目录下就会生成<code>gen-cpp</code>的文件夹</p>
<p>可以看到里面生成一系列文件</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210611102635048.png" alt="image-20210611102635048"></p>
<p>再试试生成Java代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">thrift -r --gen java tutorial.thrift</span><br></pre></td></tr></table></figure>
<p>可以看到生成<code>gen-java</code>文件</p>
<p>尝试用idea打开gen-java，可以看到gen-java的目录结构</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210612134945276.png" alt="image-20210612134945276"></p>
<h2 id="编译运行thrift-tutorial-java"><a class="header-anchor" href="#编译运行thrift-tutorial-java"> </a>编译运行thrift/tutorial/java</h2>
<h3 id="安装apache-ant"><a class="header-anchor" href="#安装apache-ant"> </a>安装apache ant</h3>
<p>阅读<a href="https://github.com/apache/thrift/blob/master/tutorial/java/README.md">readme</a>，要编译java项目需要使用make或者ant命令。因此我们先下载apache ant工具</p>
<ul>
<li><a href="http://ant.apache.org/"><em>Apache</em> <em>Ant</em> - Welcome</a>官方网站</li>
<li><a href="https://ant.apache.org/bindownload.cgi">Apache ant 下载地址</a></li>
</ul>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210612140424695.png" alt="image-20210612140424695"></p>
<p>将其下载解压，并添加系统环境变量</p>
<p>输入<code>ant -version</code>进行测试</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210612140807435.png" alt="image-20210612140807435"></p>
<h3 id="编译compiler"><a class="header-anchor" href="#编译compiler"> </a>编译compiler</h3>
<p>切换到<code>thrift/compiler/cpp</code>目录下，打开readme.md阅读阅读</p>
<p>根据<code>Prerequisites</code>所说的，安装Cmake和git bash</p>
<p>在<code>thrift\compiler\cpp</code>目录下，使用git bash 依次执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir cmake-vs &amp;&amp; cd cmake-vs</span><br><span class="line">cmake -DWITH_SHARED_LIB=off ..</span><br><span class="line">cmake --build .</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ERROR</p>
<p>在执行<code>cmake -DWITH_SHARED_LIB=off ..</code>可能会报错</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210612144508183.png" alt="image-20210612144508183"></p>
</blockquote>
<h3 id="编译java-tutorial"><a class="header-anchor" href="#编译java-tutorial"> </a>编译java tutorial</h3>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210612140922678.png" alt="image-20210612140922678"></p>
<p>可以看到<code>build.xml</code>是给ant命令的。<code>Makefile.am</code>是给make命令的</p>
<p>切换到<code>build.xml</code>所在的目录，输入<code>ant</code>命令</p>
<blockquote>
<p><strong>ERROR</strong></p>
<p>如果报<code>Execute failed: java.io.IOException: Cannot run program &quot;..\..\compiler\cpp\thrift&quot;</code>的错误的话，需要编译自行编译编译器</p>
</blockquote>
<blockquote>
<p>在windows中，配置环境过程有点劝退，所以我放弃了！</p>
<p>因为自行编译编译器需要满足下列环境要求</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210612145600801.png" alt="image-20210612145600801"></p>
</blockquote>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Thrift</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis学习笔记</title>
    <url>/2021/01/22/MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>MyBatis学习笔记</p>
<p>参考学习资料</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV185411s7Ry?p=1">2020最新MyBatis教程【IDEA版】-MyBatis从入门到精通</a></li>
<li><a href="https://github.com/mybatis/mybatis-3">MyBatisGithub</a></li>
<li><a href="https://mybatis.org/mybatis-3/">MyBatis官方文档</a></li>
<li><a href="https://baike.baidu.com/item/MyBatis/2824918?fr=aladdin">MyBatis百度百科</a></li>
</ul>
<!-- more -->
<h2 id="开发框架"><a class="header-anchor" href="#开发框架"> </a>开发框架</h2>
<h3 id="三层结构"><a class="header-anchor" href="#三层结构"> </a>三层结构</h3>
<ul>
<li>界面层（User Interface layer）
<ul>
<li>亦叫表示层、视图层。用于接受用户的数据，显示请求的处理结果</li>
<li>如html,jsp</li>
</ul>
</li>
<li>业务逻辑层（Bussiness Logic layer）
<ul>
<li>接收界面层传递过来的数据，检查数据，计算业务逻辑，调用数据访问层获取数据</li>
</ul>
</li>
<li>数据访问层（Data access layer）
<ul>
<li>也叫持久层。与数据库打交道，实现数据的增删查改。</li>
<li>将储存在数据库中的数据提交给业务层，同时将业务层处理的数据保存到数据库</li>
</ul>
</li>
</ul>
<h3 id="三层对应的包"><a class="header-anchor" href="#三层对应的包"> </a>三层对应的包</h3>
<ul>
<li>界面层 --&gt; controller包 （servlet）</li>
<li>业务逻辑层 --&gt; service包 （XXXService类）</li>
<li>数据访问层 --&gt; dao包 （XXXDao类）</li>
</ul>
<h3 id="三层对应的处理框架"><a class="header-anchor" href="#三层对应的处理框架"> </a>三层对应的处理框架</h3>
<ul>
<li>界面层 – servlet – springmvc</li>
<li>业务逻辑层 – service类 – spring</li>
<li>数据访问层 – dao类 – mybatis</li>
</ul>
<h2 id="使用JDBC缺点"><a class="header-anchor" href="#使用JDBC缺点"> </a>使用JDBC缺点</h2>
<ul>
<li>代码多，开发效率低</li>
<li>需要关注<code>Connection</code>,<code>Statement</code>,<code>ResultSet</code>对象创建和销毁</li>
<li>对于<code>ResultSet</code>查询结果需要自己封装为<code>List</code></li>
<li>重复代码多</li>
<li>业务代码和数据库的操作混在一起</li>
</ul>
<h2 id="MyBatis框架概述"><a class="header-anchor" href="#MyBatis框架概述"> </a>MyBatis框架概述</h2>
<ul>
<li>
<p>MyBatis 本是apache的一个开源项目iBatis</p>
</li>
<li>
<p>2010年该项目由apache software foundation 迁移到了[google code](<a href="https://baike.baidu.com/item/google">https://baike.baidu.com/item/google</a> code/2346604)，并且改名为MyBatis</p>
</li>
<li>
<p>2013年11月迁移到<a href="https://baike.baidu.com/item/Github/10145341">Github</a></p>
</li>
<li>
<p>iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的<a href="https://baike.baidu.com/item/%E6%8C%81%E4%B9%85%E5%B1%82/3584971">持久层</a>框架（即数据访问层）。</p>
</li>
<li>
<p>iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAOs）</p>
</li>
<li>
<p>MyBatis SQL Mapper Framework for Java sql映射框架</p>
</li>
<li>
<p>sql mapper：sql映射</p>
<ul>
<li>将数据库中的一行数据映射为一个java对象</li>
<li>一行数据可以看作一个java对象，操作这个对象相当于操作表中的数据</li>
</ul>
</li>
<li>
<p>Data Access Objects （DAOs）：数据访问，对数据库执行增删改查</p>
</li>
</ul>
<h2 id="MyBatis提供的功能"><a class="header-anchor" href="#MyBatis提供的功能"> </a>MyBatis提供的功能</h2>
<ul>
<li>提供创建<code>Connection</code>,<code>Statement</code>,<code>ResultSet</code>的能力，不需要开发人员创建这些对象</li>
<li>提供执行sql语句的能力</li>
<li>提供循环sql，将sql的结果封装成java对象，List集合的能力</li>
<li>提供关闭资源的能力，不需要手动关闭<code>Connection</code>,<code>Statement</code>,<code>ResultSet</code></li>
</ul>
<p>开发人员需要做的是：提供sql语句</p>
<p>流程为：开发人员提供sql语句-&gt;MyBatis执行sql语句-&gt;开发人员得到List集合或java对象（即表中数据）</p>
<h2 id="MyBatis环境搭建"><a class="header-anchor" href="#MyBatis环境搭建"> </a>MyBatis环境搭建</h2>
<p>到github下载MyBatis：<a href="https://github.com/mybatis/mybatis-3/releases">下载地址</a></p>
<p>这里下载<a href="https://github.com/mybatis/mybatis-3/releases/download/mybatis-3.5.1/mybatis-3.5.1.zip">mybatis-3.5.1.zip</a></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210120181409477.png" alt="image-20210120181409477"></p>
<p>下载后解压即可</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210120181543940.png" alt="image-20210120181543940"></p>
<h2 id="使用MyBatis实践"><a class="header-anchor" href="#使用MyBatis实践"> </a>使用MyBatis实践</h2>
<h3 id="创建数据库与数据"><a class="header-anchor" href="#创建数据库与数据"> </a>创建数据库与数据</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database mybatispra;</span><br><span class="line"></span><br><span class="line">use `mybatispra`;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> `student`;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `student`(</span><br><span class="line">	`id` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">	`name` <span class="type">varchar</span>(<span class="number">80</span>),</span><br><span class="line">	`email` <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">	`age` <span class="type">int</span>,</span><br><span class="line">	<span class="keyword">primary</span> key(`id`)</span><br><span class="line">)engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `student`(`id`,`name`,`email`,`age`)</span><br><span class="line"><span class="keyword">values</span> (<span class="number">1001</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;lisi@qq.com&#x27;</span>,<span class="number">20</span>),</span><br><span class="line">(<span class="number">1002</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;zhangsan@qq.com&#x27;</span>,<span class="number">28</span>);</span><br></pre></td></tr></table></figure>
<h3 id="idea中创建项目"><a class="header-anchor" href="#idea中创建项目"> </a>idea中创建项目</h3>
<p>创建一个空项目</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210120182523306.png" alt="image-20210120182523306"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210120182548275.png" alt="image-20210120182548275"></p>
<p>创建maven模块</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210120182639151.png" alt="image-20210120182639151"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210120182712510.png" alt="image-20210120182712510"></p>
<p>记得将maven改成自己本地的</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210120182802722.png" alt="image-20210120182802722"></p>
<p>又报错了，把pom.xml中<buid>标签里默认的maven插件都删掉然后重新sycn即可</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210120182836676.png" alt="image-20210120182836676"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hellomybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="实现步骤说明"><a class="header-anchor" href="#实现步骤说明"> </a>实现步骤说明</h3>
<ol>
<li>新建student表</li>
<li>加入maven的mybatis坐标，mysql驱动的坐标</li>
<li>创建实体类Student ： 用于保存表中的一行数据</li>
<li>创建持久层的dao接口： 定义操作数据库的方法</li>
<li>创建一个mybatis使用的配置文件
<ul>
<li>该文件叫做sql映射文件，用于写sql语句。</li>
<li>一般一个表一个sql映射文件</li>
<li>在接口所在的目录中</li>
<li>文件名称和接口保持一致</li>
</ul>
</li>
<li>创建mybatis的主配置文件
<ul>
<li>一个项目就一个主配置文件</li>
<li>主配置文件提供数据库的连接信息和sql映射文件的位置信息</li>
</ul>
</li>
<li>创建mybatis类：通过mybatis访问数据库</li>
</ol>
<h3 id="添加依赖"><a class="header-anchor" href="#添加依赖"> </a>添加依赖</h3>
<p>根据官方文档，在我们的pom文件中加入mybatis依赖并且指定版本</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210120183937223.png" alt="image-20210120183937223"></p>
<p>同时加入mysql驱动的依赖，并刷新一下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="创建实体类"><a class="header-anchor" href="#创建实体类"> </a>创建实体类</h3>
<p>这是idea自动生成的目录</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210120184416494.png" alt="image-20210120184416494"></p>
<p>删除<code>App</code>和<code>AppTest</code>两个类，并创建resources目录</p>
<p>在<code>src/main/java</code>创建org.example.domain包和Student实体类</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210120184604127.png" alt="image-20210120184604127"></p>
<p>这里的<code>Student</code>类名与数据库的表明一致</p>
<p>同时实体类中的属性的名和类型也和表中列名保持一致，并生成构造器以及对应的getter和setter</p>
<p>Student.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(Integer id, String name, String email, Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, email=&#x27;&quot;</span> + email + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建dao接口"><a class="header-anchor" href="#创建dao接口"> </a>创建dao接口</h3>
<p>在<code>org.example.dao</code>包中，创建<code>StudentDao</code>的接口</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210120185128149.png" alt="image-20210120185128149"></p>
<p>其中<code>StudentDao</code>接口中定义方法，这里定义一个查询student表中所有数据的方法<code>selectStudents</code></p>
<p>该方法的返回类型为<code>List&lt;Student&gt;</code>，因为student表中的一行数据代表一个<code>Student</code>对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.example.domain.Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">selectStudents</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编写sql映射文件"><a class="header-anchor" href="#编写sql映射文件"> </a>编写sql映射文件</h3>
<p>sql映射文件要与对应的dao类在同一个目录之中，同时名字与dao类一致，后缀为.xml</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210120190415320.png" alt="image-20210120190415320"></p>
<p>该sql映射文件需要符合一定的规则，可参考官方文档</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210120190451250.png" alt="image-20210120190451250"></p>
<p>官方文档xml映射语言示例</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.mybatis.example.BlogMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from Blog where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="分析"><a class="header-anchor" href="#分析"> </a>分析</h4>
<ul>
<li>sql映射文件（sql mapper）：写sql语句的，mybatis会执行这些sql</li>
</ul>
<ol>
<li>指定约束文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br></pre></td></tr></table></figure>
<p><code>mybatis-3-mapper.dtd</code>是约束文件的名称，扩展名是dtd</p>
<p>约束文件的作用：限制，检查在当前文件中出现的标签，属性必须满足mybatis的要求</p>
<ol start="2">
<li>mapper 当前文件的跟标签，是必须的</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.mybatis.example.BlogMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>namespace</code>是命名空间，唯一值，可以是自定义的字符串，但是<strong>要求</strong>使用<strong>dao接口的全限定名称</strong>（即定义操作某个表的那个接口interface所有的全限定名称：包名.接口名）</p>
<ol start="3">
<li>在当前文件中，可以使用特定的标签，表示数据库的特定操作</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  select * from Blog where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;select&gt;</code>：表示执行查询，select语句</li>
<li><code>&lt;update&gt;</code>：表示更新数据库的操作，即在<update>标签中，写update sql语句</li>
<li><code>&lt;insert&gt;</code>：表示插入，放的是insert语句</li>
<li><code>&lt;delete&gt;</code>：表示删除，执行的是delete语句</li>
</ul>
<p><code>id</code>：执行sql语句的唯一标识，mybatis会使用这个id的值来找到要执行的sql语句，可以自定义，但是<strong>要求</strong>使用接口中的<strong>方法名称</strong></p>
<p><code>resultType</code>：标识结果类型的，是sql语句执行后得到的<code>ResultSet</code>，遍历这个<code>ResultSet</code>得到的java对象的类型，值写类型的<strong>全限定名称</strong>（包名.类名）</p>
<p>标签中间写的是sql语句</p>
<p>因此，根据我们的需求，要完成在<code>StudentDao</code>接口中定义的<code>selectStudents</code>方法，我们在StudentDao.xml应该这样写</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.example.dao.StudentDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudents&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;org.example.domain.Student&quot;</span>&gt;</span></span><br><span class="line">    select `id`,`name`,`email`,`age` from student order by `id`;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210120220651934.png" alt="image-20210120220651934"></p>
<h3 id="创建主配置文件"><a class="header-anchor" href="#创建主配置文件"> </a>创建主配置文件</h3>
<p>主配置文件参考官方文档的说明</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210120221925661.png" alt="image-20210120221925661"></p>
<p>我们在<code>src/main/resources</code>目录下创建<code>mybatis-config.xml</code></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210120222043511.png" alt="image-20210120222043511"></p>
<p>将官方文档的范例复制过去再修改</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="分析-v2"><a class="header-anchor" href="#分析-v2"> </a>分析</h4>
<p>mybatis的主配置文件：主要定义了数据库的配置信息，sql映射文件的信息</p>
<ol>
<li>约束文件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>mybatis-3-config.dtd</code>是约束文件的名称</p>
<ol start="2">
<li><code>&lt;configuration&gt;</code>根标签，是配置信息</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 环境配置信息：数据库的连接信息 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- default:必须和某个environment的id值一样，</span></span><br><span class="line"><span class="comment"> 告诉mybatis要使用哪个数据库的连接信息，即访问哪个数据库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- environment: 一个数据库信息的配置，环境--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- id: 唯一值，值可以自定义， 标识环境的名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- transactionManager: mybatis的事务类型 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- type:JDBC(表示使用jdbc中的Connection对象的commit,rollback做事务处理) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- dataSource：表示数据源，连接数据库的 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- type：表示数据源的类型，POOLED表示连接池 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- driver,url, username,password是固定的，不能自定义 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 数据库驱动类型 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 连接数据库的url字符串 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 访问数据库的用户名 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 密码 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 另外一个数据库信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;online&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- sql mapper(sql映射文件)的位置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 一个mapper标签指定一个文件的位置</span></span><br><span class="line"><span class="comment">		从类路径开始的路径信息。 target/classes(类路径下)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因此，在我们的mybatis-config.xml文件这些编写</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatispra&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/example/dao/StudentDao.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="pom-xml编写"><a class="header-anchor" href="#pom-xml编写"> </a>pom.xml编写</h3>
<p>由于maven构建项目时默认只将<code>src/main/java</code>中的java文件生成到target目录，所以需要配置pom.xml中的build标签，使其能够将这些sql映射文件（.xml）也能拷贝到生成文件中去</p>
<p>在pom.xml中添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="执行sql语句"><a class="header-anchor" href="#执行sql语句"> </a>执行sql语句</h3>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210120232747502.png" alt="image-20210120232747502"></p>
<p>在<code>org.example</code>包下创建个<code>MyApp</code>类来放主函数</p>
<p>这是官方文档的说明</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210120233145958.png" alt="image-20210120233145958"></p>
<p>由于我们mybatis-config.xml文件放在<code>src/resources</code>目录下，所以值直接写<code>mybatis-config.xml</code>即可</p>
<p>注意<code>Resources</code>类是<code>org.apache.ibatis</code>包下的</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210120233545490.png" alt="image-20210120233545490"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.example.domain.Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//访问mybatis读取student数据</span></span><br><span class="line">        <span class="comment">//定义mybatis主配置文件的名称，从类路径的根开始（target/classes）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">        <span class="comment">//获取SqlSession对象，从SqlSessionFactory获得</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">//指定要执行的sql语句的标识：sql映射文件中的namespace + &quot;.&quot; + 标签的id值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sqlId</span> <span class="operator">=</span> <span class="string">&quot;org.example.dao.StudentDao&quot;</span> + <span class="string">&quot;.&quot;</span> + <span class="string">&quot;selectStudents&quot;</span>;</span><br><span class="line">        <span class="comment">//执行sql语句，通过sqlId找到语句</span></span><br><span class="line">        List&lt;Student&gt; studentList = sqlSession.selectList(sqlId);</span><br><span class="line">        studentList.forEach(stu -&gt; System.out.println(stu));</span><br><span class="line">        <span class="comment">//关闭sqlSession对象</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不幸的是报错了</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210120235253830.png" alt="image-20210120235253830"></p>
<p>所以根据要求，我们修改一下mybatis-config.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatispra?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf-8<span class="symbol">&amp;amp;</span>useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=UTC&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>重新运行main函数，可以看到能够正确输出了</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121000009110.png" alt="image-20210121000009110"></p>
<p>明明改了driver还给我出现警告表示困惑，但是问题不大</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121000332312.png" alt="image-20210121000332312"></p>
<p>这里出现有个不同。如果是通过<code>maven clean</code>和<code>maven compile</code>生成的项目，因为之前pom.xml没有指定resources，所以target中没有mybatis-config.xml文件</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121092850806.png" alt="image-20210121092850806"></p>
<p>但如果是通过<code>maven clean</code>，然后点击main函数进行编译，则会包含mybatis-config.xml</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121093006406.png" alt="image-20210121093006406"></p>
<h3 id="编写插入操作"><a class="header-anchor" href="#编写插入操作"> </a>编写插入操作</h3>
<p>先在<code>StudentDao.java</code>的dao接口中，编写插入方法<code>insertStudent</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.example.domain.Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">//接口操作student表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentDao</span> &#123;</span><br><span class="line">    <span class="comment">// 查询student表的所有数据</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">selectStudents</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//插入student数据</span></span><br><span class="line">    <span class="comment">//参数：student 表示要插入数据库的数据</span></span><br><span class="line">    <span class="comment">//返回值：int 表示执行insert操作后，影响数据库的行数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insertStudent</span><span class="params">(Student student)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着在该dao接口对应的sql映射文件中<code>StudentDao.xml</code>中编写sql语句</p>
<p>在<mapper></mapper>标签内编写一条insert标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertStudent&quot;</span>&gt;</span></span><br><span class="line">    insert into `student` values(1003,&#x27;刘备&#x27;,&#x27;liubei@163.com&#x27;,70);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以这样写，但是这样的话，就把数据写死了，所以可以通过<code>#&#123;&#125;</code>来占位表示变量，其中花括号内填写变量名和方法传入对象中的属性名对应，例如传入的是<code>Student</code>对象，则插入语句这样写</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertStudent&quot;</span>&gt;</span></span><br><span class="line">    insert into `student` values(#&#123;id&#125;,#&#123;name&#125;,#&#123;email&#125;,#&#123;age&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="创建单元测试"><a class="header-anchor" href="#创建单元测试"> </a>创建单元测试</h3>
<p>在test文件夹中，创建一个<code>TestMyBatis</code>类</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121095442916.png" alt="image-20210121095442916"></p>
<p>接着编写测试方法<code>TestInsertStudent</code>，大体流程与上面的查询一致，但需要更改</p>
<p><code>String sqlId = &quot;org.example.dao.StudentDao&quot; + &quot;.&quot; + &quot;insertStudent&quot;;</code></p>
<p>以及对应的数据<code>student</code>，和执行sql方法<code>sqlSession.insert(sqlId,student);</code></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121100438831.png" alt="image-20210121100438831"></p>
<p>但是会发现在数据库中并没有插入该数据</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121100507839.png" alt="image-20210121100507839"></p>
<p>这是因为mybatis默认不是自动提交事务的，所以在<code>insert</code>,<code>update</code>,<code>delete</code>后要手动提交事务</p>
<p>因此我们在最后加入一条语句</p>
<p><code>sqlSession.commit();</code></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121100644927.png" alt="image-20210121100644927"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121100654065.png" alt="image-20210121100654065"></p>
<p>可以看到数据已经插入</p>
<p><code>TestMyBatis.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.example.domain.Student;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMyBatis</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsertStudent</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sqlId</span> <span class="operator">=</span> <span class="string">&quot;org.example.dao.StudentDao&quot;</span> + <span class="string">&quot;.&quot;</span> + <span class="string">&quot;insertStudent&quot;</span>;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.setId(<span class="number">1003</span>);</span><br><span class="line">        student.setName(<span class="string">&quot;刘备&quot;</span>);</span><br><span class="line">        student.setEmail(<span class="string">&quot;liubei@163.com&quot;</span>);</span><br><span class="line">        student.setAge(<span class="number">80</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> sqlSession.insert(sqlId,student);</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        System.out.println(<span class="string">&quot;插入数据=&quot;</span>+nums);</span><br><span class="line">        <span class="comment">//关闭sqlSession对象</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置日志"><a class="header-anchor" href="#配置日志"> </a>配置日志</h3>
<p>想要查看mybatis执行sql的具体操作，可以通过配置mybatis-config.xml中setting标签（在configuration标签内），对日志功能进行开启</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121101348130.png" alt="image-20210121101348130"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>日志开启后，重新执行查询语句</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121101436055.png" alt="image-20210121101436055"></p>
<p>有一条输出<code>Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@1ad282e0]</code></p>
<p>表示mybatis将自动提交事务关闭了</p>
<p>现在执行插入功能，先写一个新的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">student.setId(<span class="number">1004</span>);</span><br><span class="line">student.setName(<span class="string">&quot;李白&quot;</span>);</span><br><span class="line">student.setEmail(<span class="string">&quot;libai@163.com&quot;</span>);</span><br><span class="line">student.setAge(<span class="number">40</span>);</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121101713551.png" alt="image-20210121101713551"></p>
<h3 id="类的介绍"><a class="header-anchor" href="#类的介绍"> </a>类的介绍</h3>
<ol>
<li><code>Resource</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.io;</span><br><span class="line"><span class="comment">//通过classloader去访问资源</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Resources</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>mybatis中负责读取主配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>SqlSessionFactoryBuilder</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.session;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactoryBuilder</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>为了创建<code>SqlSessionFactory</code>对象，通过其<code>build</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>SqlSessionFactory</code></li>
</ol>
<p>该对象为重量级对象：程序创建一个对象耗时比较长，使用资源比较多。在整个项目中，有一个就够了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.session;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an &#123;<span class="doctag">@link</span> SqlSession&#125; out of a connection or a DataSojavaurc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SqlSessionFactory</span> &#123;</span><br><span class="line">  SqlSession <span class="title function_">openSession</span><span class="params">()</span>;</span><br><span class="line">  SqlSession <span class="title function_">openSession</span><span class="params">(<span class="type">boolean</span> autoCommit)</span>;</span><br><span class="line">  SqlSession <span class="title function_">openSession</span><span class="params">(Connection connection)</span>;</span><br><span class="line">  SqlSession <span class="title function_">openSession</span><span class="params">(TransactionIsolationLevel level)</span>;</span><br><span class="line">  SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType)</span>;</span><br><span class="line">  SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType, <span class="type">boolean</span> autoCommit)</span>;</span><br><span class="line">  SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level)</span>;</span><br><span class="line">  SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType, Connection connection)</span>;</span><br><span class="line">  Configuration <span class="title function_">getConfiguration</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SqlSessionFactory</code>是一个接口，其接口的实现类为<code>DefaultSqlSessionFactory</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.session.defaults;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSqlSessionFactory</span> <span class="keyword">implements</span> <span class="title class_">SqlSessionFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">DefaultSqlSessionFactory</span><span class="params">(Configuration configuration)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.configuration = configuration;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> SqlSession <span class="title function_">openSession</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> SqlSession <span class="title function_">openSession</span><span class="params">(<span class="type">boolean</span> autoCommit)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="literal">null</span>, autoCommit);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> openSessionFromDataSource(execType, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> SqlSession <span class="title function_">openSession</span><span class="params">(TransactionIsolationLevel level)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), level, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> openSessionFromDataSource(execType, level, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType, <span class="type">boolean</span> autoCommit)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> openSessionFromDataSource(execType, <span class="literal">null</span>, autoCommit);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> SqlSession <span class="title function_">openSession</span><span class="params">(Connection connection)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> openSessionFromConnection(configuration.getDefaultExecutorType(), connection);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType, Connection connection)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> openSessionFromConnection(execType, connection);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Configuration <span class="title function_">getConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> configuration;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> SqlSession <span class="title function_">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="type">boolean</span> autoCommit)</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> SqlSession <span class="title function_">openSessionFromConnection</span><span class="params">(ExecutorType execType, Connection connection)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> TransactionFactory <span class="title function_">getTransactionFactoryFromEnvironment</span><span class="params">(Environment environment)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">closeTransaction</span><span class="params">(Transaction tx)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SqlSessionFactory</code>是为了获取<code>Session</code>对象</p>
<p>其中</p>
<p><code>openSession()</code>获取的是非自动提交事务的<code>SqlSession</code>对象</p>
<p><code>openSession(boolean autoCommit)</code>如果传入<code>true</code>：<code>openSession(true)</code>，则获取自动提交事务的<code>SqlSession</code>对象</p>
<ol start="4">
<li><code>SqlSession</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.session;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The primary Java interface for working with MyBatis.</span></span><br><span class="line"><span class="comment"> * Through this interface you can execute commands, get mappers and manage transactions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SqlSession</span> <span class="keyword">extends</span> <span class="title class_">Closeable</span> &#123;</span><br><span class="line"></span><br><span class="line">  &lt;T&gt; T <span class="title function_">selectOne</span><span class="params">(String statement)</span>;</span><br><span class="line">  &lt;T&gt; T <span class="title function_">selectOne</span><span class="params">(String statement, Object parameter)</span>;</span><br><span class="line">  &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement)</span>;</span><br><span class="line">  &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter)</span>;</span><br><span class="line">  &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span>;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">insert</span><span class="params">(String statement)</span>;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">insert</span><span class="params">(String statement, Object parameter)</span>;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">update</span><span class="params">(String statement)</span>;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">update</span><span class="params">(String statement, Object parameter)</span>;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">delete</span><span class="params">(String statement, Object parameter)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">boolean</span> force)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(<span class="type">boolean</span> force)</span>;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">  &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type)</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SqlSession</code>接口定义了操作数据的方法，实现类为<code>DefaultSqlSession</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.session.defaults;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default implementation for &#123;<span class="doctag">@link</span> SqlSession&#125;.</span></span><br><span class="line"><span class="comment"> * Note that this class is not Thread-Safe.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSqlSession</span> <span class="keyword">implements</span> <span class="title class_">SqlSession</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>SqlSession</code>对象不是线程安全的，</p>
<p>需要在方法内部使用，在执行sql语句之前，使用<code>openSession</code>获取<code>SqlSession</code>对象。在执行完sql语句后，需要关闭它，执行<code>SqlSession.close()</code></p>
</blockquote>
<h3 id="工具类封装"><a class="header-anchor" href="#工具类封装"> </a>工具类封装</h3>
<p>在<code>org.example</code>下创建个工具类<code>MyBatisUtils</code></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121112848413.png" alt="image-20210121112848413"></p>
<p>定义获取<code>sqlSession</code>的方法</p>
<p>因此在静态块中首先初始化<code>SqlSessionFactory</code></p>
<p>MyBatisUtils.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title function_">getSqlSession</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(sqlSessionFactory != <span class="literal">null</span>)&#123;</span><br><span class="line">            sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sqlSession;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="工具类的使用"><a class="header-anchor" href="#工具类的使用"> </a>工具类的使用</h3>
<p>接下来在<code>MyApp.java</code>中就不需要自己创建<code>SqlSessionFactory</code>去获取<code>SqlSession</code>对象了，只需通过工具类<code>MyBatisUtils.getSqlSession()</code></p>
<p>MyApp.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.example.domain.Student;</span><br><span class="line"><span class="keyword">import</span> org.example.utils.MyBatisUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtils.getSqlSession();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sqlId</span> <span class="operator">=</span> <span class="string">&quot;org.example.dao.StudentDao&quot;</span> + <span class="string">&quot;.&quot;</span> + <span class="string">&quot;selectStudents&quot;</span>;</span><br><span class="line">        List&lt;Student&gt; studentList = sqlSession.selectList(sqlId);</span><br><span class="line">        studentList.forEach(stu -&gt; System.out.println(stu));</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MyBatis-dao实践"><a class="header-anchor" href="#MyBatis-dao实践"> </a>MyBatis-dao实践</h2>
<p>可以看到上一个实践中，实际上没有用到<code>StudentDao.java</code>中的接口，而是指定sql映射文件就完成sql操作</p>
<p>这里创建一个使用dao的方式的mybatis</p>
<h3 id="idea创建项目"><a class="header-anchor" href="#idea创建项目"> </a>idea创建项目</h3>
<p>创建一个新的模块<code>mybatis-dao</code></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121130859791.png" alt="image-20210121130859791"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121130939924.png" alt="image-20210121130939924"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121132001852.png" alt="image-20210121132001852"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121131031746.png" alt="image-20210121131031746"></p>
<p>修改pom.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-dao<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>同时创建resources文件夹</p>
<h3 id="创建实体类Student和dao接口StudentDao"><a class="header-anchor" href="#创建实体类Student和dao接口StudentDao"> </a>创建实体类<code>Student</code>和dao接口<code>StudentDao</code></h3>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121141905187.png" alt="image-20210121141905187"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121142029107.png" alt="image-20210121142029107"></p>
<p>Student.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(Integer id, String name, String email, Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, email=&#x27;&quot;</span> + email + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StudentDao.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.example.domain.Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentDao</span> &#123;</span><br><span class="line">    List&lt;Student&gt; <span class="title function_">selectStudents</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertStudent</span><span class="params">(Student student)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="创建配置文件"><a class="header-anchor" href="#创建配置文件"> </a>创建配置文件</h3>
<p>这里可以借助idea的模板方法快速生成</p>
<p>打开idea的settings界面</p>
<p>创建sql映射文件的模板</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121142616309.png" alt="image-20210121142616309"></p>
<p>模板内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.mybatis.example.BlogMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from Blog where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>创建主配置文件mybatis-config的模板</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121142823027.png" alt="image-20210121142823027"></p>
<p>模板内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatispra?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf-8<span class="symbol">&amp;amp;</span>useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=UTC&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/example/dao/StudentDao.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后创建sql配置文件<code>StudentDao.xml</code></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121142936729.png" alt="image-20210121142936729"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.example.dao.StudentDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudents&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;org.example.domain.Student&quot;</span>&gt;</span></span><br><span class="line">        select `id`,`name`,`email`,`age` from student order by id</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertStudent&quot;</span>&gt;</span></span><br><span class="line">        insert into `student` values (#&#123;id&#125;,#&#123;name&#125;,#&#123;email&#125;,#&#123;age&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>创建主配置文件</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121143208076.png" alt="image-20210121143208076"></p>
<h3 id="创建StudentDao的实现类StudentDaoImpl"><a class="header-anchor" href="#创建StudentDao的实现类StudentDaoImpl"> </a>创建<code>StudentDao</code>的实现类<code>StudentDaoImpl</code></h3>
<p>先将之前的<code>MyBatisUtils</code>类复制过来</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121143824604.png" alt="image-20210121143824604"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title function_">getSqlSession</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(sqlSessionFactory != <span class="literal">null</span>)&#123;</span><br><span class="line">            sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sqlSession;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>在<code>org.example.dao.impl</code>创建<code>StudentDaoImpl</code>类实现<code>StudentDao</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.example.dao.StudentDao;</span><br><span class="line"><span class="keyword">import</span> org.example.domain.Student;</span><br><span class="line"><span class="keyword">import</span> org.example.utils.MyBatisUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">StudentDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">selectStudents</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtils.getSqlSession();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sqlI</span> <span class="operator">=</span> <span class="string">&quot;org.example.dao.StudentDao.selectStudents&quot;</span>;</span><br><span class="line">        List&lt;Student&gt; students = sqlSession.selectList(sqlI);</span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">        <span class="keyword">return</span> students;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insertStudent</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtils.getSqlSession();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sqlId</span> <span class="operator">=</span> <span class="string">&quot;org.example.dao.StudentDao.insertStudent&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> sqlSession.insert(sqlId, student);</span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编写测试类"><a class="header-anchor" href="#编写测试类"> </a>编写测试类</h3>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121144235721.png" alt="image-20210121144235721"></p>
<p>TestMyBatis.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.example.dao.StudentDao;</span><br><span class="line"><span class="keyword">import</span> org.example.dao.impl.StudentDaoImpl;</span><br><span class="line"><span class="keyword">import</span> org.example.domain.Student;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMyBatis</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectStudents</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StudentDao</span> <span class="variable">dao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentDaoImpl</span>();</span><br><span class="line">        List&lt;Student&gt; students = dao.selectStudents();</span><br><span class="line">        <span class="keyword">for</span>(Student student : students)&#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsertStudent</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StudentDao</span> <span class="variable">dao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentDaoImpl</span>();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1005</span>,<span class="string">&quot;关羽&quot;</span>,<span class="string">&quot;guanyu@qq.com&quot;</span>,<span class="number">40</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> dao.insertStudent(student);</span><br><span class="line">        System.out.println(<span class="string">&quot;添加数量&quot;</span>+nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即可</p>
<h2 id="MyBatis动态代理"><a class="header-anchor" href="#MyBatis动态代理"> </a>MyBatis动态代理</h2>
<p>在上面使用dao的实现过程中，通过调用<code>List&lt;Student&gt; students = dao.selectStudents();</code>来获取查询结果</p>
<p>可以发现</p>
<ol>
<li>dao对象，类型是<code>StudentDao</code>，全限定名称是:<code>org.example.dao.StudentDao</code>
<ul>
<li>全限定名称为其对应的sql映射文件中的<code>namespace</code>是一致的</li>
</ul>
</li>
<li>方法名称，<code>selectStudents</code>，这个方法就是mapper文件中的id值 selectStudents</li>
<li>通过dao方法的返回值也可以确定MyBatis要调用的SqlSession方法
<ul>
<li>如果返回值是List，调用的是<code>SqlSession.selectList()</code>方法
<ul>
<li>如果返回值是int，或是非List的，看mapper文件中的标签是<insert>，<update>就会调用<code>Sqlsession</code>的<code>insert</code>,<code>update</code>等方法</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>mybatis的动态代理</strong></p>
<p>mybatis根据dao方法的调用，获取执行sql语句的信息。</p>
<p>mybatis根据dao接口，创建出一个dao接口的实现类，并创建这个类的对象。完成<code>SqlSession</code>调用方法，访问数据库</p>
<h3 id="动态代理的使用"><a class="header-anchor" href="#动态代理的使用"> </a>动态代理的使用</h3>
<p>复制一份<code>mybatis-dao</code>并重命名为<code>mybatis-proxy</code></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121153443657.png" alt="image-20210121153443657"></p>
<p>将<code>target</code>和<code>mybatis-dao.iml</code>删除</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121153528035.png" alt="image-20210121153528035"></p>
<p>并修改pom.xml的坐标为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-proxy<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在idea中导入模块<code>mybatis-proxy</code></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121153803879.png" alt="image-20210121153803879"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121153831585.png" alt="image-20210121153831585"></p>
<p>使用动态代理的方法，mybatis会自动刚创建dao的实现类，所以我们将之前自己写的<code>StudentDaoImpl</code>删掉</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121160348019.png" alt="image-20210121160348019"></p>
<p>在<code>TestMyBatis</code>使用动态代理的方式执行sql语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.example.dao.StudentDao;</span><br><span class="line"><span class="keyword">import</span> org.example.domain.Student;</span><br><span class="line"><span class="keyword">import</span> org.example.utils.MyBatisUtils;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMyBatis</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectStudents</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//使用mybatis的动态代理机制</span></span><br><span class="line">        <span class="comment">//获取sqlSession</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtils.getSqlSession();</span><br><span class="line">        <span class="comment">//getMapper能获取dao接口对应的实现类对象</span></span><br><span class="line">        <span class="type">StudentDao</span> <span class="variable">dao</span> <span class="operator">=</span> sqlSession.getMapper(StudentDao.class);</span><br><span class="line">        List&lt;Student&gt; studentList = dao.selectStudents();</span><br><span class="line">        studentList.forEach(student -&gt; System.out.println(student));</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsertStudent</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtils.getSqlSession();</span><br><span class="line">        <span class="type">StudentDao</span> <span class="variable">dao</span> <span class="operator">=</span> sqlSession.getMapper(StudentDao.class);</span><br><span class="line">        <span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> dao.insertStudent(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1006</span>, <span class="string">&quot;诸葛亮&quot;</span>, <span class="string">&quot;zhugeliang@163.com&quot;</span>, <span class="number">49</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;插入数据=&quot;</span>+nums);</span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        sqlSession.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MyBatis传入参数"><a class="header-anchor" href="#MyBatis传入参数"> </a>MyBatis传入参数</h2>
<p>mybatis传入参数：从java代码中把数据传入到mapper文件的sql语句中</p>
<p><code>parameterType</code>：接口中方法参数的类型，该值为类型的完全限定名或别名</p>
<ul>
<li><code>&lt;select&gt;</code>，<code>&lt;insert&gt;</code>，<code>&lt;update&gt;</code>，<code>&lt;delete&gt;</code>都可以使用<code>parameterType</code>指定类型</li>
</ul>
<h3 id="传入单个参数实践"><a class="header-anchor" href="#传入单个参数实践"> </a>传入单个参数实践</h3>
<p>同上，复制<code>mybatis-proxy</code>目录，重命名为<code>mybatis-para</code>，并删除<code>mybatis-proxy.iml</code>和<code>target</code></p>
<p>同时修改pom.xml中的坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-para<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在idea中导入该模块</p>
<p>修改<code>StudentDao</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.example.domain.Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentDao</span> &#123;</span><br><span class="line">    Student <span class="title function_">selectStudentById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在dao接口中，不要使用重载方法：即不要去写同名不同参数的方法</p>
</blockquote>
<p>修改对应的sql映射文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.example.dao.StudentDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudentById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Integer&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;org.example.domain.Student&quot;</span>&gt;</span></span><br><span class="line">        select `id`,`name`,`email`,`age` from student where `id`=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里即指明传入的参数类型是<code>java.lang.Integer</code>，这里必须为类型的全限定名称，也可以是mybatis定义的别名</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121165418586.png" alt="image-20210121165418586"></p>
<p>例如可以改成</p>
<p><code>&lt;select id=&quot;selectStudentById&quot; parameterType=&quot;int&quot; resultType=&quot;org.example.domain.Student&quot;&gt;</code></p>
<p>修改<code>TestMyBatis</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.example.dao.StudentDao;</span><br><span class="line"><span class="keyword">import</span> org.example.domain.Student;</span><br><span class="line"><span class="keyword">import</span> org.example.utils.MyBatisUtils;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMyBatis</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectStudents</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtils.getSqlSession();</span><br><span class="line">        <span class="type">StudentDao</span> <span class="variable">dao</span> <span class="operator">=</span> sqlSession.getMapper(StudentDao.class);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> dao.selectStudentById(<span class="number">1002</span>);</span><br><span class="line">        System.out.println(student);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，parameterType不是强制的，因为mybatis通过反射机制能够发现接口参数的类型，所以可以不写</p>
</blockquote>
<p>在上面的语句中，使用占位符<code>#&#123;&#125;</code>来给变量流出一个位置</p>
<p>一个简单类型的参数：</p>
<p>关键词：<strong>一个</strong>、<strong>简单</strong></p>
<ul>
<li>简单类型：mybatis把java的基本数据类型和String叫做简单类型</li>
<li>在mapper文件获取简单类型的一个参数的值，使用#{任意字符}，与方法中声明的形参名字不一样也没关系</li>
</ul>
<p>mybatis底层通过<code>PreparedStatement</code>来实现sql语句，其中<code>#&#123;&#125;</code>换成一个<code>?</code>占位符</p>
<h3 id="传入多个参数"><a class="header-anchor" href="#传入多个参数"> </a>传入多个参数</h3>
<p>使用<code>@Param</code>注解方式命名参数，在形参定义的前面加入<code>@Param(&quot;自定义参数名&quot;)</code></p>
<p>使用方式：<code>@Param(&quot;自定义参数名&quot;) String name</code></p>
<p>例如<code>List&lt;Student&gt; selectMultiParam(@Param(&quot;myname&quot;) String name, @Param(&quot;myage&quot;) Integer age);</code></p>
<p>因此在<code>StudentDao</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.dao;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"><span class="keyword">import</span> org.example.domain.Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentDao</span> &#123;</span><br><span class="line">    <span class="comment">//一个简单类型的参数</span></span><br><span class="line">    Student <span class="title function_">selectStudentById</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多个参数</span></span><br><span class="line">    List&lt;Student&gt; <span class="title function_">selectMultiParam</span><span class="params">(<span class="meta">@Param(&quot;myname&quot;)</span> String name,</span></span><br><span class="line"><span class="params">                                   <span class="meta">@Param(&quot;myage&quot;)</span> Integer age)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里在<code>@Param</code>内自定义的参数名对应到sql映射文件中，占位<code>#&#123;&#125;</code>内的名字</p>
<p>因此在<code>StudentDao.xml</code>这样编写</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.example.dao.StudentDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudentById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Integer&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;org.example.domain.Student&quot;</span>&gt;</span></span><br><span class="line">        select `id`,`name`,`email`,`age` from student where `id`=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectMultiParam&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;org.example.domain.Student&quot;</span>&gt;</span></span><br><span class="line">        select `id`,`name`,`email`,`age` from student where `name`=#&#123;myname&#125; or `age`=#&#123;myage&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<code>TestMyBatis.java</code>增加测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectMultiParam</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtils.getSqlSession();</span><br><span class="line">    <span class="type">StudentDao</span> <span class="variable">dao</span> <span class="operator">=</span> sqlSession.getMapper(StudentDao.class);</span><br><span class="line">    List&lt;Student&gt; studentList = dao.selectMultiParam(<span class="string">&quot;张三&quot;</span>, <span class="number">40</span>);</span><br><span class="line">    <span class="keyword">for</span>(Student student : studentList)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生=&quot;</span>+ student);</span><br><span class="line">    &#125;</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="传入对象"><a class="header-anchor" href="#传入对象"> </a>传入对象</h3>
<p>传入多个参数，这些参数为传入的这个对象参数内的属性值</p>
<p>新建一个<code>QueryParam</code>类</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121183746299.png" alt="image-20210121183746299"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.vo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueryParam</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String paramName;</span><br><span class="line">    <span class="keyword">private</span> Integer paramAge;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QueryParam</span><span class="params">(String paramName, Integer paramAge)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paramName = paramName;</span><br><span class="line">        <span class="built_in">this</span>.paramAge = paramAge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QueryParam</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getParamName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> paramName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParamName</span><span class="params">(String paramName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paramName = paramName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getParamAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> paramAge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParamAge</span><span class="params">(Integer paramAge)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paramAge = paramAge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>StudentDao</code>接口中新增方法，其形参为<code>QueryParam</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用java对象作为接口中方法的参数</span></span><br><span class="line">List&lt;Student&gt; <span class="title function_">selectMultiObject</span><span class="params">(QueryParam param)</span>;</span><br></pre></td></tr></table></figure>
<p>接着在<code>QueryParam.xml</code>写标签来执行sql</p>
<ul>
<li>这里使用java对象的属性值，作为参数实际值</li>
</ul>
<blockquote>
<p>使用的完整的语法是</p>
<p>#{属性名,javaType=类型名称,jdbcType=数据类型}</p>
<p>例如<code>name=#&#123;paramName,javaType=java.lang.String,jdbcType=VARCHAR&#125;</code></p>
<p>这里javaType指java中的属性数据类型</p>
<p>jdbcType是数据库中的数据类型</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121185004010.png" alt="image-20210121185004010"></p>
</blockquote>
<p>完整写法</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectMultiObject&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;org.example.domain.Student&quot;</span>&gt;</span></span><br><span class="line">    select `id`,`name`,`email`,`age` from student where `name`=#&#123;paramName,javaType=java.lang.String,jdbcType=VARCHAR&#125;</span><br><span class="line">    or `age`=#&#123;paramAge,javaType=java.lang.Integer,jdbcType=INTEGER&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是由于<code>javaType</code>和<code>jdbcType</code>的值mybatis反射能获取，所以可以不用写，因此简化形式:#{属性名}</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectMultiObject&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;org.example.domain.Student&quot;</span>&gt;</span></span><br><span class="line">    select `id`,`name`,`email`,`age` from student where `name`=#&#123;paramName&#125; or `age`=#&#123;paramAge&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>编写测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectMultiObject</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtils.getSqlSession();</span><br><span class="line">    <span class="type">StudentDao</span> <span class="variable">dao</span> <span class="operator">=</span> sqlSession.getMapper(StudentDao.class);</span><br><span class="line">    List&lt;Student&gt; studentList = dao.selectMultiObject(<span class="keyword">new</span> <span class="title class_">QueryParam</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>));</span><br><span class="line">    studentList.forEach(student -&gt; System.out.println(student));</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，在dao接口方法中传入的参数也可以定义为是<code>Student</code>，然后根据需要对对应的属性进行赋值。</p>
<h3 id="包名说明"><a class="header-anchor" href="#包名说明"> </a>包名说明</h3>
<ul>
<li>vo：value object，放一些储存数据的类。比如说提交请求参数，name, age。现在想把name,age传给一个servlet类，那就将这两个值封装在一个类里面</li>
<li>vo：view object，从servlet把数据返回给浏览器使用的类，表示显示结果的类</li>
<li>pojo：plain ordinary java object，普通的，有set, get方法的java类，普通的java对象</li>
<li>entity（domain域）：实体类，和数据库中的表对应的类</li>
</ul>
<h3 id="按位置传参"><a class="header-anchor" href="#按位置传参"> </a>按位置传参</h3>
<p>参数位置从0开始，引用参数语法#{arg位置}，第一个位置是<code>#&#123;arg0&#125;</code>，第二个是<code>#&#123;arg1&#125;</code></p>
<blockquote>
<p>注意，mybatis-3.3版本及之前使</p>
<p>java用#{0},#{1}方法。从mybatis3.4开始使用#{arg0}方式</p>
</blockquote>
<p>在<code>StudentDao</code>接口中写新的方法</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210121191103707.png" alt="image-20210121191103707"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多个简单类型按位置传值</span></span><br><span class="line">List&lt;Student&gt; <span class="title function_">selectMultiPosition</span><span class="params">(String name, Integer age)</span>;</span><br></pre></td></tr></table></figure>
<p>在sql映射文件中编写</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectMultiPosition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;org.example.domain.Student&quot;</span>&gt;</span></span><br><span class="line">    select `id`,`name`,`email`,`age` from student where `name` = #&#123;arg0&#125; or `age`=#&#123;arg1&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>编写测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectMultiPositon</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtils.getSqlSession();</span><br><span class="line">    <span class="type">StudentDao</span> <span class="variable">dao</span> <span class="operator">=</span> sqlSession.getMapper(StudentDao.class);</span><br><span class="line">    List&lt;Student&gt; studentList = dao.selectMultiPosition(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    studentList.forEach(student -&gt; System.out.println(student));</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过map传参"><a class="header-anchor" href="#通过map传参"> </a>通过map传参</h3>
<p>Map集合可以储存多个值，使用Map向mapper文件一次传多个参数。</p>
<p>Map集合使用<code>String</code>作为key，<code>Object</code>类型作为值来储存参数。</p>
<p>而在mapper文件中，使用<code>#&#123;key&#125;</code>来引用参数值</p>
<p>在<code>StudentDao</code>接口中新增方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多个参数使用map传参</span></span><br><span class="line">List&lt;Student&gt; <span class="title function_">selectMultiByMap</span><span class="params">(Map&lt;String,Object&gt; map)</span>;</span><br></pre></td></tr></table></figure>
<p>在<code>StudentDao.xml</code>新增select标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectMultiByMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;org.example.domain.Student&quot;</span>&gt;</span></span><br><span class="line">    select `id`,`name`,`email`,`age` from student where `name` = #&#123;myname&#125; or `age`=#&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>新增测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectMultiByMap</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtils.getSqlSession();</span><br><span class="line">    <span class="type">StudentDao</span> <span class="variable">dao</span> <span class="operator">=</span> sqlSession.getMapper(StudentDao.class);</span><br><span class="line">    Map&lt;String,Object&gt; data = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    data.put(<span class="string">&quot;myname&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    data.put(<span class="string">&quot;age&quot;</span>,<span class="number">40</span>);</span><br><span class="line">    List&lt;Student&gt; studentList = dao.selectMultiByMap(data);</span><br><span class="line">    studentList.forEach(student -&gt; System.out.println(student));</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不推荐使用map进行传参，因为map中Object对象不确定，同时select标签依赖于map的键</p>
<h3 id="和-区别"><a class="header-anchor" href="#和-区别"> </a><code>#</code>和<code>$</code>区别</h3>
<h4 id=""><a class="header-anchor" href="#"> </a><code>#</code></h4>
<ul>
<li>
<p><code>#</code>是占位符，告诉mybatis使用实际的参数值代替。</p>
</li>
<li>
<p>并且用PrepareStatement对象执行sql语句。<code>#&#123;&#125;</code>代替sql语句的<code>?</code>。</p>
</li>
<li>
<p>这种用法更安全，效率也更高</p>
</li>
</ul>
<h4 id="-v2"><a class="header-anchor" href="#-v2"> </a><code>$</code></h4>
<ul>
<li><code>$</code>是字符串替换，告诉mybatis使用<code>$</code>包含的字符串替换所在位置。</li>
<li>使用<code>Statement</code>把sql语句和<code>$&#123;&#125;</code>的内容连接起来</li>
<li>主要用于替换表名，列名，不同列排列等操作</li>
<li>安全性和效率比<code>#</code>低，有sql注入风险</li>
</ul>
<p><code>#</code>使用的select标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudentById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Integer&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;org.example.domain.Student&quot;</span>&gt;</span></span><br><span class="line">    select `id`,`name`,`email`,`age` from student where `id`=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>替换结果</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">==&gt; Preparing: select `id`,`name`,`email`,`age` from student where `id`=? </span><br><span class="line">==&gt; Parameters: 1002(Integer)</span><br></pre></td></tr></table></figure>
<p><code>$</code>使用的select标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudentById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Integer&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;org.example.domain.Student&quot;</span>&gt;</span></span><br><span class="line">    select `id`,`name`,`email`,`age` from student where `id`=$&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>替换结果</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: select `id`,`name`,`email`,`age` from student where `id`=1002 </span><br><span class="line">==&gt; Parameters: </span><br></pre></td></tr></table></figure>
<h3 id="替换列名"><a class="header-anchor" href="#替换列名"> </a><code>$</code>替换列名</h3>
<p>在<code>StudentDao</code>接口新增方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用$替换列名排序</span></span><br><span class="line">List&lt;Student&gt; select$Order(<span class="meta">@Param(&quot;colName&quot;)</span> String colName);</span><br></pre></td></tr></table></figure>
<p>新增select标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;select$Order&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;org.example.domain.Student&quot;</span>&gt;</span></span><br><span class="line">    select `id`,`name`,`email`,`age` from student order by $&#123;colName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>编写测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> testSelect$Order()&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtils.getSqlSession();</span><br><span class="line">    <span class="type">StudentDao</span> <span class="variable">dao</span> <span class="operator">=</span> sqlSession.getMapper(StudentDao.class);</span><br><span class="line">    <span class="comment">//List&lt;Student&gt; studentList = dao.select$Order(&quot;name&quot;);</span></span><br><span class="line">    List&lt;Student&gt; studentList = dao.select$Order(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    studentList.forEach(student -&gt; System.out.println(student));</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意，Mybatis排序时使用order by 动态参数，只能使用<code>$&#123;&#125;</code>，不能使用<code>#&#123;&#125;</code></strong></p>
<h2 id="Mybatis输出结果"><a class="header-anchor" href="#Mybatis输出结果"> </a>Mybatis输出结果</h2>
<p><code>resultType</code>：执行sql得到<code>ResultSet</code>转换的类型，使用类型的完全限定名或别名。</p>
<p>注意如果返回的是集合，那应该设置为集合<strong>包含的类型</strong>，而不是集合本身</p>
<p><code>resultType</code>和<code>resultMap</code>不能同时使用</p>
<h3 id="resultType结果类型"><a class="header-anchor" href="#resultType结果类型"> </a>resultType结果类型</h3>
<h4 id="对象类型"><a class="header-anchor" href="#对象类型"> </a>对象类型</h4>
<p><code>resultType</code>指sql语句执行完毕后，数据转换的java对象， java类型是任意的</p>
<p><code>resultType</code>结果类型的值</p>
<ul>
<li>类型的全限定名称， 如<code>java.lang.Integer</code></li>
<li>类型的别名， 如<code>int</code></li>
</ul>
<p>处理方法：</p>
<ul>
<li>mybatis执行sql语句，然后mybatis调用类的无参数构造方法，创建对象</li>
<li>mybatis把<code>ResultSet</code>指定的列值赋值给同名的属性</li>
<li>如果<code>resultType</code>指定的对象没有与列明同名的属性，则丢弃该值</li>
</ul>
<h4 id="简单类型"><a class="header-anchor" href="#简单类型"> </a>简单类型</h4>
<p>例如查询结果是一行一列的数值的话，方法返回int</p>
<p>在<code>StudentDao</code>接口新增方法声明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">countStudents</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>在mapper定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;countStudents&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">    select count(*) from student</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span>	</span><br></pre></td></tr></table></figure>
<p>新增测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCountStudents</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtils.getSqlSession();</span><br><span class="line">    <span class="type">StudentDao</span> <span class="variable">dao</span> <span class="operator">=</span> sqlSession.getMapper(StudentDao.class);</span><br><span class="line">    <span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> dao.countStudents();</span><br><span class="line">    System.out.println(<span class="string">&quot;学生总数&quot;</span>+nums);</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="返回map"><a class="header-anchor" href="#返回map"> </a>返回map</h4>
<p>sql查询结果作为Map的key和value，定义接口方法的返回类型为：<code>Map&lt;Object,Object&gt;</code></p>
<blockquote>
<p>Map作为接口返回值时，sql语句的查询结果最多只能有一条记录。如果大于一条记录就会报错</p>
</blockquote>
<p>在<code>StudentDao</code>接口中定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Object, Object&gt; <span class="title function_">selectMap</span><span class="params">(<span class="type">int</span> stuid)</span>;</span><br></pre></td></tr></table></figure>
<p>在mapper中定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.util.HashMap&quot;</span>&gt;</span></span><br><span class="line">    select `id`,`name`,`email`,`age` from student where `id`=#&#123;stuid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对应的测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectMap</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtils.getSqlSession();</span><br><span class="line">    <span class="type">StudentDao</span> <span class="variable">dao</span> <span class="operator">=</span> sqlSession.getMapper(StudentDao.class);</span><br><span class="line">    Map&lt;Object, Object&gt; map = dao.selectMap(<span class="number">1003</span>);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="resultMap结果映射"><a class="header-anchor" href="#resultMap结果映射"> </a><code>resultMap</code>结果映射</h3>
<p>指定列名和java对象属性名的对应关系</p>
<ul>
<li>自定义列值赋值给哪个属性</li>
<li>当列名和属性名不一样时，一定使用<code>resultMap</code></li>
</ul>
<p><code>resultMap</code>和<code>resultSet</code>不要一起用，二选一</p>
<p>在<code>StudentDao</code>接口声明方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Student&gt; <span class="title function_">selectAllStudents</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>在mapper中定义</p>
<p>如果使用<code>resultMap</code></p>
<ol>
<li>要先定义<code>resultMap</code></li>
<li>在<code>&lt;select&gt;</code>标签中，使用<code>resultMap</code>来引用(1)中定义的</li>
</ol>
<p>定义<code>resultMap</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义resultMap</span></span><br><span class="line"><span class="comment">        id:自定义名称，表示定义的这个resultMap</span></span><br><span class="line"><span class="comment">        type:java类型的全限定名称</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;studentMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;org.example.domain.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 列名和java属性的关系 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 主键列 使用id标签--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- column: 列名    property：java类型的属性名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 非主键列， 使用result标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAllStudents&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;studentMap&quot;</span>&gt;</span></span><br><span class="line">    select `id`,`name`,`email`,`age` from student</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectAllStudents</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtils.getSqlSession();</span><br><span class="line">    <span class="type">StudentDao</span> <span class="variable">dao</span> <span class="operator">=</span> sqlSession.getMapper(StudentDao.class);</span><br><span class="line">    List&lt;Student&gt; studentList = dao.selectAllStudents();</span><br><span class="line">    <span class="keyword">for</span>(Student student : studentList)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生=&quot;</span>+ student);</span><br><span class="line">    &#125;</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个定义的 <code>resultMap</code>可以多次使用，即在多个标签内使用</p>
<p>例如我们创建一个<code>MyStudent</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStudent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer stuid;</span><br><span class="line">    <span class="keyword">private</span> String stuname;</span><br><span class="line">    <span class="keyword">private</span> String stuemail;</span><br><span class="line">    <span class="keyword">private</span> Integer stuage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStudent</span><span class="params">(Integer stuid, String stuname, String stuemail, Integer stuage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stuid = stuid;</span><br><span class="line">        <span class="built_in">this</span>.stuname = stuname;</span><br><span class="line">        <span class="built_in">this</span>.stuemail = stuemail;</span><br><span class="line">        <span class="built_in">this</span>.stuage = stuage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStudent</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getStuid</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stuid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStuid</span><span class="params">(Integer stuid)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stuid = stuid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getStuname</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stuname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStuname</span><span class="params">(String stuname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stuname = stuname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getStuemail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stuemail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStuemail</span><span class="params">(String stuemail)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stuemail = stuemail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getStuage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stuage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStuage</span><span class="params">(Integer stuage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stuage = stuage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyStudent&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;stuid=&quot;</span> + stuid +</span><br><span class="line">                <span class="string">&quot;, stuname=&#x27;&quot;</span> + stuname + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, stuemail=&#x27;&quot;</span> + stuemail + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, stuage=&quot;</span> + stuage +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>StudentDao</code>接口新增方法，来返回<code>MyStudent</code>类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;MyStudent&gt; <span class="title function_">selectMyStudent</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>此时数据库的列名就和<code>MyStudent</code>的属性名不一致，这时候就定义一个<code>resultMap</code>来实现映射</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;myStudentMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;org.example.domain.MyStudent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;stuid&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;stuname&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;stuemail&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;stuage&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectMyStudent&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;myStudentMap&quot;</span>&gt;</span></span><br><span class="line">    select `id`,`name`,`email`,`age` from student</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>定义测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectMyStudent</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtils.getSqlSession();</span><br><span class="line">    <span class="type">StudentDao</span> <span class="variable">dao</span> <span class="operator">=</span> sqlSession.getMapper(StudentDao.class);</span><br><span class="line">    List&lt;MyStudent&gt; studentList = dao.selectMyStudent();</span><br><span class="line">    <span class="keyword">for</span>(MyStudent student : studentList)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生=&quot;</span>+ student);</span><br><span class="line">    &#125;</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="列名和属性名不一致第二种方法"><a class="header-anchor" href="#列名和属性名不一致第二种方法"> </a>列名和属性名不一致第二种方法</h3>
<p>可以对sql语句中起别名，其中这里的别名和java对象的属性名一致，即可，这样就可以用<code>resultType</code>来实现列名和属性名不一样的获取</p>
<p>定义<code>StudentDao</code>接口的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;MyStudent&gt; <span class="title function_">selectDiffProperty</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>mapper</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectDiffProperty&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;org.example.domain.MyStudent&quot;</span>&gt;</span></span><br><span class="line">    select `id` as `stuid`,`name` as `stuname`,`email` as `stuemail`,`age` as `stueage`from student</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectDiffProperty</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtils.getSqlSession();</span><br><span class="line">    <span class="type">StudentDao</span> <span class="variable">dao</span> <span class="operator">=</span> sqlSession.getMapper(StudentDao.class);</span><br><span class="line">    List&lt;MyStudent&gt; studentList = dao.selectDiffProperty();</span><br><span class="line">    <span class="keyword">for</span>(MyStudent student : studentList)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生=&quot;</span>+ student);</span><br><span class="line">    &#125;</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定义别名"><a class="header-anchor" href="#定义别名"> </a>定义别名</h2>
<p>在<code>mybatis-config.xml</code>主配置文件中定义，使用<typeAlias>定义别名（位于<typeAliases>标签内）</p>
<p>注意<typeAliases>标签放置的位置</p>
<p><img src="/image-20210122084124662.png" alt="image-20210122084124662"></p>
<p>可以在mapper中的<code>resultType</code>内使用自定义别名</p>
<p>定义别名有两种形式</p>
<ol>
<li>使用<typeAlias></li>
</ol>
<p>可以指定一个类型一个自定义别名</p>
<p><code>type</code>：自定义类型的全限定名称</p>
<p><code>alias</code>：别名（短小，容易记）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;org.example.domain.Student&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;stu&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样，对应的mapper中的<code>resultType</code>这样写即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudentById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Integer&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;stu&quot;</span>&gt;</span></span><br><span class="line">    select `id`,`name`,`email`,`age` from student where `id`=#&#123;myid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用<package></li>
</ol>
<p><code>name</code>是包名。这个包中的所有的类，类名就是别名</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;org.example.domain&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因此对应的mapper中的语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudentById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Integer&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">    select `id`,`name`,`email`,`age` from student where `id`=#&#123;myid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是注意，如果定义了两个<package>，但这两个不同包中存在同名的类，则会出错</p>
<h2 id="模糊查询like"><a class="header-anchor" href="#模糊查询like"> </a>模糊查询like</h2>
<p>本质上其实就是使用sql的like方法，只是可以用java动态的指定like内容</p>
<p>在<code>StudentDao</code>接口声明方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Student&gt; <span class="title function_">selectLike</span><span class="params">(String name)</span>;</span><br></pre></td></tr></table></figure>
<p>在mapper中指定</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;org.example.domain.Student&quot;</span>&gt;</span></span><br><span class="line">    select `id`,`name`,`email`,`age` from student where `name`like #&#123;name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectLike</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtils.getSqlSession();</span><br><span class="line">    <span class="type">StudentDao</span> <span class="variable">dao</span> <span class="operator">=</span> sqlSession.getMapper(StudentDao.class);</span><br><span class="line">    List&lt;Student&gt; studentList = dao.selectLike(<span class="string">&quot;%李%&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(Student student : studentList)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生=&quot;</span>+ student);</span><br><span class="line">    &#125;</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态sql"><a class="header-anchor" href="#动态sql"> </a>动态sql</h2>
<p>sql的内容是变化的，可以根据条件获取到不同的sql语句</p>
<p>主要是where部分发生变化</p>
<p>动态sql的实现，使用的是mybatis提供的标签，<code>&lt;if&gt;</code>, <code>&lt;where&gt;</code>, <code>&lt;foreach&gt;</code></p>
<ul>
<li><code>&lt;if&gt;</code>是判断条件的</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;判断java对象的属性值&quot;</span>&gt;</span></span><br><span class="line">    部分sql语句</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="动态sql实践"><a class="header-anchor" href="#动态sql实践"> </a>动态sql实践</h3>
<p>拷贝新模块,该删除的删除</p>
<p>修改pom.xml坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-dynamicsql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用动态sql，用java对象进行传参</p>
<h4 id="if标签"><a class="header-anchor" href="#if标签"> </a>if标签</h4>
<p>在<code>StudentDao</code>接口定义方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Student&gt; <span class="title function_">selectStudentIf</span><span class="params">(Student student)</span>;</span><br></pre></td></tr></table></figure>
<p>在mapper定义<code>&lt;select&gt;</code>标签，内部嵌套<code>&lt;if&gt;</code></p>
<p>在<code>&lt;if&gt;</code>标签中，<code>test=&quot;使用参数java对象的属性值作为判断条件， 语法： 属性=xxx值&quot;</code></p>
<p>同时，为了避免出现<code>where and age &gt; 10</code>这种情况，可以在<code>where</code>后面加一个恒等条件</p>
<p>mapper</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudentIf&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;org.example.domain.Student&quot;</span>&gt;</span></span><br><span class="line">    select `id`,`name`,`email`,`age` from student</span><br><span class="line">    where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        and `name` = #&#123;name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age &gt; 0&quot;</span>&gt;</span></span><br><span class="line">        and `age` &gt; #&#123;age&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectStudentIf</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtils.getSqlSession();</span><br><span class="line">    <span class="type">StudentDao</span> <span class="variable">dao</span> <span class="operator">=</span> sqlSession.getMapper(StudentDao.class);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    student.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    student.setAge(<span class="number">20</span>);</span><br><span class="line">    List&lt;Student&gt; students = dao.selectStudentIf(student);</span><br><span class="line">    students.forEach(stu -&gt; System.out.println(stu));</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="where标签"><a class="header-anchor" href="#where标签"> </a>where标签</h4>
<ul>
<li><code>&lt;where&gt;</code>标签，在有查询条件时，可以自动添加上<code>where</code>语句。在没有查询条件时，不会添加<code>where</code>子句</li>
<li>如果<code>&lt;where&gt;</code>标签中有条件成立，如果第一个条件<code>&lt;if&gt;</code>前面带有关键字<code>and</code>,<code>or</code>等，<code>&lt;where&gt;</code>标签会自动去除，但是对于第二个及之后的<code>&lt;if&gt;</code>标签，必须自己带上<code>and</code>,<code>or</code>，否则会出错</li>
</ul>
<p>在<code>StudentDao</code>接口新增方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Student&gt; <span class="title function_">selectStudentWhere</span><span class="params">(Student student)</span>;</span><br></pre></td></tr></table></figure>
<p>mapper</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudentWhere&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;org.example.domain.Student&quot;</span>&gt;</span></span><br><span class="line">    select `id`,`name`,`email`,`age` from student</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            name = #&#123;name&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age &gt; 0&quot;</span>&gt;</span></span><br><span class="line">            and age &gt; 20</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectStudentWhere</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtils.getSqlSession();</span><br><span class="line">    <span class="type">StudentDao</span> <span class="variable">dao</span> <span class="operator">=</span> sqlSession.getMapper(StudentDao.class);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    student.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    student.setAge(<span class="number">20</span>);</span><br><span class="line">    List&lt;Student&gt; students = dao.selectStudentWhere(student);</span><br><span class="line">    students.forEach(stu -&gt; System.out.println(stu));</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="foreach标签"><a class="header-anchor" href="#foreach标签"> </a>foreach标签</h4>
<p><code>&lt;foreach&gt;</code>循环java中的数组，list集合。主要用在sql的<code>in</code>语句中</p>
<p>在<code>StudentDao</code>接口定义方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Student&gt; <span class="title function_">selectForeachOne</span><span class="params">(List&lt;Integer&gt; idlist)</span>;</span><br></pre></td></tr></table></figure>
<p>在<code>foreach</code>标签中</p>
<ul>
<li><code>collection</code>：表示接口中方法参数的类型，如果是数组使用<code>array</code>，如果是list集合使用<code>list</code></li>
<li><code>item</code> ：自定义的，表示数组中集合成员的变量</li>
<li><code>open</code>：循环开始的字符</li>
<li><code>close</code>：循环结束的字符</li>
<li><code>separator</code>：集合成员之间的分隔符</li>
</ul>
<p><code>&lt;foreach&gt;</code>标签本质上执行的是字符串拼接的操作，即将集合中的成员变量以一定的形式拼接在一起</p>
<p>mapper</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectForeachOne&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;org.example.domain.Student&quot;</span>&gt;</span></span><br><span class="line">    select `id`,`name`,`email`,`age` from student where id in</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;stuid&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        #&#123;stuid&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectForeachOne</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtils.getSqlSession();</span><br><span class="line">    <span class="type">StudentDao</span> <span class="variable">dao</span> <span class="operator">=</span> sqlSession.getMapper(StudentDao.class);</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">1002</span>);</span><br><span class="line">    list.add(<span class="number">1003</span>);</span><br><span class="line">    List&lt;Student&gt; students = dao.selectForeachOne(list)</span><br><span class="line">        students.forEach(stu -&gt; System.out.println(stu));</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果数组或集合中的成员是对象的话，而我们需要使用到的是对象的属性值，那么使用<code>#&#123;item.属性名&#125;</code></p>
<p>例如在<code>StudentDao</code>接口新增方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Student&gt; <span class="title function_">selectForeachTwo</span><span class="params">(List&lt;Student&gt; stulist)</span>;</span><br></pre></td></tr></table></figure>
<p>mapper</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectForeachTwo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;org.example.domain.Student&quot;</span>&gt;</span></span><br><span class="line">    select `id`,`name`,`email`,`age` from student where id in</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        #&#123;stu.id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectForeachTwo</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtils.getSqlSession();</span><br><span class="line">    <span class="type">StudentDao</span> <span class="variable">dao</span> <span class="operator">=</span> sqlSession.getMapper(StudentDao.class);</span><br><span class="line">    List&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    student1.setId(<span class="number">1003</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    student2.setId(<span class="number">1002</span>);</span><br><span class="line">    list.add(student1);</span><br><span class="line">    list.add(student2);</span><br><span class="line">    List&lt;Student&gt; students = dao.selectForeachTwo(list);</span><br><span class="line">    students.forEach(stu -&gt; System.out.println(stu));</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sql代码片段"><a class="header-anchor" href="#sql代码片段"> </a>sql代码片段</h2>
<p><code>&lt;sql&gt;</code>标签用于定义sql的代码片段，以便其他sql标签进行复用。</p>
<p>在需要使用该sql片段中，需要使用<code>&lt;include&gt;</code>子标签</p>
<p>例如在mapper中</p>
<p>对于</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudentIf&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;org.example.domain.Student&quot;</span>&gt;</span></span><br><span class="line">    select `id`,`name`,`email`,`age` from student</span><br><span class="line">    where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        and `name` = #&#123;name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age &gt; 0&quot;</span>&gt;</span></span><br><span class="line">        and `age` &gt; #&#123;age&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们可以将<code>select </code>id<code>,</code>name<code>,</code>email<code>,</code>age<code> from student</code>提取出来</p>
<p>所以定义一个sql代码片段</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;studentSql&quot;</span>&gt;</span></span><br><span class="line">    select `id`,`name`,`email`,`age` from student</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后要引用的时候用<code>refid</code>来指定引用的是哪个代码片段</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudentIf&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;org.example.domain.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;studentSql&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        and `name` = #&#123;name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age &gt; 0&quot;</span>&gt;</span></span><br><span class="line">        and `age` &gt; #&#123;age&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>即可</p>
<h2 id="mybatis-config-xml主配置文件"><a class="header-anchor" href="#mybatis-config-xml主配置文件"> </a>mybatis-config.xml主配置文件</h2>
<p>主配置文件的结果大致如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;org.example.domain&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatispra?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf-8<span class="symbol">&amp;amp;</span>useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=UTC&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/example/dao/StudentDao.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="设置（settings）"><a class="header-anchor" href="#设置（settings）"> </a>设置（settings）</h3>
<p>对于<code>&lt;settings&gt;&lt;/settings&gt;</code>标签有以下配置信息，截图来自官方<a href="https://mybatis.org/mybatis-3/zh/configuration.html#settings">settings配置</a></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210122140259076.png" alt="image-20210122140259076"></p>
<h3 id="类型别名（typeAliases）"><a class="header-anchor" href="#类型别名（typeAliases）"> </a>类型别名（typeAliases）</h3>
<p>截图来自官方</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210122140721514.png" alt="image-20210122140721514"><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases">类型别名</a></p>
<h3 id="环境配置（environments）"><a class="header-anchor" href="#环境配置（environments）"> </a>环境配置（environments）</h3>
<p><code>dataSource</code>中指实现<code>DataSource</code>接口的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> javax.sql;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DataSource</span>  <span class="keyword">extends</span> <span class="title class_">CommonDataSource</span>, Wrapper &#123;</span><br><span class="line">  Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line">  Connection <span class="title function_">getConnection</span><span class="params">(String username, String password)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mybatis实现了两个实现<code>DataSource</code>接口的类<code>PooledDataSource</code>和<code>UnpooledDataSource</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.datasource.pooled;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PooledDataSource</span> <span class="keyword">implements</span> <span class="title class_">DataSource</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.datasource.unpooled;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnpooledDataSource</span> <span class="keyword">implements</span> <span class="title class_">DataSource</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- transactionManager：mybatis回顾事务，回滚事务的方法</span></span><br><span class="line"><span class="comment">                type：事务处理的类型</span></span><br><span class="line"><span class="comment">                1) JDBC：表示mybatis底层是调用JDBC中的Connection对象的，commit, rollback</span></span><br><span class="line"><span class="comment">                2) MANAGED：把mybatis的事务处理委托给其他的容器（一个服务器软件，一个框架（SPRING））</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- dataSource：表示数据源，java体系中，规定实现了javax.sql.DataSource接口的都是数据源</span></span><br><span class="line"><span class="comment">                数据源表示Connection对象的</span></span><br><span class="line"><span class="comment">                type：指定数据源的类型</span></span><br><span class="line"><span class="comment">                1) POOLED:使用连接池，mybatis会创建PooledDataSource类</span></span><br><span class="line"><span class="comment">                2) UNPOOLED:不使用连接池，在每次执行sql语句，先创建连接，执行sql，再关闭连接</span></span><br><span class="line"><span class="comment">                    mybatis会创建一个UnPooledDataSource.管理Comnection对象的使用</span></span><br><span class="line"><span class="comment">                3） JNDI:java命名和目录服务</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatispra?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf-8<span class="symbol">&amp;amp;</span>useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=UTC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="映射器（mappers）"><a class="header-anchor" href="#映射器（mappers）"> </a>映射器（mappers）</h3>
<p>截图来自官网<a href="https://mybatis.org/mybatis-3/zh/configuration.html#mappers">mappers</a></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210122145335713.png" alt="image-20210122145335713"></p>
<p>主要使用两种方式来指定mapper</p>
<p>第一种方式：指定多个mapper文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/example/dao/StudentDao.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/example/dao/OrderDao.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第二种方式：使用包名</p>
<p><code>name</code>：xml文件（mapper文件）所在的包名，这个包名中所有xml文件都能一次性加载给mybatis</p>
<p>使用<package>标签的要求</p>
<ol>
<li>mapper文件名称需要和dao接口名称一样，区分大小写一样</li>
<li>mapper文件和dao接口需要在同一目录</li>
</ol>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210122145655659.png" alt="image-20210122145655659"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;org.example.dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="属性配置文件"><a class="header-anchor" href="#属性配置文件"> </a>属性配置文件</h2>
<p>数据库的属性配置文件：把数据库连接信息放到一个单独的文件中。</p>
<p>把mybatis-config主配置文件分开，目的是便于修改和保存，处理多个数据库的信息</p>
<h3 id="操作步骤-v3"><a class="header-anchor" href="#操作步骤-v3"> </a>操作步骤</h3>
<ol>
<li>
<p>在<code>resources</code>目录中定义一个属性配置文件：命名为：<code>xxxx.properties</code>，如<code>jdbc.properties</code></p>
<ul>
<li>
<p>在属性配置文件中，定义数据，格式为：key=value</p>
</li>
<li>
<p>对于key，一般使用<code>.</code>来做多级目录，例如<code>jdbc.mysql.driver</code></p>
</li>
<li>
<pre><code class="language-properties">jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://.....
jdbc.username=root
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 在mybatis的主配置文件，使用`&lt;properties&gt;`指定文件的位置。在需要使用值的地方，使用`$&#123;key&#125;`</span><br><span class="line"></span><br><span class="line">### 实践</span><br><span class="line"></span><br><span class="line">在`resources`目录下创建文件`jdbc.properties`</span><br><span class="line"></span><br><span class="line">![image-20210122143250777](http://algorithm-image.qibinaoe.top/image-20210122143250777.png)</span><br><span class="line"></span><br><span class="line">输入内容</span><br><span class="line"></span><br><span class="line">```properties</span><br><span class="line">jdbc.driver=com.mysql.cj.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:3306/mybatispra?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>注意，由于之前在xml中写url,所以用到<code>&amp;</code>的地方，都需要使用<code>&amp;amp;</code>进行转义。但是在properties文件中，直接用<code>&amp;</code>就可以了，如果使用转义字符则会报错</p>
</blockquote>
<p>在mybatis-config.xml内创建<code>&lt;properties&gt;</code>标签，<code>resource</code>指定properties文件的位置，从类路径根开始找文件</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210122144141250.png" alt="image-20210122144141250"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>接着在下面<code>environment</code>中修改数据库连接信息的<code>&lt;property&gt;</code>，使用<code>$&#123;key&#125;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="PageHelper插件"><a class="header-anchor" href="#PageHelper插件"> </a>PageHelper插件</h2>
<p>github地址：<a href="https://github.com/pagehelper/Mybatis-PageHelper">Mybatis-PageHelper</a></p>
<p>通过maven添加依赖的方式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>latest version<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里版本导入<code>5.1.10</code>，所以这样导入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接着在mybatis-config.xml文件中添加插件</p>
<p>注意，在这主配置文件中，标签顺序应该如下</p>
<ol>
<li>properties</li>
<li>settings</li>
<li>typeAliases</li>
<li>typeHandlers</li>
<li>objectFactory</li>
<li>objectWrapperFactory</li>
<li>plugins</li>
<li>environments</li>
<li>databaseIdProvider</li>
<li>mappers</li>
</ol>
<p>所以这个<code>&lt;plugins&gt;</code>标签要放在<code>&lt;environments&gt;</code>标签之前</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210122152022453.png" alt="image-20210122152022453"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用实践"><a class="header-anchor" href="#使用实践"> </a>使用实践</h3>
<p>在<code>StudentDao</code>接口定义方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Student&gt; <span class="title function_">selectAllPageHelper</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>在mapper中定义select标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAllPageHelper&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;org.example.domain.Student&quot;</span>&gt;</span></span><br><span class="line">    select * from `student` order by `id`</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>编写测试方法</p>
<p>PageHelper写在select语句之前，它会影响它之后的第一条select语句</p>
<p>对于<code>PageHelper.startPage(int pageNum, int pageSize)</code>参数意义</p>
<ul>
<li><code>pageNum</code>第几页（这里第0页和第1页输出结果是一样的，所以其实从第1页开始计数）</li>
<li><code>pageSize</code>一页多少数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectAllPageHelper</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtils.getSqlSession();</span><br><span class="line">    <span class="type">StudentDao</span> <span class="variable">dao</span> <span class="operator">=</span> sqlSession.getMapper(StudentDao.class);</span><br><span class="line">    PageHelper.startPage(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    List&lt;Student&gt; studentList = dao.selectAllPageHelper();</span><br><span class="line">    studentList.forEach(stu -&gt; System.out.println(stu));</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出信息</p>
<p>可以看到其先获得记录的总数目，然后计算得出在sql语句中拼接limit</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: SELECT count(0) FROM `student` </span><br><span class="line">==&gt; Parameters: </span><br><span class="line">&lt;==    Columns: count(0)</span><br><span class="line">&lt;==        Row: 6</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">==&gt;  Preparing: select * from `student` order by `id` LIMIT ?, ? </span><br><span class="line">==&gt; Parameters: 3(Integer), 3(Integer)</span><br><span class="line">&lt;==    Columns: id, name, email, age</span><br><span class="line">&lt;==        Row: 1004, 李白, libai@163.com, 40</span><br><span class="line">&lt;==        Row: 1005, 关羽, guanyu@qq.com, 40</span><br><span class="line">&lt;==        Row: 1006, 诸葛亮, zhugeliang@163.com, 49</span><br><span class="line">&lt;==      Total: 3</span><br></pre></td></tr></table></figure>
<p>其中全部数据的顺序应该是如下</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&lt;==    Columns: id, name, email, age</span><br><span class="line">&lt;==        Row: 1001, 李四, lisi@qq.com, 20</span><br><span class="line">&lt;==        Row: 1002, 张三, zhangsan@qq.com, 28</span><br><span class="line">&lt;==        Row: 1003, 刘备, liubei@163.com, 80</span><br><span class="line">&lt;==        Row: 1004, 李白, libai@163.com, 40</span><br><span class="line">&lt;==        Row: 1005, 关羽, guanyu@qq.com, 40</span><br><span class="line">&lt;==        Row: 1006, 诸葛亮, zhugeliang@163.com, 49</span><br><span class="line">&lt;==      Total: 6</span><br></pre></td></tr></table></figure>
<p>对于sql的limit，第一个参数是从0开始计算的</p>
<h2 id="CRUD"><a class="header-anchor" href="#CRUD"> </a>CRUD</h2>
<p>这里补充一下更新和删除的标签</p>
<h3 id="update"><a class="header-anchor" href="#update"> </a>update</h3>
<p>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">updateStudent</span><span class="params">(Student student)</span>;</span><br></pre></td></tr></table></figure>
<p>mapper</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateStudent&quot;</span>&gt;</span></span><br><span class="line">    update `student` set `age` = #&#123;age&#125; where `id` = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试方法（记得提交事务）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdateStudent</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtils.getSqlSession();</span><br><span class="line">    <span class="type">StudentDao</span> <span class="variable">dao</span> <span class="operator">=</span> sqlSession.getMapper(StudentDao.class);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    stu.setId(<span class="number">1002</span>);</span><br><span class="line">    stu.setAge(<span class="number">100</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> dao.updateStudent(stu);</span><br><span class="line">    sqlSession.commit();</span><br><span class="line">    sqlSession.close();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="delete"><a class="header-anchor" href="#delete"> </a>delete</h3>
<p>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deleteStudentById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure>
<p>mapper</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteStudentById&quot;</span>&gt;</span></span><br><span class="line">    delete from `student` where `id` = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试方法（记得提交事务）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteStudentById</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtils.getSqlSession();</span><br><span class="line">    <span class="type">StudentDao</span> <span class="variable">dao</span> <span class="operator">=</span> sqlSession.getMapper(StudentDao.class);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> dao.deleteStudentById(<span class="number">1002</span>);</span><br><span class="line">    sqlSession.commit();</span><br><span class="line">    sqlSession.close();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="作用域（Scope）和生命周期"><a class="header-anchor" href="#作用域（Scope）和生命周期"> </a>作用域（Scope）和生命周期</h2>
<p>详细介绍见<a href="https://mybatis.org/mybatis-3/zh/getting-started.html">官方</a></p>
<h3 id="SqlSessionFactoryBuilder"><a class="header-anchor" href="#SqlSessionFactoryBuilder"> </a>SqlSessionFactoryBuilder</h3>
<ul>
<li>
<p><code>SqlSessionFactoryBuilder</code>可以被实例化、使用和丢弃。一旦创建了<code>SqlSessionFactory</code>，就<strong>不再需要</strong><code>SqlSessionFactoryBuilder</code>。</p>
</li>
<li>
<p>因此<code>SqlSessionFactoryBuilder </code>实例的最佳作用域是<strong>方法作用域</strong>（也就是<strong>局部方法变量</strong>）。</p>
</li>
<li>
<p>你可以重用<code>SqlSessionFactoryBuilder</code> 来创建多个 <code>SqlSessionFactory</code> 实例，但最好还是<strong>不要一直保留着它</strong>，以保证所有的 XML 解析资源可以被释放给更重要的事情。</p>
</li>
</ul>
<h3 id="SqlSessionFactory"><a class="header-anchor" href="#SqlSessionFactory"> </a>SqlSessionFactory</h3>
<ul>
<li><code>SqlSessionFactory</code>一旦被创建就应该在应用的运行期间<strong>一直存在</strong>，<strong>没有任何理由</strong>丢弃它或重新创建另一个实例。</li>
<li>使用 <code>SqlSessionFactory</code> 的最佳实践是在应用运行期间<strong>不要重复创建多次</strong></li>
<li><code>SqlSessionFactory</code> 的最佳作用域是<strong>应用作用域</strong>。 有很多方法可以做到，最简单的就是使用<strong>单例模式</strong>或者<strong>静态单例模式</strong></li>
</ul>
<h3 id="SqlSession"><a class="header-anchor" href="#SqlSession"> </a>SqlSession</h3>
<ul>
<li><strong>每个线程</strong>都应该有它<strong>自己</strong>的 <code>SqlSession</code> 实例。</li>
<li><code>SqlSession</code> 的实例<strong>不是线程安全</strong>的，因此是不能被共享的，</li>
<li>最佳的<strong>作用域是请求或方法作用域</strong>。<strong>绝对不能</strong>将 <code>SqlSession</code> 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝<strong>不能</strong>将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。</li>
<li>如果你现在正在使用一种 Web 框架，考虑将 <code>SqlSession</code> 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以<strong>打开一个</strong> <code>SqlSession</code>，返回一个响应后，就<strong>关闭</strong>它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 <code>finally</code> 块中。 下面的示例就是一个确保 <code>SqlSession</code> 关闭的标准模式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="映射器实例"><a class="header-anchor" href="#映射器实例"> </a>映射器实例</h3>
<ul>
<li>映射器是一些<strong>绑定映射语句的接口</strong>。映射器接口的实例是从 <code>SqlSession</code> 中获得的。</li>
<li>任何映射器实例的最大作用域与请求它们的 <code>SqlSession</code> 相同。但<strong>方法作用域</strong>才是<strong>映射器实例</strong>的最合适的作用域。 也就是说，映射器实例应该在<strong>调用它们的方法中被获取，使用完毕之后即可丢弃</strong>。</li>
<li>映射器实例并<strong>不需要被显式地关闭</strong>。尽管在整个请求作用域保留映射器实例不会有什么问题，但是你很快会发现，在这个作用域上管理太多像 SqlSession 的资源会让你忙不过来。 因此，最好将映射器放在方法作用域内。就像下面的例子一样：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  <span class="type">BlogMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(BlogMapper.class);</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="缓存"><a class="header-anchor" href="#缓存"> </a>缓存</h2>
<p>官方解说<a href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html#cache">缓存cache</a></p>
<ul>
<li>
<p>Mybatis默认情况下，只启用了本地的会话缓存，它仅仅对<strong>一个会话</strong>（<code>sqlSession</code>）中的数据进行缓存。</p>
</li>
<li>
<p>要启用全局的二级缓存，只需要在 <strong>SQL 映射文件</strong>中添加一行：</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>映射语句文件中的<strong>所有 select 语句的结果</strong>将会被缓存。</li>
<li>映射语句文件中的所有 <strong>insert、update 和 delete 语句</strong>会<strong>刷新缓存</strong>。</li>
<li>缓存会使用最近最少使用算法（<strong>LRU, Least Recently Used</strong>）算法来<strong>清除不需要的缓存</strong>。</li>
<li>缓存<strong>不会</strong>定时进行刷新（也就是说，没有刷新间隔）。</li>
<li>缓存<strong>会保存列表或对象</strong>（无论查询方法返回哪种）的 1024 个引用。</li>
<li>缓存会被视为<strong>读/写缓存</strong>，这意味着获取到的对象<strong>并不是共享的</strong>，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</li>
</ul>
<p><strong>cache 元素的属性</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag">  <span class="attr">eviction</span>=<span class="string">&quot;FIFO&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushInterval</span>=<span class="string">&quot;60000&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">size</span>=<span class="string">&quot;512&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">readOnly</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个更高级的配置创建了一个 <strong>FIFO 缓存</strong>，每隔 <strong>60 秒刷新</strong>，最多可以<strong>存储结果对象或列表的 512 个引用</strong>，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。</p>
</blockquote>
<p>可用的清除策略有：</p>
<ul>
<li><code>LRU</code> – 最近最少使用：移除最长时间不被使用的对象。</li>
<li><code>FIFO</code> – 先进先出：按对象进入缓存的顺序来移除它们。</li>
<li><code>SOFT</code> – 软引用：基于垃圾回收器状态和软引用规则移除对象。</li>
<li><code>WEAK</code> – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。</li>
</ul>
<p><strong>默认</strong>的清除策略是 <strong>LRU</strong>。</p>
<blockquote>
<p>二级缓存是<strong>事务性</strong>的。这意味着，当 SqlSession 完成并提交时，或是完成并回滚，但没有执行 flushCache=true 的 insert/delete/update 语句时，缓存会获得更新</p>
</blockquote>
<h3 id="缓存测试"><a class="header-anchor" href="#缓存测试"> </a>缓存测试</h3>
<h4 id="测试1"><a class="header-anchor" href="#测试1"> </a>测试1</h4>
<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectStudents</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtils.getSqlSession();</span><br><span class="line">    <span class="type">StudentDao</span> <span class="variable">dao</span> <span class="operator">=</span> sqlSession.getMapper(StudentDao.class);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> dao.selectStudentById(<span class="number">1002</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;=========两次查询分割线=========&quot;</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> dao.selectStudentById(<span class="number">1002</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;student==student2:&quot;</span> + String.valueOf(student==student2));</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出信息</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Opening JDBC Connection</span><br><span class="line">Created connection 339099861.</span><br><span class="line">Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@143640d5]</span><br><span class="line">==&gt;  Preparing: select `id`,`name`,`email`,`age` from student where `id`=? </span><br><span class="line">==&gt; Parameters: 1002(Integer)</span><br><span class="line">&lt;==    Columns: id, name, email, age</span><br><span class="line">&lt;==        Row: 1002, 蓝猫, lanmao@163.com, 30</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">=========两次查询分割线=========</span><br><span class="line">student==student2:true</span><br><span class="line">Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@143640d5]</span><br><span class="line">Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@143640d5]</span><br><span class="line">Returned connection 339099861 to pool.</span><br></pre></td></tr></table></figure>
<p>可以看到，第二次查询并没有再次执行sql语句，同时两次结果是一致的</p>
<h4 id="测试2"><a class="header-anchor" href="#测试2"> </a>测试2</h4>
<p>现在在语句中插入更新语句试试</p>
<p>测试方法,<strong>注意</strong>，这里的更新操作的事务并没有提交</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectStudents</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MyBatisUtils.getSqlSession();</span><br><span class="line">    <span class="type">StudentDao</span> <span class="variable">dao</span> <span class="operator">=</span> sqlSession.getMapper(StudentDao.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;=========进行第一次查询分割线=========&quot;</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> dao.selectStudentById(<span class="number">1002</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;=========进行更新分割线=========&quot;</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">studentUpdate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    studentUpdate.setId(<span class="number">1003</span>);</span><br><span class="line">    studentUpdate.setAge(<span class="number">88</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> dao.updateStudent(studentUpdate);</span><br><span class="line">    System.out.println(<span class="string">&quot;更新数量&quot;</span>+nums);</span><br><span class="line">    System.out.println(<span class="string">&quot;=========进行第二次查询分割线=========&quot;</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> dao.selectStudentById(<span class="number">1002</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;student==student2:&quot;</span> + String.valueOf(student==student2));</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出信息</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">=========进行第一次查询分割线=========</span><br><span class="line">Opening JDBC Connection</span><br><span class="line">Created connection 339099861.</span><br><span class="line">Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@143640d5]</span><br><span class="line">==&gt;  Preparing: select `id`,`name`,`email`,`age` from student where `id`=? </span><br><span class="line">==&gt; Parameters: 1002(Integer)</span><br><span class="line">&lt;==    Columns: id, name, email, age</span><br><span class="line">&lt;==        Row: 1002, 蓝猫, lanmao@163.com, 30</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">=========进行更新分割线=========</span><br><span class="line">==&gt;  Preparing: update `student` set `age` = ? where `id` = ? </span><br><span class="line">==&gt; Parameters: 88(Integer), 1003(Integer)</span><br><span class="line">&lt;==    Updates: 1</span><br><span class="line">更新数量1</span><br><span class="line">=========进行第二次查询分割线=========</span><br><span class="line">==&gt;  Preparing: select `id`,`name`,`email`,`age` from student where `id`=? </span><br><span class="line">==&gt; Parameters: 1002(Integer)</span><br><span class="line">&lt;==    Columns: id, name, email, age</span><br><span class="line">&lt;==        Row: 1002, 蓝猫, lanmao@163.com, 30</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">student==student2:false</span><br><span class="line">Rolling back JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@143640d5]</span><br><span class="line">Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@143640d5]</span><br><span class="line">Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@143640d5]</span><br><span class="line">Returned connection 339099861 to pool.</span><br></pre></td></tr></table></figure>
<p>可以看到这里进行了两遍查询，况且这里更新操作的事务并没有提交上去</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu搭建Java服务器</title>
    <url>/2020/10/18/Ubuntu%E6%90%AD%E5%BB%BAJava%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h3 id="Java-Web环境配置"><a class="header-anchor" href="#Java-Web环境配置"> </a>Java Web环境配置</h3>
<!-- more -->
<hr>
<h3 id="为了配置大创的服务器来实现文件传输，因此搭建了Java-Web的服务器"><a class="header-anchor" href="#为了配置大创的服务器来实现文件传输，因此搭建了Java-Web的服务器"> </a>为了配置大创的服务器来实现文件传输，因此搭建了Java Web的服务器</h3>
<hr>
<h4 id="Ubuntu版本16-04"><a class="header-anchor" href="#Ubuntu版本16-04"> </a>Ubuntu版本16.04</h4>
<hr>
<h3 id="Java环境"><a class="header-anchor" href="#Java环境"> </a>Java环境</h3>
<!-- more -->
<ol>
<li>
<p>下载Ubuntu环境下的Java JDK</p>
<p><a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">Java JDK下载网站</a>然后选择对应的版本，这里选择<code>Linux x64 Compressed Archive</code>对应的安装包为<code>jdk-8u261-linux-x64.tar.gz</code></p>
</li>
<li>
<p><code>sudo mkdir /usr/local/java</code> 来创建环境(<em><strong>我还不太明白ubuntu下面各个目录的意义是什么</strong></em>)</p>
</li>
<li>
<p><code>sudo mv jdk-8u261-linux-x64.tar.gz /usr/local/java</code> 将JDK移到该目录</p>
</li>
<li>
<p><code>cd /usr/local/java</code></p>
</li>
<li>
<p><code>tar -zxvf jdk-8u261-linux-x64.tar.gz</code> 来解压</p>
</li>
<li>
<p><code>sudo vim /etc/profile</code> 配置环境 (<strong>记得加sudo</strong>否则报错会报错： E212：无法打开并写入文件)</p>
</li>
<li>
<p>在文件末尾加入</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_261</span><br><span class="line">export JRE_HOME=/usr/local/java/jdk1.8.0_261/jre</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line">export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>(复制的时候输入:set paste) (相应取消操作为:set nopaste)<br>
8. <code>source /etc/profile</code></p>
<ol start="9">
<li>查看是否成功<code>java -version</code></li>
</ol>
<hr>
<hr>
<h2 id="Tomcat环境搭建"><a class="header-anchor" href="#Tomcat环境搭建"> </a>Tomcat环境搭建</h2>
<p>这里搭建Tomcat环境,选择的是Tomcat8.5.59,</p>
<ol>
<li>
<p><a href="https://tomcat.apache.org/download-80.cgi">下载地址</a>,这里选择下载Core中的tar.gz。<br>
<img src="http://algorithm-image.qibinaoe.top/tomcat%E4%B8%8B%E8%BD%BD.jpg" alt="代码下载"></p>
</li>
<li>
<p><code>sudo mkdir /usr/local/tomcat</code> 创建文件夹</p>
</li>
<li>
<p>将文件移到刚刚创建的目录 <code>sudo mv apache-tomcat-8.5.59.tar.gz /usr/local/tomcat</code></p>
</li>
<li>
<p>解压 <code>sudo tar -zxvf apache-tomcat-8.5.59.tar.gz</code></p>
</li>
<li>
<p>修改tomcat的权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/tomcat</span><br><span class="line">sudo chmod 755 -R apache-tomcat-8.5.59</span><br></pre></td></tr></table></figure>
<p>其中-R的递归更改权限的意思，755意思是文件所有者可读可写可执行（7），与文件所有者同属一个用户组的其他用户可读可执行(5)，其他用户组可读可执行。<em><strong>这部分内容需要学习</strong></em></p>
</li>
<li>
<p>修改startup.sh文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/tomcat/apache-tomcat-8.5.59/bin</span><br><span class="line">sudo vim startup.sh</span><br></pre></td></tr></table></figure>
<p>在最后一句<code> exec &quot;$PRGDIR&quot;/&quot;$EXECUTABLE&quot; start &quot;$@&quot;</code>的上面<br>
添加如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_261</span><br><span class="line">export JRE_HOME=/usr/local/java/jdk1.8.0_261/jre</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line">export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH</span><br><span class="line">export TOMCAT_HOME=/usr/local/tomcat/apache-tomcat-8.5.59</span><br></pre></td></tr></table></figure>
<p>如图<img src="http://algorithm-image.qibinaoe.top/startup.sh%E4%BF%AE%E6%94%B9.jpg" alt="修改startup.sh"></p>
</li>
<li>
<p>修改shutdown.sh文件<br>
过程与修改startup.sh类似</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/tomcat/apache-tomcat-8.5.59/bin</span><br><span class="line">sudo vim shutdown.sh</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/shutdown.sh%E4%BF%AE%E6%94%B9.jpg" alt="修改shutdown.sh"></p>
</li>
<li>
<p>运行测试<br>
sudo ./startup.sh</p>
<p>访问8080端口</p>
</li>
<li>
<p>关闭测试<br>
sudo ./shutdown.sh</p>
</li>
</ol>
<hr>
<hr>
<h3 id="Mysql搭建"><a class="header-anchor" href="#Mysql搭建"> </a>Mysql搭建</h3>
<p>我服务器上面不知道为什么已经带有Mysql，因此我就没有再安装Mysql了，不过Mysql的版本是5.7.28版本的(<code>mysql -V</code>)，不是最新的8版本的，但是没有再去卸载再安装了.<br>
但是遇到了mysql输入登陆用户名和密码一直错误，主要参考了这篇博客<a href="https://blog.csdn.net/qq_38737992/article/details/81090373">ubuntu18.04 首次登录mysql未设置密码或忘记密码解决方法</a></p>
<p>具体步骤如下</p>
<ol>
<li>
<p>首先要知道自己有没有mysql,方法借鉴这篇博客的<a href="https://blog.csdn.net/lizuqingblog/article/details/18423751?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight">Linux(Ubuntu)下MySQL的安装与配置</a><br>
输入<code>sudo netstat -tap | grep mysql</code>后，如果显示<br>
<img src="http://algorithm-image.qibinaoe.top/mysql%E5%AE%89%E8%A3%85.jpg" alt="判断mysql是否安装">，则意味则有安装，如果显示其他，则需要安装</p>
</li>
<li>
<p>然后修改mysql默认用户名和密码</p>
<ol>
<li><code>sudo cat /etc/mysql/debian.cnf</code><br>
会显示如下信息<br>
<img src="http://algorithm-image.qibinaoe.top/%E9%BB%98%E8%AE%A4%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81.jpg" alt="mysql默认用户名"></li>
<li>然后自己根据上面的</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user = debian-sys-maint</span><br><span class="line">password = jnFC1nzYXcyRbw00</span><br></pre></td></tr></table></figure>
<p>来进行登陆：输入指令<code>mysql -u debian-sys-maint -p</code>，再输入密码，其中密码不会显示出来</p>
<ol start="3">
<li>进入mysql修改数据库，将用户名<code>root</code>的密码修改成<code>root</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">update mysql.user set authentication_string=password(&#x27;root&#x27;) where user=&#x27;root&#x27; and Host =&#x27;localhost&#x27;;</span><br><span class="line">update user set plugin=&quot;mysql_native_password&quot;; </span><br><span class="line">flush privileges;</span><br><span class="line">quit;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<p>重启mysql<code>sudo service mysql restart</code></p>
</li>
<li>
<p>这时候<code>root</code>用户名就可以登陆了，密码为<code>root</code><br>
<code>mysql -u root -p</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习</title>
    <url>/2020/11/02/git%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="学习git记录"><a class="header-anchor" href="#学习git记录"> </a>学习git记录</h2>
<!-- more -->
<h3 id="廖雪峰博客"><a class="header-anchor" href="#廖雪峰博客"> </a>廖雪峰博客</h3>
<p>先从<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰博客git教程</a>中学习并作记录。</p>
<hr>
<h4 id="知识点记录"><a class="header-anchor" href="#知识点记录"> </a>知识点记录</h4>
<ul>
<li>
<p>git属于分布式版本控制系统</p>
</li>
<li>
<p>集中式与分布式</p>
<ul>
<li>
<p>集中式的版本控制系统</p>
<ul>
<li>CVS和SVN(SVN是对CVS的一种改进)</li>
<li>缺点:
<ul>
<li>需要联网工作上传到中央服务器</li>
<li>中央服务器坏掉后，会影响所有人</li>
</ul>
</li>
</ul>
</li>
<li>
<p>分布式的版本控制系统</p>
<ul>
<li>git、bitkeeper</li>
<li>优点
<ul>
<li>每一个人的电脑都有一个完整的版本库</li>
<li>安全性高</li>
</ul>
</li>
</ul>
<p>github服务器是用来中转的，即每一个人可以把自己修改后的推上去，其他人也可以从中同步，而github服务器故障后，只要本地的仓库(repository)还存在,就不会丢失。而对于集中式的版本控制系统，必须联网提交回滚等操作，如果断网就不能实现这些操作，并且服务器故障后，历史版本信息都没有了</p>
</li>
</ul>
</li>
<li>
<p>所有版本控制系统只能跟踪文本文件，如txt、网页、程序代码。不能跟踪二进制文件内容的变化，如图片、word</p>
</li>
<li>
<p>git跟踪并管理的是修改而非文件，意思就是文件中的内容修改后，git能跟踪内容变化是什么。</p>
</li>
</ul>
<hr>
<h4 id="git安装"><a class="header-anchor" href="#git安装"> </a>git安装</h4>
<p><code>sudo apt-get install git</code></p>
<h4 id="git使用问题"><a class="header-anchor" href="#git使用问题"> </a>git使用问题</h4>
<ol>
<li><code>git add</code>与<code>git commit</code>区别</li>
</ol>
<h4 id="git命令"><a class="header-anchor" href="#git命令"> </a>git命令</h4>
<ul>
<li>
<p><code>git config</code></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--global</code>参数表示电脑上的所有仓库都使用该配置</li>
</ul>
</li>
<li>
<p><code>git init</code></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in D:/CODE/gitlearning/.git/</span><br></pre></td></tr></table></figure>
<ul>
<li><code>git init</code>用于声明当前目录为git可以管理的仓库</li>
<li>会生成<code>.git</code>目录，用于跟踪管理版本库</li>
</ul>
</li>
<li>
<p><code>git add</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure>
<ul>
<li>将文件添加到仓库</li>
</ul>
</li>
<li>
<p><code>git commit</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;wrote a readme file&quot;</span><br><span class="line">[master (root-commit) eaadf4e] wrote a readme file</span><br><span class="line">1 file changed, 2 insertions(+)</span><br><span class="line">create mode 100644 readme.txt</span><br></pre></td></tr></table></figure>
<ul>
<li><code>git commit</code>表示将文件提交到仓库</li>
<li><code>-m </code>后的文字代表本次提交的说明</li>
</ul>
</li>
<li>
<p><code>git status</code></p>
</li>
<li>
<p>查看当前仓库的状态</p>
</li>
<li>
<p><code>git diff</code></p>
</li>
<li>
<p>查看对当前仓库里的文件做了什么修改</p>
</li>
<li>
<p><code>git log</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit e31be9240c251ddde0747f160b13ca30a8a055aa (HEAD -&gt; master)</span><br><span class="line">Author: qibin &lt;780891896@qq.com&gt;</span><br><span class="line">Date:   Mon Nov 2 15:25:30 2020 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit 99403f77708a6f871ab514371f4dffb075f4c57d</span><br><span class="line">Author: qibin &lt;780891896@qq.com&gt;</span><br><span class="line">Date:   Mon Nov 2 15:24:32 2020 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit 620a5b729a1ed380ae4f7630b1255e5cea3694aa</span><br><span class="line">Author: qibin &lt;780891896@qq.com&gt;</span><br><span class="line">Date:   Mon Nov 2 15:20:14 2020 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">e31be9240c251ddde0747f160b13ca30a8a055aa (HEAD -&gt; master) append GPL</span><br><span class="line">99403f77708a6f871ab514371f4dffb075f4c57d add distributed</span><br><span class="line">620a5b729a1ed380ae4f7630b1255e5cea3694aa wrote a readme file</span><br></pre></td></tr></table></figure>
<ul>
<li>注意这里<code>--pretty=oneline</code>不能写成<code>-pretty=oneline</code></li>
<li>查看仓库的提交历史记录</li>
<li>这里类似<code>e31be9240c251ddde0747f160b13ca30a8a055aa</code>叫做<code>commit id</code> 版本号，是由sha1计算出来的，用十六进制表示</li>
<li>当前版本用<code>HEAD</code>表示，上一个版本用<code>HEAD^</code>表示，上上个版本用<code>HEAD^^</code>表示，而上100个版本可以写成<code>HEAD~100</code></li>
</ul>
</li>
<li>
<p><code>git reset</code></p>
<ol>
<li>
<p>将工作区的版本回退到版本库的某个版本</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at 99403f7 add distributed</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>
<p>回退版本</p>
</li>
<li>
<p>git用一个指针<code>HEAD</code>来指向当前版本，</p>
</li>
<li>
<p>要想回到时间最新的那个版本，需要有那个版本的commit id，即</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset --hard e31be92</span><br><span class="line">HEAD is now at e31be92 append GPL</span><br></pre></td></tr></table></figure>
<p>如果<code>commit id</code>找不到了可以通过<code>git reflog</code>来查看历史命令</p>
</li>
<li>
<p>对于<code>commit id</code>只需要前几位数就可以了，当然也不能写太少，不然有重复的时候就指向不明</p>
</li>
</ul>
<ol start="2">
<li>将暂存区的修改撤销，重新放回工作区</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD readme.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       readme.txt</span><br></pre></td></tr></table></figure>
<ul>
<li>这里的<code>HEAD</code>表示使用最新版本</li>
<li>这时工作区内的文件还是修改后的，如果要撤销工作区的修改使用<code>git checkout -- file</code></li>
</ul>
</li>
<li>
<p><code>git reflog</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e31be92 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to e31be92</span><br><span class="line">99403f7 HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">e31be92 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">99403f7 HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">620a5b7 HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure>
<ul>
<li>查看命令历史</li>
</ul>
</li>
<li>
<p><code>git checkout</code></p>
<ol>
<li>在工作区的修改全部撤销</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$git  checkout -- readme.txt</span><br></pre></td></tr></table></figure>
<ul>
<li>当 <code>readme.txt</code>修改后没放到暂存区的时候，撤销修改回到和版本库一样</li>
<li>当 <code>readme.txt</code>修改后已经添加到暂存区，又修改了，则撤销修改回到暂存区的状态</li>
<li>即回到最近一次<code>git commit</code>或<code>git add</code>状态<br>
<strong>注：git checkout – file</strong>中<code>--</code>需要加上，否则变成“切换到另一个分支”的命令</li>
<li>将工作区的被删除的文件，从版本库中复原，即将误删的文件恢复到最新版本(其实是将版本库中的版本替换工作区的把版本，所以工作区是修改还是删除都是变成版本库的版本)</li>
</ul>
<ol start="2">
<li><code>git checkout -b dev</code></li>
</ol>
<ul>
<li>
<p>创建<code>dev</code>分支，并切换到<code>dev</code>分支</p>
</li>
<li>
<p>相当于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch dev</span><br><span class="line">git checkout dev</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>git rm &lt;file&gt;</code></p>
<ul>
<li>当有个文件提交到版本库后，我们在工作目录后删除该文件，如果确实要将改文件从版本库删除，则使用<code>git rm &lt;file&gt;</code>然后再<code>git commit</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git rm test.txt</span><br><span class="line">rm &#x27;test.txt&#x27;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;remove test.txt&quot;</span><br><span class="line">[master e5ffcc1] remove test.txt</span><br><span class="line">1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line">delete mode 100644 test.txt</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>git branch</code></p>
<ul>
<li>
<p><code>git branch</code>命令查看当前分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>git branch dev</code> 创建<code>dev</code>分支</p>
</li>
<li>
<p><code>git branch -d dev</code> 删除<code>dev</code>分支</p>
</li>
</ul>
</li>
<li>
<p><code>git merge</code>命令用于合并并指定分支到当前分支(比如要将dev合并到master,则得先将HEAD指针指向master分支)</p>
</li>
<li>
<p><code>git merge dev</code></p>
</li>
<li>
<p><code>git switch</code></p>
<ul>
<li><code>git switch -c dev</code> 创建并切换到新的<code>dev</code>分支</li>
<li><code>git switch dev</code> 切换到<code>dev</code>分支</li>
</ul>
</li>
</ul>
<hr>
<h4 id="git概念"><a class="header-anchor" href="#git概念"> </a>git概念</h4>
<ul>
<li>
<p>工作区(Working Directory)</p>
<ul>
<li>电脑的目录，即这里的gitlearning文件夹就是工作区<br>
<img src="workingdirectory.jpg" alt="工作区"></li>
</ul>
</li>
<li>
<p>版本库(Repository)</p>
</li>
<li>
<p>工作区中隐藏的文件夹 <code>.git</code>属于版本库不属于工作区 ，其中版本库中存了一个叫做stage(或者叫index)的<strong>暂存区</strong>,同时版本库中还有一个git自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的指针<code>HEAD</code></p>
</li>
<li>
<p><code>git add</code>是将文件添加到暂存区</p>
<p><code>git commit</code>是将暂存区的所有内容提交到当前分支</p>
<p>当添加一个新文件<code>LISENCE</code>而没有add到暂存区的时候，使用<code>git status</code>命令会显示其<code>Untracked</code></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">(use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">(use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">(use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        LISENCE</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而当我们把其新添加的文件<code>git add</code>到仓库时，会显示 <code>new files</code></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">(use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   LISENCE</span><br><span class="line">        modified:   readme.txt</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>git commit</code>是将暂存区的内容提交，因此如果工作区内的内容没有<code>git add</code>的话，其不会被<code>commit</code>上去</p>
</li>
</ul>
<hr>
<h3 id="远程仓库管理"><a class="header-anchor" href="#远程仓库管理"> </a>远程仓库管理</h3>
<ul>
<li>
<p>创建SSH key</p>
<ul>
<li><code>ssh-keygen -t rsa -C &quot;youremail@example.com</code></li>
<li><code>id_rsa</code>是私钥</li>
<li><code>id_rsa.pub</code>是公钥</li>
<li>将<code>id_rsa.pub</code>记录在github上</li>
</ul>
</li>
<li>
<p>创建新的repository</p>
</li>
<li>
<p>将本地仓库推送远程库</p>
<ul>
<li>在git文件夹里
<ul>
<li><code>git remote add origin https://github.com/qibinaoe/learngit.git</code>
<ul>
<li><code>origin</code>是远程库的名字，git的默认叫法</li>
</ul>
</li>
<li><code>git push -u origin master</code> 用<code>git push</code>将本地库中的当前分支<code>master</code>推送到远程
<ul>
<li>第一次推送<code>master</code>分支时，加上<code>-u</code>参数，同时实现两种操作
<ol>
<li>将本地<code>master</code>分支内容推送到远程新的<code>master</code>分支</li>
<li>将本地<code>master</code>分支和远程<code>master</code>分支关联起来，在以后的推送和拉去就可以简化命令</li>
</ol>
</li>
</ul>
</li>
<li>此后修改后要将本地仓库推送到远程时，只需要使用<code>git push origin master</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>将远程库克隆到本地</p>
<ul>
<li><code>$ git clone git@github.com:qibinaoe/gitskills.git</code>
<ul>
<li>使用的是ssh的协议</li>
</ul>
</li>
<li><code>$ git clone https://github.com/qibinaoe/gitskills.git</code>
<ul>
<li>使用的是https的协议</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="分支管理"><a class="header-anchor" href="#分支管理"> </a>分支管理</h3>
<p>在分支<code>dev</code>上修改后，如果需要将该分支的内容合并到<code>master</code>分支</p>
<ol>
<li>切换到<code>master</code>分支</li>
</ol>
<p><code>git checkout master</code><br>
2. 指定要合并的分支</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating e5ffcc1..a3f33f3</span><br><span class="line">Fast-forward</span><br><span class="line">  readme.txt | 3 ++-</span><br><span class="line">  1 file changed, 2 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>
<p>这里的<code>Fast-forward</code>指的是将<code>master</code>指向<code>dev</code></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hashcode与equals探索</title>
    <url>/2021/04/17/hashcode%E4%B8%8Eequals%E6%8E%A2%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="Java中hashcode与equals探索"><a class="header-anchor" href="#Java中hashcode与equals探索"> </a>Java中hashcode与equals探索</h1>
<p>在面试中，面试官问了一个问题：程序员在使用HashMap的时候，如何插入数据能够减少发生哈希碰撞。</p>
<!-- more -->
<p>而我思考HashMap中，对于key的定位与其hashcode有关系，那么如何选择key呢？</p>
<p>在这个思考的过程中，参考资料中的问题与解答给了我很大的启发。</p>
<p>首先明白，为什么重写equals的时候需要重写hashcode？</p>
<p>这是因为对于类似HashSet或HashMap容器中，其判断key是否相等，是先判断其hashcode是否相等，再去调用equals方法。判断两个整型是否相等和equals调用方法相比，开销会小很多。</p>
<p><img src="http://algorithm-image.qibinaoe.top/hashcode%E4%B8%8Eequals%E6%8E%A2%E7%B4%A2-1.png" alt="hashcode与equals探索-1"></p>
<p>因此，我们需要保证，如果两个对象其equals相等，那么其hashcode也需要相等。</p>
<p><img src="http://algorithm-image.qibinaoe.top/hashcode%E4%B8%8Eequals%E6%8E%A2%E7%B4%A2-2.png" alt="hashcode与equals探索-2"></p>
<p><img src="http://algorithm-image.qibinaoe.top/hashcode%E4%B8%8Eequals%E6%8E%A2%E7%B4%A2-3.png" alt="hashcode与equals探索-3"></p>
<p>而对于Object类中的hashcode是一个native方法，网上大多数的解释都是说hashcode返回的是对象的内存地址。但是该说法不准确。</p>
<p>因为hashcode返回一个整型int，其如果算上最高位的符号位，也就2<sup>32</sup>种取值。而对于64位操作系统，其取址范围可达2<sup>64</sup>种，因此显然对于hashcode存在某种映射关系或其他方法，使其大小缩小到一个整型。</p>
<p>我在<a href="https://blog.csdn.net/bachbrahms/article/details/106983428?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-6.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-6.control">参考资料1</a>的验证代码的基础上，再进一步做了修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> HashcodeTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashCodeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        HashSet&lt;Object&gt; setObject = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; setHashcode = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">hashcode</span> <span class="operator">=</span> obj.hashCode();</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(hashcode)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;存在相同hashcode:&quot;</span> + hashcode</span><br><span class="line">                        + <span class="string">&quot;&gt;&gt;&gt;当前obj:&quot;</span> + obj</span><br><span class="line">                        + <span class="string">&quot;&gt;&gt;&gt;已存在obj:&quot;</span> +map.get(hashcode)</span><br><span class="line">                        + <span class="string">&quot;&gt;&gt;&gt;size:&quot;</span> + map.size()</span><br><span class="line">                        + <span class="string">&quot;&gt;&gt;&gt;与已存在的obj是否相等==:&quot;</span>+ (obj == map.get(hashcode))</span><br><span class="line">                        + <span class="string">&quot;&gt;&gt;&gt;与已存在的obj是否相等equals:&quot;</span> + obj.equals(map.get(hashcode))</span><br><span class="line">                        + <span class="string">&quot;&gt;&gt;&gt;当前ObjectSet的大小:&quot;</span> + setObject.size()</span><br><span class="line">                        + <span class="string">&quot;&gt;&gt;&gt;当前HashcodeSet的大小:&quot;</span> + setHashcode.size());</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(hashcode, obj);</span><br><span class="line">            setObject.add(obj);</span><br><span class="line">            setHashcode.add(hashcode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<p><img src="http://algorithm-image.qibinaoe.top/hashcode%E4%B8%8Eequals%E6%8E%A2%E7%B4%A2-4.png" alt="hashcode与equals探索-4"></p>
<p>可以看到存在通过<code>==</code>比较不相等，但是hashcode相等的两个对象。从这个可以说明，两个不同的对象其hashcode是可以相同的</p>
<h2 id="后话"><a class="header-anchor" href="#后话"> </a>后话</h2>
<p>在使用HashMap的时候，其key传入的对象，通常需要重写hashcode以及equals方法，来满足我们预期效果。通过对于equals和hashcode的计算和判断，主要是覆盖那些具有区分度的属性。如果某个类的某个属性在该类中都一致，那么就没有将该属性加入到计算当中的必要了。</p>
<p>同时我们通常使用String类作为key，主要有以下几个原因</p>
<ol>
<li>String类中已经重写了hashcode和equals方法
<ul>
<li><img src="http://algorithm-image.qibinaoe.top/hashcode%E4%B8%8Eequals%E6%8E%A2%E7%B4%A2-5.png" alt="hashcode与equals探索-5"></li>
</ul>
</li>
<li>String类为final类，不可以修改，因为如果修改了HashMap中的key对象的属性，其在下一次调用时计算出来的hashcode不一致，会导致获取的value为null</li>
<li>String类型的hashcode会被缓存下来</li>
</ol>
<h2 id="参考资料-v2"><a class="header-anchor" href="#参考资料-v2"> </a>参考资料</h2>
<ul>
<li><a href="https://blog.csdn.net/bachbrahms/article/details/106983428?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-6.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-6.control">彻底理解java中HashMap的“冲突”问题及hashCode和equals方法重写问题</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>hexoBlog</title>
    <url>/2020/10/05/hexoBlog/</url>
    <content><![CDATA[<h2 id="搭建的第一个博客"><a class="header-anchor" href="#搭建的第一个博客"> </a>搭建的第一个博客</h2>
<ul>
<li>hexo框架</li>
<li>next主题</li>
</ul>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划笔记</title>
    <url>/2020/12/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="动态规划题目特点"><a class="header-anchor" href="#动态规划题目特点"> </a>动态规划题目特点</h2>
<ol>
<li>计数
<ul>
<li>有多少种方式可以走到右下角</li>
<li>有多少种方法从n个数中选出k个数使得和为Sum</li>
</ul>
</li>
<li>求最大最小值
<ul>
<li>从左上角走到右下角路径的最大数字和</li>
<li>最长上升子序列长度</li>
</ul>
</li>
<li>求存在性
<ul>
<li>取石子游戏（轮流取石子，一人一次可以取一个或两个），先手是否必胜</li>
<li>能不能选出k个数使得和是Sum</li>
</ul>
</li>
</ol>
<!-- more -->
<h3 id="递归解法的问题"><a class="header-anchor" href="#递归解法的问题"> </a>递归解法的问题</h3>
<ul>
<li>做了很多重复计算，效率低下</li>
</ul>
<p>而动态规划的解法将计算结果保存下来，从而避免重复计算</p>
<h2 id="动态规划组成部分"><a class="header-anchor" href="#动态规划组成部分"> </a>动态规划组成部分</h2>
<h3 id="一、确定状态"><a class="header-anchor" href="#一、确定状态"> </a>一、确定状态</h3>
<ul>
<li>解动态规划的时候需要开一个数组，数组的每个元素<code>f[i]</code>或者<code>f[i][j]</code>代表什么
<ul>
<li>类似于解数学题中，X，Y，Z代表什么</li>
</ul>
</li>
<li>确定状态需要有两个意识：
<ul>
<li>最后一步</li>
<li>子问题</li>
</ul>
</li>
</ul>
<p>在明白最后一步是什么后，如果把最后一步去掉，就生成了一个子问题。</p>
<p>同时我们需要最终答案是最优的，则去掉最后一步后的子问题也必须是最优的。这样就生成一个规模更小的问题</p>
<h3 id="二、转移方程"><a class="header-anchor" href="#二、转移方程"> </a>二、转移方程</h3>
<ul>
<li>即一个当前问题与子问题如何关联在一起的一个等式</li>
<li>例如<code>f[X]=min&#123;f[X-2]+1,f[X-5]+1,f[X-7]+1&#125;</code></li>
</ul>
<h3 id="三、初始条件和边界情况"><a class="header-anchor" href="#三、初始条件和边界情况"> </a>三、初始条件和边界情况</h3>
<p>初始条件指的是最开始的情况是什么？有点类似递归中的终止条件。一般情况有<code>f[0] = 0</code>或<code>f[0][0] = 0</code>，即子问题分割到不能再分割的地步。</p>
<p>而边界情况指的是不能出现非法的数字，例如数组越界，小于0或者大于规定的值</p>
<h3 id="四、计算顺序"><a class="header-anchor" href="#四、计算顺序"> </a>四、计算顺序</h3>
<p>一般情况下，动态规划如果是一维数组是从小到大。如果是二维数组则是从上到下，从左到右。但也是需要根据实际情况判断。</p>
<p>例如<code>f[X]=min&#123;f[X-2]+1,f[X-5]+1,f[X-7]+1&#125;</code>，我们需要计算<code>f[X]</code>，那么需要先将<code>f[X-2]</code>,<code>f[X-5]</code>,<code>f[X-7]</code>计算出来</p>
<h2 id="博弈型动态规划"><a class="header-anchor" href="#博弈型动态规划"> </a>博弈型动态规划</h2>
<ul>
<li>博弈型动态规划通常从第一步分析，而不是最后一步分析（因为我们需要从复杂的局面往简单的局面去思考）</li>
</ul>
<h3 id="必胜和必败的定义"><a class="header-anchor" href="#必胜和必败的定义"> </a>必胜和必败的定义</h3>
<ul>
<li>
<p>必胜定义为：自己走了这步棋后，对手面对剩下的局面，对手必败（即对手无论怎么走，都是输）</p>
</li>
<li>
<p>如果无论怎么走，面对剩下的局面，对手（这时候称为先手）必胜，则当前先手必败</p>
</li>
</ul>
<blockquote>
<p>这里考虑的是，先手必须走会让自己赢的那一步。即先手可能有多种走法，有些走法会让自己赢，有些走法会让自己输，这时候先手只走会让自己赢的</p>
</blockquote>
<h2 id="背包问题"><a class="header-anchor" href="#背包问题"> </a>背包问题</h2>
<ul>
<li>每个物品都有重量和价值</li>
<li>目标：在不撑爆背包的前提下
<ul>
<li>装下最多重量的物品</li>
<li>装下最大总价值的物品</li>
<li>有多少种方式正好带走满满一书包的物品</li>
</ul>
</li>
<li>物品的重量都是整数</li>
<li>背包问题中，数组大小和总承重有关</li>
<li>每个装物品的方案的总重量都是0到M</li>
</ul>
<p>背包问题需要把总承重放入状态（即开的数组的下标）</p>
<ul>
<li>最后一步：
<ul>
<li>最后一个背包内的物品是哪个</li>
<li>最后一个物品（重量A<sub>N-1</sub>，价值V<sub>N-1</sub>）是否进入背包</li>
</ul>
</li>
</ul>
<h2 id="区间型动态规划"><a class="header-anchor" href="#区间型动态规划"> </a>区间型动态规划</h2>
<ul>
<li>
<p>通常是给定一个序列或者字符串，进行操作</p>
</li>
<li>
<p>最后一步会将序列/字符串去头/去尾</p>
</li>
<li>
<p>剩下的会是一个区间<code>[i,j]</code>（连续区间）</p>
</li>
<li>
<p>状态自然定义为<code>f[i][j]</code>，表示面对子序列<code>[i...j]</code>时的最优性质</p>
</li>
<li>
<p>区间型动态规划的初始条件是区间的长度</p>
<ul>
<li><code>f[0][0]=f[1][1]=...=f[n-1][n-1]=1</code></li>
<li>如果<code>S[i] == S[i+1], f[i][i+1]=2</code></li>
<li>如果<code>S[i] != S[i+1], f[i][i+1]=1</code></li>
</ul>
</li>
<li>
<p>需要按照长度<code>j-i</code>从小到大的顺序去算。不能按照i的顺序去算</p>
</li>
</ul>
<h2 id="记忆化搜索方法"><a class="header-anchor" href="#记忆化搜索方法"> </a>记忆化搜索方法</h2>
<ul>
<li>记忆化：计算<code>f(x,y)</code>结束后，将结果保存在数组<code>f[i][j]</code>里，下次如果需要再次计算<code>f(i,j)</code>，直接返回<code>f[x][y]</code></li>
</ul>
<h2 id="动态规划小体会"><a class="header-anchor" href="#动态规划小体会"> </a>动态规划小体会</h2>
<ul>
<li>
<p>需要如果单纯<code>f[X-1]</code>无法区分所需要的条件时，可以开多维数组来记录不同情况的值</p>
</li>
<li>
<p>对于转移方程中，在处理当前状态和上一个状态中，什么时候要加一？</p>
<ul>
<li>如果求的是方式有多少种，则不需要加一</li>
<li>如果求的是数量有多少个，则需要加一</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode—树</title>
    <url>/2020/12/15/leetcode%E2%80%94%E6%A0%91/</url>
    <content><![CDATA[<p>本篇是leetcode树Tag的学习记录</p>
<p>所有题目来自于 <a href="https://leetcode-cn.com/tag/tree/">树</a></p>
<!-- more -->
<h2 id="100-相同的树"><a class="header-anchor" href="#100-相同的树"> </a><a href="https://leetcode-cn.com/problems/same-tree/">100. 相同的树</a></h2>
<h3 id="题目"><a class="header-anchor" href="#题目"> </a>题目</h3>
<p>给定两个二叉树，编写一个函数来检验它们是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<blockquote>
<p>示例 1:<br>
输入:       1         1<br>
/ \       / <br>
2   3     2   3</p>
<p>[1,2,3],   [1,2,3]<br>
输出: true</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
输入:      1          1<br>
/           <br>
2             2</p>
<p>[1,2],     [1,null,2]<br>
输出: false</p>
</blockquote>
<blockquote>
<p>示例 3:<br>
输入:       1         1<br>
/ \       / <br>
2   1     1   2</p>
<p>[1,2,1],   [1,1,2]<br>
输出: false</p>
</blockquote>
<h3 id="解题思路"><a class="header-anchor" href="#解题思路"> </a>解题思路</h3>
<p>完成这题的思路就是遍历一下这两棵树，如果遍历过程中两个树中同一个位置的每个结点都相同，则说明这两棵树是相同的</p>
<p>对于遍历的方法有很多，比如深度优先、广度优先</p>
<h3 id="解题代码深度优先——递归"><a class="header-anchor" href="#解题代码深度优先——递归"> </a>解题代码深度优先——递归</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p == <span class="literal">null</span> || q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p.val != q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码广度优先——队列"><a class="header-anchor" href="#解题代码广度优先——队列"> </a>解题代码广度优先——队列</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">// 广度遍历</span></span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> ^ q == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        Deque&lt;TreeNode&gt; queue1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; queue2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue1.offer(p);</span><br><span class="line">        queue2.offer(q);</span><br><span class="line">        <span class="keyword">while</span>(!queue1.isEmpty() &amp;&amp; !queue2.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">t1</span> <span class="operator">=</span> queue1.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">t2</span> <span class="operator">=</span> queue2.poll();</span><br><span class="line">            <span class="keyword">if</span>(t1.val != t2.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">l1</span> <span class="operator">=</span> t1.left;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">l2</span> <span class="operator">=</span> t2.left;</span><br><span class="line">            <span class="keyword">if</span>(l1 == <span class="literal">null</span> ^ l2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="literal">null</span>) queue1.offer(l1);</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="literal">null</span>) queue2.offer(l2);</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">r1</span> <span class="operator">=</span> t1.right;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">r2</span> <span class="operator">=</span> t2.right;</span><br><span class="line">            <span class="keyword">if</span>(r1 == <span class="literal">null</span> ^ r2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(r1 != <span class="literal">null</span>) queue1.offer(r1);</span><br><span class="line">            <span class="keyword">if</span>(r2 != <span class="literal">null</span>) queue2.offer(r2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue1.isEmpty() &amp;&amp; queue2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="101-对称二叉树"><a class="header-anchor" href="#101-对称二叉树"> </a><a href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></h2>
<h3 id="题目-v2"><a class="header-anchor" href="#题目-v2"> </a>题目</h3>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
<blockquote>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。<br>
1<br>
/ <br>
2   2<br>
/ \ / <br>
3  4 4  3</p>
</blockquote>
<blockquote>
<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:<br>
1<br>
/ <br>
2   2<br>
\   <br>
3    3</p>
</blockquote>
<h3 id="解题思路1"><a class="header-anchor" href="#解题思路1"> </a>解题思路1</h3>
<p>通过递归的方法，每一个小的迭代解决的问题是两个指针指向的值是否相等，如果相等的话，则判断一个指针的左子树是否和另一个指针的右子树相等，一个指针的右子树是否和另一个指针的左子树相等</p>
<h3 id="解题代码1"><a class="header-anchor" href="#解题代码1"> </a>解题代码1</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//用一个栈来判断左右两个子树是否一样</span></span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">return</span> check(root.left,root.right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode p, TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> || q == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> p.val==q.val &amp;&amp; check(p.left,q.right) &amp;&amp; check(p.right,q.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2"><a class="header-anchor" href="#解题思路2"> </a>解题思路2</h3>
<p>借助一个队列，通过迭代的方式解决这题。但本质的思路跟解题思路1是类似的，即判断当前的两个结点的值是否一样，如果一样则接下来需要保证下一次判断的时候，是判断一个是左子树、另一个是右子树。或者反过来。</p>
<h3 id="解题代码2"><a class="header-anchor" href="#解题代码2"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">       queue.offer(root);</span><br><span class="line">       queue.offer(root);</span><br><span class="line">       <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">           <span class="comment">//取出的两个应该是镜像对称位置的</span></span><br><span class="line">           <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">           <span class="type">TreeNode</span> <span class="variable">q</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">           <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">           <span class="keyword">if</span>(p == <span class="literal">null</span> || q == <span class="literal">null</span> || p.val != q.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            queue.offer(p.left);</span><br><span class="line">            queue.offer(q.right);</span><br><span class="line">            queue.offer(p.right);</span><br><span class="line">            queue.offer(q.left);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="104-二叉树的最大深度"><a class="header-anchor" href="#104-二叉树的最大深度"> </a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h2>
<h3 id="题目-v3"><a class="header-anchor" href="#题目-v3"> </a>题目</h3>
<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<blockquote>
<p>示例：<br>
给定二叉树 [3,9,20,null,null,15,7]，<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回它的最大深度 3 。</p>
</blockquote>
<h3 id="解题思路-v2"><a class="header-anchor" href="#解题思路-v2"> </a>解题思路</h3>
<p>可以通过递归的思路，空结点为0，非空的话，则是当前结点的1，加上左右子树中，深度最大的那个数。</p>
<p>也可以 用迭代的方式，通过广度优先去遍历每一层，每一层加一，同时对于每一层的迭代中，需要将该层的所有结点从队列中取出，再放入其左右子树，才能判断一层是否遍历完。</p>
<h3 id="解题代码递归"><a class="header-anchor" href="#解题代码递归"> </a>解题代码递归</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+ (left&gt;right?left:right);     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>精简版</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">root</span> <span class="operator">=</span>= <span class="literal">null</span>? <span class="number">0</span> : Math.max(maxDepth(root.left),maxDepth(root.right))+<span class="number">1</span>;     </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码迭代"><a class="header-anchor" href="#解题代码迭代"> </a>解题代码迭代</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//广度优先</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">deep</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size-- &gt; <span class="number">0</span> )&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">t</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(t.left != <span class="literal">null</span>) queue.offer(t.left);</span><br><span class="line">                <span class="keyword">if</span>(t.right != <span class="literal">null</span>) queue.offer(t.right);</span><br><span class="line">            &#125;</span><br><span class="line">            deep++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="107-二叉树的层次遍历-II"><a class="header-anchor" href="#107-二叉树的层次遍历-II"> </a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层次遍历 II</a></h2>
<h3 id="题目-v4"><a class="header-anchor" href="#题目-v4"> </a>题目</h3>
<p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<blockquote>
<p>例如：<br>
给定二叉树 [3,9,20,null,null,15,7],<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回其自底向上的层次遍历为：<br>
[<br>
[15,7],<br>
[9,20],<br>
[3]<br>
]</p>
</blockquote>
<h3 id="解题思路-v3"><a class="header-anchor" href="#解题思路-v3"> </a>解题思路</h3>
<p>对于这题实现的思路主要是参考于”104. 二叉树的最大深度“中广度优先的方法，将每一次在一层的遍历的数字储存在一块，最后要么通过栈的方式逆输出，或者直接通过链表插入头的方式输出。或者最后翻转一遍数组或链表</p>
<p><code>LinkedList</code>实现了<code>addFirst</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        linkFirst(e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>List</code>接口中有声明<code>void add(int index, E element);</code>的方法，所以可以直接<code>add(0,val)</code>的方式插入</p>
<h3 id="解题代码1-0"><a class="header-anchor" href="#解题代码1-0"> </a>解题代码1.0</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        LinkedList&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); <span class="comment">//用于层次遍历的队列</span></span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; curLayer = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">//新一层元素</span></span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                curLayer.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span> ) queue.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span> ) queue.offer(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.addFirst(curLayer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码1-1"><a class="header-anchor" href="#解题代码1-1"> </a>解题代码1.1</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); <span class="comment">//用于层次遍历的队列</span></span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; curLayer = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">//新一层元素</span></span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                curLayer.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span> ) queue.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span> ) queue.offer(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(<span class="number">0</span>,curLayer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="108-将有序数组转换为二叉搜索树"><a class="header-anchor" href="#108-将有序数组转换为二叉搜索树"> </a><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h2>
<h2 id="题目-v5"><a class="header-anchor" href="#题目-v5"> </a>题目</h2>
<p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<blockquote>
<p>示例:<br>
给定有序数组: [-10,-3,0,5,9],<br>
一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：<br>
0<br>
/ <br>
-3   9<br>
/   /<br>
-10  5</p>
</blockquote>
<h3 id="解题思路-v4"><a class="header-anchor" href="#解题思路-v4"> </a>解题思路</h3>
<p>看到这题就想起来之前做链表专题有一题类似的“<a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a>”</p>
<p>其中我写的”解题思路1“就是先将链表转成数组再进行转换。</p>
<h3 id="解题代码"><a class="header-anchor" href="#解题代码"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> subArray2BST(nums,<span class="number">0</span>,nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">subArray2BST</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="comment">//左开右闭</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = subArray2BST(nums,left,mid);</span><br><span class="line">        root.right = subArray2BST(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="110-平衡二叉树"><a class="header-anchor" href="#110-平衡二叉树"> </a><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a></h2>
<h3 id="题目-v6"><a class="header-anchor" href="#题目-v6"> </a>题目</h3>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<blockquote>
<p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p>
</blockquote>
<p>示例 1：<br>
输入：root = [3,9,20,null,null,15,7]<br>
输出：true</p>
<p><img src="http://algorithm-image.qibinaoe.top/balance_1.jpg" alt="img"></p>
<p>示例 2：<br>
输入：root = [1,2,2,3,3,null,null,4,4]<br>
输出：false</p>
<p><img src="http://algorithm-image.qibinaoe.top/balance_2.jpg" alt="img"></p>
<p>示例 3：<br>
输入：root = []<br>
输出：true</p>
<h3 id="解题思路-v5"><a class="header-anchor" href="#解题思路-v5"> </a>解题思路</h3>
<p>这题有很明显的递归的影子</p>
<p>如果一棵树是高度平衡二叉树，则它子树也是高度平衡二叉树。</p>
<p>因此我们可以通过递归，先判断一个结点的左右子树是否都为高度平衡二叉树，然后再看加上当前结点和左右子树构成更大的树，是否为高度平衡二叉树</p>
<h3 id="解题代码-v2"><a class="header-anchor" href="#解题代码-v2"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> root.left;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> root.right;</span><br><span class="line">        <span class="keyword">if</span>(!isBalanced(left) || !isBalanced(right)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Math.abs(getHeight(left) - getHeight(right))&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getHeight(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getHeight(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="111-二叉树的最小深度"><a class="header-anchor" href="#111-二叉树的最小深度"> </a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h2>
<h3 id="题目-v7"><a class="header-anchor" href="#题目-v7"> </a>题目</h3>
<p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p>说明：叶子节点是指没有子节点的节点。</p>
<blockquote>
<p>示例 1：<br>
输入：root = [3,9,20,null,null,15,7]<br>
输出：2</p>
<p><img src="http://algorithm-image.qibinaoe.top/ex_depth.jpg" alt="img"></p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：root = [2,null,3,null,4,null,5,null,6]<br>
输出：5</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201217104230565.png" alt="image-20201217104230565"></p>
</blockquote>
<h3 id="解题思路1-v2"><a class="header-anchor" href="#解题思路1-v2"> </a>解题思路1</h3>
<p><u>注意这题有个坑</u></p>
<p>题目的意思并<strong>不是</strong>单纯的求出左右两个子树的最短路径。</p>
<p>题目意思是到<strong>叶节点</strong>的最短路径，而叶节点的定义为：左右两个子树<strong>均为空</strong>。</p>
<p>所以当一个根节点中，假设其左子树为空，右子树不为空。不能认定为其长度为空。长度应该是右子树的最短路径。</p>
<p>总之，这题想表达的意思是：<strong>不是</strong>到<strong>空结点</strong>的最短路径，<strong>而是</strong>到<strong>叶子节点</strong>的<strong>最短路径</strong>。</p>
<p>解题代码1的思路是如果遇到只有单个子树的根节点，则返回非空子树的长度</p>
<p>解题代码2的思路是只计算不是空结点的子树的深度</p>
<h3 id="解题代码1-0-v2"><a class="header-anchor" href="#解题代码1-0-v2"> </a>解题代码1.0</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getDepth(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="comment">// 这题有个坑</span></span><br><span class="line">        <span class="comment">// 根节点不属于叶子结点</span></span><br><span class="line">        <span class="comment">// 所以如果根节点的只有一个子树为空，则最短路径为到另一棵非空子树的最短的路径</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span>) <span class="keyword">return</span> getDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.right == <span class="literal">null</span>) <span class="keyword">return</span> getDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> getDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> getDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.min(leftDepth,rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码1-1-v2"><a class="header-anchor" href="#解题代码1-1-v2"> </a>解题代码1.1</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getDepth(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>) min = Math.min(min,getDepth(root.left));</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>) min = Math.min(min,getDepth(root.right));</span><br><span class="line">        <span class="keyword">return</span> min + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v2"><a class="header-anchor" href="#解题思路2-v2"> </a>解题思路2</h3>
<p>另一种做法是广度遍历</p>
<p>广度遍历借助队列的结构，根据这道题，需要判断一整层是否都没有存在叶子节点，才需要使我们记录的最小深度加一。</p>
<p>所以类似“<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a>”这道题的解法，需要先记录队列长度，遍历整层再判断</p>
<p>对于官方解法不是将整层取出来遍历，而是定义一个新的类来保存该结点以及该节点所对应的深度，这样就不需要将整层取出来了。</p>
<h3 id="解题代码2-v2"><a class="header-anchor" href="#解题代码2-v2"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>) queue.offer(root.left);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>) queue.offer(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//我们需要一整层的结果，才能判断该层是否存在最短的叶子节点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="comment">//找到叶子结点</span></span><br><span class="line">                <span class="keyword">if</span>(cur.left == <span class="literal">null</span> &amp;&amp; cur. right == <span class="literal">null</span>) <span class="keyword">return</span> depth+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) queue.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//整层都没有叶子节点</span></span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="112-路径总和"><a class="header-anchor" href="#112-路径总和"> </a><a href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a></h2>
<h3 id="题目-v8"><a class="header-anchor" href="#题目-v8"> </a>题目</h3>
<p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<blockquote>
<p>示例:<br>
给定如下二叉树，以及目标和 sum = 22，<br>
5<br>
/ <br>
4   8<br>
/     / <br>
11  13  4<br>
/  \      <br>
7    2      1<br>
返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p>
</blockquote>
<h3 id="解题思路1-v3"><a class="header-anchor" href="#解题思路1-v3"> </a>解题思路1</h3>
<p>可以通过递归的方式。如果当前判断当前根节点是否存在满足路径总和，即判断其左右子节点是否存在满足总路径和。</p>
<p>同时要注意该题是到叶子节点的总路径和，而不是到空结点的总路径和。所以遍历的思想参考“<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a>”的做法</p>
<h3 id="解题代码1-v2"><a class="header-anchor" href="#解题代码1-v2"> </a>解题代码1</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过递归的方式，判断根节点是否有该目标和</span></span><br><span class="line">        <span class="comment">// 即判断子节点是否有减去根节点的值的目标和</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> sum-root.val==<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.right,sum-root.val) || hasPathSum(root.left,sum-root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v3"><a class="header-anchor" href="#解题思路2-v3"> </a>解题思路2</h3>
<p>也可以通过广度优先的方式，进行遍历。</p>
<p>一个队列用于保存该层结点</p>
<p>另一个队列用于保存该层结点所对应：从上层传下来的值，减去自身值。即如果该队列存在一个叶子节点，同时对应数值队列的值为0，则该叶子节点为满足的结点</p>
<h3 id="解题代码2-v3"><a class="header-anchor" href="#解题代码2-v3"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="comment">//广度优先遍历</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queueNode = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; queueValue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queueNode.offer(root);</span><br><span class="line">        queueValue.offer(sum-root.val);</span><br><span class="line">        <span class="keyword">while</span>(!queueNode.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">curNode</span> <span class="operator">=</span> queueNode.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> queueValue.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span>curNode.left;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> curNode.right;</span><br><span class="line">            <span class="keyword">if</span>(leftNode == <span class="literal">null</span> &amp;&amp; rightNode == <span class="literal">null</span> &amp;&amp; val == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(leftNode != <span class="literal">null</span>)&#123;</span><br><span class="line">                queueNode.offer(leftNode);</span><br><span class="line">                queueValue.offer(val - leftNode.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rightNode != <span class="literal">null</span>)&#123;</span><br><span class="line">                queueNode.offer(rightNode);</span><br><span class="line">                queueValue.offer(val - rightNode.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="226-翻转二叉树"><a class="header-anchor" href="#226-翻转二叉树"> </a><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h2>
<h3 id="题目-v9"><a class="header-anchor" href="#题目-v9"> </a>题目</h3>
<p>翻转一棵二叉树。</p>
<blockquote>
<p>示例：<br>
输入：<br>
4<br>
/     <br>
2        7<br>
/  \       /   <br>
1    3     6    9<br>
输出：<br>
4<br>
/        <br>
7            2<br>
/   \         /   <br>
9     6      3    1</p>
</blockquote>
<h3 id="解题思路-v6"><a class="header-anchor" href="#解题思路-v6"> </a>解题思路</h3>
<p>这题用递归的做法较为简单</p>
<p>有两种递归思路</p>
<ol>
<li>自底向上的对换左右子树</li>
<li>自顶向下的对换左右子树</li>
</ol>
<h3 id="解题代码1自底向上"><a class="header-anchor" href="#解题代码1自底向上"> </a>解题代码1自底向上</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//递归做法</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//一种是先转换当前结点，再转换子节点</span></span><br><span class="line">        <span class="comment">//另一种是先转换子节点，再转换当前结点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> invertTree(root.left);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> invertTree(root.right);</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码2自顶向下"><a class="header-anchor" href="#解题代码2自顶向下"> </a>解题代码2自顶向下</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//递归做法</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//一种是先转换当前结点，再转换子节点</span></span><br><span class="line">        <span class="comment">//另一种是先转换子节点，再转换当前结点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="235-二叉搜索树的最近公共祖先"><a class="header-anchor" href="#235-二叉搜索树的最近公共祖先"> </a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h2>
<h3 id="题目-v10"><a class="header-anchor" href="#题目-v10"> </a>题目</h3>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="http://algorithm-image.qibinaoe.top/binarysearchtree_improved.png" alt="img"></p>
<blockquote>
<p>示例 1:<br>
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>
输出: 6<br>
解释: 节点 2 和节点 8 的最近公共祖先是 6。</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>
输出: 2<br>
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p>
</blockquote>
<p>说明:<br>
所有节点的值都是唯一的。<br>
p、q 为不同节点且均存在于给定的二叉搜索树中。</p>
<h3 id="解题思路1-v4"><a class="header-anchor" href="#解题思路1-v4"> </a>解题思路1</h3>
<p>开始的时候，没有注意到该结点为二叉搜索树，没有利用这个二叉搜索树的的性质的时候（即<strong>左子树的值都比根节点小，右子树的值都比根节点大</strong>），一脸懵逼。但是注意到这点问题就变得比较简单</p>
<p>首先可以通过递归的方式。获取<strong>根节点的值</strong>、<strong>结点<code>p</code>的值</strong>、<strong>结点<code>q</code>的值</strong>。然后从根节点开始，比较它们大小。同时为了方便，可以先算出<code>p</code>和<code>q</code>中的最大值和最小值</p>
<p>可以分成5种情况</p>
<ul>
<li>根节点值大于最大值</li>
<li>根节点值等于最大值</li>
<li>根节点的值小于最大值，大于最小值</li>
<li>根节点的值等于最小值</li>
<li>根节点的值小于最小值</li>
</ul>
<p>可以通过树的图，清楚的看到。</p>
<p>如果大于最大值，则意味着，<code>p</code>、<code>q</code>两个结点都会在根节点左边。此时递归判断根节点的左孩子和<code>p</code>、<code>q</code>的关系</p>
<p>如果等于最大值的情况。说明根节点即为最大值所在的结点，而最小值在根节点的左子树中，此时返回根节点</p>
<p>如果大于最小组，小于最大值。说明，最小值在根节点的左子树，最大值在根节点的右子树，此时返回根节点</p>
<p>如果等于最小值。说明根节点为最小值的结点，而最大值在根节点的右子树中，此时也可以直接返回根节点</p>
<p>如果小于最小值，说明<code>p</code>和<code>q</code>都在根节点的右子树中，此时就去判断根节点的右孩子和<code>p</code>、<code>q</code>的关系</p>
<h3 id="解题代码1-v3"><a class="header-anchor" href="#解题代码1-v3"> </a>解题代码1</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> min;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        min = Math.min(p.val,q.val);</span><br><span class="line">        max = Math.max(p.val,q.val);</span><br><span class="line">        <span class="keyword">return</span> getCommonAncestor(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">getCommonAncestor</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; max)&#123;</span><br><span class="line">            <span class="comment">//最近公共祖先在左子树中</span></span><br><span class="line">            <span class="keyword">return</span> getCommonAncestor(root.left);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val == max)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; min)&#123;</span><br><span class="line">            <span class="comment">//p和q分别在左右两子树中，因此该结点为最近的公共祖先</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val == min)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//在右子树</span></span><br><span class="line">            <span class="keyword">return</span> getCommonAncestor(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v4"><a class="header-anchor" href="#解题思路2-v4"> </a>解题思路2</h3>
<p>也可以通过迭代的方式，思路大同小异</p>
<h3 id="解题代码2-v4"><a class="header-anchor" href="#解题代码2-v4"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(p.val,q.val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.max(p.val,q.val);</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val &gt; max)&#123;</span><br><span class="line">            <span class="comment">//最近公共祖先在左子树中</span></span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val == max)&#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; min)&#123;</span><br><span class="line">                <span class="comment">//p和q分别在左右两子树中，因此该结点为最近的公共祖先</span></span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val == min)&#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//在右子树</span></span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="257-二叉树的所有路径"><a class="header-anchor" href="#257-二叉树的所有路径"> </a><a href="https://leetcode-cn.com/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h2>
<h3 id="题目-v11"><a class="header-anchor" href="#题目-v11"> </a>题目</h3>
<p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<blockquote>
<p>示例:<br>
输入:<br>
1<br>
/   <br>
2     3<br>
<br>
5<br>
输出: [“1-&gt;2-&gt;5”, “1-&gt;3”]</p>
</blockquote>
<p>解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3</p>
<h3 id="解题思路-v7"><a class="header-anchor" href="#解题思路-v7"> </a>解题思路</h3>
<p>对于这道题，应该用深度优先去遍历。在递归的过程中，携带上一层的路径字符串，同时判断遍历到的该结点的情况，如果非叶子节点，则拼接并递归到叶子节点。</p>
<p>注意一下路径字符串拼接的样子</p>
<h3 id="解题代码-v3"><a class="header-anchor" href="#解题代码-v3"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; ans;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        getPath(root,path);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPath</span><span class="params">(TreeNode root,String path)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//说明该节点为叶子结点</span></span><br><span class="line">            path += String.valueOf(root.val);</span><br><span class="line">            ans.add(path);</span><br><span class="line">        &#125;</span><br><span class="line">        path = path + String.valueOf(root.val)+ <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            getPath(root.left,path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            getPath(root.right,path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v5"><a class="header-anchor" href="#解题思路2-v5"> </a>解题思路2</h3>
<p>该题也可以通过广度遍历，利用两个队列，一个用于储存结点，一个用于储存该结点所对应的路径字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//广度优先遍历</span></span><br><span class="line">        <span class="comment">//基本思路是一个储存结点的队列 对应一个储存路径字符串的队列</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queueNode = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;String&gt; queuePath = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        queueNode.offer(root);</span><br><span class="line">        queuePath.offer(Integer.toString(root.val));</span><br><span class="line">        <span class="keyword">while</span>(!queueNode.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">curNode</span> <span class="operator">=</span> queueNode.poll();</span><br><span class="line">            <span class="type">String</span> <span class="variable">curPath</span> <span class="operator">=</span> queuePath.poll();</span><br><span class="line">            <span class="keyword">if</span>(curNode.left == <span class="literal">null</span> &amp;&amp; curNode.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                ans.add(curPath);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(curNode.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                queueNode.offer(curNode.left);</span><br><span class="line">                queuePath.offer(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(curPath).append(<span class="string">&quot;-&gt;&quot;</span>).append(Integer.toString(curNode.left.val)).toString());   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curNode.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                queueNode.offer(curNode.right);</span><br><span class="line">                queuePath.offer(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(curPath).append(<span class="string">&quot;-&gt;&quot;</span>).append(Integer.toString(curNode.right.val)).toString());   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="404-左叶子之和"><a class="header-anchor" href="#404-左叶子之和"> </a><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/">404. 左叶子之和</a></h2>
<h3 id="题目-v12"><a class="header-anchor" href="#题目-v12"> </a>题目</h3>
<p>计算给定二叉树的所有左叶子之和。</p>
<blockquote>
<p>示例：<br>
3<br>
/  <br>
9   20<br>
/  <br>
15   7<br>
在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</p>
</blockquote>
<h3 id="解题思路-v8"><a class="header-anchor" href="#解题思路-v8"> </a>解题思路</h3>
<p>这题我的思路是通过递归来寻找<strong>左叶子节点</strong>，并将其返回。而如何判断递归到的这一个结点是左节点还是右节点呢？我通过在遍历下一层的时候传入一个值（例如左子孩子为0，右孩子为1）这样就解决该结点是左孩子还是右孩子的问题。</p>
<p>而如何获得总和呢？通过递归的思路，如果该结点为左叶子节点，意味着这个结点的左叶子之后为它本身。如果为中间结点的话，则左叶子节点之和和其左子树的叶子节点加上其右子树的叶子节点</p>
<h3 id="解题代码-v4"><a class="header-anchor" href="#解题代码-v4"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> checkLeftSum(<span class="number">0</span>,root.left) + checkLeftSum(<span class="number">1</span>,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">checkLeftSum</span><span class="params">(<span class="type">int</span> type,TreeNode root)</span>&#123;</span><br><span class="line">        <span class="comment">//type 0 左孩子 </span></span><br><span class="line">        <span class="comment">//type 1 右孩子</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">0</span> &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> checkLeftSum(<span class="number">0</span>,root.left) + checkLeftSum(<span class="number">1</span>,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v6"><a class="header-anchor" href="#解题思路2-v6"> </a>解题思路2</h3>
<p>官方题解的整体思路是提前判断。</p>
<p>如果根节点不为空的话，提前判断该根节点的左孩子如果是左叶子节点，是则记录该值；如果为空，则不关；如果是中间节点，则继续访问。判断右孩子如果为叶子节点，则不管；如果为空，则不管；如果为中间结点，则继续访问。同时在这个过程中，累加左叶子结点的值。</p>
<h3 id="解题代码2-0"><a class="header-anchor" href="#解题代码2-0"> </a>解题代码2.0</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root==<span class="literal">null</span>? <span class="number">0</span> : dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isLeaf(root.left))&#123;</span><br><span class="line">                ans += root.left.val;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans += dfs(root.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span> &amp;&amp; !isLeaf(root.right))&#123;</span><br><span class="line">            ans += dfs(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLeaf</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码2-1"><a class="header-anchor" href="#解题代码2-1"> </a>解题代码2.1</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isLeaf(cur.left))&#123;</span><br><span class="line">                    sum+= cur.left.val;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    queue.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span> &amp;&amp; !isLeaf(cur.right))&#123;</span><br><span class="line">                queue.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLeaf</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="501-二叉搜索树中的众数"><a class="header-anchor" href="#501-二叉搜索树中的众数"> </a><a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></h2>
<h3 id="题目-v13"><a class="header-anchor" href="#题目-v13"> </a>题目</h3>
<p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p>
<p>假定 BST 有如下定义：</p>
<p>结点左子树中所含结点的值小于等于当前结点的值<br>
结点右子树中所含结点的值大于等于当前结点的值<br>
左子树和右子树都是二叉搜索树</p>
<blockquote>
<p>例如：<br>
给定 BST [1,null,2,2],<br>
1<br>
<br>
2<br>
/<br>
2<br>
返回[2].</p>
</blockquote>
<blockquote>
<p>提示：如果众数超过1个，不需考虑输出顺序<br>
进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p>
</blockquote>
<h3 id="解题思路1-v5"><a class="header-anchor" href="#解题思路1-v5"> </a>解题思路1</h3>
<p>开始我解决这题的想法是通过简单粗暴的方式。既然题目需要众数，那我们就把整个树遍历一遍，同时储存每一个出现过的数字的次数。最后再挑出最大值塞进答案中，即可。</p>
<p>但是这种做法效率和空间利用率较低</p>
<h3 id="解题代码1效率较低版"><a class="header-anchor" href="#解题代码1效率较低版"> </a>解题代码1效率较低版</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            map.put(cur.val,map.getOrDefault(cur.val,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) queue.offer(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) queue.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> maxValue;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="keyword">if</span>(count &gt; maxCount)&#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">                maxCount = count;</span><br><span class="line">                ans.clear();</span><br><span class="line">                ans.add(value);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count == maxCount)&#123;</span><br><span class="line">                ans.add(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[ans.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ans.size(); i++)&#123;</span><br><span class="line">            result[i] = ans.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2初步优化"><a class="header-anchor" href="#解题思路2初步优化"> </a>解题思路2初步优化</h3>
<p>看了官解的做法，这道题可以通过两步优化：一、优化哈希表储存的空间。二、优化遍历树占用的栈空间</p>
<p>先是优化哈希表的储存空间</p>
<p>可以注意到，题目给的二叉树是一棵<strong>二叉搜索树BST</strong>，而BST树通过<strong>中序遍历（左孩子、根节点、右孩子）<strong>得到的结果是一个有序的数组，由于题目给的BST树是存在相同数字的，所以遍历结果是一个</strong>非递减的序列</strong>。</p>
<p>而如何不使用哈希表去记录存在的众数呢？</p>
<p>可以注意到，出现的相同数字是连续出现的。因此我们可以通过以下几个变量去实时记录和更改众数</p>
<ul>
<li><code>base</code>：记录当前遍历的数字。
<ul>
<li>通过记录这个数字，才可以在遍历下一个结点时，判断是否在连续数字出现的区间中</li>
</ul>
</li>
<li><code>count</code>：记录当前遍历的数字出现的次数
<ul>
<li>如果第一次<code>base</code>与上一次不同，则更改<code>base</code>，同时<code>count</code>置为一。否则<code>count++</code></li>
</ul>
</li>
<li><code>maxCount</code>：来保存目前为止，出现过的最大<code>count</code>值
<ul>
<li>如果<code>count &gt; maxCount</code>，说明最大众数已经变了，需要<strong>清空</strong>已经保存的答案数组。同时将新的众数加入答案数组中，并把<code>maxCount = count</code></li>
<li>如果<code>count == maxCount</code>，说明遍历到的当前数字与记录中的数字，出现的次数一致，都是众数。因此将该数加入答案数组中</li>
</ul>
</li>
<li><code>answers</code>：答案数组，用于保存出现的次数最多的数字。因为众数可能不唯一，所以声明为数组</li>
</ul>
<h3 id="解题代码2-v5"><a class="header-anchor" href="#解题代码2-v5"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; answers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 这里不赋值的话，也是默认为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[answers.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; answers.size(); i++)&#123;</span><br><span class="line">            result[i] = answers.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="comment">//递归的方式进行中序遍历</span></span><br><span class="line">        <span class="comment">//会占用栈空间</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        update(root.val); <span class="comment">//判断当前结点，进行操作</span></span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(val == base)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            base = val;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; maxCount)&#123;</span><br><span class="line">            <span class="comment">//说明之前存的答案数组都是假的众数，清空</span></span><br><span class="line">            answers.clear();</span><br><span class="line">            answers.add(val);</span><br><span class="line">            maxCount = count;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count == maxCount)&#123;</span><br><span class="line">            answers.add(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路3再优化-morris中序遍历"><a class="header-anchor" href="#解题思路3再优化-morris中序遍历"> </a>解题思路3再优化 morris中序遍历</h3>
<p>在一般的中序遍历中，由于访问顺序是左孩子-&gt;根节点-&gt;右孩子。</p>
<p>所以如果我们直接去访问左孩子，而不做任何措施保存根节点，这样我们就回不到根节点了。</p>
<p>所以通常做法是：</p>
<p>如果通过递归回溯的方式，那么在访问左孩子时，根节点被压入栈空间中。当递归返回时，根节点就回来了。</p>
<p>如果通过迭代的方式，也需要我们手动维护一个栈。所以这两种方法都需要消耗栈空间的大小。</p>
<p>而morris中序遍历通过改变树的结构，来达到访问左节点的时候能够保存当前结点，以便前驱结点访问后，能够回到当前结点。</p>
<p>对于morris中序遍历思想的学习，我是结合 <a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-zhong-shu-by-leetcode-/">leetcode官解介绍</a>和 <a href="https://www.bilibili.com/video/BV13J411z7Z5?from=search&amp;seid=13089413801761549678">【算法奇淫技】第一期Morris遍历（二叉树的特殊遍历法）</a>的学习。</p>
<p>其中实现的最基本操作就是：将<strong>当前结点</strong>的<strong>左孩子</strong>的<strong>最右结点</strong>指向<strong>当前结点</strong>。</p>
<p>这样做的目的是，我们在每一次访问某个结点时，去找到其左孩子的最右结点。这个“左孩子的最右结点”即为当前结点的前驱结点（前驱结点意思就是按中序遍历的顺序中，访问了“左孩子的最右结点”之后，就该访问当前结点了）。</p>
<p>当我们找到了“左孩子的最右结点”后，需要判断，这个节点是否已经指向了当前结点。如果没有，就将其指向当前结点；如果指向了，说明我们已经设置过这个结点，同时也表明当前结点的左子树都已经遍历过了，接下来是访问当前结点，然后去访问其右孩子。</p>
<p>当然，如果当前结点连左孩子都没有的时候，说明可以直接访问当前结点，在访问右孩子。直到遍历到左右孩子都为空。</p>
<p>虽然morris算法的空间复杂度为O(1)，但是这种算法的时间上的效率会相对较低一点，毕竟对于每个节点都要去看一看它左孩子的最右结点。</p>
<h3 id="解题代码3"><a class="header-anchor" href="#解题代码3"> </a>解题代码3</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; answers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 这里不赋值的话，也是默认为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        morris(root);</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[answers.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; answers.size(); i++)&#123;</span><br><span class="line">            result[i] = answers.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">morris</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="comment">//morris中序遍历</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//判断左子树是否为空</span></span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//说明当前结点可以进行操作</span></span><br><span class="line">                update(root.val);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//获得当前结点的左子树的最右结点</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">prev</span> <span class="operator">=</span> root.left;</span><br><span class="line">                <span class="keyword">while</span>(prev.right != <span class="literal">null</span> &amp;&amp; prev.right != root) prev = prev.right;</span><br><span class="line">                <span class="comment">//判断是否是当前结点</span></span><br><span class="line">                <span class="comment">//如果是，说明已经设置过，可以进行访问</span></span><br><span class="line">                <span class="comment">//如果没有，则将其右节点指向当前结点，并访问其左节点，因为我们已经将当前节点储存到leftNode.right，所以不用担心访问不到</span></span><br><span class="line">                <span class="keyword">if</span>(prev.right == root)&#123;</span><br><span class="line">                    prev.right = <span class="literal">null</span>; <span class="comment">//复原，但是不写不影响答案</span></span><br><span class="line">                    update(root.val);</span><br><span class="line">                    root = root.right;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    prev.right = root;</span><br><span class="line">                    root = root.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(val == base)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            base = val;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; maxCount)&#123;</span><br><span class="line">            <span class="comment">//说明之前存的答案数组都是假的众数，清空</span></span><br><span class="line">            answers.clear();</span><br><span class="line">            answers.add(val);</span><br><span class="line">            maxCount = count;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count == maxCount)&#123;</span><br><span class="line">            answers.add(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="530-二叉搜索树的最小绝对差"><a class="header-anchor" href="#530-二叉搜索树的最小绝对差"> </a><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h2>
<h3 id="题目-v14"><a class="header-anchor" href="#题目-v14"> </a>题目</h3>
<p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p>
<blockquote>
<p>示例：<br>
输入：<br>
1<br>
<br>
3<br>
/<br>
2<br>
输出：<br>
1<br>
解释：<br>
最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。</p>
</blockquote>
<p>提示：</p>
<p>树中至少有 2 个节点。</p>
<h3 id="解题思路-v9"><a class="header-anchor" href="#解题思路-v9"> </a>解题思路</h3>
<p>注意到这题是一棵BST树。而题目要求的是差的绝对值的最小值。那么这个数值只可能出现在两个相邻结点中（即某个结点与它的前驱结点或某个结点与它的后继结点）。</p>
<p>根据这个思路，我们进行中序遍历，并边遍历，边判断是否是最小绝对差。</p>
<p>我认为这题的难点在于上一个数值（<code>preval</code>）的初始化和最小绝对差（<code>minAbs</code>）的初始化。</p>
<p>于是我就采用最土的方式：判断是否是第一个数，判断是否是第二个数，来解决这个问题</p>
<p>注：开始的时候，我是这样初始化的：<code>preval = Integer.MIN_VALUE;</code> 和<code>minAbs = Integer.MAX_VALUE;</code>结果出现了整型溢出了。</p>
<p>看到官解它是这样初始化的：<code>preval = -1</code> 和<code>minAbs = Integer.MAX_VALUE;</code>然后通过判断<code>preval == -1</code>来分辨是否是第一次。</p>
<h3 id="解题代码1-0-v3"><a class="header-anchor" href="#解题代码1-0-v3"> </a>解题代码1.0</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> preval; <span class="comment">//上一个数值</span></span><br><span class="line">    <span class="type">int</span> minAbs; <span class="comment">// 最小绝对值</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">first</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">//判断是否是第一个数</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">second</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 判断是否是第二个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//中序遍历，计算两个相邻数的差值</span></span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">return</span> minAbs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        calculate(root.val);</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="comment">//1.计算差值的绝对值</span></span><br><span class="line">        <span class="comment">//2.比较与记录值的大小</span></span><br><span class="line">        <span class="keyword">if</span>(first)&#123;</span><br><span class="line">            preval = val;</span><br><span class="line">            first = <span class="literal">false</span>;</span><br><span class="line">            second = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> Math.abs(val-preval);</span><br><span class="line">        <span class="keyword">if</span>(second)&#123;</span><br><span class="line">            minAbs = diff;</span><br><span class="line">            preval = val;</span><br><span class="line">            second = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;            </span><br><span class="line">        &#125;</span><br><span class="line">        minAbs = diff &lt; minAbs?diff:minAbs;</span><br><span class="line">        preval = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码2-0-v2"><a class="header-anchor" href="#解题代码2-0-v2"> </a>解题代码2.0</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> preval; <span class="comment">//上一个数值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">minAbs</span> <span class="operator">=</span> Integer.MAX_VALUE; <span class="comment">// 最小绝对值</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">first</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">//判断是否是第一个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//中序遍历，计算两个相邻数的差值</span></span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">return</span> minAbs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        calculate(root.val);</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="comment">//1.计算差值的绝对值</span></span><br><span class="line">        <span class="comment">//2.比较与记录值的大小</span></span><br><span class="line">        <span class="keyword">if</span>(first)&#123;</span><br><span class="line">            preval = val;</span><br><span class="line">            first = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> Math.abs(val-preval);</span><br><span class="line">        minAbs = diff &lt; minAbs?diff:minAbs;</span><br><span class="line">        preval = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="543-二叉树的直径"><a class="header-anchor" href="#543-二叉树的直径"> </a><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h2>
<h3 id="题目-v15"><a class="header-anchor" href="#题目-v15"> </a>题目</h3>
<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<blockquote>
<p>示例 :<br>
给定二叉树<br>
1<br>
/ <br>
2   3<br>
/ \<br>
4   5<br>
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p>
</blockquote>
<p>注意：两结点之间的路径长度是以它们之间边的数目表示。</p>
<h3 id="解题思路-v10"><a class="header-anchor" href="#解题思路-v10"> </a>解题思路</h3>
<p>这题计算树的直径，可以看到，计算直径的过程又与计算树的高度有关系（“<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a>”）。即一个树的某个结点的直径即为其左子树的深度加上右子树的深度。</p>
<p>因此，我们可以根据递归算出左子树的深度，右子树的深度，（注意<u><strong>“两结点之间的路径长度是以它们之间边的数目表示”</strong></u>，因此深度之和后不需要再加1），然后相加判断当前的直径是否是最大直径。由于最大直径只需要一个变量即可满足，因此可以把它定义在函数外，然后的每个递归中去判断当前的直径和最大直径大小即可</p>
<h3 id="解题代码-v5"><a class="header-anchor" href="#解题代码-v5"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">maxDiameter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//可以在获取树的高度的同时，计算是否大于最大直径，如果是，更新</span></span><br><span class="line">        <span class="comment">// 由于最大直径在整个计算过程具有唯一性，所以定义成全局变量就可以了，不需要每次递归都返回</span></span><br><span class="line">        height(root);</span><br><span class="line">        <span class="keyword">return</span> maxDiameter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> height(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> height(root.right);</span><br><span class="line">        <span class="comment">//判断是否大于最大直径</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">diameter</span> <span class="operator">=</span> leftHeight+rightHeight;</span><br><span class="line">        <span class="keyword">if</span>(diameter &gt; maxDiameter) maxDiameter = diameter;</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftHeight,rightHeight) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="559-N-叉树的最大深度"><a class="header-anchor" href="#559-N-叉树的最大深度"> </a><a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></h2>
<h3 id="题目-v16"><a class="header-anchor" href="#题目-v16"> </a>题目</h3>
<p>给定一个 N 叉树，找到其最大深度。</p>
<p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p>
<p>N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。</p>
<blockquote>
<p>示例 1：<br>
输入：root = [1,null,3,2,4,null,5,6]<br>
输出：3</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]<br>
输出：5</p>
</blockquote>
<blockquote>
<p>提示：<br>
树的深度不会超过 1000 。<br>
树的节点数目位于 [0, 104] 之间。</p>
</blockquote>
<h3 id="解题思路1-v6"><a class="header-anchor" href="#解题思路1-v6"> </a>解题思路1</h3>
<p>我觉得求N叉树的最大深度的思想与“<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a>”的思想是一样的。</p>
<p>主要有两种方式去做：</p>
<ol>
<li>
<p>通过深度优先遍历，用递归的方式，判断N个孩子的最大深度，然后返回自身加1</p>
</li>
<li>
<p>通过广度优先遍历，借助队列的方式，遍历到最深层</p>
</li>
</ol>
<p>不同点在于孩子的个数，N叉树需要把每个孩子都取出来，然后获取其值最大的那个孩子。</p>
<p>由于要比较这N个孩子的最小值，想想太过麻烦，于是想到<code>PriorityQueue</code>能够取出最小值（或者最大值），通过传入一个<code>Comparator</code>即可实现。于是第一种方法就是借助优先队列完成</p>
<h3 id="解题代码1-v4"><a class="header-anchor" href="#解题代码1-v4"> </a>解题代码1</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="comment">//递归法</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//获取孩子们的最大深度</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((Integer a, Integer b)-&gt; b-a);</span><br><span class="line">        <span class="keyword">for</span>(Node child : root.children)&#123;</span><br><span class="line">            <span class="keyword">if</span>(child != <span class="literal">null</span>) queue.offer(maxDepth(child));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty()?<span class="number">1</span> : queue.poll()+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码2-v6"><a class="header-anchor" href="#解题代码2-v6"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="comment">//递归法</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.children.isEmpty()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        List&lt;Integer&gt; heights = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Node child : root.children)&#123;</span><br><span class="line">            heights.add(maxDepth(child));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Collections.max(heights)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码3-v2"><a class="header-anchor" href="#解题代码3-v2"> </a>解题代码3</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个版本是最快的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="comment">//递归法</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.children.isEmpty()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(Node child : root.children)&#123;</span><br><span class="line">            ans = Math.max(maxDepth(child),ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码4"><a class="header-anchor" href="#解题代码4"> </a>解题代码4</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="comment">//层次遍历法</span></span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) queue.add(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="comment">//整层取出来</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">for</span>(Node child : cur.children)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(child != <span class="literal">null</span>)&#123;</span><br><span class="line">                        queue.offer(child);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码5"><a class="header-anchor" href="#解题代码5"> </a>解题代码5</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这方法最慢</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="comment">//层次遍历法</span></span><br><span class="line">        Queue&lt;Pair&lt;Node,Integer&gt;&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) queue.add(<span class="keyword">new</span> <span class="title class_">Pair</span>(root,<span class="number">1</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            Pair&lt;Node,Integer&gt; p = queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">curDepth</span> <span class="operator">=</span> p.getValue();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">curNode</span> <span class="operator">=</span> p.getKey();</span><br><span class="line">            depth = curDepth &gt; depth ? curDepth : depth;</span><br><span class="line">            <span class="keyword">for</span>(Node child : curNode.children)&#123;</span><br><span class="line">                <span class="keyword">if</span>(child != <span class="literal">null</span>) queue.offer(<span class="keyword">new</span> <span class="title class_">Pair</span>(child,curDepth + <span class="number">1</span>));</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="563-二叉树的坡度"><a class="header-anchor" href="#563-二叉树的坡度"> </a><a href="https://leetcode-cn.com/problems/binary-tree-tilt/">563. 二叉树的坡度</a></h2>
<h3 id="题目-v17"><a class="header-anchor" href="#题目-v17"> </a>题目</h3>
<p>给定一个二叉树，计算 整个树 的坡度 。</p>
<p>一个树的 节点的坡度 定义即为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。</p>
<p>整个树 的坡度就是其所有节点的坡度之和。</p>
<blockquote>
<p>示例 1：<br>
输入：root = [1,2,3]<br>
输出：1<br>
解释：<br>
节点 2 的坡度：|0-0| = 0（没有子节点）<br>
节点 3 的坡度：|0-0| = 0（没有子节点）<br>
节点 1 的坡度：|2-3| = 1（左子树就是左子节点，所以和是 2 ；右子树就是右子节点，所以和是 3 ）<br>
坡度总和：0 + 0 + 1 = 1</p>
<p><img src="http://algorithm-image.qibinaoe.top/tilt1.jpg" alt="img"></p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：root = [4,2,9,3,5,null,7]<br>
输出：15<br>
解释：<br>
节点 3 的坡度：|0-0| = 0（没有子节点）<br>
节点 5 的坡度：|0-0| = 0（没有子节点）<br>
节点 7 的坡度：|0-0| = 0（没有子节点）<br>
节点 2 的坡度：|3-5| = 2（左子树就是左子节点，所以和是 3 ；右子树就是右子节点，所以和是 5 ）<br>
节点 9 的坡度：|0-7| = 7（没有左子树，所以和是 0 ；右子树正好是右子节点，所以和是 7 ）<br>
节点 4 的坡度：|(3+5+2)-(9+7)| = |10-16| = 6（左子树值为 3、5 和 2 ，和是 10 ；右子树值为 9 和 7 ，和是 16 ）<br>
坡度总和：0 + 0 + 0 + 2 + 7 + 6 = 15</p>
<p><img src="http://algorithm-image.qibinaoe.top/tilt2.jpg" alt="img"></p>
</blockquote>
<blockquote>
<p>示例 3：<br>
输入：root = [21,7,14,1,1,2,2,3,3]<br>
输出：9</p>
<p><img src="http://algorithm-image.qibinaoe.top/tilt3.jpg" alt="img"></p>
</blockquote>
<blockquote>
<p>提示：<br>
树中节点数目的范围在 [0, 104] 内<br>
-1000 &lt;= Node.val &lt;= 1000</p>
</blockquote>
<h3 id="解题思路-v11"><a class="header-anchor" href="#解题思路-v11"> </a>解题思路</h3>
<p>要解决这题首先要理解题目中坡度的意思。</p>
<p><strong>一个</strong>结点的<strong>坡度</strong>指的是：该结点的<strong>左子树</strong>中的所有结点的<strong>值之和</strong>与该结点的<strong>右子树</strong>的所有结点的<strong>值之和</strong>，这两个左子树的和与右子树的和的<strong>差的绝对值</strong></p>
<p>而对于题目要<strong>求</strong>的是<strong>整个树</strong>的坡度。即<strong>每个结点</strong>的坡度的<strong>和</strong>。</p>
<p>显然这个题目有种递归的感觉，但是又带点迷惑性。因为对于某个结点而言，我们要算的是其左右子树的差。但是我们又要其左右子树的和，来返回给父结点。</p>
<p>因此我想到的解决办法是定义一个全局变量<code>totalTilt = 0</code>初始化为零。我们先不管坡度的定义。我们去思考，如何去算一个结点的左子树之和，和其右子树子树，并返回这两个值的总和。解决了这个问题之后。我们只需要在递归的过程中。将一个结点的左右子树和的差的绝对值加入我们定义的全局变量，即可得到答案。</p>
<h3 id="解题代码-v6"><a class="header-anchor" href="#解题代码-v6"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">totalTilt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTilt</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        treeSum(root);</span><br><span class="line">        <span class="keyword">return</span> totalTilt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">treeSum</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSum</span> <span class="operator">=</span>  treeSum(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightSum</span> <span class="operator">=</span> treeSum(root.right);</span><br><span class="line">        totalTilt+= Math.abs(leftSum-rightSum);</span><br><span class="line">        <span class="keyword">return</span> root.val + leftSum + rightSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="572-另一个树的子树"><a class="header-anchor" href="#572-另一个树的子树"> </a><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/">572. 另一个树的子树</a></h2>
<h3 id="题目-v18"><a class="header-anchor" href="#题目-v18"> </a>题目</h3>
<p>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p>
<blockquote>
<p>示例 1:<br>
给定的树 s:<br>
3<br>
/ <br>
4   5<br>
/ <br>
1   2<br>
给定的树 t：<br>
4<br>
/ <br>
1   2<br>
返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
给定的树 s：<br>
3<br>
/ <br>
4   5<br>
/ <br>
1   2<br>
/<br>
0<br>
给定的树 t：<br>
4<br>
/ <br>
1   2<br>
返回 false。</p>
</blockquote>
<h3 id="解题思路-v12"><a class="header-anchor" href="#解题思路-v12"> </a>解题思路</h3>
<p>这题显然可以用递归的方法去求解。即判断一棵树t是否是另一棵树s的子树，只需判断t和s是否是相等的树，或者t和s的左子树相等，或者t和s的右子树相等，或者t是s的左子树的一棵子树，或者t是s的右子树的一棵子树。根据这个条件可以写递归的函数。</p>
<p>但是要注意一点，要区别子树和相等的条件。以下是<strong>错误</strong>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> ^ t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> &amp;&amp; t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.val != t.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> isSubtree(s.left,t) || isSubtree(s.right,t);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (isSubtree(s.left,t.left) &amp;&amp; isSubtree(s.right,t.right)) || isSubtree(s.left,t) || isSubtree(s.right,t);<span class="comment">//ERROR 主要是这一步是错的。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在分析一下最后一个<code>return</code>为什么是错的：</p>
<p>这个语句块的条件是s的值等于t的值。那么s和t可能就是一棵相同的树，那么继续判断是不是真的是一棵相同树，应该判断s的左子树是否和t的左子树<strong>完全相等</strong>，s的右子树是否和t的右子树<strong>完全相等</strong>。而这个语句块却写的是：<code>isSubtree(s.left,t.left) &amp;&amp; isSubtree(s.right,t.right)</code>即s的左子树是否包括t.左子树（有可能存在s的左子树中有t的左子树中没有的结点），s的右子树是否包括t的右子树。这样一来，成为子树的条件就<strong>放宽</strong>了，导致出错。</p>
<p>例如当s为</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201219164624286.png" alt="image-20201219164624286"></p>
<p>t为</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201219164646422.png" alt="image-20201219164646422"></p>
<p>就错了。</p>
<h3 id="解题代码-v7"><a class="header-anchor" href="#解题代码-v7"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> ^ t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> &amp;&amp; t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.val != t.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> isSubtree(s.left,t) || isSubtree(s.right,t);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (isSameTree(s.left,t.left) &amp;&amp; isSameTree(s.right,t.right)) || isSubtree(s.left,t) || isSubtree(s.right,t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode s, TreeNode t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> ^ t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> &amp;&amp; t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.val != t.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> isSameTree(s.left,t.left) &amp;&amp; isSameTree(s.right,t.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="589-N叉树的前序遍历"><a class="header-anchor" href="#589-N叉树的前序遍历"> </a><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/">589. N叉树的前序遍历</a></h2>
<h3 id="题目-v19"><a class="header-anchor" href="#题目-v19"> </a>题目</h3>
<p>给定一个 N 叉树，返回其节点值的前序遍历。</p>
<p>例如，给定一个 3叉树 :</p>
<p><img src="http://algorithm-image.qibinaoe.top/narytreeexample.png" alt="img">返回其前序遍历: [1,3,5,6,2,4]。</p>
<p>说明: 递归法很简单，你可以使用迭代法完成此题吗?</p>
<h3 id="解题思路1-v7"><a class="header-anchor" href="#解题思路1-v7"> </a>解题思路1</h3>
<p>递归法的思路就是简单的前序遍历的写法，只需要遍历左右孩子改成循环遍历每个孩子</p>
<h3 id="解题代码1-v5"><a class="header-anchor" href="#解题代码1-v5"> </a>解题代码1</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; answer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        answer.add(root.val);</span><br><span class="line">        <span class="comment">//遍历孩子节点们</span></span><br><span class="line">        <span class="keyword">for</span>(Node child : root.children) dfs(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v7"><a class="header-anchor" href="#解题思路2-v7"> </a>解题思路2</h3>
<p>用迭代的方法就是利用栈的方式，先将根节点压栈。</p>
<p>判断停止的条件是栈不为空</p>
<p>先弹出栈顶元素，进行访问，然后将该元素的孩子从右自左开始压栈。这样下一个栈顶元素就是其最左孩子。符合前序遍历的顺序</p>
<h3 id="解题代码2-v7"><a class="header-anchor" href="#解题代码2-v7"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; answer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> answer;</span><br><span class="line">        Deque&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.addLast(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span>stack.removeLast();</span><br><span class="line">            List&lt;Node&gt; children = cur.children;</span><br><span class="line">            <span class="comment">//孩子入栈</span></span><br><span class="line">            Collections.reverse(children);</span><br><span class="line">            <span class="keyword">for</span>(Node child : children) stack.addLast(child);</span><br><span class="line">            answer.add(cur.val);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="590-N叉树的后序遍历"><a class="header-anchor" href="#590-N叉树的后序遍历"> </a><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">590. N叉树的后序遍历</a></h2>
<h3 id="题目-v20"><a class="header-anchor" href="#题目-v20"> </a>题目</h3>
<p>给定一个 N 叉树，返回其节点值的后序遍历。</p>
<p>例如，给定一个 3叉树 :</p>
<p><img src="http://algorithm-image.qibinaoe.top/narytreeexample.png" alt="img"></p>
<p>返回其后序遍历: [5,6,3,2,4,1].</p>
<p>说明: 递归法很简单，你可以使用迭代法完成此题吗?</p>
<h3 id="解题思路-v13"><a class="header-anchor" href="#解题思路-v13"> </a>解题思路</h3>
<p>递归的方式也是先取出所有的子节点，进行递归遍历。最后再访问当前结点</p>
<h3 id="解题代码-v8"><a class="header-anchor" href="#解题代码-v8"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; answer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">       postOrder(root);</span><br><span class="line">       <span class="keyword">return</span> answer; </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(Node child : root.children)&#123;</span><br><span class="line">            postOrder(child);</span><br><span class="line">        &#125;</span><br><span class="line">        answer.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v8"><a class="header-anchor" href="#解题思路2-v8"> </a>解题思路2</h3>
<p>既然要使用迭代的方式进行递归。而后序遍历的顺序是最右孩子-&gt;最左孩子-&gt;根节点</p>
<p>因此如果要利用栈的方式的话，先压根结点，再把孩子从右到左的顺序压栈。</p>
<p>按这种思路去做的话，需要记录该结点是第几次入栈，第几次出栈。当一个结点第二次出栈的时候，是可以进行访问的。</p>
<p>我是利用有一个哈希表去记录这个结点是第几次出栈</p>
<h3 id="解题代码2-v8"><a class="header-anchor" href="#解题代码2-v8"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; answer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> answer;</span><br><span class="line">        Deque&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;Node,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">// 用于存储访问次数</span></span><br><span class="line">        stack.addLast(root);</span><br><span class="line">        map.put(root,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//压栈顺序是</span></span><br><span class="line">            <span class="comment">//先压根节点，再从右自左压栈</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> stack.removeLast();</span><br><span class="line">            <span class="keyword">if</span>(map.getOrDefault(cur,<span class="number">0</span>) == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">//可以访问</span></span><br><span class="line">                answer.add(cur.val);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;Node&gt; children = cur.children;</span><br><span class="line">            stack.addLast(cur);</span><br><span class="line">            map.put(cur,map.getOrDefault(cur,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            Collections.reverse(children);</span><br><span class="line">            <span class="keyword">for</span>(Node child : children)&#123;</span><br><span class="line">                stack.addLast(child);</span><br><span class="line">                map.put(child,map.getOrDefault(child,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路3"><a class="header-anchor" href="#解题思路3"> </a>解题思路3</h3>
<p>“解题思路2”通过记录每个结点出栈次数来进行后续遍历，但是这样做法太过繁琐，以及需要消耗空间来储存次数。</p>
<p>可以发现</p>
<p>前序遍历的顺序是根-&gt;左-&gt;右。</p>
<p>后序遍历的顺序是左-&gt;右-&gt;根。</p>
<p>那么我们可以通过再修改前序遍历顺序，即我们将访问顺序改成：根-&gt;右-&gt;左。</p>
<p>那么这样访问后的结果就是和真正的后序遍历的结果顺序刚好相反。</p>
<p>我们可以在最后对整个结果进行一次翻转。或者在插入的过程中，向数组开头插入元素。都可以达成我们想要的结果</p>
<p>而怎么做才能做到根-&gt;右-&gt;左的顺序呢？</p>
<p>我们只需要修改压栈的顺序。</p>
<p>对于<strong>前序遍历</strong>，我们是先压右孩子，再压左孩子，来让左孩子在栈顶，右孩子在栈底。这样我们就能先访问左孩子，来完成前序遍历。</p>
<p>而对于<strong>后序遍历</strong>，我们就先压左孩子，再压右孩子，就能够先访问右孩子，再访问左孩子。这样就是根-&gt;右-&gt;左的顺序了</p>
<h3 id="解题代码3-v3"><a class="header-anchor" href="#解题代码3-v3"> </a>解题代码3</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; answer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> answer;</span><br><span class="line">        Deque&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.addLast(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> stack.removeLast();</span><br><span class="line">            answer.add(cur.val);</span><br><span class="line">            <span class="keyword">for</span>(Node child : cur.children) stack.addLast(child);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(answer);</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码3-1"><a class="header-anchor" href="#解题代码3-1"> </a>解题代码3.1</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; answer = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> answer;</span><br><span class="line">        Deque&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.addLast(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> stack.removeLast();</span><br><span class="line">            answer.addFirst(cur.val);</span><br><span class="line">            <span class="keyword">for</span>(Node child : cur.children) stack.addLast(child);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="606-根据二叉树创建字符串"><a class="header-anchor" href="#606-根据二叉树创建字符串"> </a><a href="https://leetcode-cn.com/problems/construct-string-from-binary-tree/">606. 根据二叉树创建字符串</a></h2>
<h3 id="题目-v21"><a class="header-anchor" href="#题目-v21"> </a>题目</h3>
<p>你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。</p>
<p>空节点则用一对空括号 “()” 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。</p>
<blockquote>
<p>示例 1:<br>
输入: 二叉树: [1,2,3,4]<br>
1<br>
/   <br>
2     3<br>
/<br>
4<br>
输出: “1(2(4))(3)”<br>
解释: 原本将是“1(2(4)())(3())”，<br>
在你省略所有不必要的空括号对之后，<br>
它将是“1(2(4))(3)”。</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
输入: 二叉树: [1,2,3,null,4]<br>
1<br>
/   <br>
2     3<br>
\<br>
4<br>
输出: “1(2()(4))(3)”<br>
解释: 和第一个示例相似，</p>
</blockquote>
<p>除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。</p>
<h3 id="解题思路-v14"><a class="header-anchor" href="#解题思路-v14"> </a>解题思路</h3>
<p>首先我们可以通过递归的思路实现这题。</p>
<p>首先我们讨论几种特殊情况</p>
<p>括号输出的情况</p>
<ul>
<li>当前结点为空结点
<ul>
<li>空结点按道理需要输出“()”</li>
<li>但是如果该空结点的<strong>父节点</strong>是<strong>叶子结点</strong>的时候，该空结点不需要输出空括号</li>
<li>如果该空结点的父节点是中间结点时，那就要判断整个空结点相对于父节点来说，是左结点还是右节点。
<ul>
<li>当这个空结点是左孩子时，那么其兄弟结点（父节点的右孩子）不为空。那这个空括号必须输出，才能够体现出兄弟结点</li>
<li>当这个空结点时右孩子时，那么其兄弟结点（父节点的左孩子）不为空。那么这个空括号可以省略</li>
</ul>
</li>
</ul>
</li>
<li>当前结点不为空
<ul>
<li>那么肯定要输出一个括号来包括它</li>
</ul>
</li>
</ul>
<p>现在讨论输出格式的问题</p>
<p>第一点：外层括号问题</p>
<p>可以发现答案输出的结果最外层并没有括号。那么我们可以通过<code>answer.substring(1,answer.length()-1)</code>来去掉做外层括号。</p>
<p>第二点：如何把当前结点的左右孩子“塞”进当前结点的数字的右边，右括号的左边呢？</p>
<p>我们可以在递归的流程中，先输出左括号和当前结点的值，再递归左右孩子，再补上右括号</p>
<p>根据上面的讨论，我们就可以写出递归的式子了</p>
<p>第三点：怎么知道当前结点是左孩子还是右孩子呢</p>
<p>我们可以把这件事交给父结点去判断，然后传入子递归中</p>
<h3 id="解题代码-v9"><a class="header-anchor" href="#解题代码-v9"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">StringBuilder</span> <span class="variable">answer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tree2str</span><span class="params">(TreeNode t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        dfs(t,<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> answer.substring(<span class="number">1</span>,answer.length()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode t,<span class="type">boolean</span> need)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(need) answer.append(<span class="string">&quot;()&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理当前结点</span></span><br><span class="line">        answer.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        answer.append(String.valueOf(t.val));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(t.right == <span class="literal">null</span> &amp;&amp; t.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            dfs(t.left,<span class="literal">false</span>);</span><br><span class="line">            dfs(t.right,<span class="literal">false</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dfs(t.left,<span class="literal">true</span>);</span><br><span class="line">            dfs(t.right,<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        answer.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="官方题解代码递归"><a class="header-anchor" href="#官方题解代码递归"> </a>官方题解代码递归</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接采用字符串拼接，效率低</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tree2str</span><span class="params">(TreeNode t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(t.left == <span class="literal">null</span> &amp;&amp; t.right == <span class="literal">null</span>) <span class="keyword">return</span> t.val+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(t.right == <span class="literal">null</span>) <span class="keyword">return</span> t.val + <span class="string">&quot;(&quot;</span>+tree2str(t.left)+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> t.val+<span class="string">&quot;(&quot;</span>+tree2str(t.left)+<span class="string">&quot;)&quot;</span>+<span class="string">&quot;(&quot;</span>+tree2str(t.right)+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="改进官解代码递归"><a class="header-anchor" href="#改进官解代码递归"> </a>改进官解代码递归</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">StringBuilder</span> <span class="variable">answer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tree2str</span><span class="params">(TreeNode t)</span> &#123;</span><br><span class="line">        treetostr(t);</span><br><span class="line">        <span class="keyword">return</span> answer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">treetostr</span><span class="params">(TreeNode t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>)&#123;</span><br><span class="line">            answer.append(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(t.left == <span class="literal">null</span> &amp;&amp; t.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            answer.append(t.val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(t.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            answer.append(t.val);</span><br><span class="line">            answer.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            treetostr(t.left);</span><br><span class="line">            answer.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            answer.append(t.val);</span><br><span class="line">            answer.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            treetostr(t.left);</span><br><span class="line">            answer.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">            answer.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            treetostr(t.right);</span><br><span class="line">            answer.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v9"><a class="header-anchor" href="#解题思路2-v9"> </a>解题思路2</h3>
<p>当然，也可以用迭代的方式来实现这一道题（主要参考官解）</p>
<p>要通过迭代的方式实现前序遍历，那就需要一个栈来实现我们所需要的元素顺序</p>
<p>但是我们还需要知道，什么时候，需要添加右括号。换句话说，我们不能直接把栈的元素弹出来，并添加左括号以后，就把该元素丢弃了，这样我们就无法添加右括号</p>
<p>因此我们可以在第一次访问该元素时，不弹出该元素，而是将它添加到一个集合set中，以便下一次在栈中又访问到该元素时，知道它是第二次被访问。而在第二次被访问时，就可以添加上右括号</p>
<h3 id="解题代码2-v9"><a class="header-anchor" href="#解题代码2-v9"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tree2str</span><span class="params">(TreeNode t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Set&lt;TreeNode&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        stack.offerLast(t);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> stack.peekLast();</span><br><span class="line">            <span class="keyword">if</span>(visited.contains(cur))&#123;</span><br><span class="line">                s.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">                stack.pollLast();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                visited.add(cur);</span><br><span class="line">                s.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">                s.append(cur.val);</span><br><span class="line">                <span class="keyword">if</span>(cur.left == <span class="literal">null</span> &amp;&amp; cur.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    s.append(<span class="string">&quot;()&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    stack.offerLast(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    stack.offerLast(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(<span class="number">1</span>,s.length()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="617-合并二叉树"><a class="header-anchor" href="#617-合并二叉树"> </a><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></h2>
<h3 id="题目-v22"><a class="header-anchor" href="#题目-v22"> </a>题目</h3>
<p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<blockquote>
<p>示例 1:<br>
输入:<br>
Tree 1                     Tree 2<br>
1                         2<br>
/ \                       / \<br>
3   2                   1   3<br>
/                            \   \<br>
5                               4   7<br>
输出:<br>
合并后的树:<br>
3<br>
/ <br>
4   5<br>
/ \   \<br>
5   4   7<br>
注意: 合并必须从两个树的根节点开始。</p>
</blockquote>
<h3 id="解题思路-v15"><a class="header-anchor" href="#解题思路-v15"> </a>解题思路</h3>
<p>如果通过递归想法去解决这题的话。可以先思考是要重新生成一棵新的树，或者是直接在原来的树上修改。</p>
<p>然后递归的话，要合并一棵树，我们就从一个结点入手。一个结点要被合并，则其值要等于两棵树上该位置的值。同时不能直接递归下去，这样会失去当前结点和其两个孩子结点的两个引用。因此要在一个递归中，设置其左孩子和右孩子。</p>
<h3 id="解题代码1-v6"><a class="header-anchor" href="#解题代码1-v6"> </a>解题代码1</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="literal">null</span> &amp;&amp; t2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> (t1==<span class="literal">null</span>?<span class="number">0</span>:t1.val)+(t2==<span class="literal">null</span>?<span class="number">0</span>:t2.val);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        t3.left = mergeTrees(t1==<span class="literal">null</span>?<span class="literal">null</span>:t1.left,t2==<span class="literal">null</span>?<span class="literal">null</span>:t2.left);</span><br><span class="line">        t3.right = mergeTrees(t1==<span class="literal">null</span>?<span class="literal">null</span>:t1.right,t2==<span class="literal">null</span>?<span class="literal">null</span>:t2.right);</span><br><span class="line">        <span class="keyword">return</span> t3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码1-1-v3"><a class="header-anchor" href="#解题代码1-1-v3"> </a>解题代码1.1</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="literal">null</span>) <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span>(t2 == <span class="literal">null</span>) <span class="keyword">return</span> t1;</span><br><span class="line">        t1.val = t1.val + t2.val;</span><br><span class="line">        t1.left = mergeTrees(t1.left,t2.left);</span><br><span class="line">        t1.right = mergeTrees(t1.right,t2.right);</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v10"><a class="header-anchor" href="#解题思路2-v10"> </a>解题思路2</h3>
<p>也可以通过迭代来做，即BFS。</p>
<p>通过创建3个队列，一个用于保存新生成的结点，另外两个队列分别存放两棵树</p>
<p>代码太过繁琐了就不写了</p>
<h2 id="637-二叉树的层平均值"><a class="header-anchor" href="#637-二叉树的层平均值"> </a><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></h2>
<h3 id="题目-v23"><a class="header-anchor" href="#题目-v23"> </a>题目</h3>
<p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p>
<blockquote>
<p>示例 1：<br>
输入：<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
输出：[3, 14.5, 11]<br>
解释：<br>
第 0 层的平均值是 3 ,  第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。</p>
</blockquote>
<p>提示：<br>
节点值的范围在32位有符号整数范围内。</p>
<h3 id="解题思路1-v8"><a class="header-anchor" href="#解题思路1-v8"> </a>解题思路1</h3>
<p>如果用BFS进行遍历的思路挺简单的，迭代的思考与“<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a>”一样。通过一次循环中遍历整层结点。</p>
<p>这里主要麻烦点在于数值转换</p>
<p>考虑测试用例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="number">2147483647</span>,<span class="number">2147483647</span>,<span class="number">2147483647</span>]</span><br><span class="line">预期：</span><br><span class="line">[<span class="number">2147483647.00000</span>,<span class="number">2147483647.00000</span>]</span><br></pre></td></tr></table></figure>
<p>数值溢出的错误代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Double&gt; answer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> answer;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// ERROR sum会溢出，导致结果错误 </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> size;</span><br><span class="line">            <span class="keyword">while</span>(count--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                sum += cur.val;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) queue.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">double</span> <span class="variable">average</span> <span class="operator">=</span> (<span class="type">double</span>)sum / size;</span><br><span class="line">            answer.add(average);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而将<code>sum</code>改成<code>double</code>类型可以解决这个问题，因为<code>double</code>有8个字节</p>
<h3 id="解题代码1-v7"><a class="header-anchor" href="#解题代码1-v7"> </a>解题代码1</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//这题显然BFS</span></span><br><span class="line">        List&lt;Double&gt; answer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> answer;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> size;</span><br><span class="line">            <span class="keyword">while</span>(count--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                sum += cur.val;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) queue.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            answer.add(sum / size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v11"><a class="header-anchor" href="#解题思路2-v11"> </a>解题思路2</h3>
<p>可以通过深度优先去遍历。但是深度优先我们必须要直到当前结点时第几层，所以可以通过递归传参的方式告诉下一层的层数。</p>
<p>通过累计统计特定层的总和和个数。最终再遍历相除获得结果</p>
<h3 id="解题代码2-v10"><a class="header-anchor" href="#解题代码2-v10"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//DFS做法</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Double&gt; sums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//用于储存某层的和</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 用于储存某层的个数</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root,<span class="number">0</span>);</span><br><span class="line">        List&lt;Double&gt; average = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            average.add(sums.get(i)/nums.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> average;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> level)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(level &lt; nums.size())&#123; <span class="comment">//说明已经存在该层了，直接加就完事了</span></span><br><span class="line">            nums.set(level,nums.get(level)+<span class="number">1</span>);</span><br><span class="line">            sums.set(level,sums.get(level)+root.val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            nums.add(<span class="number">1</span>);</span><br><span class="line">            sums.add(<span class="number">1.0</span>*root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left,level+<span class="number">1</span>);</span><br><span class="line">        dfs(root.right,level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="653-两数之和-IV-输入-BST"><a class="header-anchor" href="#653-两数之和-IV-输入-BST"> </a><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/">653. 两数之和 IV - 输入 BST</a></h2>
<h3 id="题目-v24"><a class="header-anchor" href="#题目-v24"> </a>题目</h3>
<p>给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</p>
<blockquote>
<p>案例 1:<br>
输入:<br>
5<br>
/ <br>
3   6<br>
/ \   <br>
2   4   7<br>
Target = 9<br>
输出: True</p>
</blockquote>
<blockquote>
<p>案例 2:<br>
输入:<br>
5<br>
/ <br>
3   6<br>
/ \   <br>
2   4   7<br>
Target = 28<br>
输出: False</p>
</blockquote>
<h3 id="解题思路-v16"><a class="header-anchor" href="#解题思路-v16"> </a>解题思路</h3>
<p>对于这题可以这样理解，它既然要两个数<code>a</code>、<code>b</code>等于一个给定和<code>k</code>，那么我们可以先选择一个数<code>a</code>，再去寻找是否存在<code>k-a</code>。</p>
<p>因此根据这个思路，我们可以边遍历边记录所遇到的值<code>a</code>，同时寻找我们已经遍历过的值中是否存在<code>k-a</code>。针对这点需求，我们可以用一个<code>HashSet</code>去存放我们已经遍历过的值</p>
<p>但是这种思路就没有利用好这棵树是一棵BST树</p>
<h3 id="解题代码-v10"><a class="header-anchor" href="#解题代码-v10"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="variable">find</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> kval;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findTarget</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//写一个前序遍历  时间复杂度O(N) 空间复杂度O(H+N)</span></span><br><span class="line">        kval = k;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> find;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(find) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedVal</span> <span class="operator">=</span> kval - root.val;</span><br><span class="line">        <span class="keyword">if</span>(set.contains(expectedVal))&#123;</span><br><span class="line">            find = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            set.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line"></span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="669-修剪二叉搜索树"><a class="header-anchor" href="#669-修剪二叉搜索树"> </a><a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h2>
<h3 id="题目-v25"><a class="header-anchor" href="#题目-v25"> </a>题目</h3>
<p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树不应该改变保留在树中的元素的相对结构（即，如果没有被移除，原有的父代子代关系都应当保留）。 可以证明，存在唯一的答案。</p>
<p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p>
<blockquote>
<p>示例 1：<br>
输入：root = [1,0,2], low = 1, high = 2<br>
输出：[1,null,2]</p>
<p><img src="http://algorithm-image.qibinaoe.top/trim1.jpg" alt="img"></p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3<br>
输出：[3,2,null,1]</p>
<p><img src="http://algorithm-image.qibinaoe.top/trim2.jpg" alt="img"></p>
</blockquote>
<blockquote>
<p>示例 3：<br>
输入：root = [1], low = 1, high = 2<br>
输出：[1]</p>
</blockquote>
<blockquote>
<p>示例 4：<br>
输入：root = [1,null,2], low = 1, high = 3<br>
输出：[1,null,2]</p>
</blockquote>
<blockquote>
<p>示例 5：<br>
输入：root = [1,null,2], low = 2, high = 4<br>
输出：[2]</p>
</blockquote>
<blockquote>
<p>提示：<br>
树中节点数在范围 [1, 104] 内<br>
0 &lt;= Node.val &lt;= 104<br>
树中每个节点的值都是唯一的<br>
题目数据保证输入是一棵有效的二叉搜索树<br>
0 &lt;= low &lt;= high &lt;= 104</p>
</blockquote>
<h3 id="解题思路-v17"><a class="header-anchor" href="#解题思路-v17"> </a>解题思路</h3>
<p>这题看起来挺容易绕晕的，但是我们根据递归的思想，将这个问题分解成子问题。就考虑一个局部问题：</p>
<p>就当前结点而言。我们进行后序遍历（左-&gt;右-&gt;根），这样做的意思是，先让左子树满足修剪二叉树的规则，至于左子树要怎么满足我们先不管。再让右子树满足修剪二叉树的规则。至此，我们已经拿到了处理好的左子树、右子树，现在我们要做的工作是处理根节点并把左右子树拼在根节点上，然后返回根节点。</p>
<p>怎么处理根节点呢？</p>
<p>我们想，如果根节点的值小于了修剪规则的最小值(<code>low</code>)，这说明什么？说明根节点我们要弃掉。而根节点的左子树还要不要？根节点的左子树肯定都比根节点小，那肯定都比<code>low</code>小，那么左子树可以舍弃了。那左子树怎么办？还要不要？根据我们递归的思想，我们管好我们当前的问题：怎么处理根节点，以及怎么拼接，同时假设左右子树都是已经满足修剪规则的了。那么此时我们只需要返回右子树即可，因为右子树已经是满足修剪规则的了。</p>
<p>同理，如果根节点的值大于了修剪规则的最大值(<code>high</code>)，那么我们返回左子树即可。</p>
<p>那如果根节点是满足条件的，我们只需简单的将左右子树拼接上去即可</p>
<h3 id="解题代码-v11"><a class="header-anchor" href="#解题代码-v11"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> trimSubBST(root,low,high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimSubBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">leftChild</span> <span class="operator">=</span> trimSubBST(root.left,low,high);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightChild</span> <span class="operator">=</span> trimSubBST(root.right,low,high);</span><br><span class="line">        <span class="comment">//判断当前根节点是否保留</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; low) <span class="keyword">return</span> rightChild;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; high) <span class="keyword">return</span> leftChild;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//保留当前结点</span></span><br><span class="line">            root.left = leftChild;</span><br><span class="line">            root.right = rightChild;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="671-二叉树中第二小的节点"><a class="header-anchor" href="#671-二叉树中第二小的节点"> </a><a href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/">671. 二叉树中第二小的节点</a></h2>
<h3 id="题目-v26"><a class="header-anchor" href="#题目-v26"> </a>题目</h3>
<p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。</p>
<p>更正式地说，root.val = min(root.left.val, root.right.val) 总成立。</p>
<p>给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。</p>
<blockquote>
<p>示例 1：<br>
输入：root = [2,2,5,null,null,5,7]<br>
输出：5<br>
解释：最小的值是 2 ，第二小的值是 5 。</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：root = [2,2,2]<br>
输出：-1<br>
解释：最小的值是 2, 但是不存在第二小的值。</p>
</blockquote>
<p>提示：<br>
树中节点数目在范围 [1, 25] 内<br>
1 &lt;= Node.val &lt;= 231 - 1<br>
对于树中每个节点 root.val == min(root.left.val, root.right.val)</p>
<h3 id="解题思路-v18"><a class="header-anchor" href="#解题思路-v18"> </a>解题思路</h3>
<p>比较简单的思路获取整棵树的值，然后返回第二大的值</p>
<p>这里可以借助优先队列来获得第二大的数</p>
<h3 id="解题代码-v12"><a class="header-anchor" href="#解题代码-v12"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findSecondMinimumValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//定义一个最小值</span></span><br><span class="line">        <span class="comment">//遍历一遍树</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> root.val;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; priorityqueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(!priorityqueue.contains(cur.val)) priorityqueue.offer(cur.val);</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) queue.offer(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) queue.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        priorityqueue.poll();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">second</span> <span class="operator">=</span> priorityqueue.poll();</span><br><span class="line">        <span class="type">return</span> <span class="variable">second</span> <span class="operator">=</span>= <span class="literal">null</span>? -<span class="number">1</span>: second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v12"><a class="header-anchor" href="#解题思路2-v12"> </a>解题思路2</h3>
<p>这里可以去掉这里的优先队列，取而代之的是一个储存第二个大的变量<code>second</code></p>
<p><code>second</code>初始化为<code>-1</code>。在遍历的过程中，判断是否有大于根节点的值<code>root.val</code>，有则更新<code>second</code>，同时保证<code>second</code>是除了<code>min</code>是最小的</p>
<h3 id="解题代码2-v11"><a class="header-anchor" href="#解题代码2-v11"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findSecondMinimumValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//定义一个最小值</span></span><br><span class="line">        <span class="comment">//遍历一遍树</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> root.val;</span><br><span class="line">        <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(cur.val&gt;min)&#123;</span><br><span class="line">                second = second == -<span class="number">1</span>?cur.val:(cur.val&gt;second ? second: cur.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) queue.offer(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) queue.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="700-二叉搜索树中的搜索"><a class="header-anchor" href="#700-二叉搜索树中的搜索"> </a><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h2>
<h3 id="题目-v27"><a class="header-anchor" href="#题目-v27"> </a>题目</h3>
<p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p>
<blockquote>
<p>例如，<br>
给定二叉搜索树:<br>
4<br>
/ <br>
2   7<br>
/ <br>
1   3<br>
和值: 2<br>
你应该返回如下子树:<br>
2<br>
/ \<br>
1   3<br>
在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。</p>
</blockquote>
<h3 id="解题思路-v19"><a class="header-anchor" href="#解题思路-v19"> </a>解题思路</h3>
<p>这题比较简单，即判断树中有没有我们想要的结点，最直接的做法就是遍历一遍树，如果整个过程没有找到，即可返回null</p>
<p>我们可以通过BFS来遍历树，循环跳出后即没有找到的意思，返回null</p>
<h3 id="解题代码-v13"><a class="header-anchor" href="#解题代码-v13"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(cur.val == val)&#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) queue.offer(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) queue.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v13"><a class="header-anchor" href="#解题思路2-v13"> </a>解题思路2</h3>
<p>同样的，这是一棵BST树，那我们根据BST树的特点，如果<code>val</code>大于当前值，说明要在右子树找。如果<code>val</code>小于当前值，则在左子树找。如果相等，返回当前结点即可，</p>
<h3 id="解题代码2-v12"><a class="header-anchor" href="#解题代码2-v12"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val == val) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; val) <span class="keyword">return</span> searchBST(root.left,val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> searchBST(root.right,val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码3-v4"><a class="header-anchor" href="#解题代码3-v4"> </a>解题代码3</h3>
<p>同时我们可以通过迭代的方式，直接进行判断，这样就连栈空间都省了</p>
<h3 id="解题代码3-v5"><a class="header-anchor" href="#解题代码3-v5"> </a>解题代码3</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span> &amp;&amp; root.val != val)&#123;</span><br><span class="line">            root = root.val&lt;val?root.right:root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="783-二叉搜索树节点最小距离"><a class="header-anchor" href="#783-二叉搜索树节点最小距离"> </a><a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/">783. 二叉搜索树节点最小距离</a></h2>
<h3 id="题目-v28"><a class="header-anchor" href="#题目-v28"> </a>题目</h3>
<p>给定一个二叉搜索树的根节点 root，返回树中任意两节点的差的最小值。</p>
<blockquote>
<p>示例：<br>
输入: root = [4,2,6,1,3,null,null]<br>
输出: 1<br>
解释:<br>
注意，root是树节点对象(TreeNode object)，而不是数组。<br>
给定的树 [4,2,6,1,3,null,null] 可表示为下图:<br>
4<br>
/   <br>
2      6<br>
/ \<br>
1   3<br>
最小的差值是 1, 它是节点1和节点2的差值, 也是节点3和节点2的差值。</p>
</blockquote>
<p>注意：</p>
<p>二叉树的大小范围在 2 到 100。<br>
二叉树总是有效的，每个节点的值都是整数，且不重复。<br>
本题与 530：<a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/</a> 相同</p>
<h3 id="解题思路-v20"><a class="header-anchor" href="#解题思路-v20"> </a>解题思路</h3>
<p>通过前序遍历，判断相邻两个数的差值，并与最小差值进行比较</p>
<h3 id="解题代码-v14"><a class="header-anchor" href="#解题代码-v14"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minDiff</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">first</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDiffInBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> minDiff;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        update(root);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> root.val;</span><br><span class="line">        <span class="keyword">if</span>(first)&#123;</span><br><span class="line">            base = val;</span><br><span class="line">            first = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        minDiff = val - base &lt; minDiff ? val-base : minDiff;</span><br><span class="line">        base = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="872-叶子相似的树"><a class="header-anchor" href="#872-叶子相似的树"> </a><a href="https://leetcode-cn.com/problems/leaf-similar-trees/">872. 叶子相似的树</a></h2>
<h3 id="题目-v29"><a class="header-anchor" href="#题目-v29"> </a>题目</h3>
<p>请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 叶值序列 。</p>
<p><img src="http://algorithm-image.qibinaoe.top/tree.png" alt="img"></p>
<p>举个例子，如上图所示，给定一棵叶值序列为 (6, 7, 4, 9, 8) 的树。<br>
如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 叶相似 的。<br>
如果给定的两个头结点分别为 root1 和 root2 的树是叶相似的，则返回 true；否则返回 false 。</p>
<p>示例 1：</p>
<p><img src="http://algorithm-image.qibinaoe.top/leaf-similar-1.jpg" alt="img"></p>
<p>输入：root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]<br>
输出：true</p>
<p>示例 2：<br>
输入：root1 = [1], root2 = [1]<br>
输出：true</p>
<p>示例 3：<br>
输入：root1 = [1], root2 = [2]<br>
输出：false</p>
<p>示例 4：<br>
输入：root1 = [1,2], root2 = [2,2]<br>
输出：true</p>
<p>示例 5：</p>
<p><img src="http://algorithm-image.qibinaoe.top/leaf-similar-2.jpg" alt="img"></p>
<p>输入：root1 = [1,2,3], root2 = [1,3,2]<br>
输出：false</p>
<p>提示：<br>
给定的两棵树可能会有 1 到 200 个结点。<br>
给定的两棵树上的值介于 0 到 200 之间。</p>
<h3 id="解题思路-v21"><a class="header-anchor" href="#解题思路-v21"> </a>解题思路</h3>
<p>这题所谓的寻找叶值序列判断相等</p>
<p>本质上就是找出两颗树的叶子结点，然后判断是否相等</p>
<p>那么怎么寻找叶子节点？只需要左右结点都为空，即使叶子节点。然后可以将两棵树的叶子节点分别放入两个数组中，然后判断是否相等</p>
<h3 id="解题代码-v15"><a class="header-anchor" href="#解题代码-v15"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">leafSimilar</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="comment">//首先找出叶子结点</span></span><br><span class="line">        <span class="comment">// 判断相等</span></span><br><span class="line">        List&lt;Integer&gt; array1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; array2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(root1,array1);</span><br><span class="line">        dfs(root2,array2);</span><br><span class="line">        <span class="comment">//判断相等</span></span><br><span class="line">        <span class="keyword">return</span> array1.equals(array2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,List&lt;Integer&gt; array)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left,array);</span><br><span class="line">        <span class="comment">//判断是否是叶子结点</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            array.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right,array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="897-递增顺序查找树"><a class="header-anchor" href="#897-递增顺序查找树"> </a><a href="https://leetcode-cn.com/problems/increasing-order-search-tree/">897. 递增顺序查找树</a></h2>
<h3 id="题目-v30"><a class="header-anchor" href="#题目-v30"> </a>题目</h3>
<p>给你一个树，请你 按中序遍历 重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。</p>
<blockquote>
<p>示例 ：<br>
输入：[5,3,6,2,4,null,8,1,null,null,null,7,9]<br>
5<br>
/ <br>
3    6<br>
/ \    <br>
2   4    8<br>
/        / \<br>
1        7   9<br>
输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]<br>
1<br>
<br>
2<br>
<br>
3<br>
<br>
4<br>
<br>
5<br>
<br>
6<br>
<br>
7<br>
<br>
8<br>
<br>
9</p>
</blockquote>
<p>提示：<br>
给定树中的结点数介于 1 和 100 之间。<br>
每个结点都有一个从 0 到 1000 范围内的唯一整数值。</p>
<h3 id="解题思路-v22"><a class="header-anchor" href="#解题思路-v22"> </a>解题思路</h3>
<p>既然要中序遍历来形成一条只有通过右结点连接在一起的一条链。</p>
<p>那我们开始想象，我如果我们通过中序遍历，先遍历到了这颗树的最左的叶子结点，那我们需要怎么做才能把当前这个最左的叶子结点，接在它父节点上面呢？</p>
<p>可以想到，在栈弹出时，我们回到了该节点的父节点，这时候如果我们有这个最左的叶子结点的一个引用，我们就能够直接操作，将最左的叶子节点的右孩子指向当前结点即可。</p>
<p>然后接下来将保存当前结点的引用，并递归到下一层，或者弹出当前栈，回到父节点，再进行同样的操作</p>
<h3 id="解题代码-v16"><a class="header-anchor" href="#解题代码-v16"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">TreeNode</span> <span class="variable">prevNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">increasingBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="comment">//拼接</span></span><br><span class="line">        <span class="keyword">if</span>(prevNode == <span class="literal">null</span>)&#123;</span><br><span class="line">            head = root;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            prevNode.right = root;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = <span class="literal">null</span>;</span><br><span class="line">        prevNode = root;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="938-二叉搜索树的范围和"><a class="header-anchor" href="#938-二叉搜索树的范围和"> </a><a href="https://leetcode-cn.com/problems/range-sum-of-bst/">938. 二叉搜索树的范围和</a></h2>
<h3 id="题目-v31"><a class="header-anchor" href="#题目-v31"> </a>题目</h3>
<p>给定二叉搜索树的根结点 root，返回值位于范围 [low, high] 之间的所有结点的值的和。</p>
<blockquote>
<p>示例 1：</p>
<p><img src="http://algorithm-image.qibinaoe.top/bst1.jpg" alt="img"></p>
<p>输入：root = [10,5,15,3,7,null,18], low = 7, high = 15<br>
输出：32</p>
</blockquote>
<blockquote>
<p>示例 2：</p>
<p><img src="http://algorithm-image.qibinaoe.top/bst2.jpg" alt="img"></p>
<p>输入：root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10<br>
输出：23</p>
</blockquote>
<blockquote>
<p>提示：<br>
树中节点数目在范围 [1, 2 * 104] 内<br>
1 &lt;= Node.val &lt;= 105<br>
1 &lt;= low &lt;= high &lt;= 105<br>
所有 Node.val 互不相同</p>
</blockquote>
<h3 id="解题思路-v23"><a class="header-anchor" href="#解题思路-v23"> </a>解题思路</h3>
<p>这题其实和“<a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a>”一样的，然后我们递归的过程中，对于在该区间的值进行累加</p>
<h3 id="解题代码-v17"><a class="header-anchor" href="#解题代码-v17"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="comment">//首先要找到 [low, high] 的结点</span></span><br><span class="line">        <span class="comment">//然后计算这些结点的总和</span></span><br><span class="line">        <span class="comment">//构成我们想要的树,同时在遍历过程计算值</span></span><br><span class="line">        trimSubBST(root,low,high);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimSubBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">        <span class="comment">// 返回一个已经裁剪好的树</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">leftChild</span> <span class="operator">=</span> trimSubBST(root.left,low,high);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightChild</span> <span class="operator">=</span> trimSubBST(root.right,low,high);</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; low) <span class="keyword">return</span> rightChild;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; high) <span class="keyword">return</span> leftChild;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            root.left = leftChild;</span><br><span class="line">            root.right = rightChild;</span><br><span class="line">            sum += root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v14"><a class="header-anchor" href="#解题思路2-v14"> </a>解题思路2</h3>
<p>想想其实我想复杂了，题目并不要求去生成这样一棵树。那我们只需要在递归的过程中，去看结点的值是否在[low,high]之间，即可累加</p>
<h3 id="解题代码2-v13"><a class="header-anchor" href="#解题代码2-v13"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="comment">//首先要找到 [low, high] 的结点</span></span><br><span class="line">        <span class="comment">//然后计算这些结点的总和</span></span><br><span class="line">        <span class="comment">//构成我们想要的树,同时在遍历过程计算值</span></span><br><span class="line">        dfs(root,low,high);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left,low,high);</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt;= low &amp;&amp; root.val &lt;= high) sum+= root.val;</span><br><span class="line">        dfs(root.right,low,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路3-v2"><a class="header-anchor" href="#解题思路3-v2"> </a>解题思路3</h3>
<p>解题思路2中的做法没有用到BST的特点，我们可以判断一下当前结点值，来选择递归的路径</p>
<h3 id="解题代码3-v6"><a class="header-anchor" href="#解题代码3-v6"> </a>解题代码3</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="comment">//首先要找到 [low, high] 的结点</span></span><br><span class="line">        <span class="comment">//然后计算这些结点的总和</span></span><br><span class="line">        <span class="comment">//构成我们想要的树,同时在遍历过程计算值</span></span><br><span class="line">        dfs(root,low,high);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; low) dfs(root.right,low,high);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; high) dfs(root.left,low,high);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sum+= root.val;</span><br><span class="line">            dfs(root.right,low,high);</span><br><span class="line">            dfs(root.left,low,high);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="965-单值二叉树"><a class="header-anchor" href="#965-单值二叉树"> </a><a href="https://leetcode-cn.com/problems/univalued-binary-tree/">965. 单值二叉树</a></h2>
<h3 id="题目-v32"><a class="header-anchor" href="#题目-v32"> </a>题目</h3>
<p>如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。<br>
只有给定的树是单值二叉树时，才返回 true；否则返回 false。</p>
<blockquote>
<p>示例 1：<br>
输入：[1,1,1,1,1,null,1]<br>
输出：true</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：[2,2,2,5,2]<br>
输出：false</p>
</blockquote>
<p>提示：<br>
给定树的节点数范围是 [1, 100]。<br>
每个节点的值都是整数，范围为 [0, 99] 。</p>
<h3 id="解题思路-v24"><a class="header-anchor" href="#解题思路-v24"> </a>解题思路</h3>
<p>简单的做法就是把树过一遍，出现不同的值就返回false即可</p>
<h3 id="解题代码-v18"><a class="header-anchor" href="#解题代码-v18"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isUnivalTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.offerLast(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> root.val;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pollLast();</span><br><span class="line">            <span class="keyword">if</span>(cur.val != val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) stack.offerLast(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) stack.offerLast(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="993-二叉树的堂兄弟节点"><a class="header-anchor" href="#993-二叉树的堂兄弟节点"> </a><a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/">993. 二叉树的堂兄弟节点</a></h2>
<h3 id="题目-v33"><a class="header-anchor" href="#题目-v33"> </a>题目</h3>
<p>在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。<br>
如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。<br>
我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。<br>
只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。</p>
<blockquote>
<p>示例 1：</p>
<p><img src="http://algorithm-image.qibinaoe.top/q1248-01.png" alt="img"></p>
<p>输入：root = [1,2,3,4], x = 4, y = 3<br>
输出：false</p>
</blockquote>
<blockquote>
<p>示例 2：</p>
<p><img src="http://algorithm-image.qibinaoe.top/q1248-02.png" alt="img"></p>
<p>输入：root = [1,2,3,null,4,null,5], x = 5, y = 4<br>
输出：true</p>
</blockquote>
<blockquote>
<p>示例 3：</p>
<p><img src="http://algorithm-image.qibinaoe.top/q1248-03.png" alt="img"></p>
<p>输入：root = [1,2,3,null,4], x = 2, y = 3<br>
输出：false</p>
</blockquote>
<blockquote>
<p>提示：<br>
二叉树的节点数介于 2 到 100 之间。<br>
每个节点的值都是唯一的、范围为 1 到 100 的整数。</p>
</blockquote>
<h3 id="解题思路-v25"><a class="header-anchor" href="#解题思路-v25"> </a>解题思路</h3>
<p>根据题目给的条件，堂兄弟结点的深度是一致的，说明我们可以通过层次优先遍历来在一次循环中，去判断是否存在堂兄弟结点。</p>
<p>因此我们通过一个队列去进行BFS</p>
<p>其次，我们需要直到如何判断同一层的结点是否是一个堂兄弟节点</p>
<p>我的思路是根据出现的两个结点的相对位置判断</p>
<ul>
<li>两个出现的位置大于1则肯定是堂兄弟结点</li>
<li>也有可能出现位置相距为1，但是不同父节点的情况，这种情况，较小的位置的数字为奇数（从0开始计算）</li>
</ul>
<h3 id="解题代码-v19"><a class="header-anchor" href="#解题代码-v19"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCousins</span><span class="params">(TreeNode root, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="comment">// 由于堂兄弟结点在同一层，所以用层次遍历比较方便</span></span><br><span class="line">        <span class="comment">// 通过判断两个结点的距离来判断是否是同父节点</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Queue&lt;Pair&lt;TreeNode,Integer&gt;&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;TreeNode,Integer&gt;(root,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="comment">//取出同一层</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">firstPos</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">secondPos</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                Pair&lt;TreeNode,Integer&gt; cur = queue.poll();</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">curNode</span> <span class="operator">=</span> cur.getKey();</span><br><span class="line">                <span class="type">int</span> <span class="variable">curPos</span> <span class="operator">=</span> cur.getValue();</span><br><span class="line">                <span class="keyword">if</span>(firstPos == -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curNode.val == x)&#123;</span><br><span class="line">                        firstPos = curPos;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curNode.val == y)&#123;</span><br><span class="line">                        firstPos = curPos;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curNode.val == x)&#123;</span><br><span class="line">                        secondPos = curPos;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curNode.val == y)&#123;</span><br><span class="line">                        secondPos = curPos;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//压入子节点</span></span><br><span class="line">                <span class="keyword">if</span>(curNode.left != <span class="literal">null</span>) queue.offer(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;TreeNode,Integer&gt;(curNode.left,pos));</span><br><span class="line">                pos++;</span><br><span class="line">                <span class="keyword">if</span>(curNode.right != <span class="literal">null</span>) queue.offer(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;TreeNode,Integer&gt;(curNode.right,pos));</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断是否有堂兄弟</span></span><br><span class="line">            <span class="keyword">if</span>(firstPos == -<span class="number">1</span> ^ secondPos == -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(firstPos != -<span class="number">1</span> &amp;&amp; secondPos != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> secondPos - firstPos &gt; <span class="number">1</span> || firstPos % <span class="number">2</span> == <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1022-从根到叶的二进制数之和"><a class="header-anchor" href="#1022-从根到叶的二进制数之和"> </a><a href="https://leetcode-cn.com/problems/sum-of-root-to-leaf-binary-numbers/">1022. 从根到叶的二进制数之和</a></h2>
<h3 id="题目-v34"><a class="header-anchor" href="#题目-v34"> </a>题目</h3>
<p>给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1，那么它表示二进制数 01101，也就是 13 。</p>
<p>对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。</p>
<p>返回这些数字之和。题目数据保证答案是一个 32 位 整数。</p>
<blockquote>
<p>示例 1：<br>
输入：root = [1,0,1,0,1,0,1]<br>
输出：22<br>
解释：(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22</p>
<p><img src="http://algorithm-image.qibinaoe.top/sum-of-root-to-leaf-binary-numbers.png" alt="img"></p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：root = [0]<br>
输出：0</p>
</blockquote>
<blockquote>
<p>示例 3：<br>
输入：root = [1]<br>
输出：1</p>
</blockquote>
<blockquote>
<p>示例 4：<br>
输入：root = [1,1]<br>
输出：3</p>
</blockquote>
<blockquote>
<p>提示：<br>
树中的结点数介于 1 和 1000 之间。<br>
Node.val 为 0 或 1 。</p>
</blockquote>
<h3 id="解题思路-v26"><a class="header-anchor" href="#解题思路-v26"> </a>解题思路</h3>
<p>首先考虑递归的思路，在题目中，要计算一条路径（根到叶子节点）的值，需要到叶子节点的时候，我们才能确定。因此在递归过程中，我们需要同时传递到当前节点的值。</p>
<p>如果在递归中，当前节点已经是叶子节点了，说明我们可以计算该值并保存下来，因此这里我们定义一个全局变量。而对于计算一条链的值，考虑到这是二进制，所以可以用位操作进行计算。即前面的链向左位移1位，再加上当前节点的值，即构成了整条链的值。</p>
<p>如果当前节点不是叶子节点的话。那有可能出现的是空结点，对于空结点我们不去理会，我们只关心当前节点是不是<strong>叶子节点</strong>，是就计算，不是就继续左右两个子节点递归。因此出现空结点的情况是由于父节点是只有一个孩子，另一个孩子会帮忙算这条链的值，我们来到了空孩子的位置。</p>
<h3 id="解题代码-v20"><a class="header-anchor" href="#解题代码-v20"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRootToLeaf</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        calRootToLeaf(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calRootToLeaf</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span>&#123;</span><br><span class="line">        <span class="comment">//sum 表示之前结点的和</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(isLeaf(root))&#123;</span><br><span class="line">            totalSum += (sum&lt;&lt;<span class="number">1</span>)+root.val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            calRootToLeaf(root.left,(sum&lt;&lt;<span class="number">1</span>)+root.val);</span><br><span class="line">            calRootToLeaf(root.right,(sum&lt;&lt;<span class="number">1</span>)+root.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLeaf</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-27-二叉树的镜像"><a class="header-anchor" href="#剑指-Offer-27-二叉树的镜像"> </a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h2>
<h3 id="题目-v35"><a class="header-anchor" href="#题目-v35"> </a>题目</h3>
<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<blockquote>
<p>例如输入：<br>
4<br>
/   <br>
2     7<br>
/ \   / <br>
1   3 6   9<br>
镜像输出：<br>
4<br>
/   <br>
7     2<br>
/ \   / <br>
9   6 3   1<br>
示例 1：<br>
输入：root = [4,2,7,1,3,6,9]<br>
输出：[4,7,2,9,6,3,1]</p>
</blockquote>
<p>限制：<br>
0 &lt;= 节点个数 &lt;= 1000<br>
注意：本题与主站 226 题相同：<a href="https://leetcode-cn.com/problems/invert-binary-tree/">https://leetcode-cn.com/problems/invert-binary-tree/</a></p>
<h3 id="解题思路-v27"><a class="header-anchor" href="#解题思路-v27"> </a>解题思路</h3>
<p>这题使用递归思路挺简单的。即一棵树的镜像的原理是将其左右子树交换，同时左右子树也要是镜像的</p>
<h3 id="解题代码-v21"><a class="header-anchor" href="#解题代码-v21"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        mirrorTree(root.left);</span><br><span class="line">        mirrorTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-28-对称的二叉树"><a class="header-anchor" href="#剑指-Offer-28-对称的二叉树"> </a><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></h2>
<h3 id="题目-v36"><a class="header-anchor" href="#题目-v36"> </a>题目</h3>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<pre><code>1
</code></pre>
<p>/ <br>
2   2<br>
/ \ / <br>
3  4 4  3<br>
但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<pre><code>1
</code></pre>
<p>/ <br>
2   2<br>
\   <br>
3    3</p>
<p>示例 1：</p>
<p>输入：root = [1,2,2,3,4,4,3]<br>
输出：true<br>
示例 2：</p>
<p>输入：root = [1,2,2,null,3,null,3]<br>
输出：false</p>
<p>限制：</p>
<p>0 &lt;= 节点个数 &lt;= 1000</p>
<p>注意：本题与主站 101 题相同：<a href="https://leetcode-cn.com/problems/symmetric-tree/">https://leetcode-cn.com/problems/symmetric-tree/</a></p>
<h3 id="解题代码-v22"><a class="header-anchor" href="#解题代码-v22"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSubSymmetric(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubSymmetric</span><span class="params">(TreeNode t1, TreeNode t2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="literal">null</span> ^ t2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="literal">null</span> &amp;&amp;  <span class="literal">null</span> == t2)  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1.val == t2.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> isSubSymmetric(t1.left,t2.right) &amp;&amp; isSubSymmetric(t1.right,t2.left);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a class="header-anchor" href="#剑指-Offer-32-II-从上到下打印二叉树-II"> </a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h2>
<h3 id="题目-v37"><a class="header-anchor" href="#题目-v37"> </a>题目</h3>
<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<blockquote>
<p>例如:<br>
给定二叉树: [3,9,20,null,null,15,7],<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回其层次遍历结果：<br>
[<br>
[3],<br>
[9,20],<br>
[15,7]<br>
]</p>
</blockquote>
<h3 id="解题思路-v28"><a class="header-anchor" href="#解题思路-v28"> </a>解题思路</h3>
<p>显然这题考察层次遍历,同时需要一次性将整层都取出来,所以要先读取该层的个数</p>
<h3 id="解题代码-v23"><a class="header-anchor" href="#解题代码-v23"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">t</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                level.add(t.val);</span><br><span class="line">                <span class="keyword">if</span>(t.left != <span class="literal">null</span>) queue.offer(t.left);</span><br><span class="line">                <span class="keyword">if</span>(t.right != <span class="literal">null</span>) queue.offer(t.right);            </span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v15"><a class="header-anchor" href="#解题思路2-v15"> </a>解题思路2</h3>
<p>同时也可以通过递归的方式去实现将每一层作为一组放到一个数组中去.</p>
<p>虽然遍历的顺序不是按照广度优先的顺序,但是可以根据每一层储存的位置于其深度是对应的,因此我们只需要记住正在操作的该节点的深度,根据深度去访问其应该归属的数组即可</p>
<h3 id="解题代码2-v14"><a class="header-anchor" href="#解题代码2-v14"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//迭代法的思路是根据深度优先，但是在遍历每一个节点的时候，我们能够确定该节点的深度，根据深度取出对应的数组加进去就可以了</span></span><br><span class="line">        ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">0</span>,root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> depth, TreeNode t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//判断该层是否已经存在数组</span></span><br><span class="line">        <span class="comment">//即判断ans.get(depth)是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(ans.size() == depth)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        ans.get(depth).add(t.val);</span><br><span class="line">        <span class="comment">//先访问左子树再访问右子树能够保证从左到右的顺序</span></span><br><span class="line">        dfs(depth+<span class="number">1</span>,t.left);</span><br><span class="line">        dfs(depth+<span class="number">1</span>,t.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-54-二叉搜索树的第k大节点"><a class="header-anchor" href="#剑指-Offer-54-二叉搜索树的第k大节点"> </a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></h2>
<h3 id="题目-v38"><a class="header-anchor" href="#题目-v38"> </a>题目</h3>
<p>给定一棵二叉搜索树，请找出其中第k大的节点。</p>
<blockquote>
<p>示例 1:<br>
输入: root = [3,1,4,null,2], k = 1<br>
3<br>
/ <br>
1   4<br>
<br>
2<br>
输出: 4</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
输入: root = [5,3,6,2,4,null,null,1], k = 3<br>
5<br>
/ <br>
3   6<br>
/ <br>
2   4<br>
/<br>
1<br>
输出: 4</p>
</blockquote>
<p>限制：<br>
1 ≤ k ≤ 二叉搜索树元素个数</p>
<h3 id="解题思路-v29"><a class="header-anchor" href="#解题思路-v29"> </a>解题思路</h3>
<p>注意题目给的是BST树,那利用BST树的特点,中序遍历的话是从小到大的访问.那我们就仿照中序遍历,将访问顺序改成<code>右-&gt;中-&gt;左</code>,那就是从大到小的访问顺序了.</p>
<h3 id="解题代码-v24"><a class="header-anchor" href="#解题代码-v24"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthLargest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//注意这是一棵BST树</span></span><br><span class="line">        <span class="comment">//根据中序遍历的输出是从小到大</span></span><br><span class="line">        <span class="comment">//仿照中序遍历，我们先访问右子树，再当前节点，再左子树，即可从大到小遍历</span></span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; k) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">        <span class="comment">//访问当前节点</span></span><br><span class="line">        <span class="keyword">if</span>(count == k)&#123;</span><br><span class="line">            <span class="comment">//这里就不考虑k &gt; 树的结点树的情况</span></span><br><span class="line">            ans = root.val;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v16"><a class="header-anchor" href="#解题思路2-v16"> </a>解题思路2</h3>
<p>尝试用迭代的方式执行.</p>
<p>仿照中序遍历的非递归版本(迭代的方式)</p>
<h3 id="解题代码2-v15"><a class="header-anchor" href="#解题代码2-v15"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthLargest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//注意这是一棵BST树</span></span><br><span class="line">        <span class="comment">//根据中序遍历的输出是从小到大</span></span><br><span class="line">        <span class="comment">//仿照中序遍历，我们先访问右子树，再当前节点，再左子树，即可从大到小遍历</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//非递归版本</span></span><br><span class="line">       <span class="comment">//栈</span></span><br><span class="line">       Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">       <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       <span class="comment">//压栈的整体思路是：</span></span><br><span class="line">       <span class="comment">//不断将当前结点以及当前结点靠右的一整排压栈</span></span><br><span class="line">       <span class="comment">//直到达到最右端，即root == null的时候</span></span><br><span class="line">       <span class="comment">//此时要弹出栈顶，访问能够访问的最右端。这个被访问的结点相当于当前结点（因为被访问）</span></span><br><span class="line">       <span class="comment">//访问后，需要去看当前被访问的左结点（因为我们要的访问顺序是右中左）</span></span><br><span class="line">       <span class="comment">//因此我们将root = root.left。但这并不代表我们就要访问其左节点</span></span><br><span class="line">       <span class="comment">//再下一次循环中我们又将其最右的一整排压栈。</span></span><br><span class="line">       <span class="keyword">while</span>(!stack.isEmpty() || root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//不断将右节点压栈</span></span><br><span class="line">            <span class="comment">//注意这里不是标准的中序遍历访问顺序</span></span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.offerLast(root);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//到底了</span></span><br><span class="line">                <span class="comment">//此时到达最右</span></span><br><span class="line">                <span class="comment">//弹出栈顶，访问元素，再左子树</span></span><br><span class="line">                root = stack.pollLast();</span><br><span class="line">                <span class="keyword">if</span>(count == k)&#123;</span><br><span class="line">                    <span class="keyword">return</span> root.val;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//这里是随便一个数字，因为如果保证k是小于等于树的个数的话，是执行不到这句的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-55-I-二叉树的深度"><a class="header-anchor" href="#剑指-Offer-55-I-二叉树的深度"> </a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度</a></h2>
<h3 id="题目-v39"><a class="header-anchor" href="#题目-v39"> </a>题目</h3>
<p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<blockquote>
<p>例如：<br>
给定二叉树 [3,9,20,null,null,15,7]，<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回它的最大深度 3 。</p>
</blockquote>
<p>提示：<br>
节点总数 &lt;= 10000<br>
注意：本题与主站 104 题相同：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a></p>
<h3 id="解题代码-v25"><a class="header-anchor" href="#解题代码-v25"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root!=<span class="literal">null</span>?Math.max(maxDepth(root.left),maxDepth(root.right))+<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-55-II-平衡二叉树"><a class="header-anchor" href="#剑指-Offer-55-II-平衡二叉树"> </a><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a></h2>
<h3 id="题目-v40"><a class="header-anchor" href="#题目-v40"> </a>题目</h3>
<p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<blockquote>
<p>示例 1:<br>
给定二叉树 [3,9,20,null,null,15,7]<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回 true 。</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
给定二叉树 [1,2,2,3,3,null,null,4,4]<br>
1<br>
/ <br>
2   2<br>
/ <br>
3   3<br>
/ <br>
4   4<br>
返回 false 。</p>
</blockquote>
<p>限制：<br>
1 &lt;= 树的结点个数 &lt;= 10000<br>
注意：本题与主站 110 题相同：<a href="https://leetcode-cn.com/problems/balanced-binary-tree/">https://leetcode-cn.com/problems/balanced-binary-tree/</a></p>
<h3 id="解题思路-v30"><a class="header-anchor" href="#解题思路-v30"> </a>解题思路</h3>
<p>一棵树要平衡,不仅要当前结点是平衡,其左右结点也要是平衡</p>
<h3 id="解题代码-v26"><a class="header-anchor" href="#解题代码-v26"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(getDepth(root.left)-getDepth(root.right))&lt;<span class="number">2</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root!=<span class="literal">null</span>?Math.max(getDepth(root.left),getDepth(root.right))+<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a class="header-anchor" href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先"> </a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h2>
<h3 id="题目-v41"><a class="header-anchor" href="#题目-v41"> </a>题目</h3>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。<br>
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>
例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<blockquote>
<p>示例 1:<br>
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>
输出: 6<br>
解释: 节点 2 和节点 8 的最近公共祖先是 6。</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>
输出: 2<br>
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p>
</blockquote>
<p>说明:<br>
所有节点的值都是唯一的。<br>
p、q 为不同节点且均存在于给定的二叉搜索树中。<br>
注意：本题与主站 235 题相同：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p>
<h3 id="解题思路-v31"><a class="header-anchor" href="#解题思路-v31"> </a>解题思路</h3>
<p>这题要注意的一点是什么时候去遍历左子树,什么时候去遍历右子树</p>
<p>如果当前结点的值大于最大值,说明当前结点也比其公共祖先还大,得去左子树找.如果去右子树找的话,那右子树的每一个结点都大于当前结点,那就更找不到了</p>
<p>同理小于最小值</p>
<h3 id="解题代码-v27"><a class="header-anchor" href="#解题代码-v27"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode ancestor;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">//分类讨论</span></span><br><span class="line">        dfs(root,p,q);</span><br><span class="line">        <span class="keyword">return</span> ancestor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.max(p.val,q.val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(p.val,q.val);</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; min)&#123;</span><br><span class="line">            dfs(root.right,p,q);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; max)&#123;</span><br><span class="line">            dfs(root.left,p,q);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ancestor = root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-68-II-二叉树的最近公共祖先"><a class="header-anchor" href="#剑指-Offer-68-II-二叉树的最近公共祖先"> </a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></h2>
<h3 id="题目-v42"><a class="header-anchor" href="#题目-v42"> </a>题目</h3>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src="http://algorithm-image.qibinaoe.top/binarytree.png" alt="img"></p>
<blockquote>
<p>示例 1:<br>
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>
输出: 3<br>
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>
输出: 5<br>
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</p>
</blockquote>
<p>说明:<br>
所有节点的值都是唯一的。<br>
p、q 为不同节点且均存在于给定的二叉树中。<br>
注意：本题与主站 236 题相同：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p>
<h3 id="解题思路-v32"><a class="header-anchor" href="#解题思路-v32"> </a>解题思路</h3>
<p>注意,这题与上一题&quot;<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a>&quot;的区别在于,本题不是BST树,那注定效率就比不上是BST树的搜索.</p>
<p>想到第一种解题方法是,从上到下去判断当前结点是不是最近公共祖先.</p>
<p>首先我们先判断是不是祖先.如果是祖先的话,那么该节点包含这两个结点<code>p</code>,<code>q</code>(包含等于情况).</p>
<p>判断完是不是祖先后,接着判断是不是最近祖先,如果是最近祖先的话,那么其层数应该比较深,所以我们定义一个变量去记录当前较近祖先的值</p>
<p>但是这种做法有很多重复的判断,每个结点都去遍历一遍其子树,因此效率非常低</p>
<h3 id="解题代码-v28"><a class="header-anchor" href="#解题代码-v28"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode ancestor;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 祖先的层数，越大越好</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">// 从上到下，逐个判断当前结点是不是最近最近公共祖先</span></span><br><span class="line">        <span class="comment">// 但是会出现很多冗余的操作，所以效率会低</span></span><br><span class="line">        ancestor = root;</span><br><span class="line">        findAncestor(root,p,q,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ancestor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q, <span class="type">int</span> depth)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 先判断当前结点是不是祖先</span></span><br><span class="line">        <span class="keyword">if</span>(isChild(root,p) &amp;&amp; isChild(root,q))&#123;</span><br><span class="line">            <span class="keyword">if</span>(age &lt; depth)&#123;</span><br><span class="line">                ancestor = root;</span><br><span class="line">                age = depth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断其左右结点是不是</span></span><br><span class="line">        findAncestor(root.left,p,q,depth+<span class="number">1</span>);</span><br><span class="line">        findAncestor(root.right,p,q,depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isChild</span><span class="params">(TreeNode root, TreeNode p)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">return</span> <span class="variable">root</span> <span class="operator">=</span>= p || isChild(root.left,p) || isChild(root.right,p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v17"><a class="header-anchor" href="#解题思路2-v17"> </a>解题思路2</h3>
<p>我们可以通过后序遍历来避免重复执行重复的代码</p>
<p>因为后序遍历,第一次出现符合的祖先必定为最近公共祖先</p>
<p>如果判断一个结点是最近公共祖先呢?</p>
<p>第一种情况是左子树存在一个结点<code>p</code>,右子树存在另一个结点<code>q</code>,那么当前结点<code>root</code>即为最近公共祖先</p>
<p>如果当前结点等于<code>p</code>或<code>q</code>,那么其左子树(或右子树)如果存在另一个结点,则当前结点是最近公共祖先.</p>
<p>根据我们可以写下代码参考<a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-ii-er-cha-shu-de-zui-jin-gong-gon-7/">面试题68 - II. 二叉树的最近公共祖先（后序遍历 DFS ，清晰图解）</a></p>
<p>其中返回值代表的意思是要么返回空,要么返回最近公共祖先,因此其最近公共祖先是不断往上层传递</p>
<h3 id="解题代码2-v16"><a class="header-anchor" href="#解题代码2-v16"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">// 从下到上</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || root == p || root == q ) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p , q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> ) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路3-v3"><a class="header-anchor" href="#解题思路3-v3"> </a>解题思路3</h3>
<p>根据解题思路2的思想,用官方题解的代码去写<a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/er-cha-shu-de-zui-jin-gong-gong-zu-xian-6fdt7/">官方题解递归</a></p>
<h3 id="解题代码3-v7"><a class="header-anchor" href="#解题代码3-v7"> </a>解题代码3</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode ans;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        dfs(root,p,q);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">lson</span> <span class="operator">=</span> dfs(root.left,p,q);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rson</span> <span class="operator">=</span> dfs(root.right,p,q);</span><br><span class="line">        <span class="comment">//判断成立条件</span></span><br><span class="line">        <span class="keyword">if</span>((lson &amp;&amp; rson) || ((root.val == p.val || root.val == q.val) &amp;&amp;(lson || rson)))&#123;</span><br><span class="line">            ans = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lson || rson || root.val == p.val || root.val == q.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路4"><a class="header-anchor" href="#解题思路4"> </a>解题思路4</h3>
<p>可以根据hashmap去储存每一条链的每个结点</p>
<p>然后取<code>p</code>去保存该路径(从root到p)</p>
<p>接着去寻找<code>q</code>网上倒退的过程中,在hashset中第一次出现重复结点即为最近公共结点</p>
<h3 id="解题代码4-v2"><a class="header-anchor" href="#解题代码4-v2"> </a>解题代码4</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;TreeNode,TreeNode&gt; map;</span><br><span class="line">    Set&lt;TreeNode&gt; set;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">// 先获取每个结点及其父节点构成键值对，存入hashmap</span></span><br><span class="line">        <span class="comment">// 再获取p的路径（从root到p）存入hashSet</span></span><br><span class="line">        <span class="comment">// 再从q开始，往上遍历，第一次出现存在的结点即为最近公共结点</span></span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        dfs(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">null</span>)&#123;</span><br><span class="line">            set.add(p);</span><br><span class="line">            p = map.get(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(q)) <span class="keyword">return</span> q;</span><br><span class="line">            q = map.get(q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            map.put(root.left,root);</span><br><span class="line">            dfs(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            map.put(root.right,root);</span><br><span class="line">            dfs(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题-04-02-最小高度树"><a class="header-anchor" href="#面试题-04-02-最小高度树"> </a><a href="https://leetcode-cn.com/problems/minimum-height-tree-lcci/">面试题 04.02. 最小高度树</a></h2>
<h3 id="题目-v43"><a class="header-anchor" href="#题目-v43"> </a>题目</h3>
<p>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。</p>
<blockquote>
<p>示例:<br>
给定有序数组: [-10,-3,0,5,9],<br>
一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：<br>
0<br>
/ \<br>
-3   9<br>
/   /<br>
-10  5</p>
</blockquote>
<h3 id="解题思路-v33"><a class="header-anchor" href="#解题思路-v33"> </a>解题思路</h3>
<p>如果要生成一个高度最小的二叉树，则尽量让左右两个子树的个数相等。于是我们就规定数组的中间结点为根节点。</p>
<h3 id="解题代码-v29"><a class="header-anchor" href="#解题代码-v29"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sortedBST(nums,<span class="number">0</span>,nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedBST</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="comment">//取中间作为根节点</span></span><br><span class="line">        <span class="comment">// 规定左闭右开</span></span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = sortedBST(nums,left,mid);</span><br><span class="line">        root.right =sortedBST(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题-04-04-检查平衡性"><a class="header-anchor" href="#面试题-04-04-检查平衡性"> </a><a href="https://leetcode-cn.com/problems/check-balance-lcci/">面试题 04.04. 检查平衡性</a></h2>
<h3 id="题目-v44"><a class="header-anchor" href="#题目-v44"> </a>题目</h3>
<p>实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过 1。</p>
<blockquote>
<p>示例 1:<br>
给定二叉树 [3,9,20,null,null,15,7]<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回 true 。</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
给定二叉树 [1,2,2,3,3,null,null,4,4]<br>
1<br>
/ <br>
2   2<br>
/ <br>
3   3<br>
/ <br>
4   4<br>
返回 false 。</p>
</blockquote>
<h3 id="解题思路-v34"><a class="header-anchor" href="#解题思路-v34"> </a>解题思路</h3>
<p>同”<a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a>“</p>
<h3 id="解题代码-v30"><a class="header-anchor" href="#解题代码-v30"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 只需在获取高度的过程中，判断其左右两个子树是否高度平衡</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> getHeight(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> getHeight(root.right);</span><br><span class="line">        <span class="keyword">return</span>  Math.abs(leftHeight-rightHeight)&lt;=<span class="number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root!=<span class="literal">null</span>?Math.max(getHeight(root.left),getHeight(root.right))+<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题-17-12-BiNode"><a class="header-anchor" href="#面试题-17-12-BiNode"> </a><a href="https://leetcode-cn.com/problems/binode-lcci/">面试题 17.12. BiNode</a></h2>
<h3 id="题目-v45"><a class="header-anchor" href="#题目-v45"> </a>题目</h3>
<p>二叉树数据结构TreeNode可用来表示单向链表（其中left置空，right为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求依然符合二叉搜索树的性质，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。</p>
<p>返回转换后的单向链表的头节点。<br>
注意：本题相对原题稍作改动</p>
<blockquote>
<p>示例：<br>
输入： [4,2,5,1,3,null,6,0]<br>
输出： [0,null,1,null,2,null,3,null,4,null,5,null,6]</p>
</blockquote>
<p>提示：<br>
节点数量不会超过 100000。</p>
<h3 id="解题思路-v35"><a class="header-anchor" href="#解题思路-v35"> </a>解题思路</h3>
<p>注意到中序遍历的访问顺序刚好为我们需要的链表顺序</p>
<p>需要注意的技巧是，通过保存上一个结点来实现拼接</p>
<p>同时需要将当前结点的left置空</p>
<h3 id="解题代码-v31"><a class="header-anchor" href="#解题代码-v31"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertBiNode</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 注意到转换后的链表其实是一个递增的，所以代表这是个中序遍历</span></span><br><span class="line">        <span class="comment">// 但是如果按通常中序遍历的递归，我们先来到了最小的结点，我们不好决定返回值</span></span><br><span class="line">        <span class="comment">// 如果返回数值最大的结点，即新构成的链表最尾巴的结点，会比较好操作，即拼接只需要O（1）的复杂度，但是这样会丢失头结点的信息，除非我们一开始就保存</span></span><br><span class="line">        <span class="comment">// 如果一直返回头节点的话，我们每次都需要将其指向链表尾部进行拼接，浪费时间。</span></span><br><span class="line">        convert(root);</span><br><span class="line">        <span class="keyword">return</span> dummy.right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">convert</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        convert(root.left);</span><br><span class="line">        <span class="keyword">if</span>(prev == <span class="literal">null</span>)&#123;</span><br><span class="line">            dummy.right = root;</span><br><span class="line">            prev = root;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            prev.right = root;</span><br><span class="line">            prev = root;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = <span class="literal">null</span>;</span><br><span class="line">        convert(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="94-二叉树的中序遍历"><a class="header-anchor" href="#94-二叉树的中序遍历"> </a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h2>
<h3 id="题目-v46"><a class="header-anchor" href="#题目-v46"> </a>题目</h3>
<p>给定一个二叉树的根节点 root ，返回它的 中序 遍历。</p>
<blockquote>
<p>示例 1：<br>
输入：root = [1,null,2,3]<br>
输出：[1,3,2]</p>
<p><img src="http://algorithm-image.qibinaoe.top/inorder_1.jpg" alt="img"></p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：root = []<br>
输出：[]</p>
</blockquote>
<blockquote>
<p>示例 3：<br>
输入：root = [1]<br>
输出：[1]</p>
</blockquote>
<blockquote>
<p>示例 4：<br>
输入：root = [1,2]<br>
输出：[2,1]</p>
<p><img src="http://algorithm-image.qibinaoe.top/inorder_5.jpg" alt="img"></p>
</blockquote>
<blockquote>
<p>示例 5：<br>
输入：root = [1,null,2]<br>
输出：[1,2]</p>
<p><img src="http://algorithm-image.qibinaoe.top/inorder_4.jpg" alt="img"></p>
</blockquote>
<blockquote>
<p>提示：<br>
树中节点数目在范围 [0, 100] 内<br>
-100 &lt;= Node.val &lt;= 100</p>
</blockquote>
<p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>
<h3 id="解题思路递归"><a class="header-anchor" href="#解题思路递归"> </a>解题思路递归</h3>
<p>较简单不详细介绍了</p>
<h3 id="解题代码递归-v2"><a class="header-anchor" href="#解题代码递归-v2"> </a>解题代码递归</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; result;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路迭代"><a class="header-anchor" href="#解题思路迭代"> </a>解题思路迭代</h3>
<p>对于树的中序遍历而言，需要借助栈进行存储当前结点。但是使用栈的思路跟前序遍历不一样。</p>
<p>中序遍历使用栈，对于“左”、“中”、“右”而言，只存了中，然后就往“左”边跑。并不是先压“右”再压”中“。</p>
<p>因为中序遍历会最先访问树的最左结点，但是同时在访问完最左结点之后，需要能够返回上一层父节点，所以只压父节点就可以了，对于其右结点，可以 通过<code>root.right</code>进行访问。</p>
<h3 id="解题代码迭代-v2"><a class="header-anchor" href="#解题代码迭代-v2"> </a>解题代码迭代</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//不断将当前结点压栈，直到来到最左的结点</span></span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.offerLast(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//root为空，说明已经不能再左了</span></span><br><span class="line">                <span class="comment">//此时取出栈中元素进行访问</span></span><br><span class="line">                root = stack.pollLast();</span><br><span class="line">                <span class="comment">//访问操作：</span></span><br><span class="line">                result.add(root.val);</span><br><span class="line">                <span class="comment">//对于中序遍历而言，当前已经操作过左子树 当前结点， 现在应该访问其右子树</span></span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路morris"><a class="header-anchor" href="#解题思路morris"> </a>解题思路morris</h3>
<p>具体看“501. 二叉搜索树中的众数”-“解题思路3再优化 morris中序遍历”</p>
<h3 id="解题代码-v32"><a class="header-anchor" href="#解题代码-v32"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//morris算法</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//将左孩子的最右结点的指向自己</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> root.left;</span><br><span class="line">            <span class="keyword">if</span>(left != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(left.right != <span class="literal">null</span> &amp;&amp; left.right != root)&#123;</span><br><span class="line">                    left = left.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//根据left.right的结果判断当前结点是否访问过</span></span><br><span class="line">                <span class="keyword">if</span>(left.right == root)&#123;</span><br><span class="line">                    <span class="comment">//说明当前结点的左子树都访问过了，现在要访问当前结点</span></span><br><span class="line">                    <span class="comment">//访问操作:</span></span><br><span class="line">                    result.add(root.val);</span><br><span class="line">                    left.right = <span class="literal">null</span>; <span class="comment">//恢复原来的树结构</span></span><br><span class="line">                    <span class="comment">//现在访问右子树</span></span><br><span class="line">                    root = root.right;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//说明还没将当前结点接在左孩子的最右结点上</span></span><br><span class="line">                    left.right = root; <span class="comment">//保存完该节点</span></span><br><span class="line">                    <span class="comment">//进行左子树的访问</span></span><br><span class="line">                    root = root.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//没有左子树，那就直接访问当前结点</span></span><br><span class="line">                result.add(root.val);</span><br><span class="line">                <span class="comment">// 去访问右子树</span></span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="95-不同的二叉搜索树-II"><a class="header-anchor" href="#95-不同的二叉搜索树-II"> </a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a></h2>
<h3 id="题目-v47"><a class="header-anchor" href="#题目-v47"> </a>题目</h3>
<p>给定一个整数 n，生成所有由 1 … n 为节点所组成的 二叉搜索树 。</p>
<p>示例：<br>
输入：3<br>
输出：<br>
[<br>
[1,null,3,2],<br>
[3,2,null,1],<br>
[3,1,null,null,2],<br>
[2,1,3],<br>
[1,null,2,null,3]<br>
]<br>
解释：<br>
以上的输出对应以下 5 种不同结构的二叉搜索树：</p>
<p>1         3     3      2      1<br>
\       /     /      / \      <br>
3     2     1      1   3      2<br>
/     /       \                 <br>
2     1         2                 3</p>
<p>提示：<br>
0 &lt;= n &lt;= 8</p>
<h3 id="解题思路-v36"><a class="header-anchor" href="#解题思路-v36"> </a>解题思路</h3>
<p>在生成一棵这样的二叉搜索树的时候，能够发现，在选定一个根节点后，去生成其左右子树的过程，又是重复生成当前结点的步骤。因此我们可以利用递归去解决这道题</p>
<h3 id="解题代码-v33"><a class="header-anchor" href="#解题代码-v33"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过递归的方式去解决这道题</span></span><br><span class="line">        <span class="comment">// 因为可以发现，生成一棵这样的二叉搜索树，在生成其左子树和右子树是其子问题，解决的方式是一致的。</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">generateTrees</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; allTrees = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); <span class="comment">// allTrees存放的是在start到end这些编号中，分别以其中某一个数字为根节点，所能生成的所有树的根节点的集合</span></span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            <span class="comment">//说明结点为空， 放入空结点</span></span><br><span class="line">            allTrees.add(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> allTrees;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//现在生成allTrees</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="comment">// i 代表当前是以i编号为根节点</span></span><br><span class="line">            <span class="comment">//生成左右子树</span></span><br><span class="line">            List&lt;TreeNode&gt; leftTrees = generateTrees(start,i-<span class="number">1</span>);</span><br><span class="line">            List&lt;TreeNode&gt; rightTrees = generateTrees(i+<span class="number">1</span>,end);</span><br><span class="line">            <span class="comment">//将左子树，右子树，根节点组合在一起</span></span><br><span class="line">            <span class="comment">//注意leftTrees和rightTrees存放的都是根节点，所以直接放在根节点的左右子树就行了</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode leftr : leftTrees)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode rightr : rightTrees)&#123;</span><br><span class="line">                    <span class="comment">//生成根节点</span></span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(i);</span><br><span class="line">                    root.left = leftr;</span><br><span class="line">                    root.right = rightr;</span><br><span class="line">                    allTrees.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allTrees;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2TODO"><a class="header-anchor" href="#解题思路2TODO"> </a>解题思路2TODO</h3>
<p>还有动态规划的解法，等学习后再来补充</p>
<p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-2-7/">详细通俗的思路分析，多解法</a></p>
<h2 id="96-不同的二叉搜索树"><a class="header-anchor" href="#96-不同的二叉搜索树"> </a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h2>
<h3 id="题目-v48"><a class="header-anchor" href="#题目-v48"> </a>题目</h3>
<p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<blockquote>
<p>示例:<br>
输入: 3<br>
输出: 5<br>
解释:<br>
给定 n = 3, 一共有 5 种不同结构的二叉搜索树<br>
1         3     3      2      1<br>
\       /     /      / \      <br>
3     2     1      1   3      2<br>
/     /       \                 <br>
2     1         2                 3</p>
</blockquote>
<h3 id="解题思路-v37"><a class="header-anchor" href="#解题思路-v37"> </a>解题思路</h3>
<p>这题解题的想法和上一道题“<a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a>”的想法大致是一样的。</p>
<p>整体上递归的方法，先选定根节点，然后去分别判断左右子树的个数。与上一题不同的是，这题只需要个数，不需要具体的树，因此我们可以通过将左右子树的个数相乘即可。<strong>但是</strong>需要注意的一点是，当其中一侧为空时，则也属于一种情况，因此</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">leftnums = leftnums == <span class="number">0</span>? <span class="number">1</span>:leftnums;</span><br><span class="line">rightnums = rightnums == <span class="number">0</span>? <span class="number">1</span>:rightnums;</span><br></pre></td></tr></table></figure>
<p>来使得子树为空的情况也能计算在内</p>
<p>接着只需要<code>leftnums*rightnums</code>左右子树个数相乘即可。</p>
<p>另一个与上一题不同的地方在于，左右子树由于只需要个数，因此数值<code>n</code>就能决定输出的个数<code>nums</code>。如果像上一道题，每一棵树都去计算个数的话，会超时。因此这里我们借助hashmap去保存<code>n</code>和对应的<code>nums</code>，进一步减少计算</p>
<h3 id="解题代码-v34"><a class="header-anchor" href="#解题代码-v34"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//通过递归，选定根节点后进行左右子树的判断</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numsTrees(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numsTrees</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> end - start;</span><br><span class="line">        <span class="comment">//先判断是否计算过该值</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> map.get(n);</span><br><span class="line">        <span class="keyword">if</span>(result != <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以start至end分别为根节点，生成其左右子树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">leftnums</span> <span class="operator">=</span> numsTrees(start, i-<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightnums</span> <span class="operator">=</span> numsTrees(i+<span class="number">1</span>,end);</span><br><span class="line">            leftnums = leftnums == <span class="number">0</span>? <span class="number">1</span>:leftnums;</span><br><span class="line">            rightnums = rightnums == <span class="number">0</span>? <span class="number">1</span>:rightnums;</span><br><span class="line">            nums += leftnums*rightnums;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(n,nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2TODO-v2"><a class="header-anchor" href="#解题思路2TODO-v2"> </a>解题思路2TODO</h3>
<p>官解使用动态规划，等我具体学习了动态规划再来补充</p>
<p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode-solution/">不同的二叉搜索树</a></p>
<h2 id="98-验证二叉搜索树"><a class="header-anchor" href="#98-验证二叉搜索树"> </a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h2>
<h3 id="题目-v49"><a class="header-anchor" href="#题目-v49"> </a>题目</h3>
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：<br>
节点的左子树只包含小于当前节点的数。<br>
节点的右子树只包含大于当前节点的数。<br>
所有左子树和右子树自身必须也是二叉搜索树。</p>
<blockquote>
<p>示例 1:<br>
输入:<br>
2<br>
/ <br>
1   3<br>
输出: true</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
输入:<br>
5<br>
/ <br>
1   4<br>
/ <br>
3   6<br>
输出: false<br>
解释: 输入为: [5,1,4,null,null,3,6]。<br>
根节点的值为 5 ，但是其右子节点值为 4 。</p>
</blockquote>
<h3 id="解题思路-v38"><a class="header-anchor" href="#解题思路-v38"> </a>解题思路</h3>
<p>既然是BST，那么其中序遍历必须满足递增的规律，因此我们就通过中序遍历去判断</p>
<h3 id="解题代码-v35"><a class="header-anchor" href="#解题代码-v35"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> prev;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">first</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="keyword">if</span>(first)&#123;</span><br><span class="line">            first = <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(prev &gt;= root.val)&#123;</span><br><span class="line">                ans = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = root.val;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v18"><a class="header-anchor" href="#解题思路2-v18"> </a>解题思路2</h3>
<p>一个二叉搜索树的右孩子必然都大于当前结点</p>
<p>一个二叉搜索树的左孩子必然都小于当前结点。</p>
<p>根据这个特点，我们去递归</p>
<h3 id="解题代码2-v17"><a class="header-anchor" href="#解题代码2-v17"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root, Integer lower, Integer higher)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//判断当前结点是否满足BST</span></span><br><span class="line">        <span class="keyword">if</span>(lower != <span class="literal">null</span> &amp;&amp; root.val &lt;= lower) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(higher != <span class="literal">null</span> &amp;&amp; root.val &gt;= higher) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//判断其左右孩子</span></span><br><span class="line">        <span class="comment">//左孩子的值应该介于最小值和root.val之间</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.left,lower,root.val) &amp;&amp; isValidBST(root.right,root.val,higher);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="99-恢复二叉搜索树"><a class="header-anchor" href="#99-恢复二叉搜索树"> </a><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/">99. 恢复二叉搜索树</a></h2>
<h3 id="题目-v50"><a class="header-anchor" href="#题目-v50"> </a>题目</h3>
<p>给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。</p>
<p>进阶：使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？</p>
<blockquote>
<p>示例 1：<br>
输入：root = [1,3,null,null,2]<br>
输出：[3,1,null,null,2]<br>
解释：3 不能是 1 左孩子，因为 3 &gt; 1 。交换 1 和 3 使二叉搜索树有效。</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：root = [3,1,4,null,null,2]<br>
输出：[2,1,4,null,null,3]<br>
解释：2 不能在 3 的右子树中，因为 2 &lt; 3 。交换 2 和 3 使二叉搜索树有效。</p>
</blockquote>
<blockquote>
<p>提示：<br>
树上节点的数目在范围 [2, 1000] 内<br>
-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</p>
</blockquote>
<h3 id="解题思路-v39"><a class="header-anchor" href="#解题思路-v39"> </a>解题思路</h3>
<p>看到二叉搜索树就想到中序遍历。然后我们现在就研究一个升序数组进行其中任意两个数字进行调换会发生什么事。</p>
<p>首先是出现逆序对。但是这其中又有区别。当交换的是两个相邻的元素，则只出现一次逆序对。当交换的是两个不相邻的元素，则出现两个逆序对。然后我们就是要记录这两个逆序对中需要交换的元素进行交换即可</p>
<h3 id="解题代码-v36"><a class="header-anchor" href="#解题代码-v36"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recoverTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 对于一个调换两个结点的树，有两种情况</span></span><br><span class="line">        <span class="comment">// 1. 调换相邻元素，那么只需将这两个元素交换即可，同时只会出现一次逆序情况</span></span><br><span class="line">        <span class="comment">// 2. 调换不相邻的两个元素，那么存在两组元素：前面元素大于后面元素（按中序遍历），那么需要将第一组的第一个和第二组的第二个交换</span></span><br><span class="line">        <span class="comment">// 因此我们同一需要调换的两个元素定位x y。来统一处理逆序情况，</span></span><br><span class="line">        <span class="comment">// 只要出现逆序情况，我们将该组的第二个元素赋值给y，因为两种情况，y都是在第二个</span></span><br><span class="line">        <span class="comment">// 同时在x为空的情况，将该组第一个赋值给x，因为两种情况x都是在第一个</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">x</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">y</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pred</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 中序遍历</span></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.offerLast(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = stack.pollLast();</span><br><span class="line">                <span class="comment">// 开始进行遍历</span></span><br><span class="line">                <span class="keyword">if</span>(pred == <span class="literal">null</span>) &#123;</span><br><span class="line">                    pred = root;</span><br><span class="line">                    root = root.right;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//  判断是否有序</span></span><br><span class="line">                <span class="keyword">if</span>(root.val &lt; pred.val) &#123;</span><br><span class="line">                    <span class="comment">// 该组乱序</span></span><br><span class="line">                    y = root;</span><br><span class="line">                    <span class="keyword">if</span>(x == <span class="literal">null</span>) &#123;</span><br><span class="line">                        x = pred;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 说明这是第二组，可以结束了</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                pred = root;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找出需要交换的两个结点x , y </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x.val;</span><br><span class="line">        x.val = y.val;</span><br><span class="line">        y.val = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="102-二叉树的层序遍历"><a class="header-anchor" href="#102-二叉树的层序遍历"> </a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h2>
<h3 id="题目-v51"><a class="header-anchor" href="#题目-v51"> </a>题目</h3>
<p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<blockquote>
<p>示例：<br>
二叉树：[3,9,20,null,null,15,7],<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回其层序遍历结果：<br>
[<br>
[3],<br>
[9,20],<br>
[15,7]<br>
]</p>
</blockquote>
<h3 id="解题思路-v40"><a class="header-anchor" href="#解题思路-v40"> </a>解题思路</h3>
<p>层序遍历的话使用队列即可解决，同时它需要同时取出一整层的结点，所以我们先记录该层的结点个数，再进行访问</p>
<h3 id="解题代码-v37"><a class="header-anchor" href="#解题代码-v37"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                level.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) queue.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="103-二叉树的锯齿形层序遍历"><a class="header-anchor" href="#103-二叉树的锯齿形层序遍历"> </a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h2>
<h3 id="题目-v52"><a class="header-anchor" href="#题目-v52"> </a>题目</h3>
<p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<blockquote>
<p>例如：<br>
给定二叉树 [3,9,20,null,null,15,7],<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7<br>
返回锯齿形层序遍历如下：<br>
[<br>
[3],<br>
[20,9],<br>
[15,7]<br>
]</p>
</blockquote>
<h3 id="解题思路-v41"><a class="header-anchor" href="#解题思路-v41"> </a>解题思路</h3>
<p>这题本质上还是一个层序遍历，只是在将一整层的数组添加进最终的答案数组时，根据其在奇数层还是偶数层，判断是否要将其翻转过来</p>
<h3 id="解题代码-v38"><a class="header-anchor" href="#解题代码-v38"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) queue.offer(root);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">odd</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                level.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) queue.offer(cur.right); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据奇偶层来判断是否翻转</span></span><br><span class="line">            <span class="keyword">if</span>(!odd)&#123;</span><br><span class="line">                Collections.reverse(level);</span><br><span class="line">            &#125;</span><br><span class="line">            odd = !odd;</span><br><span class="line">            ans.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="105-从前序与中序遍历序列构造二叉树"><a class="header-anchor" href="#105-从前序与中序遍历序列构造二叉树"> </a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h2>
<h3 id="题目-v53"><a class="header-anchor" href="#题目-v53"> </a>题目</h3>
<p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p>注意:<br>
你可以假设树中没有重复的元素。</p>
<blockquote>
<p>例如，给出<br>
前序遍历 preorder = [3,9,20,15,7]<br>
中序遍历 inorder = [9,3,15,20,7]<br>
返回如下的二叉树：<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7</p>
</blockquote>
<h3 id="解题思路-v42"><a class="header-anchor" href="#解题思路-v42"> </a>解题思路</h3>
<p>基本的思路是先确定根节点，再确定左右子树的根节点</p>
<p>先通过中序遍历去确定我们要搜索的范围的根节点</p>
<p>确定搜索范围后，我们再搜索范围中出现的结点中，根据前序遍历，寻找最先出现的那个结点即为根节点</p>
<p>确定当前的根节点，我们去确定左右子树的根节点，这里只需要缩小范围去递归即可。根据中序遍历，左子树的范围在其根节点索引往左。右子树的范围在其根节点索引往右</p>
<h3 id="解题代码-v39"><a class="header-anchor" href="#解题代码-v39"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] preorder;</span><br><span class="line">    <span class="type">int</span>[] inorder;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; preorderMap;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        preorderMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; preorder.length; i++)&#123;</span><br><span class="line">            preorderMap.put(preorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构造一棵二叉树首先确定根节点</span></span><br><span class="line">        <span class="comment">// 从前序遍历最先出现的即为根节点</span></span><br><span class="line">        <span class="comment">// 所以我们按前序遍历的顺序去访问</span></span><br><span class="line">        <span class="built_in">this</span>.preorder = preorder;</span><br><span class="line">        <span class="built_in">this</span>.inorder = inorder;</span><br><span class="line">        <span class="keyword">return</span> buildTree(<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//我们要根据[start,end]生成其中的根节点，这范围是中序遍历的</span></span><br><span class="line">        <span class="comment">//先找出根节点</span></span><br><span class="line">        <span class="comment">//根节点即在我们要搜索的中序遍历的范围内，最早在前序遍历出现的结点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minindex</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootindex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curval</span> <span class="operator">=</span> inorder[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">curindex</span> <span class="operator">=</span> preorderMap.get(curval);</span><br><span class="line">            <span class="keyword">if</span>(curindex &lt; minindex)&#123;</span><br><span class="line">                minindex = curindex;</span><br><span class="line">                rootindex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//生成根节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[minindex]);</span><br><span class="line">        <span class="comment">//生成左右孩子</span></span><br><span class="line">        root.left = buildTree(start,rootindex-<span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(rootindex+<span class="number">1</span>,end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v19"><a class="header-anchor" href="#解题思路2-v19"> </a>解题思路2</h3>
<p>上一个解题思路中，在每个递归都遍历一遍数组，这样的效率过低。而我们要遍历一遍数组的原因在于我们要寻找根节点在哪，同时要找出根节点分别在中序遍历和后序遍历的位置。根据这个我们可以进行优化</p>
<p>所以，我们的思想就是要知道<strong>根节点在哪</strong>?</p>
<p>注意到前序遍历的最开头是根节点，这样我们就可以轻松的创建当前根节点。</p>
<p>那如何去创建左孩子和右孩子呢？</p>
<p>左孩子就是左子树的根节点，所以我们要找出左子树范围的前序遍历的第一个。</p>
<p>这个怎么找呢？</p>
<p>知道前序遍历的顺序是：根 左 右</p>
<p>根在前序遍历的索引已经知道了，那“左子树的根在前序遍历的位置”即“根在前序遍历的索引+1”就可以获得</p>
<p>那右子树的根的索引怎么获取呢？</p>
<p>”右子树的根的索引“即为““根在前序遍历的索引”+“左子树的长度”+1”即可。</p>
<p>记住：这里说的“根的索引”指的是在其树的范围的前序遍历的<strong>第一个结点</strong></p>
<p>这样我们就知道根，左子树根，右子树根如何生成</p>
<p>现在解决如何知道左子树的长度</p>
<p>可以通过中序遍历，在中序遍历索引中[最左，根-1]为左子树范围，[根+1，最右]即为右子树范围</p>
<p>而通过hashmap去储存结点的值与对于在中序遍历的位置。我们就可以找到前序遍历的根节点在中序遍历的索引。</p>
<h3 id="解题代码2-v18"><a class="header-anchor" href="#解题代码2-v18"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] preorder;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++)&#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.preorder = preorder;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> preorder.length;</span><br><span class="line">        <span class="keyword">return</span> buildTree(<span class="number">0</span>,length-<span class="number">1</span>,<span class="number">0</span>,length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span> preLeft, <span class="type">int</span> preRight, <span class="type">int</span> inLeft, <span class="type">int</span> inRight)</span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(preLeft &gt; preRight || inLeft &gt; inRight) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//preLeft指向根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">inroot</span> <span class="operator">=</span> map.get(preorder[preLeft]);</span><br><span class="line">        <span class="comment">//生成根节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[preLeft]);</span><br><span class="line">        <span class="comment">//左子树长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSubtreesLength</span> <span class="operator">=</span> inroot - inLeft;</span><br><span class="line">        <span class="comment">//生成左右孩子</span></span><br><span class="line">        root.left = buildTree(preLeft+<span class="number">1</span>,preLeft+leftSubtreesLength,inLeft,inroot-<span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(preLeft+leftSubtreesLength+<span class="number">1</span>,preRight,inroot+<span class="number">1</span>,inRight);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="106-从中序与后序遍历序列构造二叉树"><a class="header-anchor" href="#106-从中序与后序遍历序列构造二叉树"> </a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h2>
<h3 id="题目-v54"><a class="header-anchor" href="#题目-v54"> </a>题目</h3>
<p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意:<br>
你可以假设树中没有重复的元素。</p>
<blockquote>
<p>例如，给出<br>
中序遍历 inorder = [9,3,15,20,7]<br>
后序遍历 postorder = [9,15,7,20,3]<br>
返回如下的二叉树：<br>
3<br>
/ <br>
9  20<br>
/  <br>
15   7</p>
</blockquote>
<h3 id="解题思路-v43"><a class="header-anchor" href="#解题思路-v43"> </a>解题思路</h3>
<p>对于这道题，感觉用递归的思路会更加清晰，首先我们明确一点：</p>
<p>后序遍历是：左右根：因此根节点在最后面。</p>
<p>因此我们可以后序遍历从后往前找，最后一个就是根节点</p>
<p>根据找到根节点后，去看中序遍历的列表。</p>
<p>在中序遍历中，用后序遍历找到的根节点，去区分左右子树。</p>
<p>这样，我们又要去找左子树的根节点以及右孩子的根节点，去拼接到当前的根节点。这就有递归的味道了。</p>
<p>然后如何去写递归呢。就按照上面的思路，我们要先确定我们要寻找根节点的范围。</p>
<p>因为中序遍历的排序很好的表达出了左中右的次序关系，所以我们根据中序遍历的索引去确定我们要寻找的根节点的范围。</p>
<p>当前最左的索引<code>start</code>大于最右的索引<code>end</code>，说明已经没有存在结点了，及返回空，这个就是终止条件。</p>
<p>依次类推，如果<code>start == end</code>说明就刚好剩下一个结点，当然这不需要我们单独写出来。可以归在一般情况下。</p>
<p>假设我们知道了我们要寻找的数组下标的范围。那首先要确定根节点。</p>
<p>如何确定根节点呢？从后序遍历中，从右往左进行确认。</p>
<p>那如何知道最右的是不是我们要找的根节点的范围呢？所以我们要先对中序遍历的范围放在<code>set</code>当中，来明确我们要找到结点范围，然后在后序遍历中又在结点范围中，从右往左第一个出现的结点即为根节点。</p>
<p>这样我们就找到根节点了。</p>
<p>接下来要找左孩子和右孩子。</p>
<p>这就交给递归去完成了。显然，左孩子要寻找的范围即[最左，根结点索引的上一个]</p>
<p>右孩子要寻找的范围即[根节点索引的下一个，最右]</p>
<h3 id="解题代码-v40"><a class="header-anchor" href="#解题代码-v40"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//public HashSet&lt;TreeNode&gt; inTree = new HashSet&lt;&gt;(); //存放已经挂在树上的结点</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="comment">// 后序遍历的最后一个结点为根节点</span></span><br><span class="line">        <span class="comment">// 找到根节点后，根据中序遍历，来分别左右子树</span></span><br><span class="line">        <span class="keyword">return</span> buildTree(<span class="number">0</span>,inorder.length-<span class="number">1</span>,inorder,postorder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用递归方法实现</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span>&#123;</span><br><span class="line">        <span class="comment">//求中序遍历中，索引为[start,end]生成的树的结点</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//确定搜索范围</span></span><br><span class="line">        HashSet&lt;Integer&gt; lookfor = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++)&#123;</span><br><span class="line">            lookfor.add(inorder[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从postorder中确定根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> postorder.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curVal</span> <span class="operator">=</span> postorder[i];</span><br><span class="line">            <span class="keyword">if</span>(lookfor.contains(curVal))&#123;</span><br><span class="line">                rootVal = curVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成根节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成左右子树</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootindex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == rootVal)&#123;</span><br><span class="line">                rootindex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左子树范围[start, rootindex-1]</span></span><br><span class="line">        <span class="comment">//右子树范围[rootindex+1, end]</span></span><br><span class="line">        root.left = buildTree(start,rootindex-<span class="number">1</span>,inorder,postorder);</span><br><span class="line">        root.right = buildTree(rootindex+<span class="number">1</span>,end,inorder,postorder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="113-路径总和-II"><a class="header-anchor" href="#113-路径总和-II"> </a><a href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II</a></h2>
<h3 id="题目-v55"><a class="header-anchor" href="#题目-v55"> </a>题目</h3>
<p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<blockquote>
<p>说明: 叶子节点是指没有子节点的节点。<br>
示例:<br>
给定如下二叉树，以及目标和 sum = 22，<br>
5<br>
/ <br>
4   8<br>
/   / <br>
11  13  4<br>
/  \    / <br>
7    2  5   1<br>
返回:<br>
[<br>
[5,4,11,2],<br>
[5,8,4,5]<br>
]</p>
</blockquote>
<h3 id="解题思路-v44"><a class="header-anchor" href="#解题思路-v44"> </a>解题思路</h3>
<p>这种题目为输出所有路径结果，一般为递归思路</p>
<p>对于这题递归过程有几个坑</p>
<ol>
<li>二叉树的结点的值有正有负。所以不能因为到当前结点的路径之和已经大于所需要的和，就终止递归</li>
<li>这题要求的是到叶子节点。所以再将结果加入最终结果集合中时，需要先判断是否是叶子结点</li>
</ol>
<p>我采用的递归方式是每一条路径都生成了一个链表，但是这样的空间浪费非常严重</p>
<h3 id="解题代码-v41"><a class="header-anchor" href="#解题代码-v41"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; sumList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        dfs(root,sum,<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> sumList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum, LinkedList&lt;Integer&gt; ans)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        ans.add(root.val);</span><br><span class="line">        <span class="comment">//注意是到根节点</span></span><br><span class="line">        <span class="comment">//如果不是根节点就往下传,是则判断结果</span></span><br><span class="line">        <span class="comment">//二叉树的结点值可能是负数，所以不能通过正负值就终止递归</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val == targetSum) sumList.add(ans);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dfs(root.left,targetSum-root.val,(LinkedList&lt;Integer&gt;)ans.clone());</span><br><span class="line">            dfs(root.right,targetSum-root.val,(LinkedList&lt;Integer&gt;)ans.clone());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v20"><a class="header-anchor" href="#解题思路2-v20"> </a>解题思路2</h3>
<p>这里可以在上一种解题的思路上进行优化</p>
<p>第一种解题思路把每一条路径都创建一个集合去储存的原因在于，如果一直用同一个容器，那么遍历到其他条路径时，该容器会乱套。</p>
<p>那么我们可以通过一个栈的结构，将一条路径的结点压栈。由于这递归是深度优先，所以当一条路径遍历完，将结点弹出，就可以用同一个容器去遍历其他条链。同时，在符合条件的叶子节点，我们新创建一个容器来保存进答案就可以了。</p>
<h3 id="解题代码2-v19"><a class="header-anchor" href="#解题代码2-v19"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; sumList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> Deque&lt;Integer&gt; paths = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        dfs(root,sum);</span><br><span class="line">        <span class="keyword">return</span> sumList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        paths.offerLast(root.val);</span><br><span class="line">        <span class="comment">//注意是到根节点</span></span><br><span class="line">        <span class="comment">//如果不是根节点就往下传,是则判断结果</span></span><br><span class="line">        <span class="comment">//二叉树的结点值可能是负数，所以不能通过正负值就终止递归</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val == targetSum) sumList.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;(paths));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dfs(root.left,targetSum-root.val);</span><br><span class="line">            dfs(root.right,targetSum-root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        paths.pollLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="114-二叉树展开为链表"><a class="header-anchor" href="#114-二叉树展开为链表"> </a><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h2>
<h3 id="题目-v56"><a class="header-anchor" href="#题目-v56"> </a>题目</h3>
<p>给定一个二叉树，<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/8010757">原地</a>将它展开为一个单链表。</p>
<blockquote>
<p>例如，给定二叉树<br>
1<br>
/ <br>
2   5<br>
/ \   <br>
3   4   6<br>
将其展开为：<br>
1<br>
<br>
2<br>
<br>
3<br>
<br>
4<br>
<br>
5<br>
<br>
6</p>
</blockquote>
<h3 id="解题思路-v45"><a class="header-anchor" href="#解题思路-v45"> </a>解题思路</h3>
<p>注意这题不是单纯一个前序遍历输出链表就完事了,而是要<strong>原地</strong>,即用原来的树结构,变成一条只有右孩子的树结构</p>
<p>那么要构成这样的形状.可就得把一个当前根节点的左子树放到当前根节点和右子树的中间,这样就构成一个顺序</p>
<p>那么这就是中序遍历的做法:先处理完左子树,使其成为一条链,再将它拼接到根节点的右孩子上,然后根节点原来的右子树拼到那条链的下面,接下来再将原来的有右子树也整成一条链,就完成了</p>
<h3 id="解题代码-v42"><a class="header-anchor" href="#解题代码-v42"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//这题是原地算法</span></span><br><span class="line">        <span class="comment">//所以应该把当前结点的左子树都加到其右子树，上面</span></span><br><span class="line">        <span class="comment">//栈</span></span><br><span class="line">        <span class="comment">// 因为要先处理完左子树 当前结点 右子树  所以是中序遍历</span></span><br><span class="line">        dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> dfs(root.left);</span><br><span class="line">        <span class="comment">//处理当前结点</span></span><br><span class="line">        root.left = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> root.right;</span><br><span class="line">        <span class="comment">//拼接</span></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> left;</span><br><span class="line">            <span class="keyword">while</span>(temp.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                temp = temp.right;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.right = right; <span class="comment">//拼接</span></span><br><span class="line">            root.right = left;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v21"><a class="header-anchor" href="#解题思路2-v21"> </a>解题思路2</h3>
<p>这里可以采用类似morris算法感觉</p>
<p>morris是将 根结点的左孩子的最右孩子的右孩子成为根节点</p>
<p>而我们就将根结点的左孩子的最右孩子的右孩子成为根节点的右孩子,根节点的右孩子成为根节点的左孩子,这样就形成了题目要求的链了</p>
<h3 id="解题代码2-v20"><a class="header-anchor" href="#解题代码2-v20"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//这题是原地算法</span></span><br><span class="line">        <span class="comment">//所以应该把当前结点的左子树都加到其右子树，上面</span></span><br><span class="line">        <span class="comment">// 我们采用一个很像morris算法的思想</span></span><br><span class="line">        <span class="comment">//注意到前序遍历是 根 左 右， 而我们将根节点的 左孩子的最右孩子 的  右孩子 设置为 根节点的 右孩子， 这样子就拼起来啦</span></span><br><span class="line">        <span class="comment">// 拼起来以后，还需要把 根节点的左孩子 接到右孩子的位置  根节点的左孩子置空</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//根节点的左孩子</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">leftChild</span> <span class="operator">=</span> cur.left;</span><br><span class="line">                <span class="comment">//寻找根节点的左孩子的最右孩子</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">preNode</span> <span class="operator">=</span> leftChild;</span><br><span class="line">                <span class="keyword">while</span>(preNode.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    preNode = preNode.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将 根节点的左孩子的最右孩子的右孩子设置为根节点的右孩子</span></span><br><span class="line">                preNode.right = cur.right;</span><br><span class="line">                <span class="comment">//接到根节点上面</span></span><br><span class="line">                cur.right = leftChild;</span><br><span class="line">                cur.left = <span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="116-填充每个节点的下一个右侧节点指针"><a class="header-anchor" href="#116-填充每个节点的下一个右侧节点指针"> </a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h2>
<h3 id="题目-v57"><a class="header-anchor" href="#题目-v57"> </a>题目</h3>
<p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。<br>
初始状态下，所有 next 指针都被设置为 NULL。</p>
<p>进阶：<br>
你只能使用常量级额外空间。<br>
使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p>
<p>示例：</p>
<p><img src="http://algorithm-image.qibinaoe.top/116_sample.png" alt="img"></p>
<p>输入：root = [1,2,3,4,5,6,7]<br>
输出：[1,#,2,3,#,4,5,6,7,#]<br>
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，‘#’ 标志着每一层的结束。</p>
<p>提示：<br>
树中节点的数量少于 4096<br>
-1000 &lt;= node.val &lt;= 1000</p>
<h3 id="解题思路1-v9"><a class="header-anchor" href="#解题思路1-v9"> </a>解题思路1</h3>
<p>根据示例，很容易发现，通过一个层次遍历，将队列中头两个元素两两相连即可。需要注意的是一层中的最后一个节点的<code>next</code>应该是空，但是根据我们的算法，此时队列中不为空，因此要根据<code>size</code>来判断当前是否是队列的最后一个元素</p>
<p>但这种做法用到了队列，因此空间复杂度不为常量级</p>
<h3 id="解题代码1-v8"><a class="header-anchor" href="#解题代码1-v8"> </a>解题代码1</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="comment">//层次遍历</span></span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            queue.offer(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="type">Node</span> <span class="variable">nextRight</span> <span class="operator">=</span> queue.peek();</span><br><span class="line">                    cur.next = nextRight;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v22"><a class="header-anchor" href="#解题思路2-v22"> </a>解题思路2</h3>
<p>想要达到空间复杂度为常量级，就需要利用好题目给的<code>Node</code>类中含有<code>next</code>节点。而这题的难度主要在于两个非相同父节的同一层相邻节点如何构成联系。</p>
<p>可以发现，借助父节点的<code>next</code>，就可以使两个不是同一父节点的相关联。</p>
<p>而我们拼接这个<code>next</code>关系的位置，是站在父节点的那层，去拼下一层的关系。所以当父节点没有左孩子或右孩子的时候，即为叶子节点，可以终止</p>
<h3 id="解题代码2-v21"><a class="header-anchor" href="#解题代码2-v21"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据父节点的next，来连接同层但不同父节点的关系</span></span><br><span class="line">        <span class="comment">// 因此需要一层一层的遍历，需要记录每一层的左边的节点，通过leftmost.left要移动到下一层</span></span><br><span class="line">        <span class="comment">// 同一父节点的两个子节点直接相连接，不同父节点的两个子节点，通过父节点的next相连接，因此如果父节点没有next，则代表该节点也没有next</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">leftmost</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(leftmost.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> leftmost;</span><br><span class="line">            <span class="keyword">while</span>(head != <span class="literal">null</span> )&#123;</span><br><span class="line">                head.left.next = head.right;</span><br><span class="line">                <span class="keyword">if</span>(head.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                    head.right.next = head.next.left;</span><br><span class="line">                &#125;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            leftmost = leftmost.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路3-v4"><a class="header-anchor" href="#解题思路3-v4"> </a>解题思路3</h3>
<p>递归的思路去解这道题，总体思想和解题思路2是一致的，通过前序遍历的方式，我们只需要保证当前节点的next是有的，其叶子节点就能正确拼接</p>
<h3 id="解题代码3-v8"><a class="header-anchor" href="#解题代码3-v8"> </a>解题代码3</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            root.left.next = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span> &amp;&amp;root.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            root.right.next = root.next.left;</span><br><span class="line">        &#125;</span><br><span class="line">        connect(root.left);</span><br><span class="line">        connect(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="117-填充每个节点的下一个右侧节点指针-II"><a class="header-anchor" href="#117-填充每个节点的下一个右侧节点指针-II"> </a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></h2>
<h3 id="题目-v58"><a class="header-anchor" href="#题目-v58"> </a>题目</h3>
<p>给定一个二叉树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。<br>
初始状态下，所有 next 指针都被设置为 NULL。</p>
<blockquote>
<p>进阶：<br>
你只能使用常量级额外空间。<br>
使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p>
</blockquote>
<blockquote>
<p>示例：</p>
<p><img src="http://algorithm-image.qibinaoe.top/117_sample.png" alt="img">输入：root = [1,2,3,4,5,null,7]<br>
输出：[1,#,2,3,#,4,5,7,#]<br>
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</p>
</blockquote>
<p>提示：<br>
树中的节点数小于 6000<br>
-100 &lt;= node.val &lt;= 100</p>
<h3 id="解题思路-v46"><a class="header-anchor" href="#解题思路-v46"> </a>解题思路</h3>
<p>这题和上一题的基本思路是一致的，即如果当前节点有左右孩子，直接相连接。如果当前节点只有左孩子而没有右孩子，或者是要给右孩子寻找相连接的结点时，是通过当前节点的<code>next</code>来寻找下一个能够被连接的节点。</p>
<p>但是本题由于不是完全二叉树，因此存在许多特殊情况。</p>
<p>例如与当前结点<code>head</code>相邻的<code>head.next</code>是叶子节点，但是<code>head.next.next</code>可能存在孩子节点，如果用<code>if(head.next != null)</code>来判断的话，就会出现遗漏情况，因此需要用循环语句来判断。同时在循环语句中，不能够直接<code>head = head.next</code>。这样会把我们需要连接的左右节点给漏掉</p>
<p>同时还有一点要注意的是，如何找到下一层最左边的节点。这就不能像上一题，直接<code>leftmost = leftmost.left</code>了，因为可能<code>	leftmost</code>不存在左节点，或者就是叶子节点。所以得边连接边判断最左节点。</p>
<h2 id="解题思路-v47"><a class="header-anchor" href="#解题思路-v47"> </a>解题思路</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据子节点的孩子位置情况去判断</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// 记录层次的节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">leftmost</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(leftmost != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> leftmost;</span><br><span class="line">            <span class="comment">// 在拼接的同时寻找下一层的最左边节点</span></span><br><span class="line">            leftmost = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 拼接</span></span><br><span class="line">                <span class="keyword">if</span>(head.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(leftmost == <span class="literal">null</span>)&#123;</span><br><span class="line">                        leftmost = head.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(head.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                        head.left.next = head.right;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// 寻找第一个有孩子节点的同层节点</span></span><br><span class="line">                        <span class="type">Node</span> <span class="variable">nextHead</span> <span class="operator">=</span> head.next;</span><br><span class="line">                        <span class="keyword">while</span>(nextHead != <span class="literal">null</span>)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(nextHead.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                                head.left.next = nextHead.left;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nextHead.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                                head.left.next = nextHead.right;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            nextHead = nextHead.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(head.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(leftmost == <span class="literal">null</span>)&#123;</span><br><span class="line">                        leftmost = head.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(head.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(head.next.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                            head.right.next = head.next.left;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="comment">// 寻找第一个有孩子节点的同层节点</span></span><br><span class="line">                            <span class="type">Node</span> <span class="variable">nextHead</span> <span class="operator">=</span> head.next;</span><br><span class="line">                            <span class="keyword">while</span>(nextHead != <span class="literal">null</span>)&#123;</span><br><span class="line">                                <span class="keyword">if</span>(nextHead.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                                    head.right.next = nextHead.left;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nextHead.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                                    head.right.next = nextHead.right;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;   </span><br><span class="line">                                nextHead = nextHead.next;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="129-求根到叶子节点数字之和"><a class="header-anchor" href="#129-求根到叶子节点数字之和"> </a><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">129. 求根到叶子节点数字之和</a></h2>
<h3 id="题目-v59"><a class="header-anchor" href="#题目-v59"> </a>题目</h3>
<p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。</p>
<p>例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。</p>
<p>计算从根到叶子节点生成的所有数字之和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例 1:<br>
输入: [1,2,3]<br>
1<br>
/ <br>
2   3<br>
输出: 25<br>
解释:<br>
从根到叶子节点路径 1-&gt;2 代表数字 12.<br>
从根到叶子节点路径 1-&gt;3 代表数字 13.<br>
因此，数字总和 = 12 + 13 = 25.</p>
<p>示例 2:<br>
输入: [4,9,0,5,1]<br>
4<br>
/ <br>
9   0<br>
/ <br>
5   1<br>
输出: 1026<br>
解释:<br>
从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.<br>
从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.<br>
从根到叶子节点路径 4-&gt;0 代表数字 40.<br>
因此，数字总和 = 495 + 491 + 40 = 1026.</p>
<h3 id="解题思路-v48"><a class="header-anchor" href="#解题思路-v48"> </a>解题思路</h3>
<p>通过递归的方式进行，设置一个全局变量记录总和，而当递归到叶子节点的时候将最终值加进去即可</p>
<h3 id="解题代码-v43"><a class="header-anchor" href="#解题代码-v43"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curVal</span> <span class="operator">=</span> val * <span class="number">10</span> + root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            sum += curVal;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dfs(root.left, curVal);</span><br><span class="line">            dfs(root.right, curVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="144-二叉树的前序遍历"><a class="header-anchor" href="#144-二叉树的前序遍历"> </a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h2>
<h3 id="题目-v60"><a class="header-anchor" href="#题目-v60"> </a>题目</h3>
<p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p>
<h3 id="解题思路-v49"><a class="header-anchor" href="#解题思路-v49"> </a>解题思路</h3>
<p>前序遍历有递归，迭代和morris三种方式</p>
<p>这里写迭代</p>
<h3 id="解题代码-v44"><a class="header-anchor" href="#解题代码-v44"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.offerLast(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pollLast();</span><br><span class="line">            ans.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) stack.offerLast(cur.right);</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) stack.offerLast(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="145-二叉树的后序遍历"><a class="header-anchor" href="#145-二叉树的后序遍历"> </a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h2>
<h3 id="题目-v61"><a class="header-anchor" href="#题目-v61"> </a>题目</h3>
<p>给定一个二叉树，返回它的 后序 遍历。</p>
<blockquote>
<p>示例:<br>
输入: [1,null,2,3]<br>
1<br>
<br>
2<br>
/<br>
3<br>
输出: [3,2,1]</p>
</blockquote>
<h3 id="解题思路-v50"><a class="header-anchor" href="#解题思路-v50"> </a>解题思路</h3>
<p>可以通过递归进行。</p>
<h3 id="解题代码-v45"><a class="header-anchor" href="#解题代码-v45"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) stack.offerLast(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pollLast();</span><br><span class="line">            ans.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) stack.offerLast(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) stack.offerLast(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="173-二叉搜索树迭代器"><a class="header-anchor" href="#173-二叉搜索树迭代器"> </a><a href="https://leetcode-cn.com/problems/binary-search-tree-iterator/">173. 二叉搜索树迭代器</a></h2>
<h3 id="题目-v62"><a class="header-anchor" href="#题目-v62"> </a>题目</h3>
<p>实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：<br>
BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。<br>
boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。<br>
int next()将指针向右移动，然后返回指针处的数字。<br>
注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。</p>
<p>你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。</p>
<blockquote>
<p>示例：<br>
输入<br>
[“BSTIterator”, “next”, “next”, “hasNext”, “next”, “hasNext”, “next”, “hasNext”, “next”, “hasNext”]<br>
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]<br>
输出<br>
[null, 3, 7, true, 9, true, 15, true, 20, false]</p>
</blockquote>
<blockquote>
<p>解释<br>
BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);<br>
bSTIterator.next();    // 返回 3<br>
bSTIterator.next();    // 返回 7<br>
bSTIterator.hasNext(); // 返回 True<br>
bSTIterator.next();    // 返回 9<br>
bSTIterator.hasNext(); // 返回 True<br>
bSTIterator.next();    // 返回 15<br>
bSTIterator.hasNext(); // 返回 True<br>
bSTIterator.next();    // 返回 20<br>
bSTIterator.hasNext(); // 返回 False</p>
</blockquote>
<blockquote>
<p>提示：<br>
树中节点的数目在范围 [1, 105] 内<br>
0 &lt;= Node.val &lt;= 106<br>
最多调用 105 次 hasNext 和 next 操作</p>
</blockquote>
<p>进阶：<br>
你可以设计一个满足下述条件的解决方案吗？next() 和 hasNext() 操作均摊时间复杂度为 O(1) ，并使用 O(h) 内存。其中 h 是树的高度。</p>
<h3 id="解题思路一"><a class="header-anchor" href="#解题思路一"> </a>解题思路一</h3>
<p>比较简单的思路就是将这棵树的中序遍历结果用数组进行存储，然后通过维护数组索引来表示当前遍历到的位置。但是这种方法的空间复杂度为O(n)</p>
<h3 id="解题代码一"><a class="header-anchor" href="#解题代码一"> </a>解题代码一</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arr;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTIterator</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过中序遍历将树节点转换成数组</span></span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 中序遍历</span></span><br><span class="line">        dfs(root.left);</span><br><span class="line">        arr.add(root.val);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr.get(++index);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index+<span class="number">1</span> &lt; arr.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BSTIterator obj = new BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.next();</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.hasNext();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="解题思路二"><a class="header-anchor" href="#解题思路二"> </a>解题思路二</h3>
<p>可以借助栈结构，来进行中序遍历。</p>
<p>在这个过程中，我们并不需要将这棵二叉树遍历完，而是通过一个<code>cur</code>来记录根节点以及一个栈来保存<code>cur</code>的所有父节点。</p>
<p>这样我们可以通过判断<code>(cur != null) || !stack.isEmpty()</code>是否还存在next，因为刚开始的时候，还没进行遍历，栈为空，当时cur不为null。</p>
<h3 id="解题代码二"><a class="header-anchor" href="#解题代码二"> </a>解题代码二</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line">    </span><br><span class="line">    Deque&lt;TreeNode&gt; stack;</span><br><span class="line">    TreeNode cur;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTIterator</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 栈的形式进行中序遍历，同时不直接中序遍历完，而是在需要的时候进行中序遍历，再返回一个可用结果</span></span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        cur = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.offerLast(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = stack.pollLast();</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> cur.val;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (cur != <span class="literal">null</span>) || !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="199-二叉树的右视图"><a class="header-anchor" href="#199-二叉树的右视图"> </a><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h2>
<h3 id="题目-v63"><a class="header-anchor" href="#题目-v63"> </a>题目</h3>
<p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p>示例:</p>
<p>输入: [1,2,3,null,5,null,4]<br>
输出: [1, 3, 4]</p>
<blockquote>
<p>解释:<br>
1            &lt;—<br>
/   <br>
2     3         &lt;—<br>
\     <br>
5     4       &lt;—</p>
</blockquote>
<h3 id="解题思路-v51"><a class="header-anchor" href="#解题思路-v51"> </a>解题思路</h3>
<p>从右侧看到的话，就是每一层的最后一个。那么我们就想到进行层次遍历，同时获取每一层的最后一个元素即可。</p>
<h3 id="解题代码-v46"><a class="header-anchor" href="#解题代码-v46"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 层次遍历的最后一个元素</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); </span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 将一层的元素取出来</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= size; i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i == size) &#123;</span><br><span class="line">                    <span class="comment">// 最后一个</span></span><br><span class="line">                    res.add(cur.val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v23"><a class="header-anchor" href="#解题思路2-v23"> </a>解题思路2</h3>
<p>本题也可以通过递归的方式，通过深度优先的搜索路径进行访问，以根-右-左的顺序，能够保证我们第一次访问下一层最右边的结点。同是记录是否为该层第一个被访问到的结点，这个判断条件根据答案列表的长度和我们维护的一个深度变量进行判断。</p>
<h3 id="解题代码2-v22"><a class="header-anchor" href="#解题代码2-v22"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 结果列表</span></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//dfs方法</span></span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 判断当前结点是否为该层第一个被访问的结点</span></span><br><span class="line">        <span class="keyword">if</span>(res.size() == depth) &#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right, depth+<span class="number">1</span>);</span><br><span class="line">        dfs(root.left, depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="222-完全二叉树的节点个数"><a class="header-anchor" href="#222-完全二叉树的节点个数"> </a><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h2>
<h3 id="题目-v64"><a class="header-anchor" href="#题目-v64"> </a>题目</h3>
<p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p>
<p>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p>
<blockquote>
<p>示例 1：<br>
输入：root = [1,2,3,4,5,6]<br>
输出：6</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：root = []<br>
输出：0</p>
</blockquote>
<blockquote>
<p>示例 3：<br>
输入：root = [1]<br>
输出：1</p>
</blockquote>
<blockquote>
<p>提示：<br>
树中节点的数目范围是[0, 5 * 104]<br>
0 &lt;= Node.val &lt;= 5 * 104<br>
题目数据保证输入的树是 完全二叉树</p>
</blockquote>
<p>进阶：遍历树来统计节点是一种时间复杂度为 O(n) 的简单解决方案。你可以设计一个更快的算法吗？</p>
<h3 id="解题思路一-v2"><a class="header-anchor" href="#解题思路一-v2"> </a>解题思路一</h3>
<p>对于任意的二叉树，都可以通过遍历一遍所有的结点来统计结点个数。遍历的方式通过深度优先、广度优先都可。</p>
<p>但是这样遍历的方式就没有利用到本题完全二叉树的性质</p>
<h3 id="解题代码一-v2"><a class="header-anchor" href="#解题代码一-v2"> </a>解题代码一</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        count++;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路二-v2"><a class="header-anchor" href="#解题思路二-v2"> </a>解题思路二</h3>
<p>详见注解</p>
<h3 id="解题代码二-v2"><a class="header-anchor" href="#解题代码二-v2"> </a>解题代码二</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 对于完全二叉树，对于一个根节点，我们可以统计其左右子树的深度。而对于这个深度的计算，我们计算其最左那一条路径的深度</span></span><br><span class="line">        <span class="comment">// 如果根节点的左右子树的深度相同，说明其左子树肯定为一棵满二叉树。因为其左子树的叶子结点的最右结点的下一个邻居节点就是右子树的叶子节点的最左结点</span></span><br><span class="line">        <span class="comment">// 但是我们不能保证右子树为满二叉树，因为我们只是知道其右子树的最左路径的深度，不知道往右偏的任意一条路径，因此还需要去计算。</span></span><br><span class="line">        <span class="comment">// 对于这种情况，计算方法为左子树的节点个数，加上根节点，加上右子树递归统计的个数。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果左右子树的深度不相同，这时候我们只能确定，左子树的深度比右子树多一。而左子树不一定是满二叉树，但是右子树一定是比左子树深度少一的满二叉树。</span></span><br><span class="line">        <span class="comment">// 因此这种情况的计算方法就是：右子树的结点个数，加上根节点，加上左子树递归统计的个数。</span></span><br><span class="line">        <span class="comment">// 对于满二叉树的结点个数计算方法为：假设深度为depth（从1开始）,那么其深度为( 1 &lt;&lt; depth ) - 1</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span>  getDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span>(left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; left) + countNodes(root.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; right) + countNodes(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="230-二叉搜索树中第K小的元素"><a class="header-anchor" href="#230-二叉搜索树中第K小的元素"> </a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h2>
<h3 id="题目-v65"><a class="header-anchor" href="#题目-v65"> </a>题目</h3>
<p>给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。</p>
<blockquote>
<p>示例 1：<br>
输入：root = [3,1,4,null,2], k = 1<br>
输出：1</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：root = [5,3,6,2,4,null,null,1], k = 3<br>
输出：3</p>
</blockquote>
<blockquote>
<p>提示：<br>
树中的节点数为 n 。<br>
1 &lt;= k &lt;= n &lt;= 104<br>
0 &lt;= Node.val &lt;= 104</p>
</blockquote>
<p>进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？</p>
<h3 id="解题思路-v52"><a class="header-anchor" href="#解题思路-v52"> </a>解题思路</h3>
<p>由于这是一棵BST，那么根据中序遍历得到的是一个递增的序列，那么可以记录当前访问的是第几个数，当达到第K个数的时候返回即可。</p>
<h3 id="解题代码-v47"><a class="header-anchor" href="#解题代码-v47"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 左 中  右：中序遍历</span></span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == k) &#123;</span><br><span class="line">            res = root.val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 左 中  右：中序遍历</span></span><br><span class="line">        <span class="comment">// 迭代</span></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.offerLast(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = stack.pollLast();</span><br><span class="line">                <span class="comment">// 访问root</span></span><br><span class="line">                <span class="keyword">if</span>(--k == <span class="number">0</span>) <span class="keyword">return</span> root.val;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="236-二叉树的最近公共祖先"><a class="header-anchor" href="#236-二叉树的最近公共祖先"> </a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h2>
<h3 id="题目-v66"><a class="header-anchor" href="#题目-v66"> </a>题目</h3>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<blockquote>
<p>示例 1：<br>
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>
输出：3<br>
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>
输出：5<br>
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</p>
</blockquote>
<blockquote>
<p>示例 3：<br>
输入：root = [1,2], p = 1, q = 2<br>
输出：1</p>
</blockquote>
<blockquote>
<p>提示：<br>
树中节点数目在范围 [2, 105] 内。<br>
-109 &lt;= Node.val &lt;= 109<br>
所有 Node.val 互不相同 。<br>
p != q<br>
p 和 q 均存在于给定的二叉树中。</p>
</blockquote>
<h3 id="解题思路-v53"><a class="header-anchor" href="#解题思路-v53"> </a>解题思路</h3>
<p>可以注意到，这就是一棵普通的二叉树，不是BST，因此不能够利用BST的性质来解决。对于普通的二叉树，我们从上到下进行递归。那么我们可以规定递归函数返回值为当前结点的最近公共祖先。要么返回null，要么返回p或者q。所以我们本质是递归去寻找q或者p，所以判断当前root是否为最近公共祖先，则要满足要么root==p要么root==q，要么p和q分别分布在该根节点的左右子树中。</p>
<h3 id="解题代码-v48"><a class="header-anchor" href="#解题代码-v48"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 判断当前结点是不是公共祖先</span></span><br><span class="line">        <span class="comment">// 首先如果root等于p或者q，那么root肯定是公共祖先</span></span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// 否则其公共祖先可能在左子树或者右子树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果left为空，说明公共祖先肯定是右子树中的公共祖先</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="comment">// 如果left和right都不为空，说明p和q分别在左右子树中，那么root就是公共祖先</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="337-打家劫舍-III"><a class="header-anchor" href="#337-打家劫舍-III"> </a><a href="https://leetcode-cn.com/problems/house-robber-iii/">337. 打家劫舍 III</a></h2>
<h3 id="题目-v67"><a class="header-anchor" href="#题目-v67"> </a>题目</h3>
<p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。<br>
计算在不触动警报的情况下，小偷一晚能够盗取的最高金额</p>
<blockquote>
<p>示例 1:<br>
输入: [3,2,3,null,3,null,1]<br>
3<br>
/ <br>
2   3<br>
\   \<br>
3   1<br>
输出: 7<br>
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
输入: [3,4,5,1,3,null,1]<br>
3<br>
/ <br>
4   5<br>
/ \   \<br>
1   3   1<br>
输出: 9<br>
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.</p>
</blockquote>
<h3 id="解题思路-v54"><a class="header-anchor" href="#解题思路-v54"> </a>解题思路</h3>
<p>本题所要求的就是对于一棵二叉树中，选取一些节点，有两个要求，一是节点值和最大，二是节点间两两不相邻。</p>
<p>那么我们可以用递归的思想，对于当前节点root。如果要计算该节点所构成的最大值，有两种选择。第一种是选择加上root值，但是 这样就不能加上root的左右子树，但是可以考虑root的左右子树的子树。第二种选择是不选择加上root值，那么其值就是root左右子树之和所构成的值。通过这样去编写递归算法。</p>
<p>同时在递归的过程，为了避免重复计算某棵子树所能构成的最大值，所以用一个哈希表来保存结果。</p>
<h3 id="解题代码-v49"><a class="header-anchor" href="#解题代码-v49"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;TreeNode, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 用hashmap储存已经计算过的递归</span></span><br><span class="line">        <span class="keyword">return</span> dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 对于当前根节点有两种选择</span></span><br><span class="line">        <span class="comment">// 1 选择当前根节点，那么其左右子树都不能选</span></span><br><span class="line">        <span class="comment">// 2 不选择当前根节点，那么其值为左右子树之和</span></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(root)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(root);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> Math.max(root.val + (root.left==<span class="literal">null</span>?<span class="number">0</span>:dfs(root.left.left)+dfs(root.left.right)) + (root.right==<span class="literal">null</span>?<span class="number">0</span>:dfs(root.right.left)+dfs(root.right.right)), dfs(root.left)+dfs(root.right));</span><br><span class="line">            map.put(root, val);</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="437-路径总和-III"><a class="header-anchor" href="#437-路径总和-III"> </a><a href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a></h2>
<h3 id="题目-v68"><a class="header-anchor" href="#题目-v68"> </a>题目</h3>
<p>给定一个二叉树，它的每个结点都存放着一个整数值。<br>
找出路径和等于给定数值的路径总数。<br>
路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。<br>
二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p>
<blockquote>
<p>示例：<br>
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8<br>
10<br>
/  <br>
5   -3<br>
/ \    <br>
3   2   11<br>
/ \   <br>
3  -2   1<br>
返回 3。和等于 8 的路径有:</p>
</blockquote>
<ol>
<li>5 -&gt; 3</li>
<li>5 -&gt; 2 -&gt; 1</li>
<li>-3 -&gt; 11</li>
</ol>
<h3 id="解题思路-v55"><a class="header-anchor" href="#解题思路-v55"> </a>解题思路</h3>
<p>本题使用前缀和的方法去解决该题。</p>
<p>为什么使用前缀和呢？如果不用前缀和的方法去解决这题的话。比较直观的一个做法是加入从该节点开始，往下去遍历每个节点，看是否存在满足条件的路径和。接着再以此类推去寻找当前节点的左右孩子的路径和个数。但是这种方法去寻找会照成大量的重复遍历和重复计算。</p>
<p>而什么是前缀和：即根节点到当前节点的路径和。例如示例的树。</p>
<p>结点5的前缀和为：10-&gt;5：15</p>
<p>结点1的前缀和为：10-&gt;5-&gt;2-&gt;1：18</p>
<p>而前缀和的好处在于我们固定了每个结点的特性，而路径和与前缀和的关系在于我们可以通过两个结点的前缀和之差，来计算该两个结点的路径和。</p>
<p>因此我们通过去遍历树的过程中，计算当前结点的前缀和，同时与其祖先节点的前缀和进行比较，去查找是否有满足条件（有targetSum）的祖先的个数，同时也计算当前结点的左右孩子中，存在符合条件的路径个数，将其相加即得到结果。</p>
<p>同时在递归的过程中，需要我们通过哈希表去储存祖先前缀和的个数。因此在遍历完当前结点后，需要弹出当前结点的前缀和，因为当前节点不会再成为任何结点的祖先</p>
<h3 id="解题代码-v50"><a class="header-anchor" href="#解题代码-v50"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 储存某个节点的祖先节点中，key:祖先节点的前缀和， value：相同前缀和的个数</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="comment">// 前缀和方法去计算某段路径中之和等于targetSum</span></span><br><span class="line">        <span class="comment">// 前缀和：某个节点到根节点root的路径之和</span></span><br><span class="line">        <span class="comment">// 判断是否存在符合条件的路径：当前节点的前缀和：curSum。以及其某个祖先节点的前缀和preSum</span></span><br><span class="line">        <span class="comment">// 如果满足下列关系prevSum + targetSum = curSum，那么就存在一条路径。</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 注意要放入前缀和为0的值，才能够正确计算出到当前节点到根节点的路径和。</span></span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> recursivePathSum(root, <span class="number">0</span>, targetSum);   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">recursivePathSum</span><span class="params">(TreeNode root, <span class="type">int</span> prevSum, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 答案，即满足targetSum的路径的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> prevSum + root.val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算是否到当前节点，有满足targetSum的路径个数</span></span><br><span class="line">        <span class="comment">// 我们需要找其祖先节点中是否存在curSum - targetSum的个数</span></span><br><span class="line">        res += map.getOrDefault(curSum-targetSum, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前缀和等于curSum的个数</span></span><br><span class="line">        map.put(curSum, map.getOrDefault(curSum, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找其左右孩子是否也有路径</span></span><br><span class="line">        res += recursivePathSum(root.left, curSum, targetSum);</span><br><span class="line">        res += recursivePathSum(root.right, curSum, targetSum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前节点弹出，应为接下来不会遍历到当前节点的子孙节点</span></span><br><span class="line">        map.put(curSum, map.get(curSum)-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="449-序列化和反序列化二叉搜索树"><a class="header-anchor" href="#449-序列化和反序列化二叉搜索树"> </a><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-bst/">449. 序列化和反序列化二叉搜索树</a></h2>
<h3 id="题目-v69"><a class="header-anchor" href="#题目-v69"> </a>题目</h3>
<p>序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。<br>
设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。<br>
编码的字符串应尽可能紧凑。</p>
<blockquote>
<p>示例 1：<br>
输入：root = [2,1,3]<br>
输出：[2,1,3]</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：root = []<br>
输出：[]</p>
</blockquote>
<p>提示：<br>
树中节点数范围是 [0, 104]<br>
0 &lt;= Node.val &lt;= 104<br>
题目数据 保证 输入的树是一棵二叉搜索树。<br>
注意：不要使用类成员/全局/静态变量来存储状态。 你的序列化和反序列化算法应该是无状态的。</p>
<h3 id="解题思路-v56"><a class="header-anchor" href="#解题思路-v56"> </a>解题思路</h3>
<p>本题的树是一棵二叉搜索树，可以通过后序遍历的方式，去储存该树。后序遍历的顺序为：左 右 中。那么我们反序列的时候，可以逆着读取，先读到的是根节点。接着去生成左右子树。而二叉搜索树的右子树的值都会比根节点大，左子树的值都会比根节点小，因此我们可以传入右子树的边界范围（最大值与根节点的最大值相同，最小值必须大于根节点），和左子树的边界范围（最大值必须小于根节点，最小值与根节点相同）</p>
<h3 id="解题代码-v51"><a class="header-anchor" href="#解题代码-v51"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在序列化的过程中 通过后序遍历（左 右 中）进行储存。</span></span><br><span class="line">    <span class="comment">// 在反序列化过程中， 将序列化的字符串出入栈中，再从后往前遍历，这样就是以 根 右 左的顺序。而如何知道边界条件是通过左子树的值都小于根节点，右子树的值都大于根节点，根据这个要限定条件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">// 后序遍历</span></span><br><span class="line">        postorder(root, builder);</span><br><span class="line">        <span class="keyword">if</span>(builder.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            builder.deleteCharAt(builder.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode root, StringBuilder builder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        postorder(root.left, builder);</span><br><span class="line">        postorder(root.right, builder);</span><br><span class="line">        builder.append(root.val);</span><br><span class="line">        builder.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(data == <span class="literal">null</span> || data.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数据分割开</span></span><br><span class="line">        ArrayDeque&lt;Integer&gt; vals = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String val : data.split(<span class="string">&quot;\\s+&quot;</span>)) &#123;</span><br><span class="line">            vals.add(Integer.parseInt(val));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行恢复</span></span><br><span class="line">        <span class="keyword">return</span> helper(Integer.MIN_VALUE, Integer.MAX_VALUE,vals);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">helper</span><span class="params">(<span class="type">int</span> lower, <span class="type">int</span> upper, ArrayDeque&lt;Integer&gt; vals)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(vals.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> vals.peekLast();</span><br><span class="line">        <span class="keyword">if</span>(val &gt; upper || val &lt; lower) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vals.removeLast();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        root.right = helper(val, upper, vals);</span><br><span class="line">        root.left = helper(lower, val, vals);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser = new Codec();</span></span><br><span class="line"><span class="comment">// Codec deser = new Codec();</span></span><br><span class="line"><span class="comment">// String tree = ser.serialize(root);</span></span><br><span class="line"><span class="comment">// TreeNode ans = deser.deserialize(tree);</span></span><br><span class="line"><span class="comment">// return ans;</span></span><br></pre></td></tr></table></figure>
<h2 id="450-删除二叉搜索树中的节点"><a class="header-anchor" href="#450-删除二叉搜索树中的节点"> </a><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h2>
<h3 id="题目-v70"><a class="header-anchor" href="#题目-v70"> </a>题目</h3>
<p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<p>首先找到需要删除的节点；<br>
如果找到了，删除它。<br>
说明： 要求算法时间复杂度为 O(h)，h 为树的高度。</p>
<p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。<br>
一般来说，删除节点可分为两个步骤：<br>
首先找到需要删除的节点；<br>
如果找到了，删除它。<br>
说明： 要求算法时间复杂度为 O(h)，h 为树的高度。</p>
<blockquote>
<p>示例:<br>
root = [5,3,6,2,4,null,7]<br>
key = 3<br>
5<br>
/ <br>
3   6<br>
/ \   <br>
2   4   7<br>
给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。<br>
一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。<br>
5<br>
/ <br>
4   6<br>
/     <br>
2       7<br>
另一个正确答案是 [5,2,6,null,4,null,7]。<br>
5<br>
/ <br>
2   6<br>
\   <br>
4   7</p>
</blockquote>
<h3 id="解题思路-v57"><a class="header-anchor" href="#解题思路-v57"> </a>解题思路</h3>
<p>由于这是一棵BST，按中序遍历的顺序来讲，是递增序列。对于某个结点，在其递增序列中的相邻两个结点。分别是其左孩子的最右孩子。和其右孩子的最左孩子。所以我们如果要删除该节点，就可以将这两个相邻结点选择一个来替换。</p>
<p>同时在替换后，也需要删除其用来替换的孩子。而删除孩子的过程又可以看成一个删除结点的过程</p>
<h3 id="解题代码-v52"><a class="header-anchor" href="#解题代码-v52"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(key &gt; root.val) &#123;</span><br><span class="line">            root.right = deleteNode(root.right, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; root.val) &#123;</span><br><span class="line">            root.left = deleteNode(root.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 删除当前结点</span></span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 用后继结点来代替</span></span><br><span class="line">                root.val = successor(root);</span><br><span class="line">                <span class="comment">// 删除后继结点</span></span><br><span class="line">                root.right = deleteNode(root.right, root.val);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 用前继结点来代替</span></span><br><span class="line">                root.val = predecessor(root);</span><br><span class="line">                <span class="comment">// 删除前继结点</span></span><br><span class="line">                root.left = deleteNode(root.left, root.val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 被删除的结点为叶子结点</span></span><br><span class="line">                root = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前继结点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">predecessor</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        root = root.left;</span><br><span class="line">        <span class="keyword">while</span>(root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后继结点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">successor</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        root = root.right;</span><br><span class="line">        <span class="keyword">while</span>(root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>两数交换</title>
    <url>/2021/02/26/%E4%B8%A4%E6%95%B0%E4%BA%A4%E6%8D%A2/</url>
    <content><![CDATA[<p>对于两个数值（<code>num1</code>，<code>num2</code>）进行值的交换</p>
<p>本篇记录各种数值进行交换的方法与基本代码，同时进行其运行时间的统计与对比</p>
<p>注意：</p>
<ul>
<li>以下交换都是基于**<u>整型int</u>**</li>
<li>以下方法的命名，都是我自己编的，没有权威意义</li>
<li>测试结果存在误差</li>
</ul>
<!-- more -->
<h2 id="赋值交换法"><a class="header-anchor" href="#赋值交换法"> </a>赋值交换法</h2>
<p>赋值交换的代码例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">num1 = num2 + (num2 = num1) * <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>该表达式会先执行括号内<code>num2 = num1</code>，这样<code>num2</code>就被成功赋值。而括号外的<code>num2</code>仍是交换前的值，因此<code>num1</code>也被成功赋值</p>
<h3 id="测试-v2"><a class="header-anchor" href="#测试-v2"> </a>测试</h3>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ChangeTwoNum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChangeNum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 赋值交换法 a = b + (b = a) * 0</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1000000000L</span>;</span><br><span class="line">        <span class="type">int</span> num1,num2;</span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            num1 = random.nextInt();</span><br><span class="line">            num2 = random.nextInt();</span><br><span class="line">            num1 = num2 + (num2 = num1) * <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> end - begin;</span><br><span class="line">        System.out.println(<span class="string">&quot;赋值交换-随机数值-总耗时&quot;</span> + res + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"><span class="comment">//----------------------------------------------------------------------</span></span><br><span class="line">        num1 = <span class="number">1234567</span>;</span><br><span class="line">        num2 = <span class="number">7654321</span>;</span><br><span class="line">        begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            num1 = num2 + (num2 = num1) * <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        res = end - begin;</span><br><span class="line">        System.out.println(<span class="string">&quot;赋值交换-固定数值-总耗时&quot;</span> + res + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<h2 id="赋值交换法2"><a class="header-anchor" href="#赋值交换法2"> </a>赋值交换法2</h2>
<p>赋值交换即利用一个表达式中，一个变量用两次，一次用于赋值，一次用于被赋值。</p>
<p>赋值交换第二种方式跟上一个方法的区别是，这种方式是通过加减来抵消掉不需要的变量，上一个方法是通过乘以0来抵消掉，其实本质思想我认为是一样的</p>
<p>交换代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">num1 = num2 - num1 + (num1 = num2);</span><br></pre></td></tr></table></figure>
<h3 id="测试-v3"><a class="header-anchor" href="#测试-v3"> </a>测试</h3>
<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ChangeTwoNum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChangeNum2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 赋值交换法2 a = b + a - (b = a)</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1000000000L</span>;</span><br><span class="line">        <span class="type">int</span> num1,num2;</span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            num1 = random.nextInt();</span><br><span class="line">            num2 = random.nextInt();</span><br><span class="line">            num1 = num2 - num1 + (num2 = num1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> end - begin;</span><br><span class="line">        System.out.println(<span class="string">&quot;赋值交换2-随机数值-总耗时&quot;</span> + res + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"><span class="comment">//----------------------------------------------------------------------</span></span><br><span class="line">        num1 = <span class="number">1234567</span>;</span><br><span class="line">        num2 = <span class="number">7654321</span>;</span><br><span class="line">        begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            num1 = num2 - num1 + (num2 = num1);</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        res = end - begin;</span><br><span class="line">        System.out.println(<span class="string">&quot;赋值交换2-固定数值-总耗时&quot;</span> + res + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<h2 id="临时变量交换法"><a class="header-anchor" href="#临时变量交换法"> </a>临时变量交换法</h2>
<p>通过临时变量去交换两个数是最先接触到的一种交换方式，即通过一种临时变量<code>temp</code>去存储中间值，从而达到交换两数的方式</p>
<p>交换代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num1;</span><br><span class="line">num1 = num2;</span><br><span class="line">num2 = num1;</span><br></pre></td></tr></table></figure>
<h3 id="测试-v4"><a class="header-anchor" href="#测试-v4"> </a>测试</h3>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ChangeTwoNum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChangeNumTemp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 临时变量交换法 temp 存放临时变量</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1000000000L</span>;</span><br><span class="line">        <span class="type">int</span> num1,num2;</span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            num1 = random.nextInt();</span><br><span class="line">            num2 = random.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num2;</span><br><span class="line">            num2 = num1;</span><br><span class="line">            num1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> end - begin;</span><br><span class="line">        System.out.println(<span class="string">&quot;临时变量-随机数值-总耗时&quot;</span> + res + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"><span class="comment">//----------------------------------------------------------------------</span></span><br><span class="line">        num1 = <span class="number">1234567</span>;</span><br><span class="line">        num2 = <span class="number">7654321</span>;</span><br><span class="line">        begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num2;</span><br><span class="line">            num2 = num1;</span><br><span class="line">            num1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        res = end - begin;</span><br><span class="line">        System.out.println(<span class="string">&quot;临时变量-固定数值-总耗时&quot;</span> + res + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<h2 id="异或交换法"><a class="header-anchor" href="#异或交换法"> </a>异或交换法</h2>
<p>异或交换的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">num1 = num1 ^ num2;</span><br><span class="line">num2 = num1 ^ num2;</span><br><span class="line">num1 = num1 ^ num2;</span><br></pre></td></tr></table></figure>
<p>对于第二行<code>num2 = num1 ^ num2</code></p>
<p>这里的<code>num1</code>已经是<code>num1 ^ num2</code>了，所以展开就是</p>
<p><code>num2 = num1 ^ num2 ^ num2</code></p>
<p>可以知道异或运算是可交换的且相同的数异或的结果为0，而0异或任何数都是另一个数，因此<code>num2</code>就被成功改变了，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> ^ <span class="number">0</span> = <span class="number">0</span>;</span><br><span class="line"><span class="number">0</span> ^ <span class="number">1</span> = <span class="number">1</span>;</span><br><span class="line"><span class="number">1</span> ^ <span class="number">0</span> = <span class="number">1</span>;</span><br><span class="line"><span class="number">1</span> ^ <span class="number">1</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>而第三行展开为<code>num1 = num1 ^ num2 ^ num1</code>，则<code>num1 = num2</code></p>
<h3 id="测试-v5"><a class="header-anchor" href="#测试-v5"> </a>测试</h3>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ChangeTwoNum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChangeNumXOR</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 异或交换法</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1000000000L</span>;</span><br><span class="line">        <span class="type">int</span> num1,num2;</span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            num1 = random.nextInt();</span><br><span class="line">            num2 = random.nextInt();</span><br><span class="line">            num1 = num1 ^ num2;</span><br><span class="line">            num2 = num1 ^ num2;</span><br><span class="line">            num1 = num1 ^ num2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> end - begin;</span><br><span class="line">        System.out.println(<span class="string">&quot;异或交换-随机数值-总耗时&quot;</span> + res + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"><span class="comment">//----------------------------------------------------------------------</span></span><br><span class="line">        num1 = <span class="number">1234567</span>;</span><br><span class="line">        num2 = <span class="number">7654321</span>;</span><br><span class="line">        begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            num1 = num1 ^ num2;</span><br><span class="line">            num2 = num1 ^ num2;</span><br><span class="line">            num1 = num1 ^ num2;</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        res = end - begin;</span><br><span class="line">        System.out.println(<span class="string">&quot;异或交换-固定数值-总耗时&quot;</span> + res + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<h3 id="注意情况"><a class="header-anchor" href="#注意情况"> </a>注意情况</h3>
<p>在实践时候使用异或遇到了一些问题</p>
<h4 id="数组的同一个位置不能与自身进行交换"><a class="header-anchor" href="#数组的同一个位置不能与自身进行交换"> </a>数组的同一个位置不能与自身进行交换</h4>
<p>数组同一位数进行异或操作来交换会使得该位置的值为0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ChangeTwoNum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XORCareful</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">123456</span>;</span><br><span class="line">        a[<span class="number">0</span>] = a[<span class="number">0</span>] ^ a[<span class="number">0</span>];</span><br><span class="line">        a[<span class="number">0</span>] = a[<span class="number">0</span>] ^ a[<span class="number">0</span>];</span><br><span class="line">        a[<span class="number">0</span>] = a[<span class="number">0</span>] ^ a[<span class="number">0</span>];</span><br><span class="line">        System.out.println(a[<span class="number">0</span>]); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210226120044577.png" alt="image-20210226120044577"></p>
<p>这是因为在进行<code>a[0] = a[0] ^ a[0];</code>表达式运算时，由于<code>a[0]</code>已经被赋值为0了，接下来无论怎么操纵，都是在<code>0</code>上操作，结果还是为0</p>
<h2 id="加减交换法"><a class="header-anchor" href="#加减交换法"> </a>加减交换法</h2>
<p>交换代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">num1 = num1 + num2;</span><br><span class="line">num2 = num1 - num2;</span><br><span class="line">num1 = num1 - num2;</span><br></pre></td></tr></table></figure>
<p>可以将第二行展开：<code>num2 = num1 + num2 - num2</code>即<code>num2 = num1</code></p>
<p>将第三行展开：<code>num1 = num1 + num2 - num1</code>即<code>num1 = num2</code></p>
<h3 id="测试-v6"><a class="header-anchor" href="#测试-v6"> </a>测试</h3>
<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ChangeTwoNum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChangeNumPlusMinus</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 加减交换法</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1000000000L</span>;</span><br><span class="line">        <span class="type">int</span> num1,num2;</span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            num1 = random.nextInt();</span><br><span class="line">            num2 = random.nextInt();</span><br><span class="line">            num1 = num1 + num2;</span><br><span class="line">            num2 = num1 - num2;</span><br><span class="line">            num1 = num1 - num2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> end - begin;</span><br><span class="line">        System.out.println(<span class="string">&quot;加减交换-随机数值-总耗时&quot;</span> + res + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"><span class="comment">//----------------------------------------------------------------------</span></span><br><span class="line">        num1 = <span class="number">1234567</span>;</span><br><span class="line">        num2 = <span class="number">7654321</span>;</span><br><span class="line">        begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            num1 = num1 + num2;</span><br><span class="line">            num2 = num1 - num2;</span><br><span class="line">            num1 = num1 - num2;</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        res = end - begin;</span><br><span class="line">        System.out.println(<span class="string">&quot;加减交换-固定数值-总耗时&quot;</span> + res + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<h3 id="注意情况-v2"><a class="header-anchor" href="#注意情况-v2"> </a>注意情况</h3>
<p>两数相加有可能会超过int最大值，因此要注意</p>
<p>同时除数不能为0</p>
<h2 id="乘除交换法"><a class="header-anchor" href="#乘除交换法"> </a>乘除交换法</h2>
<p>交换代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">num1 = num1 * num2;</span><br><span class="line">num2 = num1 / num2;</span><br><span class="line">num1 = num1 / num2;</span><br></pre></td></tr></table></figure>
<p>跟加减交换法一样，将其展开可以看到结果</p>
<p><code>num2 = num1 * num2 / num2</code></p>
<p><code>num1 = num1 * num2 / num1</code></p>
<h3 id="测试-v7"><a class="header-anchor" href="#测试-v7"> </a>测试</h3>
<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ChangeTwoNum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChangeNumMultiDivide</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 乘除交换法</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1000000000L</span>;</span><br><span class="line">        <span class="type">int</span> num1,num2;</span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            num1 = random.nextInt();</span><br><span class="line">            num2 = random.nextInt();</span><br><span class="line">            num1 = num1 * num2;</span><br><span class="line">            num2 = num1 / num2;</span><br><span class="line">            num1 = num1 / num2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> end - begin;</span><br><span class="line">        System.out.println(<span class="string">&quot;乘除交换-随机数值-总耗时&quot;</span> + res + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"><span class="comment">//----------------------------------------------------------------------</span></span><br><span class="line">        num1 = <span class="number">1234567</span>;</span><br><span class="line">        num2 = <span class="number">7654321</span>;</span><br><span class="line">        begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            num1 = num1 * num2;</span><br><span class="line">            num2 = num1 / num2;</span><br><span class="line">            num1 = num1 / num2;</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        res = end - begin;</span><br><span class="line">        System.out.println(<span class="string">&quot;乘除交换-固定数值-总耗时&quot;</span> + res + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="注意-v2"><a class="header-anchor" href="#注意-v2"> </a>注意</h3>
<p>在乘法的时候，也需要注意乘法运算后，结果超过int所能表达的最大值</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode—链表</title>
    <url>/2020/11/01/leetcode%E2%80%94%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="leetcode——链表TAG"><a class="header-anchor" href="#leetcode——链表TAG"> </a>leetcode——链表TAG</h1>
<!-- more -->
<p><a href="https://leetcode-cn.com/tag/linked-list/">来源leetcode链表专题</a></p>
<blockquote>
<p>一杯茶，一包烟，一道链表做一天</p>
</blockquote>
<h2 id="leetcode21——合并两个有序链表"><a class="header-anchor" href="#leetcode21——合并两个有序链表"> </a>leetcode21——合并两个有序链表</h2>
<h3 id="题目-v71"><a class="header-anchor" href="#题目-v71"> </a>题目</h3>
<pre><code>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
</code></pre>
<h3 id="示例"><a class="header-anchor" href="#示例"> </a>示例</h3>
<blockquote>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</p>
</blockquote>
<blockquote>
<p>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
</blockquote>
<hr>
<h3 id="C-代码"><a class="header-anchor" href="#C-代码"> </a>C++代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//迭代的方式</span></span><br><span class="line">        <span class="comment">//哨兵结点，方便结果返回</span></span><br><span class="line">        ListNode *prehead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *cur = prehead;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span> &amp;&amp; l2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                <span class="comment">//l1值小，可以插入新表</span></span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cur-&gt;next = l1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prehead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="解题感悟"><a class="header-anchor" href="#解题感悟"> </a>解题感悟</h3>
<ol>
<li>这题使用了一个哨兵结点<code>prehead</code>记录链表头，便于最后返回合并后的链表。但是<strong>注意</strong>：开始第一次的时候，prehead不应该储存记录，即不能这样<code>cur = l1</code>，因为会把<code>preahead</code>指向的链表头给覆盖，导致丢掉。因此应该在<code>cur-&gt;next = l1</code>进行赋值。</li>
<li>由于两个链表都是有序的，因此当一个链表为空的时候，另外一个链表也是有序的，只需要将它接在合并后的链表末尾就可以了。</li>
</ol>
<hr>
<h2 id="leetcode83——删除排序链表中的重复元素"><a class="header-anchor" href="#leetcode83——删除排序链表中的重复元素"> </a>leetcode83——删除排序链表中的重复元素</h2>
<h3 id="题目-v72"><a class="header-anchor" href="#题目-v72"> </a>题目</h3>
<p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<h3 id="示例1"><a class="header-anchor" href="#示例1"> </a>示例1</h3>
<blockquote>
<p>输入: 1-&gt;1-&gt;2</p>
</blockquote>
<blockquote>
<p>输出: 1-&gt;2</p>
</blockquote>
<h3 id="示例2"><a class="header-anchor" href="#示例2"> </a>示例2</h3>
<blockquote>
<p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3</p>
</blockquote>
<blockquote>
<p>输出: 1-&gt;2-&gt;3</p>
</blockquote>
<h3 id="C-代码-v2"><a class="header-anchor" href="#C-代码-v2"> </a>C++代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断下一个结点与当前结点储存的值是否相等</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* nextNode = head-&gt;next;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nextNode != <span class="literal">nullptr</span> &amp;&amp; nextNode-&gt;val == cur-&gt;val)&#123;</span><br><span class="line">                nextNode = nextNode-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur-&gt;next = nextNode;  </span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题感悟-v2"><a class="header-anchor" href="#解题感悟-v2"> </a>解题感悟</h3>
<ol>
<li>这种要遍历整个链表并且返回整个链表的题目，应该先声明一个指针，例如<code>cur</code>指向该链表头，再进行遍历。在最后的结果就可以直接返回<code>head</code>。</li>
</ol>
<hr>
<h2 id="leetcode141——环形链表"><a class="header-anchor" href="#leetcode141——环形链表"> </a>leetcode141——环形链表</h2>
<h3 id="题目-v73"><a class="header-anchor" href="#题目-v73"> </a>题目</h3>
<p>给定一个链表，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
<p></p>
<p>进阶：</p>
<p>你能用 O(1)（即，常量）内存解决此问题吗？</p>
<h3 id="示例1-v2"><a class="header-anchor" href="#示例1-v2"> </a>示例1</h3>
<p><img src="http://algorithm-image.qibinaoe.top/%E7%A4%BA%E4%BE%8B1.png" alt="示例图1"></p>
<blockquote>
<p>输入：head = [3,2,0,-4], pos = 1</p>
</blockquote>
<blockquote>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>解释：链表中有一个环，其尾部连接到第二个节点。</p>
</blockquote>
<h3 id="示例2-v2"><a class="header-anchor" href="#示例2-v2"> </a>示例2</h3>
<p><img src="http://algorithm-image.qibinaoe.top/%E7%A4%BA%E4%BE%8B2.png" alt="示例图2"></p>
<blockquote>
<p>输入：head = [1,2], pos = 0</p>
</blockquote>
<blockquote>
<p>输出：true</p>
</blockquote>
<blockquote>
<p>解释：链表中有一个环，其尾部连接到第一个节点。</p>
</blockquote>
<h3 id="示例3"><a class="header-anchor" href="#示例3"> </a>示例3</h3>
<p><img src="http://algorithm-image.qibinaoe.top/%E7%A4%BA%E4%BE%8B3.png" alt="示例图3"></p>
<blockquote>
<p>输入：head = [1], pos = -1</p>
</blockquote>
<blockquote>
<p>输出：false</p>
</blockquote>
<blockquote>
<p>解释：链表中没有环。</p>
</blockquote>
<p>解释：链表中没有环。</p>
<p>提示：</p>
<ul>
<li>链表中节点的数目范围是 [0, 10<sup>4</sup>]</li>
<li>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></li>
<li>pos 为 -1 或者链表中的一个 有效索引.</li>
</ul>
<h3 id="解法一"><a class="header-anchor" href="#解法一"> </a>解法一</h3>
<p>时间复杂度O(n)，空间复杂度O(n)</p>
<p>通过集合set可以很容易判断set中是否已经存在某个元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode*&gt; seen;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(seen.<span class="built_in">count</span>(head))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                seen.<span class="built_in">insert</span>(head);</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解法二"><a class="header-anchor" href="#解法二"> </a>解法二</h3>
<h4 id="Floyd-判圈算法-Floyd-cycle-detection"><a class="header-anchor" href="#Floyd-判圈算法-Floyd-cycle-detection"> </a>Floyd 判圈算法(Floyd cycle detection)</h4>
<p>Floyd判圈算法又称龟兔赛跑算法</p>
<p>对于一个有环链表，floyd判圈算法能做到三件事</p>
<ul>
<li>判断链表是否有环</li>
<li>计算环的长度</li>
<li>寻找环的起点</li>
</ul>
<ol>
<li>
<p>判断链表是否有环</p>
<p>假设有两个指针它们移动速度不同。一个指针每一次走两步，称为快指针fast(也叫兔子hare)。另一个指针每一次走一步，称为慢指针slow(也叫乌龟tortoise)。它们同时从起点出发，会发生两种情况。</p>
<ul>
<li>快指针fast到达了链表的尾部，这说明该链表没有环</li>
<li>快指针fast和慢指针slow相遇，说明链表存在环</li>
</ul>
<p>当链表存在环的时候，fast走过的路程比slow走的路程，多走了k个环的长度,即kC。其中C为环的长度</p>
</li>
</ol>
<h4 id="代码实现"><a class="header-anchor" href="#代码实现"> </a>代码实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//同时在跑道开头 </span></span><br><span class="line">	ListNode* fast = head;</span><br><span class="line">	ListNode* slow = head;</span><br><span class="line">	<span class="keyword">while</span>(fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">		fast = fast-&gt;next-&gt;next;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		<span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">			<span class="comment">//相遇</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>计算环的长度</p>
<p>由于快指针和慢指针相遇的地方一定是环中的某一点，这时候快指针停下来，让慢指针继续走。当快慢指针再次相遇的时候，慢指针所走过的步长即为环的长度。</p>
</li>
</ol>
<h4 id="代码实现-v2"><a class="header-anchor" href="#代码实现-v2"> </a>代码实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cycleLength</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* fast = head;</span><br><span class="line">	ListNode* slow = head;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">		fast = fast-&gt;next-&gt;next;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		<span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">			<span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">do</span>&#123;</span><br><span class="line">				slow = slow-&gt;next;</span><br><span class="line">				length++;</span><br><span class="line">			&#125;<span class="keyword">while</span>(fast != slow);</span><br><span class="line">			<span class="keyword">return</span> length;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/floyd_route.jpg" alt="floyd_route.jpg"></p>
<ol>
<li>
<p>环的起点<br>
注意，快指针每次走2步，慢指针每次走1步，因此当它们相遇的时候，快指针走的路程是慢指针的两倍。不妨设慢指针走的路程为S<sub>1</sub>,则快指针走的路程为2*S<sub>1</sub>。因此可以推导如下公式,k<sub>1</sub>为慢指针走的圈数，k<sub>2</sub>为快指针走的圈数</p>
<p>S<sub>1</sub> = d<sub>1</sub>+d<sub>2</sub>+k<sub>1</sub>*C</p>
<p>2*S<sub>1</sub> = d<sub>1</sub>+d<sub>2</sub>+k<sub>2</sub>*C</p>
<p>所以</p>
<p>S<sub>1</sub> = (k<sub>2</sub>-k<sub>1</sub>)*C =  d<sub>1</sub>+d<sub>2</sub>+k<sub>1</sub>*C</p>
<p>可以推出</p>
<p>d<sub>1</sub>+d<sub>2</sub> = (k<sub>2</sub>-2*k<sub>1</sub>)*C 该公式说明d<sub>1</sub>+d<sub>2</sub>为圈的整数倍</p>
<p>这里不妨让快指针在相遇后回到起点，慢指针留在原地M，然后步长为1同时开始移动。那么当快指针走了d<sub>1</sub>来到P(环的起点)的时候，慢指针走的路程也为d<sub>1</sub>，又我们前面知道d<sub>1</sub>+d<sub>2</sub>为圈的整数倍，而慢指针开始在M点，相当于已经走了d<sub>2</sub>,这时候再走d<sub>1</sub>长度，加起来圈的整数倍。即环的起点。</p>
<p><strong>这里有点绕，困了我很久</strong>，我们可以这么理解，当快指针和慢指针在M相遇的时候，我们把慢指针放在圈的起点P，快指针放在整个道路的起点S。这时让慢指针先走了d<sub>2</sub>的长度时，快指针才开始移动，移动的速度和慢指针一样都是1步，那么当快指针走到P点的时候，慢指针对于圈的起点P走了d<sub>1</sub>+d<sub>2</sub>的长度，为圈的整数倍，即又回到圈的起点</p>
</li>
</ol>
<h4 id="代码实现-v3"><a class="header-anchor" href="#代码实现-v3"> </a>代码实现</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ListNode* findCircleHead(ListNode* head)</span><br><span class="line">&#123;</span><br><span class="line">	if(head == nullptr || head-&gt;next == nullptr)&#123;</span><br><span class="line">		return nullptr;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* fast = head;</span><br><span class="line">	ListNode* slow = head;</span><br><span class="line">	</span><br><span class="line">	while(fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr)&#123;</span><br><span class="line">		fast = fast-&gt;next-&gt;next;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		if(fast == slow)&#123;</span><br><span class="line">			fast = head;</span><br><span class="line">			while(fast != slow)&#123;</span><br><span class="line">				fast = fast-&gt;next;</span><br><span class="line">				slow = slow-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			return slow;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过快慢指针的方法，时间复杂度为O(N),空间复杂度为O(1)</p>
<h4 id="解法三"><a class="header-anchor" href="#解法三"> </a>解法三</h4>
<p>逐个删除法，即遍历过的结点让其next指向自己。如果遇到一个结点其结点已经指向自己了，说明其存在环</p>
<h4 id="实现代码"><a class="header-anchor" href="#实现代码"> </a>实现代码</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//逐个删除法</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* prev;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;next == head)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = head;</span><br><span class="line">            <span class="comment">//删除该结点</span></span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            prev-&gt;next = prev;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="leetcode160——相交链表"><a class="header-anchor" href="#leetcode160——相交链表"> </a>leetcode160——相交链表</h2>
<h3 id="题目-v74"><a class="header-anchor" href="#题目-v74"> </a>题目</h3>
<h4 id="示例1-v3"><a class="header-anchor" href="#示例1-v3"> </a>示例1</h4>
<blockquote>
<p>编写一个程序，找到两个单链表相交的起始节点。<br>
如下面的两个链表：</p>
</blockquote>
<p><img src="http://algorithm-image.qibinaoe.top/160_%E7%A4%BA%E4%BE%8B1.png" alt="160_示例1.png"></p>
<blockquote>
<p>在节点 c1 开始相交。</p>
</blockquote>
<h4 id="示例2-v3"><a class="header-anchor" href="#示例2-v3"> </a>示例2</h4>
<p><img src="http://algorithm-image.qibinaoe.top/160_%E7%A4%BA%E4%BE%8B2.png" alt="160_示例2.png"></p>
<blockquote>
<p>不相交，返回<code>null</code></p>
</blockquote>
<h4 id="注意："><a class="header-anchor" href="#注意："> </a>注意：</h4>
<ul>
<li>如果两个链表没有交点，返回 null.</li>
<li>在返回结果后，两个链表仍须保持原有的结构。</li>
<li>可假定整个链表结构中没有循环。</li>
<li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li>
</ul>
<h3 id="解法一-v2"><a class="header-anchor" href="#解法一-v2"> </a>解法一</h3>
<p>通过集合set，两个链表同时向后移动，每移动一个结点就放入set中，如果要放入的结点已经存在，则该结点为相交点，当两个链表都遍历完后，仍没有重复结点，则不相交</p>
<p>空间复杂度O(N+M)  时间复杂度O(N)或O(M)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        set&lt;ListNode*&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="literal">nullptr</span> || headB == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(headA||headB)&#123;</span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span>(headA)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.<span class="built_in">count</span>(headA))&#123;</span><br><span class="line">                    <span class="keyword">return</span> headA;</span><br><span class="line">                &#125;</span><br><span class="line">                s.<span class="built_in">insert</span>(headA);</span><br><span class="line">                headA = headA-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(headB)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.<span class="built_in">count</span>(headB))&#123;</span><br><span class="line">                    <span class="keyword">return</span> headB;</span><br><span class="line">                &#125;</span><br><span class="line">                s.<span class="built_in">insert</span>(headB);</span><br><span class="line">                headB = headB-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解法二-v2"><a class="header-anchor" href="#解法二-v2"> </a>解法二</h3>
<p>双指针法，双指针的根本原理就是消除两个链表的长度差。然后同时判断指向的结点是否同一个。</p>
<p>基本做法就声明两个指针<em>p</em>A和<em>p</em>B，让它们分别指向链表A和链表B，然后同时移动，当一个指针例如<em>p</em>A遍历完链表A后，将它指向链表B并继续前进遍历。当<em>p</em>B遍历完链表B后，将它指向链表A并继续遍历。这样做，当<em>p</em>A和<em>p</em>B都遍历了两条链都遍历了链表A和链表B不同的部分，和一遍相同的部分，然后回同时达到相同的部分(如果存在相交)。如果指针遍历完第二次链表完都没有相同结点，则不相交</p>
<p>时间复杂度O(M+N)  空间复杂度O(1)</p>
<h3 id="代码实现-v4"><a class="header-anchor" href="#代码实现-v4"> </a>代码实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="literal">nullptr</span> || headB == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* pA = headA;</span><br><span class="line">        ListNode* pB = headB;</span><br><span class="line">        <span class="keyword">while</span>(pA != <span class="literal">nullptr</span> || pB != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pA == pB)&#123;</span><br><span class="line">                <span class="keyword">return</span> pA;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pA == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                pA = headB;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pA = pA-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pB == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                pB = headA;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pB = pB-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="代码说明"><a class="header-anchor" href="#代码说明"> </a>代码说明</h4>
<p><code> while(pA != nullptr || pB != nullptr)</code>.如果链表A和链表B等长度并且有交点，那么第一次遍历的时候就会相交，如果不相交，则两个指针同时为空。</p>
<hr>
<h2 id="leetcode203——移除链表元素"><a class="header-anchor" href="#leetcode203——移除链表元素"> </a>leetcode203——移除链表元素</h2>
<h3 id="题目-v75"><a class="header-anchor" href="#题目-v75"> </a>题目</h3>
<p>删除链表中等于给定值 val 的所有节点。</p>
<h3 id="示例-v2"><a class="header-anchor" href="#示例-v2"> </a>示例</h3>
<blockquote>
<p>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6</p>
<p>输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
</blockquote>
<h3 id="解题思路-v58"><a class="header-anchor" href="#解题思路-v58"> </a>解题思路</h3>
<p>对于该题，如果只是删除链表中间的结点，是十分简单，只需要将<code>prev-&gt;next = cur-&gt;next</code>即可</p>
<p>但是由于该链表没有特殊的头结点，因此删除头结点会显得异常麻烦，因此这里可以引入哨兵结点的方法去解决该问题，既然题目没有特殊头结点，那我们自己给它生成一个就可以了。</p>
<p>我自己做的时候不懂哨兵结点的方法，所以我采用的方法是首先对链表的头结点进行&quot;特殊对待&quot;,一直遍历头结点，直到它为空或者不需要删除位置。</p>
<h3 id="实现代码1"><a class="header-anchor" href="#实现代码1"> </a>实现代码1</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//确保头结点不是要删除的结点</span></span><br><span class="line">        <span class="keyword">while</span>(head &amp;&amp; head-&gt;val == val)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* prev = head;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val == val)&#123;</span><br><span class="line">                prev-&gt;next = cur-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prev = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="哨兵结点做法"><a class="header-anchor" href="#哨兵结点做法"> </a>哨兵结点做法</h4>
<blockquote>
<p>哨兵节点广泛应用于树和链表中，如伪头、伪尾、标记等，它们是纯功能的，通常不保存任何数据，其主要目的是使链表标准化，如使链表永不为空、永不无头、简化插入和删除。  –<a href="https://leetcode-cn.com/problems/remove-linked-list-elements/solution/yi-chu-lian-biao-yuan-su-by-leetcode/">leetcode官方解法</a></p>
</blockquote>
<p>这里我们可以初始化一个哨兵结点，让哨兵结点的<code>next</code>指向<code>head</code></p>
<h3 id="实现代码2"><a class="header-anchor" href="#实现代码2"> </a>实现代码2</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* sentinel = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        sentinel-&gt;next = head;</span><br><span class="line">        ListNode* prev = sentinel;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* toDelete = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val == val)&#123;</span><br><span class="line">                prev-&gt;next = cur-&gt;next;</span><br><span class="line">                toDelete = cur;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prev = prev-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(toDelete)&#123;</span><br><span class="line">                <span class="keyword">delete</span> toDelete;</span><br><span class="line">                toDelete = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* res = sentinel-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> sentinel;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="leetcode206——反转链表"><a class="header-anchor" href="#leetcode206——反转链表"> </a>leetcode206——反转链表</h2>
<h3 id="题目-v76"><a class="header-anchor" href="#题目-v76"> </a>题目</h3>
<p>反转一个单链表。</p>
<p>示例:</p>
<blockquote>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
</blockquote>
<h3 id="解题思路-v59"><a class="header-anchor" href="#解题思路-v59"> </a>解题思路</h3>
<p>对于迭代的方法，主要需要考虑在将当前结点指向前一个节点时，需要保存下一个结点。</p>
<p>对于递归实现的代码，主要思路是依次改变当前结点的下一个结点指向当前指针</p>
<h3 id="迭代实现代码"><a class="header-anchor" href="#迭代实现代码"> </a>迭代实现代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        ListNode* temp;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            temp = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = pre;</span><br><span class="line">            pre = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="递归实现代码——效率低下版"><a class="header-anchor" href="#递归实现代码——效率低下版"> </a>递归实现代码——效率低下版</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* cur = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        ListNode* temp = cur;</span><br><span class="line">        <span class="keyword">while</span>(temp-&gt;next !=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="递归实现代码——改进版"><a class="header-anchor" href="#递归实现代码——改进版"> </a>递归实现代码——改进版</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* p = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="leetcode234——回文链表"><a class="header-anchor" href="#leetcode234——回文链表"> </a>leetcode234——回文链表</h2>
<h3 id="题目-v77"><a class="header-anchor" href="#题目-v77"> </a>题目</h3>
<p>请判断一个链表是否为回文链表。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: 1-&gt;2<br>
输出: false</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: 1-&gt;2-&gt;2-&gt;1<br>
输出: true</p>
</blockquote>
<h3 id="解题思路-v60"><a class="header-anchor" href="#解题思路-v60"> </a>解题思路</h3>
<p>判断回文的一个思路是两个指针，一头一尾向中间边移动边比较，但是对于链表去正向访问和反向访问都挺麻烦的，有一个办法是将链表遍历一遍，储存到数组中，再进行双指针遍历。这种思路时间复杂度是O(N),空间复杂度也是O(N)</p>
<p>另一种思路是将链表分成两半，这通过快慢指针实现，再将后半部分的链表反转，再两边同时遍历；这样实现的空间复杂度为O(1),时间复杂度为O(N)</p>
<h3 id="双指针解题代码"><a class="header-anchor" href="#双指针解题代码"> </a>双指针解题代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">       vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">       <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">           v.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">           head = head-&gt;next;</span><br><span class="line">           size++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size/<span class="number">2</span>; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(v[i] != v[size<span class="number">-1</span>-i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="快慢指针-反转链表解题代码"><a class="header-anchor" href="#快慢指针-反转链表解题代码"> </a>快慢指针+反转链表解题代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="comment">//先将链表分成两部分</span></span><br><span class="line">       ListNode* endOfFirst = <span class="built_in">endOfFirstPart</span>(head);</span><br><span class="line">       <span class="comment">//将后半部分反转</span></span><br><span class="line">       ListNode* p1 = head;</span><br><span class="line">       ListNode* p2 = <span class="built_in">reverseList</span>(endOfFirst-&gt;next);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//比较回文, p1的长度 &gt;= p2的长度</span></span><br><span class="line">       <span class="keyword">while</span>(p2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(p1-&gt;val != p2-&gt;val)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           p1 = p1-&gt;next;</span><br><span class="line">           p2 = p2-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">endOfFirstPart</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* temp;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            temp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="237-删除链表中的节点"><a class="header-anchor" href="#237-删除链表中的节点"> </a>237. 删除链表中的节点</h2>
<h3 id="题目-v78"><a class="header-anchor" href="#题目-v78"> </a>题目</h3>
<p>请编写一个函数，使其可以删除某个链表中给定的**（非末尾）<strong>节点。传入函数的</strong>唯一参数**为 要被删除的节点。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：head = [4,5,1,9], node = 5<br>
输出：[4,1,9]<br>
解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：head = [4,5,1,9], node = 1<br>
输出：[4,5,9]<br>
解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p>
</blockquote>
<h3 id="解题思路-v61"><a class="header-anchor" href="#解题思路-v61"> </a>解题思路</h3>
<p>常规方法就是修改上一个next为当前结点的下一个结点，但是只传进来的当前结点，此方法行不通。因此可以将后面的结点覆盖到当前结点，这里只需修改当前结点的值和next与下一个结点的next一致就可以了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//由于不知道上一个节点，所以不能简单的取出该结点，因此可以将后面的结点补上</span></span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="876-链表的中间结点"><a class="header-anchor" href="#876-链表的中间结点"> </a>876. 链表的中间结点</h2>
<h3 id="题目-v79"><a class="header-anchor" href="#题目-v79"> </a>题目</h3>
<p>给定一个头结点为 head 的非空单链表，返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<p>输入：[1,2,3,4,5]<br>
输出：3</p>
<p>输入：[1,2,3,4,5,6]<br>
输出：4</p>
<h3 id="解题思路-v62"><a class="header-anchor" href="#解题思路-v62"> </a>解题思路</h3>
<p>这题显然用快慢指针，快指针走到末尾的时候，慢指针到中间位置，但是细节的地方具体是如何处理返回哪个结点需要注意一下</p>
<p>我们开始的时候，快慢指针都指向头指针，即第一个结点。</p>
<p>快指针走的位置为奇数位，即1，3，5，7…</p>
<p>可以通过画图发现，如果链表长度为奇数，那么快指针走到末尾的时候，下一个指针为空，此时慢指针刚好指向中间</p>
<p>如果链表长度为偶数，那么快指针走到末尾时，下一个结点还是存在的，最后一个偶数结点，因此需要<code>fast-&gt;next-&gt;next</code>才为空，而此时，慢指针走的位置其实和奇数链表长度的情况是一致的，但是题目要求返回中间的第二个节点，因此就返回<code>slow-&gt;next</code></p>
<h3 id="解题代码-v53"><a class="header-anchor" href="#解题代码-v53"> </a>解题代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="再次优化"><a class="header-anchor" href="#再次优化"> </a>再次优化</h3>
<p>这里对于快指针的判断，如果改成对当前fast指针和fast-&gt;next的结点两个判不为空进行循环，可以省去上面那种方法的条件判断</p>
<h3 id="代码实现-v5"><a class="header-anchor" href="#代码实现-v5"> </a>代码实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1290-二进制链表转整数"><a class="header-anchor" href="#1290-二进制链表转整数"> </a>1290. 二进制链表转整数</h2>
<h3 id="题目-v80"><a class="header-anchor" href="#题目-v80"> </a>题目</h3>
<p>给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。</p>
<p>请你返回该链表所表示数字的 十进制值 。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：head = [1,0,1]<br>
输出：5<br>
解释：二进制数 (101) 转化为十进制数 (5)</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：head = [0]<br>
输出：0</p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入：head = [1]<br>
输出：1</p>
</blockquote>
<p>示例 4：</p>
<blockquote>
<p>输入：head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]<br>
输出：18880</p>
</blockquote>
<p>示例 5：</p>
<blockquote>
<p>输入：head = [0,0]<br>
输出：0</p>
</blockquote>
<h3 id="解题思路-v63"><a class="header-anchor" href="#解题思路-v63"> </a>解题思路</h3>
<p>这题就是位运算和遍历链表</p>
<h3 id="解题代码-v54"><a class="header-anchor" href="#解题代码-v54"> </a>解题代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDecimalValue</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            result &lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            result+= head-&gt;val;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-06-从尾到头打印链表"><a class="header-anchor" href="#剑指-Offer-06-从尾到头打印链表"> </a>剑指 Offer 06. 从尾到头打印链表</h2>
<h3 id="题目-v81"><a class="header-anchor" href="#题目-v81"> </a>题目</h3>
<p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：head = [1,3,2]<br>
输出：[2,3,1]</p>
</blockquote>
<h3 id="解题思路-v64"><a class="header-anchor" href="#解题思路-v64"> </a>解题思路</h3>
<p>这题它要逆序导入到数组当中去，最先想到用递归的方法；然后又想到用栈的方法（时间复杂度为O(N),空间复杂度为O(N)）；然后又想到先把链表反转过来，时间复杂度需要O(N)，空间复杂度需要O(1)，然后再遍历一遍导入到数组中去，时间复杂度为O(N)，空间复杂度为O(1)</p>
<h3 id="栈实现代码"><a class="header-anchor" href="#栈实现代码"> </a>栈实现代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;s;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(s.<span class="built_in">top</span>());</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="反转链表实现"><a class="header-anchor" href="#反转链表实现"> </a>反转链表实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        head = <span class="built_in">reverseList</span>(head);</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* temp;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            temp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-18-删除链表的节点"><a class="header-anchor" href="#剑指-Offer-18-删除链表的节点"> </a>剑指 Offer 18. 删除链表的节点</h2>
<h3 id="题目-v82"><a class="header-anchor" href="#题目-v82"> </a>题目</h3>
<p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: head = [4,5,1,9], val = 5<br>
输出: [4,1,9]<br>
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: head = [4,5,1,9], val = 1<br>
输出: [4,5,9]<br>
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p>
</blockquote>
<h3 id="解题思路-v65"><a class="header-anchor" href="#解题思路-v65"> </a>解题思路</h3>
<p>这题添加一个头结点，就变成了正常删除链表结点</p>
<h3 id="解题代码-v55"><a class="header-anchor" href="#解题代码-v55"> </a>解题代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode* ahead = prev;</span><br><span class="line">        prev-&gt;next = head;</span><br><span class="line">        <span class="keyword">while</span>(prev-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prev-&gt;next-&gt;val == val)&#123;</span><br><span class="line">                <span class="comment">//删除</span></span><br><span class="line">                prev-&gt;next = prev-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">return</span> ahead-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ahead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-22-链表中倒数第k个节点"><a class="header-anchor" href="#剑指-Offer-22-链表中倒数第k个节点"> </a>剑指 Offer 22. 链表中倒数第k个节点</h2>
<h3 id="题目-v83"><a class="header-anchor" href="#题目-v83"> </a>题目</h3>
<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<blockquote>
<p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.<br>
返回链表 4-&gt;5.</p>
</blockquote>
<h3 id="解题思路-v66"><a class="header-anchor" href="#解题思路-v66"> </a>解题思路</h3>
<p>最直接的想法就是先遍历一遍获得链表的长度，再根据数学关系推出第(n-k)个位所求结点</p>
<p>另一种思路是通过双指针，一个指针先走k个结点，拉开距离k，再同时向前前进1步，当前头的指针到达末尾时，后头的指针到达倒数第k个</p>
<h3 id="遍历法解题代码"><a class="header-anchor" href="#遍历法解题代码"> </a>遍历法解题代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">        ListNode* dum = head;</span><br><span class="line">        <span class="keyword">while</span>(dum != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            size++;</span><br><span class="line">            dum = dum-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> pos = size - k;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        dum = head;</span><br><span class="line">        <span class="keyword">while</span>(count != pos)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            dum = dum-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="双指针做法"><a class="header-anchor" href="#双指针做法"> </a>双指针做法</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* front = head;</span><br><span class="line">        ListNode* back = head;</span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">            front = front-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(front != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            front = front-&gt;next;</span><br><span class="line">            back = back-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> back;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="学习借鉴"><a class="header-anchor" href="#学习借鉴"> </a>学习借鉴</h3>
<p>在看题解的时候，发现有篇归纳链表说得不错,<a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/solution/yi-wen-gao-ding-chang-jian-de-lian-biao-wen-ti-h-3/">链表总结 作者Time-Limit</a></p>
<p>其中有一句话指出了链表的缺点劣势</p>
<blockquote>
<p>无法高效获取长度，无法根据偏移快速访问元素，是链表的两个劣势。</p>
</blockquote>
<blockquote>
<p>双指针并不是固定的公式，而是一种思维方式</p>
</blockquote>
<blockquote>
<p>双指针可解决的问题:<br>
获取倒数第k个元素，获取中间位置的元素，判断链表是否存在环，判断环的长度等和长度与位置有关的问题。</p>
</blockquote>
<p>我觉得这两句话总结不错，故此引用</p>
<h2 id="剑指-Offer-52-两个链表的第一个公共节点"><a class="header-anchor" href="#剑指-Offer-52-两个链表的第一个公共节点"> </a>剑指 Offer 52. 两个链表的第一个公共节点</h2>
<h3 id="题目-v84"><a class="header-anchor" href="#题目-v84"> </a>题目</h3>
<p>该题与 leetcode160——相交链表一样</p>
<h3 id="解题思路-v67"><a class="header-anchor" href="#解题思路-v67"> </a>解题思路</h3>
<p>采用双指针方法，leetcode有人代码写得简洁，因此改写了一下</p>
<h3 id="解题代码-v56"><a class="header-anchor" href="#解题代码-v56"> </a>解题代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* node1 = headA;</span><br><span class="line">        ListNode* node2 = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(node1 != node2)&#123;</span><br><span class="line">            node1 = node1==<span class="literal">nullptr</span>?headB:node1-&gt;next;</span><br><span class="line">            node2 = node2==<span class="literal">nullptr</span>?headA:node2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="面试题-02-01-移除重复节点"><a class="header-anchor" href="#面试题-02-01-移除重复节点"> </a>面试题 02.01. 移除重复节点</h2>
<h3 id="题目-v85"><a class="header-anchor" href="#题目-v85"> </a>题目</h3>
<p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p>
<p>示例1:</p>
<blockquote>
<p>输入：[1, 2, 3, 3, 2, 1]<br>
输出：[1, 2, 3]</p>
</blockquote>
<p>示例2:</p>
<blockquote>
<p>输入：[1, 1, 1, 1, 2]<br>
输出：[1, 2]</p>
</blockquote>
<h3 id="解题思路-v68"><a class="header-anchor" href="#解题思路-v68"> </a>解题思路</h3>
<p>这题可以使用集合(set)来判断是否有重复出现的元素，注意边界条件，这种解法时间复杂度为O(N)，空间复杂度为O(N)</p>
<h3 id="集合解法"><a class="header-anchor" href="#集合解法"> </a>集合解法</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeDuplicateNodes</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        ListNode* prev = head;</span><br><span class="line">        ListNode* cur;</span><br><span class="line">        <span class="keyword">if</span>(head)&#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(head-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(prev != <span class="literal">nullptr</span> &amp;&amp; prev-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cur = prev-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">find</span>(cur-&gt;val) == s.<span class="built_in">end</span>())&#123;</span><br><span class="line">                s.<span class="built_in">insert</span>(cur-&gt;val);</span><br><span class="line">                prev = prev-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prev-&gt;next = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="面试题-02-02-返回倒数第-k-个节点"><a class="header-anchor" href="#面试题-02-02-返回倒数第-k-个节点"> </a>面试题 02.02. 返回倒数第 k 个节点</h2>
<h3 id="题目-v86"><a class="header-anchor" href="#题目-v86"> </a>题目</h3>
<p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</p>
<p>注意：本题相对原题稍作改动</p>
<p>示例：</p>
<blockquote>
<p>输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k = 2<br>
输出： 4</p>
</blockquote>
<p>说明：<br>
给定的 k 保证是有效的。</p>
<h3 id="解题思路-v69"><a class="header-anchor" href="#解题思路-v69"> </a>解题思路</h3>
<p>同剑指 Offer 22. 链表中倒数第k个节点</p>
<h3 id="解题代码-v57"><a class="header-anchor" href="#解题代码-v57"> </a>解题代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthToLast</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* front = head;</span><br><span class="line">        ListNode* back = head;</span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">            front = front-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(front != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            back = back-&gt;next;</span><br><span class="line">            front = front-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> back-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="面试题-02-03-删除中间节点"><a class="header-anchor" href="#面试题-02-03-删除中间节点"> </a>面试题 02.03. 删除中间节点</h2>
<h3 id="题目-v87"><a class="header-anchor" href="#题目-v87"> </a>题目</h3>
<p>实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。</p>
<p>示例：</p>
<blockquote>
<p>输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c<br>
结果：不返回任何数据，但该链表变为a-&gt;b-&gt;d-&gt;e-&gt;f</p>
</blockquote>
<h3 id="解题思路-v70"><a class="header-anchor" href="#解题思路-v70"> </a>解题思路</h3>
<p>同237. 删除链表中的节点</p>
<h2 id="面试题-02-06-回文链表"><a class="header-anchor" href="#面试题-02-06-回文链表"> </a>面试题 02.06. 回文链表</h2>
<h3 id="解题思路-v71"><a class="header-anchor" href="#解题思路-v71"> </a>解题思路</h3>
<p>同 leetcode234——回文链表</p>
<h3 id="快慢指针寻找中间节点学习总结"><a class="header-anchor" href="#快慢指针寻找中间节点学习总结"> </a>快慢指针寻找中间节点学习总结</h3>
<p>在不同的题目中，我发现通过快慢指针来寻找一个链表的中间结点位置。初始情况是相同的，即快慢指针都指向头结点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ListNode* fast = head;</span><br><span class="line">ListNode* slow = head;</span><br></pre></td></tr></table></figure>
<p>但是到达慢指针到达中点的位置，随着对于快指针(<code>fast</code>)判断条件不同而不同</p>
<p>例如在leetcode234——回文链表中，通过判断快指针的下一个和下一个的下一个不为空</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    slow = slow-&gt;next;</span><br><span class="line">    fast = fast-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在876. 链表的中间结点中，通过判断快指针本身和快指针下一个不为空来确定中间位置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    fast = fast-&gt;next-&gt;next;</span><br><span class="line">    slow = slow-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两种判断条件最终导致慢指针的位置有什么不同呢？</p>
<p>通过画个图发现</p>
<p><a href="%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8.jpg">快慢指针奇偶链表</a></p>
<p>两种方法对于链表长度为奇数的时候，慢指针都指向中间结点位置</p>
<p>而对于链表长度为偶数时候，慢指针位置不同。这是由于偶数长度时候，中间结点有两个。</p>
<p>因此可以这样记，由于<code>fast != nullptr &amp;&amp; fast-&gt;next != nullptr</code>条件较弱，所以慢指针可以多走，指向靠右边的结点。由于<code>fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr</code>条件较强，因此慢指针少走，所以指向靠左边的位置。</p>
<p>当然，其实两种方法都可以转换，比如876. 链表的中间结点写的两种写法，虽然题目要求是返回靠右的结点，但是我第一次解题的时候，判断条件为<code>fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr</code>，导致慢结点对于奇数和偶数情况不统一。这时候可以通过判断<code>fast</code>对于<code>null</code>的距离来确定是奇数情况还是偶数情况</p>
<p>还存在一种写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(fast-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    fast = fast-&gt;next;</span><br><span class="line">    slow = slow-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(fast-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法又和上面两种有什么区别呢？可以看到<code>fast</code>能走就走，<code>slow</code>也是能走就走。因此可以想到，<code>slow</code>如果在奇数长度链表中，处于中间位置；而在偶数长度链表中，处于中间靠右的位置。这种写法和<code>fast != nullptr &amp;&amp; fast-&gt;next != nullptr</code>的结果区别在于快指针最终的位置。</p>
<p>在分两步while语句中嵌套一个if语句这种方法，能够保证fast在最后指向的是最后一个结点，而不是空。</p>
<p>在while语句中直接把fast的当前位置和下一个位置判断不为空了，但是没有考虑fast将要移动到的那个位置是否为空，因此fast最终是空。</p>
<h2 id="面试题-02-07-链表相交"><a class="header-anchor" href="#面试题-02-07-链表相交"> </a>面试题 02.07. 链表相交</h2>
<h3 id="题目-v88"><a class="header-anchor" href="#题目-v88"> </a>题目</h3>
<p>同leetcode160——相交链表和剑指 Offer 52. 两个链表的第一个公共节点</p>
<hr>
<h2 id="2-两数相加"><a class="header-anchor" href="#2-两数相加"> </a>2. 两数相加</h2>
<h3 id="题目-v89"><a class="header-anchor" href="#题目-v89"> </a>题目</h3>
<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例：</p>
<blockquote>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>
输出：7 -&gt; 0 -&gt; 8<br>
原因：342 + 465 = 807</p>
</blockquote>
<h3 id="解题思路-v72"><a class="header-anchor" href="#解题思路-v72"> </a>解题思路</h3>
<p>开始的时候的思路是分别遍历两遍，读取每个链表的数字，再加起来，然后再生成一条新的链表返回，但是这种做法无论是<code>int</code>还是<code>long long</code>都装不下大数字。</p>
<p>后来想到直接按顺序遍历链表，只需要记录每一位是否进位，同时要注意如果最后有进位但是两个链表都为空的情况需要考虑下去</p>
<h4 id="错误解题"><a class="header-anchor" href="#错误解题"> </a>错误解题</h4>
<p>Line 48: Char 20: runtime error: signed integer overflow: 1000000000000000000 * 10 cannot be represented in type ‘long long’ (solution.cpp)</p>
<p>SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:57:20</p>
<p>最后执行的输入：</p>
<p>[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]</p>
<p>[5,6,4]</p>
<p>可以看到溢出了</p>
<p>错误实现思路代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先依次遍历两个链表取出数字</span></span><br><span class="line">        <span class="comment">//相加后生成新的链表</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> num1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            num1 += (l1-&gt;val) * <span class="built_in">pow</span>(<span class="number">10</span>,count);</span><br><span class="line">            count++;</span><br><span class="line">            l1 = l1-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            num2 += (l2-&gt;val) * <span class="built_in">pow</span>(<span class="number">10</span>,count);</span><br><span class="line">            count++;</span><br><span class="line">            l2 = l2-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> result = num1+num2;</span><br><span class="line">        ListNode* res = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode* cur = res;</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="number">0</span>)&#123;</span><br><span class="line">            res-&gt;val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(result)&#123;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">            cur-&gt;next-&gt;val = result%<span class="number">10</span>;</span><br><span class="line">            result/=<span class="number">10</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">pow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> base, <span class="type">long</span> <span class="type">long</span> index)</span></span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>; i&lt;index; i++)&#123;</span><br><span class="line">            result *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="正确解法"><a class="header-anchor" href="#正确解法"> </a>正确解法</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//边遍历边添加，直到两个都为空</span></span><br><span class="line">        ListNode* res = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode* cur = res;</span><br><span class="line">        <span class="type">int</span> num1,num2;</span><br><span class="line">        <span class="type">bool</span> overflow = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> asum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 || l2)&#123;</span><br><span class="line">            num1 = l1==<span class="literal">nullptr</span>?<span class="number">0</span>:l1-&gt;val;</span><br><span class="line">            num2 = l2==<span class="literal">nullptr</span>?<span class="number">0</span>:l2-&gt;val;</span><br><span class="line">            asum = overflow?num1+num2+<span class="number">1</span>:num1+num2;</span><br><span class="line">            <span class="keyword">if</span>(asum&gt;<span class="number">9</span>)&#123;</span><br><span class="line">                asum %= <span class="number">10</span>;</span><br><span class="line">                overflow = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                overflow = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">            cur-&gt;next-&gt;val = asum;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l1) l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2) l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(overflow)&#123;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">            cur-&gt;next-&gt;val = <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="19-删除链表的倒数第N个节点"><a class="header-anchor" href="#19-删除链表的倒数第N个节点"> </a>19. 删除链表的倒数第N个节点</h2>
<h3 id="题目-v90"><a class="header-anchor" href="#题目-v90"> </a>题目</h3>
<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<p>示例：</p>
<blockquote>
<p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>
当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p>
</blockquote>
<p>说明：</p>
<p>给定的 n 保证是有效的。</p>
<p>进阶：</p>
<p>你能尝试使用一趟扫描实现吗？</p>
<h3 id="解题思路-v73"><a class="header-anchor" href="#解题思路-v73"> </a>解题思路</h3>
<p>这题的做法就是将leetcode203——移除链表元素和剑指 Offer 22. 链表中倒数第k个节点两道题结合在一起，声明一个哨兵节点放在头结点<code>head</code>之前，然后将两个指针拉开距离<code>n</code>，记住最后是返回最初哨兵节点的下一给节点<code>dum-&gt;next</code>，而不是直接返回<code>head</code>.因为如果倒数第n个节点是head话，会出错。因此需要声明一个<code>dum</code>去记录开始定义的哨兵节点的地址</p>
<blockquote>
<p>在对链表进行操作时，一种常用的技巧是添加一个哑节点（dummy node），它的<code>next</code>指针指向链表的头节点。</p>
</blockquote>
<p>在第一种解法时，prevHead的作用和back的作用重复了，如果将prevHead去掉，将back指向dummy节点，可以简化代码</p>
<h3 id="解题代码1-v9"><a class="header-anchor" href="#解题代码1-v9"> </a>解题代码1</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* front = head;</span><br><span class="line">        ListNode* back = head;</span><br><span class="line">        ListNode* prevHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        prevHead-&gt;next = head;</span><br><span class="line">        ListNode* dum = prevHead;</span><br><span class="line">        <span class="comment">//先走n个节点</span></span><br><span class="line">        <span class="keyword">while</span>(n--) front=front-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(front != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            front = front-&gt;next;</span><br><span class="line">            back = back-&gt;next;</span><br><span class="line">            prevHead = prevHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        prevHead-&gt;next = back-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dum-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="优化代码"><a class="header-anchor" href="#优化代码"> </a>优化代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* front = head;</span><br><span class="line">        ListNode* back = dummy;</span><br><span class="line">        <span class="comment">//先走n个节点</span></span><br><span class="line">        <span class="keyword">while</span>(n--) front=front-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(front != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            front = front-&gt;next;</span><br><span class="line">            back = back-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        back-&gt;next = back-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="24-两两交换链表中的节点"><a class="header-anchor" href="#24-两两交换链表中的节点"> </a>24. 两两交换链表中的节点</h2>
<h3 id="题目-v91"><a class="header-anchor" href="#题目-v91"> </a>题目</h3>
<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：head = [1,2,3,4]<br>
输出：[2,1,4,3]</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：head = []<br>
输出：[]</p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入：head = [1]<br>
输出：[1]</p>
</blockquote>
<p>提示：</p>
<p>链表中节点的数目在范围 [0, 100] 内</p>
<p>0 &lt;= Node.val &lt;= 100</p>
<h3 id="解题思路1-v10"><a class="header-anchor" href="#解题思路1-v10"> </a>解题思路1</h3>
<p>仔细观察可以发现，如果有四个节点存在，则在两两交换后，第一个节点指向第四个结点，因此不能只两个两个看，得四个四个看。根据这个发现，进行分类讨论，即有四个结点、剩下三个结点、剩下两个结点的三种情况。</p>
<p>对于有大于四个结点的情况，只需要将第二个结点指向第一个，第一个结点指向第四个，就完成了前两个的交换，然后向后偏移两位。</p>
<p>对于三个结点情况，交换前两个的同时，将第一个结点指向链表末尾，即第三个结点，即可完成操作</p>
<p>对于两个结点情况，只需要交换前两个结点，并将第一个结点指向空结点即可。</p>
<h3 id="解题代码1-v10"><a class="header-anchor" href="#解题代码1-v10"> </a>解题代码1</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next ==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* privot = head-&gt;next;</span><br><span class="line">        ListNode* first = head;</span><br><span class="line">        ListNode* second = head-&gt;next;</span><br><span class="line">        ListNode* third;</span><br><span class="line">        ListNode* fourth;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(second != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(second-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                third = second-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(third != <span class="literal">nullptr</span> &amp;&amp; third-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                fourth = third-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进行交换</span></span><br><span class="line">            <span class="keyword">if</span>(fourth != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                second-&gt;next  = first;</span><br><span class="line">                first-&gt;next = fourth;</span><br><span class="line">                first = third;</span><br><span class="line">                second = fourth;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(third != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                second-&gt;next = first;</span><br><span class="line">                first-&gt;next = third;</span><br><span class="line">                third-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                first = <span class="literal">nullptr</span>;</span><br><span class="line">                second = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                second-&gt;next = first;</span><br><span class="line">                first-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                first = <span class="literal">nullptr</span>;</span><br><span class="line">                second = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            third = <span class="literal">nullptr</span>;</span><br><span class="line">            fourth = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> privot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v24"><a class="header-anchor" href="#解题思路2-v24"> </a>解题思路2</h3>
<p>利用递归的思想，递归返回的都是已经两两反转后的链表头，而基线是传进来的结点是空结点或者是单个节点。同时注意交换结点的位置以及与已经交换好的链表之间连接的关系</p>
<h3 id="解题代码2-v23"><a class="header-anchor" href="#解题代码2-v23"> </a>解题代码2</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next ==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换两个</span></span><br><span class="line">        ListNode* h = <span class="built_in">swapPairs</span>(head-&gt;next-&gt;next);</span><br><span class="line">        ListNode* hnext = head-&gt;next;</span><br><span class="line">        hnext-&gt;next =head;</span><br><span class="line">        head-&gt;next = h;</span><br><span class="line">        <span class="keyword">return</span> hnext;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路3-v5"><a class="header-anchor" href="#解题思路3-v5"> </a>解题思路3</h3>
<p>通过引入一个哑结点(dummy)，初始化<code>dummy-&gt;next = head</code>。然后通过三个结点之间的交换，达到temp-&gt;node1-&gt;node2  ===&gt; temp-&gt;node2-&gt;node1的效果，而下一轮temp就在node1的位置，即node1-&gt;node3-&gt;node4 ==&gt; node1-&gt;node4-&gt;node3 这样一来就保证了两两之间的交换且能保证与下一对能够正确指向。对于最终条件即<code>temp-&gt;next</code>或<code>temp-&gt;next-&gt;next</code>为空时，遍历结束</p>
<h3 id="解题代码3-v9"><a class="header-anchor" href="#解题代码3-v9"> </a>解题代码3</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* temp = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(temp-&gt;next != <span class="literal">nullptr</span> &amp;&amp; temp-&gt;next-&gt;next !=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">//这里的temp不要想象成一个空结点</span></span><br><span class="line">            <span class="comment">//而是要想象成要交换的两个结点的上一个结点</span></span><br><span class="line">            <span class="comment">//然后保证temp结点与两个结点能够正确交换位置</span></span><br><span class="line">            ListNode* node1 = temp-&gt;next;</span><br><span class="line">            ListNode* node2 = temp-&gt;next-&gt;next;</span><br><span class="line">            temp-&gt;next = node2;</span><br><span class="line">            node1-&gt;next = node2-&gt;next;</span><br><span class="line">            node2-&gt;next = node1;</span><br><span class="line">            temp = node1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="61-旋转链表"><a class="header-anchor" href="#61-旋转链表"> </a>61. 旋转链表</h2>
<h3 id="题目-v92"><a class="header-anchor" href="#题目-v92"> </a>题目</h3>
<p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br>
输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>
解释:<br>
向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>
向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4<br>
输出: 2-&gt;0-&gt;1-&gt;NULL<br>
解释:<br>
向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL<br>
向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL<br>
向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL<br>
向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</p>
</blockquote>
<h3 id="解题思路-v74"><a class="header-anchor" href="#解题思路-v74"> </a>解题思路</h3>
<p>一种解法是遍历两遍链表。第一次遍历获得链表长度，已经到达链表末尾的位置，将末尾结点指向头结点，构成环。第二次遍历找到新链表头的前一个结点位置，保存新链表头，并生成新链表尾。</p>
<h3 id="解题代码-v58"><a class="header-anchor" href="#解题代码-v58"> </a>解题代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先遍历一遍，找得到链表尾部，将其接到头部，并计算链表长度</span></span><br><span class="line">        <span class="comment">//要预测下一个，所以基准情况要先排除掉</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">int</span> length = <span class="number">1</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = head;</span><br><span class="line">        <span class="comment">//找出倒数第k的位置，注意k&gt;=length情况</span></span><br><span class="line">        <span class="type">int</span> pos = length - (k % length);</span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(count != pos)&#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* newHead = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="82-删除排序链表中的重复元素-II"><a class="header-anchor" href="#82-删除排序链表中的重复元素-II"> </a>82. 删除排序链表中的重复元素 II</h2>
<h3 id="题目-v93"><a class="header-anchor" href="#题目-v93"> </a>题目</h3>
<p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br>
输出: 1-&gt;2-&gt;5</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: 1-&gt;1-&gt;1-&gt;2-&gt;3<br>
输出: 2-&gt;3</p>
</blockquote>
<h3 id="解题思路-v75"><a class="header-anchor" href="#解题思路-v75"> </a>解题思路</h3>
<p>这题与leetcode83——删除排序链表中的重复元素不同在于，这题删除结点有可能需要删除头结点，因此需要定义一个哑结点方便操作。同时当判断当前结点与下一个结点不同，但是当前结点与之前被删除的结点是相同的情况下，因此需要定义一个变量来判断当前结点是否应该被删除</p>
<h3 id="解题代码-v59"><a class="header-anchor" href="#解题代码-v59"> </a>解题代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        prev-&gt;next =head;</span><br><span class="line">        ListNode* dummy = prev;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="type">bool</span> shouldDelete = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val == cur-&gt;next-&gt;val)&#123;</span><br><span class="line">                shouldDelete = <span class="literal">true</span>;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(shouldDelete)&#123;</span><br><span class="line">                    prev-&gt;next = cur-&gt;next;</span><br><span class="line">                    cur = prev-&gt;next;</span><br><span class="line">                    shouldDelete = <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cur = cur-&gt;next;</span><br><span class="line">                    prev = prev-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(shouldDelete)&#123;</span><br><span class="line">            prev-&gt;next = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="86-分隔链表"><a class="header-anchor" href="#86-分隔链表"> </a>86. 分隔链表</h2>
<h3 id="题目-v94"><a class="header-anchor" href="#题目-v94"> </a>题目</h3>
<p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</p>
<p>你应当保留两个分区中每个节点的初始相对位置。</p>
<p>示例:</p>
<blockquote>
<p>输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>
输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p>
</blockquote>
<h3 id="解题思路1-v11"><a class="header-anchor" href="#解题思路1-v11"> </a>解题思路1</h3>
<p>这题开始没有看懂，后来看了题解才大概明白。这里借用官方题解的图片</p>
<p><a href="%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8%E6%84%8F%E6%80%9D.png">分割链表意思</a></p>
<p>这题的意思就是将链表分成<strong>两部分</strong>(例如图中JOINT点)，第一部分是所有结点都小于<code>x</code>的值，第二部分的所有结点的值都是大于等于<code>x</code>的值。题目不要求整个链表是排序的，也不要求这两部分各自内部是排序的，因此只要将大小关系分开，同时保证原先链表的相对位置就行。</p>
<p>按照这个思路，有一种简单做法就是声明两个链表，一个存放小于<code>x</code>值的，一个存放大于等于<code>x</code>的值，同时遍历原先链表。最终将两个链表拼接起来即可</p>
<h3 id="解题代码1-v11"><a class="header-anchor" href="#解题代码1-v11"> </a>解题代码1</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode* little = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode* bigger = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line"></span><br><span class="line">        ListNode* lnode = little;</span><br><span class="line">        ListNode* bnode = bigger;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val &lt; x)&#123;</span><br><span class="line">                lnode-&gt;next = head;</span><br><span class="line">                lnode = lnode-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                bnode-&gt;next = head;</span><br><span class="line">                bnode = bnode-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        lnode-&gt;next = bigger-&gt;next;</span><br><span class="line">        bnode-&gt;next =<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> little-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v25"><a class="header-anchor" href="#解题思路2-v25"> </a>解题思路2</h3>
<p>如果不用哑结点的话，也可以操作。但是思想一致的，即找到大于等于<code>x</code>的头结点和找到小于<code>x</code>的头结点，并在最后进行拼接操作</p>
<h3 id="解题代码2-v24"><a class="header-anchor" href="#解题代码2-v24"> </a>解题代码2</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不用哑结点做法</span></span><br><span class="line">        ListNode* biggerHead = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* littleHead = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* bnode = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* lnode = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val &lt; x)&#123;</span><br><span class="line">                <span class="keyword">if</span>(littleHead == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    littleHead = head;</span><br><span class="line">                    lnode = littleHead;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    lnode-&gt;next = head;</span><br><span class="line">                    lnode = lnode-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(biggerHead == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    biggerHead = head;</span><br><span class="line">                    bnode = biggerHead;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    bnode-&gt;next = head;</span><br><span class="line">                    bnode = bnode-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拼接</span></span><br><span class="line">        <span class="keyword">if</span>(littleHead== <span class="literal">nullptr</span>) <span class="keyword">return</span> biggerHead;</span><br><span class="line">        <span class="keyword">if</span>(biggerHead == <span class="literal">nullptr</span>) <span class="keyword">return</span> littleHead;</span><br><span class="line">        lnode-&gt;next = biggerHead;</span><br><span class="line">        bnode-&gt;next =<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> littleHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="92-反转链表-II"><a class="header-anchor" href="#92-反转链表-II"> </a>92. 反转链表 II</h2>
<h3 id="题目-v95"><a class="header-anchor" href="#题目-v95"> </a>题目</h3>
<p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>
<p>说明:<br>
1 ≤ m ≤ n ≤ 链表长度。</p>
<p>示例:</p>
<blockquote>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4<br>
输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p>
</blockquote>
<h3 id="解题思路-v76"><a class="header-anchor" href="#解题思路-v76"> </a>解题思路</h3>
<p>这题做题思路是在<em>leetcode206——反转链表</em>中迭代做法的思路上进行修改。同时在看题解的时候也发现有两种不同的解法。另一种迭代思想是<em>24. 两两交换链表</em>中的<em>解题思路3</em>的思想，即四个点为一组，只在这四个点内进行中间的两个交换顺序，不会影响到第一个结点和第四个结点的关系。</p>
<p>同时注意，对于第一种解法，需要记录反转链表之前的最后一个结点，以及反转后的子链表的尾部（即第一个被改变的结点），以便内部反转后，能够与原整条链的相应位置对上</p>
<p>对于第二种解法，与两两交换不同的是，<code>prev</code>位置的改变，因为两两交换，交换一次，跳一个结点，因此<code>prev</code>指向<code>node1</code>，即翻转后的子链表的尾结点；而对于本题，<code>prev</code>不会进行移动，一直位于要反转的子链表的上一个结点，因为在两两交换的过程中，后面一个节点并不是简单的移动到相邻结点的上一个，而是要移动到整个子链表的头部。</p>
<h3 id="解题代码1-v12"><a class="header-anchor" href="#解题代码1-v12"> </a>解题代码1</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* temp;</span><br><span class="line">        ListNode* littleTail;</span><br><span class="line">        ListNode* prevLittleHead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将指针cur移到m的位置</span></span><br><span class="line">        <span class="keyword">while</span>(m&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            m--;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        prevLittleHead = prev;</span><br><span class="line">        littleTail = cur;</span><br><span class="line">        <span class="keyword">while</span>(n--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           temp = cur-&gt;next;</span><br><span class="line">           cur-&gt;next = prev;</span><br><span class="line">           prev = cur;</span><br><span class="line">           cur = temp; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拼接</span></span><br><span class="line">        <span class="comment">//如果m=1，那么prevLittleHead为空</span></span><br><span class="line">        <span class="keyword">if</span>(prevLittleHead != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            prevLittleHead-&gt;next = prev;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head = prev;</span><br><span class="line">        &#125;</span><br><span class="line">        littleTail-&gt;next = cur;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题代码2-v25"><a class="header-anchor" href="#解题代码2-v25"> </a>解题代码2</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* prev = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//要翻转的子链表的开头</span></span><br><span class="line">        ListNode* node1 = prev-&gt;next;</span><br><span class="line">        ListNode* node2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n-m; i++)&#123;</span><br><span class="line">            node2 = node1-&gt;next; </span><br><span class="line">            node1-&gt;next = node2-&gt;next;</span><br><span class="line">            node2-&gt;next = prev-&gt;next;</span><br><span class="line">            prev-&gt;next = node2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="109-有序链表转换二叉搜索树"><a class="header-anchor" href="#109-有序链表转换二叉搜索树"> </a><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a></h2>
<h3 id="题目-v96"><a class="header-anchor" href="#题目-v96"> </a>题目</h3>
<p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<p>示例:</p>
<p>给定的有序链表： [-10, -3, 0, 5, 9],</p>
<p>一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</p>
<pre><code>       0
      / \
    -3   9
   /   /
 -10  5
</code></pre>
<h3 id="解题思路1-v12"><a class="header-anchor" href="#解题思路1-v12"> </a>解题思路1</h3>
<p>这题要求高度平衡二叉树，即左右两个子树高度差不超过1，那么将这个链表中间的位置作为根节点就可以实现这种需求。</p>
<p>对于奇数个结点的链表来说，中间结点为根节点；对于偶数个结点的链表，中间的两个任意一个作为根节点都可以。</p>
<p>根据这个思路，最简单的是利用分治递归的思想，类似二分法的思想去实现这种。由于链表不能像数组一样方便获取某个位置的元素，所以就先遍历一遍链表，保存到数组中去。</p>
<h3 id="解题代码1-v13"><a class="header-anchor" href="#解题代码1-v13"> </a>解题代码1</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将链表转换成数组</span></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            vals.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">generateBST</span>(<span class="number">0</span>,vals.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">generateBST</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//这里左闭右开</span></span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(right - left == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(vals[left]);</span><br><span class="line">        <span class="type">int</span> middle = (left+right)/<span class="number">2</span>;</span><br><span class="line">        TreeNode* t = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(vals[middle]);</span><br><span class="line">        t-&gt;left = <span class="built_in">generateBST</span>(left,middle);</span><br><span class="line">        t-&gt;right = <span class="built_in">generateBST</span>(middle+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v26"><a class="header-anchor" href="#解题思路2-v26"> </a>解题思路2</h3>
<p>在解题思路1中，用到了数组来储存，耗费了空间O(N)，所以我们也可以利用快慢结点来获取中间结点。</p>
<p>其中对于中间结点的获取，我认为<code>while(fast != right &amp;&amp; fast-&gt;next != right)&#123;...&#125;</code>和<code>while(fast-&gt;next != right &amp;&amp; fast-&gt;next-&gt;next != right)&#123;...&#125;</code>都是可以的</p>
<p>空间复杂度为O(logn)，为递归过程中栈的空间。</p>
<p>时间复杂度为O(nlogn)</p>
<h3 id="解题代码2-v26"><a class="header-anchor" href="#解题代码2-v26"> </a>解题代码2</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildTree</span>(head,<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(ListNode* left, ListNode* right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == right) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* mid = <span class="built_in">getMiddle</span>(left,right);</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(mid-&gt;val);</span><br><span class="line">        root-&gt;left = <span class="built_in">buildTree</span>(left,mid);</span><br><span class="line">        root-&gt;right = <span class="built_in">buildTree</span>(mid-&gt;next,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">getMiddle</span><span class="params">(ListNode* left, ListNode* right)</span></span>&#123;</span><br><span class="line">        ListNode* fast = left;</span><br><span class="line">        ListNode* slow = left;</span><br><span class="line">        <span class="keyword">while</span>(fast != right &amp;&amp; fast-&gt;next != right)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="138-复制带随机指针的链表"><a class="header-anchor" href="#138-复制带随机指针的链表"> </a><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">138. 复制带随机指针的链表</a></h2>
<h3 id="题目-v97"><a class="header-anchor" href="#题目-v97"> </a>题目</h3>
<p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p>
<p>要求返回这个链表的 <strong>深拷贝</strong>。</p>
<p>我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p>
<ul>
<li>val：一个表示 Node.val 的整数。</li>
<li>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。</li>
</ul>
<p>示例 1：</p>
<blockquote>
<p>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]<br>
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</p>
<p><img src="http://algorithm-image.qibinaoe.top/e1.png" alt="复制带随机指针的链表示例1"></p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：head = []<br>
输出：[]<br>
解释：给定的链表为空（空指针），因此返回 null。</p>
</blockquote>
<h3 id="解题思路1-v13"><a class="header-anchor" href="#解题思路1-v13"> </a><strong>解题思路</strong>1</h3>
<p>开始思考能不能遍历一次就生成整个完整链表呢？由于可能存在当前遍历的结点的random变量还未创建出来，因而不能指向。所以我想到通过先遍历一遍原链表，同时生成一个新链表。在遍历的同时，通过两个hash表来储存每个结点对应的位置，从而在第二次遍历的时候能够快速的连接上</p>
<h3 id="解题代码1-v14"><a class="header-anchor" href="#解题代码1-v14"> </a>解题代码1</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        map&lt;Node*,<span class="type">int</span>&gt; oldlocations;</span><br><span class="line">        map&lt;<span class="type">int</span>,Node*&gt; newlocations;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        Node* dummy = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>);</span><br><span class="line">        Node* cur1 = head;</span><br><span class="line">        Node* cur2 = dummy;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cur2-&gt;next = <span class="keyword">new</span> <span class="built_in">Node</span>(cur1-&gt;val);</span><br><span class="line">            oldlocations[cur1] = count;</span><br><span class="line">            newlocations[count] = cur2-&gt;next;</span><br><span class="line"></span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">            cur2 = cur2-&gt;next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = head;</span><br><span class="line">        cur2 = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* temp = cur1-&gt;random;</span><br><span class="line">            cur2-&gt;random = temp == <span class="literal">nullptr</span>?cur2-&gt;random = <span class="literal">nullptr</span>:cur2-&gt;random = newlocations[oldlocations[temp]];</span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">            cur2 = cur2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v27"><a class="header-anchor" href="#解题思路2-v27"> </a>解题思路2</h3>
<p>根据官方的题解的方法。回溯算法的思想大致为：能进则进，不进则退。我们可以将这个链表看做是一张图，其中<code>node-&gt;next</code>是一条道路，而<code>node-&gt;random</code>又是另一条道路。我们可以同时对这两条道路进行递归，从而遍历整张图。</p>
<p>在本题中，不进则退的<strong>退</strong>：体现在当前结点是空结点，不能够再前进。而整个函数结束递归的条件即为<code>node-&gt;next</code>是空了，已经走不下去了，<code>node-&gt;random</code>要么为空要么已经走过了不必要再遍历了。</p>
<h3 id="解题代码2-v27"><a class="header-anchor" href="#解题代码2-v27"> </a>解题代码2</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;Node*, Node*&gt; visitedHash;</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//传入参数 : 旧链表上的结点</span></span><br><span class="line">        <span class="comment">//返回参数 : 新链表上对应旧结点位置的点</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果新链表已经存在该点了，直接返回新链表的该点就可以了</span></span><br><span class="line">        <span class="keyword">if</span>(visitedHash.<span class="built_in">find</span>(head) != visitedHash.<span class="built_in">end</span>()) <span class="keyword">return</span> visitedHash[head];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有新链表还没生成该节点</span></span><br><span class="line">        Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(head-&gt;val);</span><br><span class="line">        <span class="comment">//存入哈希表中</span></span><br><span class="line">        visitedHash[head] = newNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为新的结点设置下一个结点和随机结点</span></span><br><span class="line">        newNode-&gt;next = <span class="built_in">copyRandomList</span>(head-&gt;next);</span><br><span class="line">        newNode-&gt;random = <span class="built_in">copyRandomList</span>(head-&gt;random);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回新节点</span></span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="142-环形链表-II"><a class="header-anchor" href="#142-环形链表-II"> </a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h2>
<h3 id="题目-v98"><a class="header-anchor" href="#题目-v98"> </a>题目</h3>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p>
<p>说明：不允许修改给定的链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="http://algorithm-image.qibinaoe.top/circularlinkedlist.png" alt="img"></p>
<blockquote>
<p>输入：head = [3,2,0,-4], pos = 1<br>
输出：返回索引为 1 的链表节点<br>
解释：链表中有一个环，其尾部连接到第二个节点。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<p><img src="http://algorithm-image.qibinaoe.top/circularlinkedlist_test3.png" alt="img"></p>
<blockquote>
<p>输入：head = [1], pos = -1<br>
输出：返回 null<br>
解释：链表中没有环。</p>
</blockquote>
<h3 id="解题思路-v77"><a class="header-anchor" href="#解题思路-v77"> </a>解题思路</h3>
<p>这道题有两种解法，第一种是之前做的采用floyd判断法，通过快慢指针找到相遇点，然后将其中一个指针放在起点，两个指针同时步长为1前进，直到第一次相遇，即为环的入口。详细看上面的leetcode141——环形链表的解题思路</p>
<p>第二种解法即用一个hash表，如果判断当前结点已经存在表中，同时是第一次判断有存在，返回就可以了，时间复杂度为O(N)，空间复杂度为O(N)</p>
<h3 id="解题代码-v60"><a class="header-anchor" href="#解题代码-v60"> </a>解题代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                fast = head;</span><br><span class="line">                <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="143-重排链表"><a class="header-anchor" href="#143-重排链表"> </a><a href="https://leetcode-cn.com/problems/reorder-list/">143. 重排链表</a></h2>
<h3 id="题目-v99"><a class="header-anchor" href="#题目-v99"> </a>题目</h3>
<p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>
将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>示例 1:</p>
<blockquote>
<p>给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</p>
</blockquote>
<h3 id="解题思路-v78"><a class="header-anchor" href="#解题思路-v78"> </a>解题思路</h3>
<p>比较直接的思想就是把链表中所有的结点都存起来，然后通过下标的关系，来到达前面一个、后面一个的遍历关系。同时注意到，在整个循环遍历后，还需要处理一下链表尾部的关系。</p>
<p>在链表长度为奇数的情况下，中间的结点不会被遍历到，所以要自己加上去。</p>
<p>在链表长度为偶数的情况下，虽然每个链表都已经正确的前后前后的关系连上去，但是新生成的链表尾部不是指向空，所以得处理一下。</p>
<p>在方法的开头，已经将链表长度为0和为1的情况排除了，所以<code>front</code>和<code>back</code>都可以在最后处理的时候，保证不为空。</p>
<h3 id="解题代码-v61"><a class="header-anchor" href="#解题代码-v61"> </a>解题代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        vector&lt;ListNode*&gt; v;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* front = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* back = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>()/<span class="number">2</span>; i++)&#123;</span><br><span class="line">            front = v[i];</span><br><span class="line">            <span class="keyword">if</span>(back != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                back-&gt;next = front;</span><br><span class="line">            &#125;</span><br><span class="line">            back = v[v.<span class="built_in">size</span>()-i<span class="number">-1</span>];</span><br><span class="line">            front-&gt;next = back;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理尾部情况</span></span><br><span class="line">        <span class="keyword">if</span>(v.<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            ListNode* middle = v[v.<span class="built_in">size</span>()/<span class="number">2</span>];</span><br><span class="line">            back-&gt;next = middle;</span><br><span class="line">            middle-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            back-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v28"><a class="header-anchor" href="#解题思路2-v28"> </a>解题思路2</h3>
<p>可以把结尾的方法统一一下</p>
<h3 id="解题代码2-v28"><a class="header-anchor" href="#解题代码2-v28"> </a>解题代码2</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> ) <span class="keyword">return</span>;</span><br><span class="line">        vector&lt;ListNode*&gt; v;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = v.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            v[i]-&gt;next = v[j];</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">                <span class="comment">//考虑到偶数长度情况</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            v[j]-&gt;next = v[i];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        v[i]-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路3-v6"><a class="header-anchor" href="#解题思路3-v6"> </a>解题思路3</h3>
<p>由于新生成的链表是一前一后的取，因此我们可以把链表看成两部分，将后半部分的链表反转过来，再同时正向遍历合并起来，即可。这样空间复杂度为O(1)</p>
<h3 id="解题代码3-v10"><a class="header-anchor" href="#解题代码3-v10"> </a>解题代码3</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先找到中间结点</span></span><br><span class="line">        <span class="comment">//再翻转右半部链表</span></span><br><span class="line">        <span class="comment">//两个链表合并</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        ListNode* mid = <span class="built_in">findMiddle</span>(head);</span><br><span class="line">        ListNode* secondHead = <span class="built_in">reverseList</span>(mid-&gt;next);</span><br><span class="line">        mid-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* firstHead = head;</span><br><span class="line">        <span class="built_in">mergeList</span>(firstHead,secondHead);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">findMiddle</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* temp;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            temp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mergeList</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        ListNode* temp1;</span><br><span class="line">        ListNode* temp2;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            temp1 = l1-&gt;next;</span><br><span class="line">            temp2 = l2-&gt;next;</span><br><span class="line">            l1-&gt;next = l2;</span><br><span class="line">            l1 = temp1;</span><br><span class="line">            l2-&gt;next = l1;</span><br><span class="line">            l2 = temp2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="147-对链表进行插入排序"><a class="header-anchor" href="#147-对链表进行插入排序"> </a><a href="https://leetcode-cn.com/problems/insertion-sort-list/">147. 对链表进行插入排序</a></h2>
<h3 id="题目-v100"><a class="header-anchor" href="#题目-v100"> </a>题目</h3>
<p>对链表进行插入排序。</p>
<p>插入排序算法：</p>
<p>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。<br>
每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。<br>
重复直到所有输入数据插入完为止。</p>
<h3 id="解题思路-v79"><a class="header-anchor" href="#解题思路-v79"> </a>解题思路</h3>
<p>由于链表与数组不同，对于已排序的前部分，不能逆序比较，随意从第一个元素开始比较。有注意到可能会操作到头结点，因此要设置一个哑结点来保存头节点的上一个。</p>
<p>对于当前要比较的结点，有两种可能。</p>
<p>第一种是该结点不需要移动，那么只需要已排序的部分向后移动一位即可。</p>
<p>第二种情况是该结点需要插入已排序的中间，那么就从头开始遍历查找。同时注意将已排序的最后一个结点的<code>next</code>要先指向<code>cur-&gt;next</code></p>
<h3 id="解题代码-v62"><a class="header-anchor" href="#解题代码-v62"> </a>解题代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> ) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* prev;</span><br><span class="line">        ListNode* cur = head-&gt;next;</span><br><span class="line">        ListNode* lastSorted = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">//寻找该点的应该的位置</span></span><br><span class="line">            <span class="keyword">if</span>(lastSorted-&gt;val &lt;= cur-&gt;val)&#123;</span><br><span class="line">                <span class="comment">//cur不需要移动</span></span><br><span class="line">                lastSorted = lastSorted-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prev = dummy;</span><br><span class="line">                <span class="keyword">while</span>(prev-&gt;next-&gt;val &lt;= cur-&gt;val)&#123;</span><br><span class="line">                    prev = prev-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                lastSorted-&gt;next = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = prev-&gt;next;</span><br><span class="line">                prev-&gt;next = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = lastSorted-&gt;next;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="148-排序链表"><a class="header-anchor" href="#148-排序链表"> </a><a href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a></h2>
<p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p>
<blockquote>
<p>进阶：<br>
你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p>
</blockquote>
<h3 id="解题思路-v80"><a class="header-anchor" href="#解题思路-v80"> </a>解题思路</h3>
<p>这里借鉴官方题解。</p>
<p>插入排序的时间复杂度为O(N<sup>2</sup>)</p>
<p>时间复杂度为O(nlogn)排序算法有归并排序、推排序和快速排序</p>
<p>其中最适合链表排序的算法是归并排序</p>
<p>实现归并排序有两种思路。第一种是自顶向下的递归实现，在递归调用中使用的栈空间的空间复杂度为O(logn)。第二种是自底向上的实现方式,空间复杂度为O(1)</p>
<h3 id="自顶向下代码实现"><a class="header-anchor" href="#自顶向下代码实现"> </a>自顶向下代码实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sortList</span>(head,<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head, ListNode* tail)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next == tail)&#123;</span><br><span class="line">            head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//寻找中点</span></span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != tail &amp;&amp; fast-&gt;next != tail)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分治</span></span><br><span class="line">        ListNode* mid = slow;</span><br><span class="line">        ListNode* l1 = <span class="built_in">sortList</span>(head,mid);</span><br><span class="line">        ListNode* l2 = <span class="built_in">sortList</span>(mid,tail);</span><br><span class="line">        <span class="comment">//合并</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeList</span>(l1,l2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeList</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt;= l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cur-&gt;next = l1;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cur-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="自底向上代码实现"><a class="header-anchor" href="#自底向上代码实现"> </a>自底向上代码实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//归并排序自底向上</span></span><br><span class="line">        <span class="comment">//先局部有序，1 2 4 8 的顺序</span></span><br><span class="line">        <span class="comment">//局部有序的长度等于或大于链表长度时，即整体有序</span></span><br><span class="line">        <span class="comment">//在某个实现局部有序时</span></span><br><span class="line">        <span class="comment">//需要先找到两条链表，分割出来，同时保留这两条链表后的链表</span></span><br><span class="line">        <span class="comment">//将两条链表合并</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取链表长度</span></span><br><span class="line">        <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">        ListNode* node = head;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> subLength = <span class="number">1</span>; subLength &lt; size;subLength &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            ListNode* prev = dummy;</span><br><span class="line">            ListNode* cur = dummy-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="comment">//获取第一条链  cur的当前的定义是第一条链的最后一个结点</span></span><br><span class="line">                ListNode* head1 = cur;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; subLength &amp;&amp; cur-&gt;next != <span class="literal">nullptr</span>; i++)&#123;</span><br><span class="line">                    cur = cur-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode* head2 = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                cur = head2;</span><br><span class="line">                <span class="comment">// 获取第二条链 cur的当前定义是第二条链的最后一个结点</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; subLength &amp;&amp; cur != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next != <span class="literal">nullptr</span>; i++)&#123;</span><br><span class="line">                    cur = cur-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode* next = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="comment">//判断是否有第二条链</span></span><br><span class="line">                <span class="keyword">if</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    next = cur-&gt;next;</span><br><span class="line">                    cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev-&gt;next = <span class="built_in">mergeList</span>(head1,head2);</span><br><span class="line">                <span class="keyword">while</span>(prev-&gt;next !=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    prev = prev-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeList</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt;= l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cur-&gt;next = l1;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cur-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="328-奇偶链表"><a class="header-anchor" href="#328-奇偶链表"> </a><a href="https://leetcode-cn.com/problems/odd-even-linked-list/">328. 奇偶链表</a></h2>
<h3 id="题目-v101"><a class="header-anchor" href="#题目-v101"> </a>题目</h3>
<p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p>
<p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p>
<blockquote>
<p>示例 1:<br>
输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>
输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</p>
</blockquote>
<blockquote>
<p>示例 2:<br>
输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL<br>
输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</p>
</blockquote>
<p>说明:</p>
<p>应当保持奇数节点和偶数节点的相对顺序。<br>
链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</p>
<h3 id="解题思路-v81"><a class="header-anchor" href="#解题思路-v81"> </a>解题思路</h3>
<p>题目要求时间复杂度为O(N)，空间复杂度O(1)，所以想到的是迭代的方式。一个比较直接的思路就是遍历的同时生成奇数链表和偶数链表，在两个遍历完成后，同时两个链表的结尾都正确设置为空后，将偶数链表接在奇数链表后就可以了。</p>
<h3 id="解题代码-v63"><a class="header-anchor" href="#解题代码-v63"> </a>解题代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* oddHead = head;</span><br><span class="line">        ListNode* evenHead = head-&gt;next;</span><br><span class="line">        ListNode* oddptr = oddHead;</span><br><span class="line">        ListNode* evenptr = evenHead;</span><br><span class="line">        ListNode* node;</span><br><span class="line">        <span class="keyword">while</span>(evenptr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            node = evenptr-&gt;next;</span><br><span class="line">            oddptr-&gt;next = node;</span><br><span class="line">            <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">break</span>;</span><br><span class="line">            evenptr-&gt;next = node-&gt;next;</span><br><span class="line">            oddptr = node;</span><br><span class="line">            evenptr = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拼接在一起</span></span><br><span class="line">        oddptr-&gt;next = evenHead;</span><br><span class="line">        <span class="keyword">return</span> oddHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v29"><a class="header-anchor" href="#解题思路2-v29"> </a>解题思路2</h3>
<p>代码还能够进一步变得简洁。可以想到，当遍历到末尾的时候，不要求奇数结点后面指向空，指向最后一个偶数结点也是可以的。因为最后还是需要改变<code>oddptr-&gt;next = evenHead</code></p>
<h3 id="解题代码2-v29"><a class="header-anchor" href="#解题代码2-v29"> </a>解题代码2</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* evenHead = head-&gt;next;</span><br><span class="line">        ListNode* oddptr = head;</span><br><span class="line">        ListNode* evenptr = evenHead;</span><br><span class="line">        <span class="keyword">while</span>(evenptr != <span class="literal">nullptr</span> &amp;&amp; evenptr-&gt;next !=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            oddptr-&gt;next = evenptr-&gt;next;</span><br><span class="line">            oddptr = oddptr-&gt;next;</span><br><span class="line">            evenptr-&gt;next = oddptr-&gt;next;</span><br><span class="line">            evenptr = evenptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拼接在一起</span></span><br><span class="line">        oddptr-&gt;next = evenHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="430-扁平化多级双向链表"><a class="header-anchor" href="#430-扁平化多级双向链表"> </a><a href="https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/">430. 扁平化多级双向链表</a></h2>
<h3 id="题目-v102"><a class="header-anchor" href="#题目-v102"> </a>题目</h3>
<p>多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</p>
<p>给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。</p>
<p><img src="http://algorithm-image.qibinaoe.top/multilevellinkedlist.png" alt="img"></p>
<p><img src="http://algorithm-image.qibinaoe.top/multilevellinkedlistflattened.png" alt="img"></p>
<h3 id="解题思路-v82"><a class="header-anchor" href="#解题思路-v82"> </a>解题思路</h3>
<p>题目的想表达的意思是，这个链表有很多分支，它只想要一条从头贯穿到底的链表。而我们要做的是将每个结点如果有存在child结点，则把它们移动到主链表中去。此时每个结点只有<code>next</code>和<code>prev</code>是有用的。所有的<code>child</code>都要置为空。而按照<code>child</code>紧放在父节点的后面的顺序。</p>
<p>对于如何实现这道题。考虑到这道题有种递归的味道。即一个问题可以分解成多个相同的小问题：一个结点的next需要扁平化(flatten)，它的child也需要扁平化。根据这个思路，去实现递归。而对于递归的baseline显然是当前结点为空。</p>
<h3 id="解题代码-v64"><a class="header-anchor" href="#解题代码-v64"> </a>解题代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        Node* temp = head-&gt;next;</span><br><span class="line">        Node* result = <span class="built_in">flatten</span>(head-&gt;child);</span><br><span class="line">        head-&gt;child = <span class="literal">nullptr</span>;</span><br><span class="line">        Node* result2;</span><br><span class="line">        <span class="keyword">if</span>(result != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            head-&gt;next = result;</span><br><span class="line">            result-&gt;prev= head;</span><br><span class="line">            <span class="keyword">while</span>(result-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                result = result-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            result2 = <span class="built_in">flatten</span>(temp);</span><br><span class="line">            <span class="keyword">if</span>(result2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                result-&gt;next = result2;</span><br><span class="line">                result2-&gt;prev = result;     </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result2 = <span class="built_in">flatten</span>(temp);</span><br><span class="line">            <span class="keyword">if</span>(result2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                head-&gt;next = result2;</span><br><span class="line">                result2-&gt;prev = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v30"><a class="header-anchor" href="#解题思路2-v30"> </a>解题思路2</h3>
<p>参考官方题解</p>
<p>可以将多级双向链表看成一颗二叉树，即左结点为<code>child</code>，右节点为<code>next</code>。而扁平化操作是对这二叉树进行先序遍历（深度优先）。因此存在递归和迭代两种做法。</p>
<p>对于递归思路</p>
<h3 id="递归解题代码"><a class="header-anchor" href="#递归解题代码"> </a>递归解题代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        Node* dummy = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="built_in">flattenDFS</span>(dummy,head);</span><br><span class="line">        Node* result = dummy-&gt;next;</span><br><span class="line">        dummy-&gt;next-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node* <span class="title">flattenDFS</span><span class="params">(Node* prev, Node* cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span> prev;</span><br><span class="line">        <span class="comment">//将上一个结点和当前结点建立关系</span></span><br><span class="line">        <span class="comment">//这里相当于先序遍历中，访问根节点</span></span><br><span class="line">        <span class="comment">//因为我们把根节点加到的主链表上</span></span><br><span class="line">        prev-&gt;next = cur;</span><br><span class="line">        cur-&gt;prev = prev;</span><br><span class="line">        <span class="comment">//保存右节点，因为如果左节点存在，则右节点会丢掉，所以要先存起来</span></span><br><span class="line">        Node* nextTemp = cur-&gt;next;</span><br><span class="line">        <span class="comment">//访问左子结点,这里访问后，会把左子结点加到了主链表上，同时返回了最后一个结点</span></span><br><span class="line">        Node* tail = <span class="built_in">flattenDFS</span>(cur,cur-&gt;child);</span><br><span class="line">        cur-&gt;child = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//访问右子节点，将它加在tail后</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">flattenDFS</span>(tail,nextTemp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路3-v7"><a class="header-anchor" href="#解题思路3-v7"> </a>解题思路3</h3>
<p>通过迭代的方式完成先序遍历，借助栈</p>
<h3 id="解题代码3-v11"><a class="header-anchor" href="#解题代码3-v11"> </a>解题代码3</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        Node* dummy = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        Node* prev = dummy;</span><br><span class="line">        Node* cur;</span><br><span class="line">        stack&lt;Node*&gt; s;</span><br><span class="line">        s.<span class="built_in">push</span>(head);</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            cur = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//当前根节点加入链表中</span></span><br><span class="line">            prev-&gt;next = cur;</span><br><span class="line">            cur-&gt;prev = prev;</span><br><span class="line">            <span class="comment">//将右节点压栈</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                s.<span class="built_in">push</span>(cur-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将左节点压栈</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;child != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                s.<span class="built_in">push</span>(cur-&gt;child);</span><br><span class="line">                cur-&gt;child = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        Node* result = dummy-&gt;next;</span><br><span class="line">        dummy-&gt;next-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路4-v2"><a class="header-anchor" href="#解题思路4-v2"> </a>解题思路4</h3>
<p>最后还有直接迭代的方法。基本思路就是将一个结点的child结点的那一串接在当前结点，和当前结点的下一个结点之间。这样该结点就完成了它的使命，可以进行下一个结点的遍历</p>
<h3 id="解题代码4-v3"><a class="header-anchor" href="#解题代码4-v3"> </a>解题代码4</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        Node* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            Node* nxt = cur-&gt;next; <span class="comment">//保存下一个结点</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;child != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="comment">//将child结点放在主链表中</span></span><br><span class="line">                Node* curChild = cur-&gt;child;</span><br><span class="line">                cur-&gt;child = <span class="literal">nullptr</span>;</span><br><span class="line">                cur-&gt;next = curChild;</span><br><span class="line">                curChild-&gt;prev = cur;</span><br><span class="line">                <span class="comment">//将这一串child链和原来的nxt拼起来</span></span><br><span class="line">                <span class="keyword">while</span>(curChild != <span class="literal">nullptr</span> &amp;&amp; curChild-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    curChild = curChild-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nxt != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    curChild-&gt;next = nxt;</span><br><span class="line">                    nxt-&gt;prev = curChild;            </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="445-两数相加-II"><a class="header-anchor" href="#445-两数相加-II"> </a><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/">445. 两数相加 II</a></h2>
<h3 id="题目-v103"><a class="header-anchor" href="#题目-v103"> </a>题目</h3>
<p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<blockquote>
<p>进阶：<br>
如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p>
</blockquote>
<blockquote>
<p>示例：<br>
输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>
输出：7 -&gt; 8 -&gt; 0 -&gt; 7</p>
</blockquote>
<h3 id="解题思路1-v14"><a class="header-anchor" href="#解题思路1-v14"> </a>解题思路1</h3>
<p>这题可以和“<strong>2. 两数相加</strong>”相比较，其中一种实现思路就是，将两个链表都反转过来然后用“<strong>2. 两数相加</strong>”的方法去相加，注意最后结果还要再返回来一次</p>
<h3 id="解题代码1-v15"><a class="header-anchor" href="#解题代码1-v15"> </a>解题代码1</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        l1 = <span class="built_in">reverseList</span>(l1);</span><br><span class="line">        l2 = <span class="built_in">reverseList</span>(l2);</span><br><span class="line">        <span class="type">bool</span> overflow = <span class="literal">false</span>;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode* prev = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode* curNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">            <span class="type">int</span> value = overflow?l1-&gt;val + l2-&gt;val + <span class="number">1</span> : l1-&gt;val + l2-&gt;val;</span><br><span class="line">            overflow = value&gt;=<span class="number">10</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">            curNode-&gt;val = value%<span class="number">10</span>;</span><br><span class="line">            prev-&gt;next = curNode;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后拼接较长的链，同时注意进位</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            prev-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">            <span class="type">int</span> value = overflow?l1-&gt;val+<span class="number">1</span> : l1-&gt;val;</span><br><span class="line">            overflow = value &gt;= <span class="number">10</span>? <span class="literal">true</span>: <span class="literal">false</span>;</span><br><span class="line">            prev-&gt;next-&gt;val = value % <span class="number">10</span>;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            prev-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">            <span class="type">int</span> value = overflow?l2-&gt;val+<span class="number">1</span> : l2-&gt;val;</span><br><span class="line">            overflow = value &gt;= <span class="number">10</span>? <span class="literal">true</span>: <span class="literal">false</span>;</span><br><span class="line">            prev-&gt;next-&gt;val = value % <span class="number">10</span>;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(overflow)&#123;</span><br><span class="line">            prev-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">            prev-&gt;next-&gt;val = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverseList</span>(dummy-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* temp;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            temp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v31"><a class="header-anchor" href="#解题思路2-v31"> </a>解题思路2</h3>
<p>如果要完成进阶的，不反转链表的方式，可以使用栈的结构就能达到逆序。</p>
<h3 id="解题代码2-v30"><a class="header-anchor" href="#解题代码2-v30"> </a>解题代码2</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            s1.<span class="built_in">push</span>(l1-&gt;val);</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            s2.<span class="built_in">push</span>(l2-&gt;val);</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="type">bool</span> carry = <span class="literal">false</span>;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>() || !s2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!s1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                num1 = s1.<span class="built_in">top</span>();</span><br><span class="line">                s1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num1 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                num2 = s2.<span class="built_in">top</span>();</span><br><span class="line">                s2.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num2 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            value = carry?num1+num2+<span class="number">1</span>:num1+num2;</span><br><span class="line">            carry = value&gt;<span class="number">9</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">            ListNode* newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">            newNode-&gt;val = value%<span class="number">10</span>;</span><br><span class="line">            newNode-&gt;next = dummy-&gt;next;</span><br><span class="line">            dummy-&gt;next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry)&#123;</span><br><span class="line">            ListNode* newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">            newNode-&gt;val = <span class="number">1</span>;</span><br><span class="line">            newNode-&gt;next = dummy-&gt;next;</span><br><span class="line">            dummy-&gt;next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="707-设计链表"><a class="header-anchor" href="#707-设计链表"> </a><a href="https://leetcode-cn.com/problems/design-linked-list/">707. 设计链表</a></h2>
<h3 id="题目-v104"><a class="header-anchor" href="#题目-v104"> </a>题目</h3>
<p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p>
<p>在链表类中实现这些功能：</p>
<p>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。<br>
addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。<br>
addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。<br>
addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。<br>
deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</p>
<blockquote>
<p>示例：<br>
MyLinkedList linkedList = new MyLinkedList();<br>
linkedList.addAtHead(1);<br>
linkedList.addAtTail(3);<br>
linkedList.addAtIndex(1,2);   //链表变为1-&gt; 2-&gt; 3<br>
linkedList.get(1);            //返回2<br>
linkedList.deleteAtIndex(1);  //现在链表是1-&gt; 3<br>
linkedList.get(1);            //返回3</p>
</blockquote>
<h3 id="解题思路-v83"><a class="header-anchor" href="#解题思路-v83"> </a>解题思路</h3>
<p>引用官解一句话</p>
<blockquote>
<p>单链表是最简单的一种，双链表是最常用的一种</p>
</blockquote>
<p>对于双向链表的话，定义一个伪头，定义一个伪尾能够简化操作</p>
<h3 id="单向链表代码"><a class="header-anchor" href="#单向链表代码"> </a>单向链表代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node dummy;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化一个头节点</span></span><br><span class="line">        dummy = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= size || index&lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node cur = dummy;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count != index)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.next.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">addAtIndex</span>(<span class="number">0</span>,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">addAtIndex</span>(<span class="keyword">this</span>.size,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;size) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>) index = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        Node cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(count != index)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(val,cur.next);</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        <span class="keyword">this</span>.size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        Node cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(count != index)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        <span class="keyword">this</span>.size -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> val;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="type">int</span> val, Node next)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>.next = null;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">setVal</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">setNext</span><span class="params">(Node next)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">getVal</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Node <span class="title">getNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双向链表代码"><a class="header-anchor" href="#双向链表代码"> </a>双向链表代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> Node tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//初始化一个头节点</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= size || index&lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span>(index+<span class="number">1</span> &lt; size-index)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;index+<span class="number">1</span>; i++) cur = cur.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = tail;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size-index; i++) cur = cur.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(<span class="number">0</span>,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(<span class="built_in">this</span>.size,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;size) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>) index = <span class="number">0</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span>(index+<span class="number">1</span> &lt; size-index)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;index+<span class="number">1</span>; i++) cur = cur.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = tail;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size-index; i++) cur = cur.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">        cur.prev.next = newNode;</span><br><span class="line">        newNode.prev = cur.prev;</span><br><span class="line">        newNode.next = cur;</span><br><span class="line">        cur.prev = newNode;</span><br><span class="line">        <span class="built_in">this</span>.size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span>(index+<span class="number">1</span> &lt; size-index)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;index+<span class="number">1</span>; i++) cur = cur.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = tail;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size-index; i++) cur = cur.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur.prev.next = cur.next;</span><br><span class="line">        cur.next.prev = cur.prev;</span><br><span class="line">        <span class="built_in">this</span>.size -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line">        <span class="keyword">public</span> Node prev;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val, Node next, Node prev)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="725-分隔链表"><a class="header-anchor" href="#725-分隔链表"> </a><a href="https://leetcode-cn.com/problems/split-linked-list-in-parts/">725. 分隔链表</a></h2>
<h3 id="题目-v105"><a class="header-anchor" href="#题目-v105"> </a>题目</h3>
<p>给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。</p>
<p>每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。</p>
<p>这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。</p>
<p>返回一个符合上述规则的链表的列表。</p>
<p>举例： 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 结果 [ [1], [2], [3], [4], null ]</p>
<blockquote>
<p>示例 1：<br>
输入:<br>
root = [1, 2, 3], k = 5<br>
输出: [[1],[2],[3],[],[]]<br>
解释:<br>
输入输出各部分都应该是链表，而不是数组。<br>
例如, 输入的结点 root 的 val= 1, root.next.val = 2, \root.next.next.val = 3, 且 root.next.next.next = null。<br>
第一个输出 output[0] 是 output[0].val = 1, output[0].next = null。<br>
最后一个元素 output[4] 为 null, 它代表了最后一个部分为空链表。</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入:<br>
root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3<br>
输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]<br>
解释:<br>
输入被分成了几个连续的部分，并且每部分的长度相差不超过1.前面部分的长度大于等于后面部分的长度。</p>
</blockquote>
<h3 id="解题思路-v84"><a class="header-anchor" href="#解题思路-v84"> </a>解题思路</h3>
<p>要解决这道题首先要搞清楚一下几个变量的数值</p>
<ul>
<li>数组的长度</li>
<li>要分成多少个区间</li>
<li>每个区间的长度是多少</li>
<li>对于长度不同的区间，分别又是多少个</li>
</ul>
<p>对于数组的长度，可以通过遍历一遍链表知道</p>
<p>对于分成多少个区间，方法已经传进来了</p>
<p>每个区间的长度是多少，可以观察到，如果链表长度是要分成的区间个数的整数倍。则</p>
<blockquote>
<p>区间长度 = 链表长度/区间个数</p>
</blockquote>
<p>但是当不是整数倍的时候，可以观察到，区间长度只有两个值，即<code>ceil(链表长度/区间个数)</code>与<code>ceil(链表长度/区间个数)-1</code>两个值</p>
<p>对于不同区间分别又是多少个呢？可以发现，假设所有区间长度我们都设定为<code>ceil(链表长度/区间个数)</code>,那么<code>ceil(链表长度/区间个数) * 区间个数 - 链表长度</code>的话，就可以得出<strong>区间长度较短的那个区间个数</strong>，因为长区间长度比短区间长度多一，因此我们可以这个式子获得短区间的个数</p>
<p>同时<code>for(int j = 0; j &lt; sectionLengthBig-1;j++)</code>这里<code>-1</code>是为了控制 <code>cur</code>移动的位置，如果没有减一，则跑到下一个区间中，我们需要把当前区间的末尾置为空</p>
<h3 id="解题代码-v65"><a class="header-anchor" href="#解题代码-v65"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode[] splitListToParts(ListNode root, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 先获得链表长度</span></span><br><span class="line">        <span class="comment">// 获取区间长度的范围 向上取整 (n-1)/k+1</span></span><br><span class="line">        <span class="comment">// 生成结果 </span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        ListNode[] result = <span class="keyword">new</span> <span class="title class_">ListNode</span>[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            size++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = root;</span><br><span class="line">        <span class="keyword">if</span>(size &lt; k)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">                cur.next = <span class="literal">null</span>;</span><br><span class="line">                result[i] = cur;</span><br><span class="line">                cur = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size; i &lt; k; i++)&#123;</span><br><span class="line">                result[i] = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sectionLengthBig</span> <span class="operator">=</span> (<span class="type">int</span>)Math.ceil((<span class="type">double</span>)size/(<span class="type">double</span>)k);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sectionLengthSmall</span> <span class="operator">=</span> size%k == <span class="number">0</span> ? sectionLengthBig : sectionLengthBig-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sectionLengthSmallNum</span> <span class="operator">=</span> sectionLengthBig*k-size;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sectionLengthBigNum</span> <span class="operator">=</span> k - sectionLengthSmallNum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sectionLengthBigNum; i++)&#123;</span><br><span class="line">            result[i] = cur;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; sectionLengthBig-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = <span class="literal">null</span>;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sectionLengthBigNum; i &lt; k; i++)&#123;</span><br><span class="line">            result[i] = cur;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; sectionLengthSmall-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = <span class="literal">null</span>;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v32"><a class="header-anchor" href="#解题思路2-v32"> </a>解题思路2</h3>
<p>上面这种我自己想的思路想得有点复杂了，官方题解的代码比较简明，但是思想是一致的。</p>
<h3 id="解题代码2-v31"><a class="header-anchor" href="#解题代码2-v31"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode[] splitListToParts(ListNode root, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            size++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = root;</span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> size/k;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rem</span> <span class="operator">=</span> size % k;</span><br><span class="line">        ListNode[] results = <span class="keyword">new</span> <span class="title class_">ListNode</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> cur;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; (width + (i &lt; rem ? <span class="number">1</span> : <span class="number">0</span>))-<span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur != <span class="literal">null</span>) cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//这里加判断是k&gt;size的情况</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> cur;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                prev.next = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            results[i] = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="817-链表组件"><a class="header-anchor" href="#817-链表组件"> </a><a href="https://leetcode-cn.com/problems/linked-list-components/">817. 链表组件</a></h2>
<h3 id="题目-v106"><a class="header-anchor" href="#题目-v106"> </a>题目</h3>
<p>给定链表头结点 head，该链表上的每个结点都有一个 唯一的整型值 。</p>
<p>同时给定列表 G，该列表是上述链表中整型值的一个子集。</p>
<p>返回列表 G 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 G 中）构成的集合。</p>
<blockquote>
<p>示例 1：<br>
输入:<br>
head: 0-&gt;1-&gt;2-&gt;3<br>
G = [0, 1, 3]<br>
输出: 2<br>
解释:<br>
链表中,0 和 1 是相连接的，且 G 中不包含 2，所以 [0, 1] 是 G 的一个组件，同理 [3] 也是一个组件，故返回 2。</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入:<br>
head: 0-&gt;1-&gt;2-&gt;3-&gt;4<br>
G = [0, 3, 1, 4]<br>
输出: 2<br>
解释:<br>
链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。</p>
</blockquote>
<h3 id="解题思路1-v15"><a class="header-anchor" href="#解题思路1-v15"> </a>解题思路1</h3>
<p>我的解法是判断遍历每个结点，对于每个结点再遍历一次数组G，来判断该结点是否在G中，并结合结点是否属于一个组件中，来计算值。当然也可以引入Set来以空间换时间</p>
<h3 id="解题代码1-v16"><a class="header-anchor" href="#解题代码1-v16"> </a>解题代码1</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numComponents</span><span class="params">(ListNode head, <span class="type">int</span>[] G)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">inComponent</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">inG</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> cur.val;</span><br><span class="line">            inG = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v : G)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v == value)&#123;</span><br><span class="line">                    <span class="comment">//判断是组件头</span></span><br><span class="line">                    <span class="keyword">if</span>(!inComponent)&#123;</span><br><span class="line">                        count++; <span class="comment">//新头</span></span><br><span class="line">                        inComponent =  <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    inG = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!inG &amp;&amp; inComponent) inComponent = <span class="literal">false</span>;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v33"><a class="header-anchor" href="#解题思路2-v33"> </a>解题思路2</h3>
<p>引入HashSet来判断重复元素，同时对于一个组件的判断，可以通过判断组件末尾来计算个数</p>
<h3 id="解题代码2-v32"><a class="header-anchor" href="#解题代码2-v32"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numComponents</span><span class="params">(ListNode head, <span class="type">int</span>[] G)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; g = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v : G) g.add(v);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g.contains(cur.val) &amp;&amp; (cur.next == <span class="literal">null</span> || !g.contains(cur.next.val))) count++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1019-链表中的下一个更大节点"><a class="header-anchor" href="#1019-链表中的下一个更大节点"> </a><a href="https://leetcode-cn.com/problems/next-greater-node-in-linked-list/">1019. 链表中的下一个更大节点</a></h2>
<h3 id="题目-v107"><a class="header-anchor" href="#题目-v107"> </a>题目</h3>
<p>给出一个以头节点 head 作为第一个节点的链表。链表中的节点分别编号为：node_1, node_2, node_3, … 。</p>
<p>每个节点都可能有下一个更大值（next larger value）：对于 node_i，如果其 next_larger(node_i) 是 node_j.val，那么就有 j &gt; i 且  node_j.val &gt; node_i.val，而 j 是可能的选项中最小的那个。如果不存在这样的 j，那么下一个更大值为 0 。</p>
<p>返回整数答案数组 answer，其中 answer[i] = next_larger(node_{i+1}) 。</p>
<p>注意：在下面的示例中，诸如 [2,1,5] 这样的输入（不是输出）是链表的序列化表示，其头节点的值为 2，第二个节点值为 1，第三个节点值为 5 。</p>
<blockquote>
<p>示例 1：<br>
输入：[2,1,5]<br>
输出：[5,5,0]</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：[2,7,4,3,5]<br>
输出：[7,0,5,5,0]</p>
</blockquote>
<blockquote>
<p>示例 3：<br>
输入：[1,7,5,1,9,2,5,1]<br>
输出：[7,9,9,9,0,5,0,0]</p>
</blockquote>
<h3 id="解题思路1-v16"><a class="header-anchor" href="#解题思路1-v16"> </a>解题思路1</h3>
<p>时间复杂度O(N<sup>2</sup>)的方法</p>
<h3 id="解题代码1-v17"><a class="header-anchor" href="#解题代码1-v17"> </a>解题代码1</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextLargerNodes(ListNode head) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        ListNode after;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] answer = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            after = cur.next;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">hasbigger</span> <span class="operator">=</span> <span class="literal">false</span>; </span><br><span class="line">            <span class="keyword">while</span>(after!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(after.val &gt; cur.val)&#123;</span><br><span class="line">                    hasbigger = <span class="literal">true</span>;</span><br><span class="line">                    answer[index]= after.val;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                after = after.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!hasbigger) answer[index] = <span class="number">0</span>;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v34"><a class="header-anchor" href="#解题思路2-v34"> </a>解题思路2</h3>
<p>解题思路1的方法太土了，效率太低了，有种叫做单调栈的东西。</p>
<h3 id="解题代码2-v33"><a class="header-anchor" href="#解题代码2-v33"> </a>解题代码2</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextLargerNodes</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; answers; <span class="comment">//答案输出，注意这个答案数组会随着遍历过程改变</span></span><br><span class="line">        stack&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; stack; <span class="comment">// 存放链表中暂未找到bigger的元素，其中first未元素的值，second为元素的位置</span></span><br><span class="line">        <span class="comment">//基本思路就是遍历过程中，判断栈中未找到bigger的元素是否大于现在遍历到的结点，如果是bigger的弹出栈，同时判断栈下一个元素</span></span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            answers.<span class="built_in">push_back</span>(<span class="number">0</span>); <span class="comment">// 填充0的意义在于目前并不知道这个结点是否有bigger，在后面如果找到bigger的话会修改</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.<span class="built_in">empty</span>() &amp;&amp; head-&gt;val &gt; stack.<span class="built_in">top</span>().first)&#123;</span><br><span class="line">                <span class="comment">//当前遍历的元素是栈顶元素的bigger</span></span><br><span class="line">                answers[stack.<span class="built_in">top</span>().second] = head-&gt;val;</span><br><span class="line">                stack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前的结点也没找到bigger，先压栈</span></span><br><span class="line">            stack.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(head-&gt;val,index++));</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1171-从链表中删去总和值为零的连续节点"><a class="header-anchor" href="#1171-从链表中删去总和值为零的连续节点"> </a><a href="https://leetcode-cn.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/">1171. 从链表中删去总和值为零的连续节点</a></h2>
<h3 id="题目-v108"><a class="header-anchor" href="#题目-v108"> </a>题目</h3>
<p>给你一个链表的头节点 head，请你编写代码，反复删去链表中由 总和 值为 0 的连续节点组成的序列，直到不存在这样的序列为止。</p>
<p>删除完毕后，请你返回最终结果链表的头节点。</p>
<p>你可以返回任何满足题目要求的答案。</p>
<p>（注意，下面示例中的所有序列，都是对 ListNode 对象序列化的表示。）</p>
<blockquote>
<p>示例 1：<br>
输入：head = [1,2,-3,3,1]<br>
输出：[3,1]<br>
提示：答案 [1,2,1] 也是正确的。</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：head = [1,2,3,-3,4]<br>
输出：[1,2,4]</p>
</blockquote>
<blockquote>
<p>示例 3：<br>
输入：head = [1,2,3,-3,-2]<br>
输出：[1]</p>
</blockquote>
<h3 id="解题思路-v85"><a class="header-anchor" href="#解题思路-v85"> </a>解题思路</h3>
<p>解决这道题的关键是如何去定义 <strong>总和值为 <code>0</code> 的连续节点</strong>这句话。</p>
<p>而我们通过将链表值累加能够发现，在<strong>总和值为0</strong>的链表区间中，累加值<code>sum</code>会先升后降。达到与升起来之前相等的值。</p>
<p>根据这个我们可以声明一个散列表，来保存上一个达到累加值的结点。如果在遍历中发现累加值已经存在，说明在这个结点之前到这个结点的位置，为总和值为0的部分，需要将上一个出现该累加值的结点指向现在遍历到的这个结点的<code>next</code>结点。同时需要将散列表中该区间的累加值和相应的结点给删除。</p>
<h3 id="解题代码-v66"><a class="header-anchor" href="#解题代码-v66"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeZeroSumSublists</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 解题思路</span></span><br><span class="line">        <span class="comment">// 如何判断中间部分总和为0？</span></span><br><span class="line">        <span class="comment">// 如果一系列数累加上去又降下了，说明这部分存在抵消部分</span></span><br><span class="line">        <span class="comment">// 因此判断在同一水平位置的升降，即可知道中间部分是涨，水平位置右侧的值是抵消的最后一个值</span></span><br><span class="line">        <span class="comment">// 因此将水平位置左侧的结点指向水平位置右侧的next即可</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//存在头节点被删的可能，因此定义哑结点，同时值为0</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//散列表存的键是一系列累加的值，值存的是加成这个值的结点</span></span><br><span class="line">        HashMap&lt;Integer,ListNode&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>,dummy);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            sum += cur.val;</span><br><span class="line">            <span class="keyword">if</span>(map.get(sum) != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//说明已经涨落</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">before</span> <span class="operator">=</span> map.get(sum);</span><br><span class="line">                <span class="comment">//中间的值也需要删</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> before.next;</span><br><span class="line">                <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> sum;</span><br><span class="line">                <span class="keyword">while</span>(temp != cur)&#123;</span><br><span class="line">                    curSum += temp.val;</span><br><span class="line">                    map.remove(curSum);</span><br><span class="line">                    temp = temp.next;</span><br><span class="line">                &#125;</span><br><span class="line">                before.next = cur.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(sum,cur);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1367-二叉树中的列表"><a class="header-anchor" href="#1367-二叉树中的列表"> </a><a href="https://leetcode-cn.com/problems/linked-list-in-binary-tree/">1367. 二叉树中的列表</a></h2>
<h3 id="题目-v109"><a class="header-anchor" href="#题目-v109"> </a>题目</h3>
<p>给你一棵以 root 为根的二叉树和一个 head 为第一个节点的链表。</p>
<p>如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 head 为首的链表中每个节点的值，那么请你返回 True ，否则返回 False 。</p>
<p>一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。</p>
<blockquote>
<p>示例 1：<br>
输入：head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]<br>
输出：true<br>
解释：树中蓝色的节点构成了与链表对应的子路径。</p>
</blockquote>
<p><img src="http://algorithm-image.qibinaoe.top/sample_1_1720.png" alt="img"></p>
<p>示例 2:<br>
输入：head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]<br>
输出：true</p>
<p>示例 3：<br>
输入：head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]<br>
输出：false<br>
解释：二叉树中不存在一一对应链表的路径。</p>
<p><img src="http://algorithm-image.qibinaoe.top/sample_2_1720.png" alt="img"></p>
<h3 id="解题思路-v86"><a class="header-anchor" href="#解题思路-v86"> </a>解题思路</h3>
<p>这题显然是一道深度优先搜索的题目。</p>
<p>通过递归判断当前节点是否与树上当前节点相等。如果相等，则继续判断链表下一个节点与书上的左右两子树。这个即方法<code>dfs</code>的作用。</p>
<p>当然也可能存在当前链表的结点与树上的结点相等，但接下来链表下一个结点就不相等了，这并不意味着不匹配，有可能这匹配的串在树的更底层。所以要或上<code>isSubPath(head,root.left) || isSubPath(head,root.right)</code></p>
<h4 id="解题代码-v67"><a class="header-anchor" href="#解题代码-v67"> </a>解题代码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubPath</span><span class="params">(ListNode head, TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//DFS的题目</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//有可能存在head.val在树上存在两个都相等的结点，所以两个位置的结点都得判断</span></span><br><span class="line">        <span class="keyword">return</span> dfs(head,root) || isSubPath(head,root.left) || isSubPath(head,root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(ListNode head, TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.val == node.val) <span class="keyword">return</span> dfs(head.next,node.left) || dfs(head.next, node.right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1669-合并两个链表"><a class="header-anchor" href="#1669-合并两个链表"> </a><a href="https://leetcode-cn.com/problems/merge-in-between-linked-lists/">1669. 合并两个链表</a></h2>
<h3 id="题目-v110"><a class="header-anchor" href="#题目-v110"> </a>题目</h3>
<p>给你两个链表 list1 和 list2 ，它们包含的元素分别为 n 个和 m 个。</p>
<p>请你将 list1 中第 a 个节点到第 b 个节点删除，并将list2 接在被删除节点的位置。</p>
<p>下图中蓝色边和节点展示了操作后的结果：</p>
<p><img src="http://algorithm-image.qibinaoe.top/fig1.png" alt="img"></p>
<blockquote>
<p>示例 1：<br>
输入：list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]<br>
输出：[0,1,2,1000000,1000001,1000002,5]<br>
解释：我们删除 list1 中第三和第四个节点，并将 list2 接在该位置。上图中蓝色的边和节点为答案链表。</p>
</blockquote>
<p><img src="http://algorithm-image.qibinaoe.top/merge_linked_list_ex1.png" alt="img"></p>
<h3 id="解题思路-v87"><a class="header-anchor" href="#解题思路-v87"> </a>解题思路</h3>
<p>这题主要是两个指针移动b-a+1个距离，然后操作链表的题目</p>
<p>一种做法是一个指针移动<code>b-a+1</code>的距离，另一个指针从头开始，同步移动a-1个距离。</p>
<p>另一种做法是一个指针移动a-1个距离，另一个指针在第一个指针的基础上移动b-a+1个距离</p>
<h3 id="解题代码-v68"><a class="header-anchor" href="#解题代码-v68"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeInBetween</span><span class="params">(ListNode list1, <span class="type">int</span> a, <span class="type">int</span> b, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="comment">// 关键是找到第a-1个结点和b的结点</span></span><br><span class="line">        <span class="comment">// 找长度显然用快慢指针</span></span><br><span class="line">        <span class="comment">// 根据题目的条件，不会删除头结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">before</span> <span class="operator">=</span> list1;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">after</span> <span class="operator">=</span> list1;</span><br><span class="line">        <span class="comment">//偏移b-a+1个位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> b - a + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            after = after.next;</span><br><span class="line">            pos--;</span><br><span class="line">        &#125;</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将这段指针同步移动到before的位置在a的位置</span></span><br><span class="line">        a--;</span><br><span class="line">        <span class="keyword">while</span>(a&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            after = after.next;</span><br><span class="line">            before = before.next;</span><br><span class="line">            a--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拼接</span></span><br><span class="line">        before.next = list2;</span><br><span class="line">        <span class="keyword">while</span>(list2.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        list2.next = after.next;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1670-设计前中后队列"><a class="header-anchor" href="#1670-设计前中后队列"> </a><a href="https://leetcode-cn.com/problems/design-front-middle-back-queue/">1670. 设计前中后队列</a></h2>
<h3 id="题目-v111"><a class="header-anchor" href="#题目-v111"> </a>题目</h3>
<p>请你设计一个队列，支持在前，中，后三个位置的 push 和 pop 操作。</p>
<p>请你完成 FrontMiddleBack 类：</p>
<blockquote>
<p>FrontMiddleBack() 初始化队列。<br>
void pushFront(int val) 将 val 添加到队列的 最前面 。<br>
void pushMiddle(int val) 将 val 添加到队列的 正中间 。<br>
void pushBack(int val) 将 val 添加到队里的 最后面 。<br>
int popFront() 将 最前面 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。<br>
int popMiddle() 将 正中间 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。<br>
int popBack() 将 最后面 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。<br>
请注意当有 两个 中间位置的时候，选择靠前面的位置进行操作。比方说：</p>
</blockquote>
<blockquote>
<p>将 6 添加到 [1, 2, 3, 4, 5] 的中间位置，结果数组为 [1, 2, 6, 3, 4, 5] 。<br>
从 [1, 2, 3, 4, 5, 6] 的中间位置弹出元素，返回 3 ，数组变为 [1, 2, 4, 5, 6] 。</p>
</blockquote>
<h3 id="解题思路-v88"><a class="header-anchor" href="#解题思路-v88"> </a>解题思路</h3>
<p>这题可以用单向链表实现，也可以用双向链表实现。</p>
<p>如果用双向链表实现的话，还可以定义一个记录中间节点变量。这样能够提高效率。</p>
<h3 id="解题代码单向链表"><a class="header-anchor" href="#解题代码单向链表"> </a>解题代码单向链表</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FrontMiddleBackQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node dummy;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FrontMiddleBackQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个哑结点</span></span><br><span class="line">        dummy = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushFront</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val,dummy.next);</span><br><span class="line">        dummy.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushMiddle</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//找到中间位置</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">fast</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">slow</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val,slow.next);</span><br><span class="line">        slow.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushBack</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">popFront</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">result</span> <span class="operator">=</span> dummy.next;</span><br><span class="line">        dummy.next = dummy.next.next;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> result.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">popMiddle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">fast</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">slow</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span> &amp;&amp; fast.next.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">result</span> <span class="operator">=</span> slow.next;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> result.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">popBack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(cur.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">result</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> result.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val,Node next)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FrontMiddleBackQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FrontMiddleBackQueue obj = new FrontMiddleBackQueue();</span></span><br><span class="line"><span class="comment"> * obj.pushFront(val);</span></span><br><span class="line"><span class="comment"> * obj.pushMiddle(val);</span></span><br><span class="line"><span class="comment"> * obj.pushBack(val);</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.popFront();</span></span><br><span class="line"><span class="comment"> * int param_5 = obj.popMiddle();</span></span><br><span class="line"><span class="comment"> * int param_6 = obj.popBack();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-35-复杂链表的复制"><a class="header-anchor" href="#剑指-Offer-35-复杂链表的复制"> </a><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指 Offer 35. 复杂链表的复制</a></h2>
<h3 id="题目-v112"><a class="header-anchor" href="#题目-v112"> </a>题目</h3>
<p>同“138. 复制带随机指针的链表”</p>
<h3 id="解题代码-v69"><a class="header-anchor" href="#解题代码-v69"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        HashMap&lt;Node,Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//键是原链表 值是新链表</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">newhead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(head.val);</span><br><span class="line">        map.put(head,newhead);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">oldNode</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> newhead;</span><br><span class="line">        <span class="keyword">while</span>(oldNode.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(oldNode.next.val);</span><br><span class="line">            newNode.next = temp;</span><br><span class="line">            map.put(oldNode.next,temp);</span><br><span class="line">            oldNode = oldNode.next;</span><br><span class="line">            newNode = newNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        oldNode = head;</span><br><span class="line">        newNode = newhead;</span><br><span class="line">        <span class="keyword">while</span>(oldNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newRandom</span> <span class="operator">=</span> map.get(oldNode.random);</span><br><span class="line">            newNode.random = newRandom;</span><br><span class="line">            oldNode = oldNode.next;</span><br><span class="line">            newNode = newNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题-02-04-分割链表"><a class="header-anchor" href="#面试题-02-04-分割链表"> </a><a href="https://leetcode-cn.com/problems/partition-list-lcci/">面试题 02.04. 分割链表</a></h2>
<p>题目同“86. 分隔链表”</p>
<h2 id="面试题-02-05-链表求和"><a class="header-anchor" href="#面试题-02-05-链表求和"> </a><a href="https://leetcode-cn.com/problems/sum-lists-lcci/">面试题 02.05. 链表求和</a></h2>
<p>题目同“2. 两数相加”</p>
<h3 id="解题代码-v70"><a class="header-anchor" href="#解题代码-v70"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> l1==<span class="literal">null</span>?<span class="number">0</span>:l1.val;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> l2==<span class="literal">null</span>?<span class="number">0</span>:l2.val;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>((num1+num2+(carry==<span class="number">0</span>?<span class="number">0</span>:<span class="number">1</span>))%<span class="number">10</span>);</span><br><span class="line">            carry = num1+num2+carry&gt;<span class="number">9</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            cur.next = newNode;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            l1 = l1==<span class="literal">null</span>?<span class="literal">null</span>:l1.next;</span><br><span class="line">            l2 = l2==<span class="literal">null</span>?<span class="literal">null</span>:l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">            cur.next = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面试题-02-08-环路检测"><a class="header-anchor" href="#面试题-02-08-环路检测"> </a><a href="https://leetcode-cn.com/problems/linked-list-cycle-lcci/">面试题 02.08. 环路检测</a></h2>
<p>题目同“<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a>”</p>
<h2 id="23-合并K个升序链表"><a class="header-anchor" href="#23-合并K个升序链表"> </a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></h2>
<h3 id="题目-v113"><a class="header-anchor" href="#题目-v113"> </a>题目</h3>
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<blockquote>
<p>示例 1：<br>
输入：lists = [[1,4,5],[1,3,4],[2,6]]<br>
输出：[1,1,2,3,4,4,5,6]<br>
解释：链表数组如下：<br>
[<br>
1-&gt;4-&gt;5,<br>
1-&gt;3-&gt;4,<br>
2-&gt;6<br>
]<br>
将它们合并到一个有序链表中得到。<br>
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
</blockquote>
<blockquote>
<p>示例 2：<br>
输入：lists = []<br>
输出：[]</p>
</blockquote>
<blockquote>
<p>示例 3：<br>
输入：lists = [[]]<br>
输出：[]</p>
</blockquote>
<blockquote>
<p>提示：<br>
k == lists.length<br>
0 &lt;= k &lt;= 10^4<br>
0 &lt;= lists[i].length &lt;= 500<br>
-10^4 &lt;= lists[i][j] &lt;= 10^4<br>
lists[i] 按 升序 排列<br>
lists[i].length 的总和不超过 10^4</p>
</blockquote>
<h3 id="解题思路1-v17"><a class="header-anchor" href="#解题思路1-v17"> </a>解题思路1</h3>
<p>最开始的想法是不断的从数组中找到最小的值，接到新链表中。这就通过循环找最小值即可</p>
<h3 id="解题代码1-v18"><a class="header-anchor" href="#解题代码1-v18"> </a>解题代码1</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个新链表</span></span><br><span class="line">        <span class="comment">//遍历每个lists的头取最小加入新链表</span></span><br><span class="line">        <span class="keyword">if</span>(lists == <span class="literal">null</span> || lists.length == <span class="number">0</span> || (lists.length == <span class="number">1</span> &amp;&amp; lists[<span class="number">0</span>]==<span class="literal">null</span>)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> ans;</span><br><span class="line">        <span class="type">boolean</span> flag;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">minNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lists.length; i++)&#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> lists[i];</span><br><span class="line">                <span class="keyword">if</span>(temp != <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(temp.val &lt; min)&#123;</span><br><span class="line">                        min = temp.val;</span><br><span class="line">                        minNode = temp;</span><br><span class="line">                        index = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                cur.next =<span class="keyword">new</span> <span class="title class_">ListNode</span>(min);</span><br><span class="line">                lists[index] = minNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;<span class="keyword">while</span>(flag);</span><br><span class="line">        <span class="keyword">return</span> ans.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路2-v35"><a class="header-anchor" href="#解题思路2-v35"> </a>解题思路2</h3>
<p>题目要求合并K个，那么我们可以直接2个2个合并就完事了</p>
<h3 id="解题代码2-v34"><a class="header-anchor" href="#解题代码2-v34"> </a>解题代码2</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lists == <span class="literal">null</span> || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;lists.length; i++)&#123;</span><br><span class="line">           ans = mergeTwoLists(ans,lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">null</span> || l2 == <span class="literal">null</span>) <span class="keyword">return</span> l1==<span class="literal">null</span>?l2:l1;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = l1==<span class="literal">null</span>?l2:l1;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路3-v8"><a class="header-anchor" href="#解题思路3-v8"> </a>解题思路3</h3>
<p>可以通过归并排序，优化直接按顺序合并的速度</p>
<h3 id="解题代码3-v12"><a class="header-anchor" href="#解题代码3-v12"> </a>解题代码3</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lists == <span class="literal">null</span> || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> merge(lists,<span class="number">0</span>,lists.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode lists[], <span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> lists[l];</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(merge(lists,l,mid),merge(lists,mid+<span class="number">1</span>,r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">null</span> || l2 == <span class="literal">null</span>) <span class="keyword">return</span> l1==<span class="literal">null</span>?l2:l1;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = l1==<span class="literal">null</span>?l2:l1;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解题思路4-v3"><a class="header-anchor" href="#解题思路4-v3"> </a>解题思路4</h3>
<p>可以利用优先队列，每次都能够取出最小值的特点</p>
<h3 id="解题代码4-v4"><a class="header-anchor" href="#解题代码4-v4"> </a>解题代码4</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lists == <span class="literal">null</span> || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((ListNode n1, ListNode n2)-&gt;&#123;<span class="keyword">return</span> n1.val-n2.val;&#125;);</span><br><span class="line">        <span class="keyword">for</span>(ListNode n : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n != <span class="literal">null</span>) queue.offer(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> ans;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">min</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            cur.next = min;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            min = min.next;</span><br><span class="line">            <span class="keyword">if</span>(min != <span class="literal">null</span>) queue.offer(min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="25-K-个一组翻转链表"><a class="header-anchor" href="#25-K-个一组翻转链表"> </a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h2>
<h3 id="题目-v114"><a class="header-anchor" href="#题目-v114"> </a>题目</h3>
<p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<blockquote>
<p>示例：<br>
给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5<br>
当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5<br>
当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
</blockquote>
<blockquote>
<p>说明：<br>
你的算法只能使用常数的额外空间。<br>
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
</blockquote>
<h3 id="解题思路-v89"><a class="header-anchor" href="#解题思路-v89"> </a>解题思路</h3>
<p>既然是k个结点进行翻转，那本质是“leetcode206——反转链表”这道题。</p>
<p>接下来思考要翻转多少次?可以先获取链表的长度，再除以k，即可得到次数。</p>
<p>接下来比较麻烦的就是处理翻转的位置首尾的连接。</p>
<h3 id="解题代码-v71"><a class="header-anchor" href="#解题代码-v71"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> size/k;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummy;</span><br><span class="line">        cur = head;</span><br><span class="line">        ListNode after;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">            after = cur;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j&lt; k; j++)&#123;</span><br><span class="line">                after = after.next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev.next = reverseList(cur,after);</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = after;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head, ListNode end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> end;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        ListNode temp;</span><br><span class="line">        <span class="keyword">while</span>(cur != end)&#123;</span><br><span class="line">            temp = cur.next;</span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>就业相关大杂烩</title>
    <url>/2020/11/09/%E5%B0%B1%E4%B8%9A%E7%9B%B8%E5%85%B3%E5%A4%A7%E6%9D%82%E7%83%A9/</url>
    <content><![CDATA[<h2 id="就业相关问题"><a class="header-anchor" href="#就业相关问题"> </a>就业相关问题</h2>
<h3 id="腾讯"><a class="header-anchor" href="#腾讯"> </a>腾讯</h3>
<!-- more -->
<ul>
<li>腾讯校招
<ul>
<li>
<p>以能力定级，不是以学历定级</p>
</li>
<li>
<p>通用面试技巧</p>
<ul>
<li>简历（重点突出内容）
<ul>
<li>教育经历：最高学历/本科学历/交换经历（专业成绩，绩点，排名，奖学金 很小一排字）</li>
<li>GPA/综合排名</li>
<li>实习/项目经历：大厂、项目经验（主要负责人）    （实习好处：积累经验 实习转正）</li>
<li>论文/专利/学术竞赛</li>
<li>校园活动：学生干部、社团负责人（技术类岗位不是必须的）</li>
<li>奖学金/竞赛获奖：国奖、校三好学生，ACM、数学建模</li>
<li>Skills：英语水平、开发语言、算法框架等</li>
<li>加分项：公司或学校的知名实验室、学术界大导、海外知名高校交换生</li>
</ul>
</li>
</ul>
<p>注:</p>
<ul>
<li>项目经历进行量化，产出了什么，数字说话</li>
<li>什么家教、新东方兼职老师，对应聘岗位没有关系的信息，不要写在简历上面</li>
<li>措辞严谨，不要说什么（主要），而是：是参与就是参与，是负责就是负责。而不要让人感觉浑水摸鱼</li>
<li>关键词：独立负责 数据 参与 效果</li>
</ul>
</li>
<li>
<p>笔试</p>
<ul>
<li>腾讯网上笔试会查重，屏幕退出了几次。不要作弊：作弊还是帮别人作弊就进黑名单，永不录用</li>
</ul>
</li>
<li>
<p>群面</p>
<ul>
<li>互联网公司唯一不用群面的是技术类岗位</li>
<li>学会倾听 协调 节奏把控 建议和观点需要有价值的 不要观点重复 逻辑清晰</li>
</ul>
</li>
<li>
<p>1V1面试</p>
<ul>
<li>初试 复试  终面</li>
<li>自我介绍
<ul>
<li>简练、突出重点个人优势</li>
<li>项目介绍  项目背景 项目目标 成员分工 主要做了哪些工作 成果</li>
<li>对项目是否全貌了解  做项目的解决嫩里 是否主动承担 快速学习能力</li>
<li>技术面试  操作系统 网络编程 基础知识掌握</li>
<li>意愿适配： 意向城市 期望薪资 期望岗位</li>
<li>问答 补充问题 意愿适配</li>
</ul>
</li>
</ul>
</li>
<li>
<p>HR</p>
<ul>
<li>意愿适配
<ul>
<li>理想工作</li>
</ul>
</li>
<li>通用素质</li>
<li>个性风险
<ul>
<li>经历最大挫折</li>
</ul>
</li>
</ul>
</li>
<li>
<p>腾讯校招知识点</p>
</li>
</ul>
</li>
</ul>
<h3 id="问题-v3"><a class="header-anchor" href="#问题-v3"> </a>问题</h3>
<ul>
<li>寒假实习  实习面试要求</li>
<li>意愿适配中的期望薪资怎么回答</li>
</ul>
<h2 id="华为招聘"><a class="header-anchor" href="#华为招聘"> </a>华为招聘</h2>
<ul>
<li>求知欲</li>
<li>洞察力</li>
<li>感召力</li>
<li>决心与坚持</li>
<li>动机</li>
</ul>
<p>压力面试体现：让自己不舒服</p>
<h3 id="优秀"><a class="header-anchor" href="#优秀"> </a><strong>优秀</strong></h3>
<ul>
<li>专业技术知识</li>
<li>沟通能力</li>
<li>学习能看i</li>
<li>符合价值观</li>
</ul>
<h3 id="非常优秀"><a class="header-anchor" href="#非常优秀"> </a><strong>非常优秀</strong></h3>
<ul>
<li>软件架构</li>
<li>分析信息能力</li>
<li>算法能力</li>
<li>激情</li>
<li>写“好代码”</li>
<li>项目经验</li>
</ul>
<h3 id="顶尖"><a class="header-anchor" href="#顶尖"> </a><strong>顶尖</strong></h3>
<ul>
<li>极客</li>
<li>创新</li>
<li>解决问题</li>
</ul>
<h3 id="认识自我做好定位"><a class="header-anchor" href="#认识自我做好定位"> </a>认识自我做好定位</h3>
<p>不能单纯看薪酬，还需要看行业、方向。社招以后的转行比较难</p>
<p>不喜欢高压的同学慎入互联网行业：996、同僚绩效PK</p>
<p>国企、研究所、公务员等，要升官需要排排队，产出与收入不符</p>
<p>内向、外向</p>
<p>华为使用ATA定制的风格测试</p>
<p>职业价值观 最看重什么</p>
<p>个人性格</p>
<p>资源：家庭、教育学习、身体条件、人脉关系</p>
<h3 id="求职准备"><a class="header-anchor" href="#求职准备"> </a>求职准备</h3>
<ul>
<li><strong>校园就业网、BBS</strong></li>
<li><strong>大型招聘网站</strong></li>
<li><strong>企业网站投递简历</strong></li>
<li>参加特定企业的校园招聘会</li>
<li>参加大型招聘会</li>
<li>校友/朋友推荐</li>
<li>盲目投递简历</li>
</ul>
<h4 id="应聘单位"><a class="header-anchor" href="#应聘单位"> </a>应聘单位</h4>
<ul>
<li><strong>公司文化</strong>(加分项，必考题)
<ul>
<li>对公司的看法，对公司的理解</li>
</ul>
</li>
<li><strong>岗位职责</strong>
<ul>
<li>根据岗位职责，去写简历</li>
</ul>
</li>
</ul>
<h4 id="制作个人简历"><a class="header-anchor" href="#制作个人简历"> </a>制作个人简历</h4>
<ul>
<li>基本要素
<ul>
<li>基本信息</li>
<li>求职意向</li>
<li>教育背景
<ul>
<li>GPA：3.75/top20/相关专业</li>
</ul>
</li>
<li>实习实践
<ul>
<li>做了什么？负责人？负责岗位？产出？决策？ APP代码量  哪些核心开发</li>
</ul>
</li>
<li>技能特长</li>
<li>奖励荣誉</li>
<li>兴趣爱好
<ul>
<li>按照企业文化去匹配</li>
</ul>
</li>
<li>自我评价</li>
</ul>
</li>
<li>基本原则
<ul>
<li>简洁性
<ul>
<li>标红加粗，不会全部看，不要密密麻麻</li>
</ul>
</li>
<li>清晰性</li>
<li>针对性</li>
<li>客观性</li>
<li>真实性</li>
</ul>
</li>
<li>注意事项
<ul>
<li>基本信息真实</li>
<li>联系方式准确
<ul>
<li>毕业年份 2022</li>
<li>联系方式</li>
</ul>
</li>
<li>求职意向明确(不要一份简历打天下)</li>
<li>背景经历详细</li>
<li>技术特长突出
<ul>
<li>工作/实习/项目/校园经验</li>
</ul>
</li>
</ul>
</li>
<li>特别关注
<ul>
<li>语言表达
<ul>
<li>逻辑性</li>
</ul>
</li>
<li>结构完整
<ul>
<li>工作态度</li>
</ul>
</li>
<li>文字标点
<ul>
<li>认真细致</li>
</ul>
</li>
<li>学习培训
<ul>
<li>进取心、学习能力</li>
</ul>
</li>
<li>活动结果
<ul>
<li>成就导向</li>
</ul>
</li>
<li>自我评价
<ul>
<li>个人特征</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="技巧"><a class="header-anchor" href="#技巧"> </a>技巧</h4>
<ul>
<li>回答面试官的问题不要快，要思考好</li>
<li>要有结构化的（总-分）这个项目大概是怎么样的项目，我担任了什么样的角色，获得什么结果，哪些经验与不足</li>
<li>去心仪企业之前，多找几家企业去面试，练习练习</li>
<li>眼神交流</li>
<li>礼貌</li>
<li>着装</li>
<li>STAR法则</li>
<li>项目</li>
<li>公司理解</li>
<li>工作岗位的理解</li>
<li>职业规划、人生规划</li>
</ul>
<h3 id="华为老师评价同学简历"><a class="header-anchor" href="#华为老师评价同学简历"> </a>华为老师评价同学简历</h3>
<p>项目经历要和面试岗位相符</p>
<p>成绩表现自己的学习能力，需要涉及</p>
<p>项目经验</p>
<p>竞赛情况 比赛含金量，举办方，比例</p>
<p>获奖情况 写出比例</p>
<h2 id="曾益学长"><a class="header-anchor" href="#曾益学长"> </a>曾益学长</h2>
<p>2月份开始面试 春招</p>
<p><strong>投递简历</strong></p>
<ul>
<li>应聘平台</li>
<li>内推
<ul>
<li>提前锁定开发团队</li>
</ul>
</li>
</ul>
<p><strong>笔试</strong></p>
<p><strong>面试</strong></p>
<ul>
<li>第一次面试就确定leader 团队 同事</li>
<li>3-6次面试</li>
<li>HR面试
<ul>
<li>情商、智商、协作能力</li>
<li>是否有对面试的问题是否有<u>复盘</u>：理解问题、补充知识面</li>
<li>你现在手里是否有别家的offer？
<ul>
<li>要表现出别家公司对自己认可，又要对当前公司有足够的热情</li>
</ul>
</li>
</ul>
</li>
<li>第一面、第二面一般是同事：基础</li>
<li>后两面是leader：挖一个方向上，是否了解足够多。技术视野、热爱技术、前沿技术</li>
</ul>
<p><u>横向比较过程</u>：排序过程、技术面评、简历、项目经历</p>
<p><strong>意向书</strong></p>
<ul>
<li>选择接受或拒绝</li>
</ul>
<p><strong>带薪offer</strong></p>
<p><strong>简历</strong></p>
<ul>
<li>一页纸 内容简历 充分说明情况
<ul>
<li>学校 学历 年龄 联系方式</li>
<li>不要太多空白</li>
</ul>
</li>
<li>正式的证件照或不贴照片</li>
<li>会的技能一定要写，写的技能一定要会
<ul>
<li>面试官是挖掘知识的储备</li>
<li>框架 中间件：写的一定要会，底层</li>
<li>精通、输连 使用</li>
</ul>
</li>
</ul>
<p>超级简历 五百丁简历 standard resume</p>
<p><strong>知识准备</strong></p>
<ul>
<li>课本知识
<ul>
<li>操作系统</li>
<li>计网</li>
<li>计组</li>
<li>数据库</li>
</ul>
</li>
<li>开发知识
<ul>
<li>语言特性</li>
<li>框架与中间件
<ul>
<li>spring spring boot</li>
<li>没有写一般不会问</li>
</ul>
</li>
</ul>
</li>
<li>算法题</li>
</ul>
<p>编程题 健壮性：鲁棒性</p>
<ul>
<li>异常数、边界条件</li>
<li>准备项目经历</li>
</ul>
<ol>
<li>
<p>介绍自己</p>
</li>
<li>
<p>提问项目经历</p>
</li>
</ol>
<p><strong>复习指南</strong></p>
<ul>
<li>
<p>面经</p>
</li>
<li>
<p>一场前置的真实面试</p>
</li>
<li>
<p>心态调整</p>
</li>
<li>
<p>不要安排连续的面试</p>
</li>
<li>
<p>面试复盘</p>
</li>
<li>
<p>尽早投递简历</p>
</li>
<li>
<p><strong>自组信息交流群</strong></p>
</li>
</ul>
<p>掌控面试节奏</p>
<p>有可答则尽答</p>
<p>根据素质雷达图展现自己的积极面</p>
<p>逻辑清晰，不骄不躁，语气语速平缓</p>
<ul>
<li>WonderCV超级简历</li>
<li>牛客网</li>
<li>leetcode</li>
<li>offershow</li>
<li>学院的就业公众号</li>
<li>企业官方招聘入口</li>
</ul>
<h2 id="张继珂学长"><a class="header-anchor" href="#张继珂学长"> </a>张继珂学长</h2>
<p>项目经历</p>
<ul>
<li>
<p>困难是什么</p>
</li>
<li>
<p>解决方法是什么</p>
</li>
</ul>
<p>github上</p>
<ul>
<li>
<p>CSNOTES</p>
</li>
<li>
<p>JAVAGUIDE</p>
</li>
<li>
<p>面试总结</p>
</li>
</ul>
<p>Developer roadmap</p>
<p><strong>构建体系大纲</strong></p>
<p>版本差异</p>
<h2 id="钱学长"><a class="header-anchor" href="#钱学长"> </a>钱学长</h2>
<p><strong>2020.3</strong></p>
<ul>
<li>暑期实习生简历 投递</li>
<li>春季招聘</li>
</ul>
<p><strong>07月</strong></p>
<ul>
<li>暑期实习开始</li>
</ul>
<p><strong>09月</strong></p>
<ul>
<li>暑期结束，秋招开始</li>
</ul>
<h2 id="宋晋瑜学长"><a class="header-anchor" href="#宋晋瑜学长"> </a>宋晋瑜学长</h2>
<h3 id="前端"><a class="header-anchor" href="#前端"> </a>前端</h3>
<ul>
<li>web应用开发</li>
<li>组件开发</li>
<li>多端开发
<ul>
<li>移动端客户端 nodejs</li>
</ul>
</li>
<li>数据可视化</li>
</ul>
<p>面向用户的<strong>可交互</strong>的应用程序</p>
<h3 id="学习路线"><a class="header-anchor" href="#学习路线"> </a>学习路线</h3>
<ul>
<li>根据相关大厂的招聘要求去看看有什么要求（学长PPT上按官网的岗位要求来将）</li>
<li>基础知识</li>
<li>前端基础：三大件。。。。</li>
<li>组件</li>
<li>后台 计算机协议</li>
<li>typescript</li>
</ul>
<p>不同岗位有不同要求</p>
<h3 id="第一阶段"><a class="header-anchor" href="#第一阶段"> </a>第一阶段</h3>
<ol>
<li>基础（计算机专业课：计网、操作系统、算法）</li>
<li>三大件：语法 编写样式  异步请求等等</li>
<li>jquery  bootstrap</li>
</ol>
<h3 id="第二阶段"><a class="header-anchor" href="#第二阶段"> </a>第二阶段</h3>
<ol>
<li>HTML5、CSS3、ES6+
<ul>
<li>掌握牢、原理</li>
</ul>
</li>
<li>版本控制、web安全、包管理器（npm等）、CSS相关技术</li>
<li>UI框架（至少掌握一种：Vue React angular）</li>
<li>了解构建打包工具，如webpack等</li>
<li>仓库框架</li>
<li>部署</li>
</ol>
<h3 id="第三阶段"><a class="header-anchor" href="#第三阶段"> </a>第三阶段</h3>
<p>框架源码</p>
<ul>
<li>vue react等等</li>
</ul>
<p>web性能优化</p>
<p>typescript、node.js</p>
<p>node框架 SSR框架</p>
<p>PWA、小程序、Chrome插件、油猴插件</p>
<p>补充：</p>
<ul>
<li>图形学</li>
<li>动效</li>
<li>可视化</li>
<li>游戏</li>
</ul>
<h3 id="学习资源"><a class="header-anchor" href="#学习资源"> </a>学习资源</h3>
<ul>
<li>b站</li>
<li><strong>掘金</strong></li>
<li><strong>MDN</strong></li>
<li>菜鸟教程</li>
<li>segment fault</li>
<li>csdn</li>
<li>codepen</li>
<li>google baidu</li>
</ul>
<h3 id="面试经验"><a class="header-anchor" href="#面试经验"> </a>面试经验</h3>
<p>了解js深度决定能做得多深</p>
<p>面试会问js实现的原理（底层）</p>
<h3 id="总结"><a class="header-anchor" href="#总结"> </a>总结</h3>
<p><strong>重视基础</strong></p>
<p><strong>丰富项目</strong></p>
<p><strong>多看面经</strong></p>
<p>项目很重要：可以硬挖，可以跟面试官讲很久</p>
<ul>
<li>不一定网站，其他前端形式也可以</li>
</ul>
<p>面经作为补充基础的方式，对面试帮助非常大</p>
<p>软实力：</p>
<ul>
<li>
<p>技术博客</p>
</li>
<li>
<p>持续提交的github</p>
</li>
</ul>
]]></content>
      <categories>
        <category>大学时代</category>
      </categories>
      <tags>
        <tag>就业</tag>
        <tag>大学时代</tag>
      </tags>
  </entry>
  <entry>
    <title>挑战程序设计2-Areas on the cross-Section diagram</title>
    <url>/2020/10/30/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12-Areas-on-the-cross-Section-diagram/</url>
    <content><![CDATA[<h2 id="Areas-on-the-cross-Section-diagram-计算面积"><a class="header-anchor" href="#Areas-on-the-cross-Section-diagram-计算面积"> </a>Areas on the cross-Section diagram 计算面积</h2>
<!-- more -->
<p><img src="http://algorithm-image.qibinaoe.top/%E9%A2%98%E7%9B%AE.jpg" alt="题目"></p>
<h4 id="解题思路-v90"><a class="header-anchor" href="#解题思路-v90"> </a>解题思路</h4>
<p>这题解法有很多，书上使用的是用两个栈来储存面积</p>
<p>首先定义一个栈S1用于存放<code>\</code>的位置(数字)，当遇到<code>/</code>的时候，弹出栈顶。将<code>\</code>和<code>/</code>的位置相减即为该行的面积。当遇到<code>_</code>的时候，不用去理，因为<code>_</code>只是增加了<code>\</code>和<code>/</code>两个之间的距离，对于其他没有影响。</p>
<p>对于计算总面积，只需要将上面将计算每一小行的面积进行累加，即可得到总面积。而如果要计算单个区域面积，则要进行如下进一步讨论。</p>
<ol>
<li>声明一个栈S2用于存放每一个小区域的面积，以及最左边的<code>\</code>，因为该面积的围成区域是由左右两边的<code>\/</code>共同决定的，当遇到一个<code>/</code>，既可以确定一个小区域。</li>
<li>那问题来了，如何计算两个小区域是否为同一区域呢？可以发现，当右边<code>/</code>不断提高时，如果最左边<code>\</code>能够包括已经存在的<code>\</code>，换句话说，其位置范围更广，水能够淹没小区域形成大区域。那么就可以将小区域合并</li>
<li>合并的方法是判断S2中的小区域最左边的<code>\</code>与当前正在判断<code>\</code>的距离比较，如果新的能够包含旧的，则弹出S2顶，加入新的，直到栈中为空或则栈中不再能构成更大的区域。</li>
<li>也因为<code>3.</code>,所以S2应该储存一个数值对。</li>
</ol>
<h3 id="首先代码"><a class="header-anchor" href="#首先代码"> </a>首先代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStack</span><span class="params">(stack&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; s)</span></span>&#123;</span><br><span class="line">	pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; p = s.<span class="built_in">top</span>();</span><br><span class="line">	s.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="keyword">if</span>(!s.<span class="built_in">empty</span>()) <span class="built_in">printStack</span>(s);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>,p.second);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//计算面积方式，&#x27;\&#x27;与&#x27;/&#x27;相匹配，位置之差为面积 </span></span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; S1; <span class="comment">//存放&#x27;\&#x27;的位置</span></span><br><span class="line">	stack&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; S2; <span class="comment">// 存放每一部分的面积以及其最左边的位置</span></span><br><span class="line">	<span class="type">int</span> position = <span class="number">0</span>; <span class="comment">//记录当前位置</span></span><br><span class="line">	string sentence;</span><br><span class="line">	cin &gt;&gt; sentence;</span><br><span class="line">	<span class="type">int</span> totalSquare = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; sentence.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">char</span> cur = sentence[i];</span><br><span class="line">		<span class="keyword">if</span>(cur == <span class="string">&#x27;\\&#x27;</span>)&#123;</span><br><span class="line">			S1.<span class="built_in">push</span>(position);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur == <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">			<span class="comment">//计算该行面积，</span></span><br><span class="line">			<span class="keyword">if</span>(!S1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">				<span class="type">int</span> lastPosition = S1.<span class="built_in">top</span>();</span><br><span class="line">				S1.<span class="built_in">pop</span>();</span><br><span class="line">				<span class="type">int</span> curSquare = position - lastPosition;</span><br><span class="line">				totalSquare += curSquare;</span><br><span class="line">				<span class="keyword">if</span>(S2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">					S2.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(lastPosition,curSquare));	</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="type">int</span> curTotal = curSquare;</span><br><span class="line">					pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; p;</span><br><span class="line">					<span class="keyword">while</span>(!S2.<span class="built_in">empty</span>()&amp;&amp;S2.<span class="built_in">top</span>().first &gt; lastPosition)&#123;</span><br><span class="line">						p = S2.<span class="built_in">top</span>();</span><br><span class="line">						S2.<span class="built_in">pop</span>();</span><br><span class="line">						curTotal += p.second;</span><br><span class="line">					&#125;</span><br><span class="line">					S2.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(lastPosition,curTotal));</span><br><span class="line">				&#125;  </span><br><span class="line">			&#125;</span><br><span class="line">			 </span><br><span class="line">		&#125;</span><br><span class="line">		position++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,totalSquare);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,S2.<span class="built_in">size</span>());</span><br><span class="line">	<span class="built_in">printStack</span>(S2);</span><br><span class="line">	 </span><br><span class="line">	 </span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//\\///\_/\/\\\\/_/\\///__\\\_\\/_\/_/\</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="其他话"><a class="header-anchor" href="#其他话"> </a>其他话</h3>
<ul>
<li>打印栈</li>
</ul>
<p>本题要求输出每个小面积，而我们该算法中小面积是储存在栈中，因此需要打印逆序栈。对于我使用的方法，我通过递归方式去打印栈，但是这样会造成空间浪费。而对于书本给出的解法是通过遍历栈并同时存入vector，然后反转vector并打印出来</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">while</span>(S2.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">	ans.<span class="built_in">push_back</span>(S2.<span class="built_in">top</span>().second);</span><br><span class="line">	S2.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; ans.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; ans[i];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>挑战程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>挑战程序设计2-STL</title>
    <url>/2020/10/28/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12-STL/</url>
    <content><![CDATA[<h2 id="挑战程序设计2-STL-简单介绍"><a class="header-anchor" href="#挑战程序设计2-STL-简单介绍"> </a>挑战程序设计2 STL 简单介绍</h2>
<!-- more -->
<hr>
<h2 id="容器"><a class="header-anchor" href="#容器"> </a>容器</h2>
<h3 id="注意点"><a class="header-anchor" href="#注意点"> </a>注意点</h3>
<ul>
<li><em><strong>每个容器的插入的函数不尽相同，返回头元素的函数也不尽相同，需要注意</strong></em></li>
</ul>
<h3 id="栈stack"><a class="header-anchor" href="#栈stack"> </a>栈stack</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//导入栈的包 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//声明int类型元素的栈 </span></span><br><span class="line">	stack&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* size() 返回栈的元素个数      O(1) </span></span><br><span class="line"><span class="comment">	* top() 返回栈顶的元素			O(1)</span></span><br><span class="line"><span class="comment">	* pop() 从栈中取出并删除元素 	O(1)</span></span><br><span class="line"><span class="comment">	* push(x) 向栈添加元素x 		O(1)</span></span><br><span class="line"><span class="comment">	* empty() 在栈为空的时候返回true O(1)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	S.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">	S.<span class="built_in">push</span>(<span class="number">7</span>);	</span><br><span class="line">	S.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; S.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; S.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	S.<span class="built_in">pop</span>();</span><br><span class="line">	cout &lt;&lt; S.<span class="built_in">top</span>() &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h3 id="队列-queue"><a class="header-anchor" href="#队列-queue"> </a>队列 queue</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//导入queue包 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//声明元素类型为string的队列 </span></span><br><span class="line">	queue&lt;string&gt; Q;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* size() 返回队列的元素数  O(1) </span></span><br><span class="line"><span class="comment">	* push(x) 向队列添加元素x O(1) </span></span><br><span class="line"><span class="comment">	* front() 返回队头元素  O(1) </span></span><br><span class="line"><span class="comment">	* empty() 当队列为空的时候返回true O(1) </span></span><br><span class="line"><span class="comment">	* pop() 从队列中取出并删除元素 O(1) </span></span><br><span class="line"><span class="comment">	**/</span></span><br><span class="line">	</span><br><span class="line">	Q.<span class="built_in">push</span>(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">	Q.<span class="built_in">push</span>(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">	Q.<span class="built_in">push</span>(<span class="string">&quot;green&quot;</span>);</span><br><span class="line">	Q.<span class="built_in">pop</span>();</span><br><span class="line">	cout &lt;&lt; Q.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="comment">//注 pair在头文件 &lt;utility&gt; </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,q,t;</span><br><span class="line">	string name;</span><br><span class="line">	</span><br><span class="line">	queue&lt;pair&lt;string,<span class="type">int</span>&gt;&gt; Q; <span class="comment">//任务队列</span></span><br><span class="line">	cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		cin &gt;&gt; name &gt;&gt; t;</span><br><span class="line">		Q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(name,t));</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	pair&lt;string,<span class="type">int</span>&gt; u;</span><br><span class="line">	<span class="type">int</span> elaps = <span class="number">0</span>,a;</span><br><span class="line">	<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">	<span class="comment">//注意STL中pop不返回值</span></span><br><span class="line">	<span class="comment">//这样做是为了异常安全 exception safety</span></span><br><span class="line">	<span class="comment">//因此需要分两步进行操作,同时也能提高性能</span></span><br><span class="line">	<span class="comment">//而返回的u = Q.front() ,对u进行修改，也能修改队列里面的元素，而不需要重新push进去 </span></span><br><span class="line">		u = Q.<span class="built_in">front</span>();</span><br><span class="line">		Q.<span class="built_in">pop</span>(); </span><br><span class="line">		a = <span class="built_in">min</span>(u.second,q);</span><br><span class="line">		elaps += a;</span><br><span class="line">		u.second -= a;</span><br><span class="line">		<span class="keyword">if</span>(u.second &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			Q.<span class="built_in">push</span>(u);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			cout &lt;&lt; u.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; u.second; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="以上代表注意点"><a class="header-anchor" href="#以上代表注意点"> </a>以上代表注意点</h3>
<ol>
<li>
<p>STL中队列和栈，<code>pop</code>不返回值，而是要先<code>front</code>获取元素后再pop出来</p>
</li>
<li>
<p>STL中pair是用于保存数值的结构体模板，注意是结构体不是类，因此访问的时候，对于第1个元素通过<code>.first</code>访问，第2个元素通过<code>.second</code>访问。同时make_pair()用于生成一对数值，注意是圆括号不是尖括号</p>
</li>
</ol>
<hr>
<h3 id="vector-向量"><a class="header-anchor" href="#vector-向量"> </a>vector 向量</h3>
<p>vector属于动态数组或者说边长数组，即添加元素的时候能够增加长度；而必须事先指定长度，只能容纳一定数量元素的叫做静态数组</p>
<h4 id="注意-v3"><a class="header-anchor" href="#注意-v3"> </a>注意</h4>
<p><code>begin()</code>返回的是指向元素的迭代器，而<code>end()</code>返回的是指向末尾元素的后一个位置的迭代器，不指向元素</p>
<h4 id="知识点总结"><a class="header-anchor" href="#知识点总结"> </a>知识点总结</h4>
<ul>
<li>vector在内存中是分配一段连续的内存空间进行储存，(<strong>分配多大？</strong>),因此才有<code>.capacity()这个函数</code>来访问总的容量，当超过该空间后需要重新分配一段新的空间。</li>
<li>动态的进行<code>push_back()</code>和<code>pop_back()</code>操作</li>
<li>像数组一样，通过<code>[]</code>操作符进行访问元素<br>
<em><strong>但是</strong></em></li>
<li>在内部插入效率低，需要挪动空间</li>
<li>只能在尾部进行插入和删除，不能在头部进行push 和 pop</li>
</ul>
<h4 id="总之"><a class="header-anchor" href="#总之"> </a>总之</h4>
<p>vector适合高效率随机访问的场景，不适合频繁的在内部插入删除操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">double</span>&gt; V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; V.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">		<span class="comment">//vector可以通过&quot;[]&quot;运算符，像数组一样访问（赋值或写入） </span></span><br><span class="line">		cout &lt;&lt; V[i] &lt;&lt; <span class="string">&quot;  &quot;</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* size() 返回向量元素数 O(1) </span></span><br><span class="line"><span class="comment">	* push_back(x) 向向量末尾添加元素x  O(1) </span></span><br><span class="line"><span class="comment">	* pop_back() 删除向量最后一个元素  O(1) </span></span><br><span class="line"><span class="comment">	* begin() 返回指向向量开头的迭代器  O(1)</span></span><br><span class="line"><span class="comment">	* end() 返回指向向量末尾(***最后一个元素的后一个位置***)的迭代器 O(1)</span></span><br><span class="line"><span class="comment">	* insert(p,x) 在向量的位置p处插入元素x O(n)</span></span><br><span class="line"><span class="comment">	* erase(p) 删除向量中位置p的元素  O(n)</span></span><br><span class="line"><span class="comment">	* clear() 删除向量中所有元素 O(n) </span></span><br><span class="line"><span class="comment">	* </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">//vector</span></span><br><span class="line">	vector&lt;<span class="type">double</span>&gt; V;</span><br><span class="line">	V.<span class="built_in">push_back</span>(<span class="number">0.1</span>);</span><br><span class="line">	V.<span class="built_in">push_back</span>(<span class="number">0.2</span>);</span><br><span class="line">	V.<span class="built_in">push_back</span>(<span class="number">0.3</span>);</span><br><span class="line">	V[<span class="number">1</span>] = <span class="number">0.4</span>;</span><br><span class="line">	<span class="built_in">print</span>(V);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	V.<span class="built_in">insert</span>(V.<span class="built_in">begin</span>()+<span class="number">2</span>,<span class="number">0.8</span>);</span><br><span class="line">	<span class="built_in">print</span>(V); </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//注意这里是左闭右开 ，即删除 begin()+1  begin()+2 </span></span><br><span class="line">	V.<span class="built_in">erase</span>(V.<span class="built_in">begin</span>()+<span class="number">1</span>,V.<span class="built_in">begin</span>()+<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">print</span>(V);</span><br><span class="line">	V.<span class="built_in">push_back</span>(<span class="number">0.11</span>);</span><br><span class="line">	V.<span class="built_in">push_back</span>(<span class="number">0.12</span>);</span><br><span class="line">	V.<span class="built_in">push_back</span>(<span class="number">0.13</span>);</span><br><span class="line">	V.<span class="built_in">push_back</span>(<span class="number">0.14</span>);</span><br><span class="line">	V.<span class="built_in">erase</span>(V.<span class="built_in">begin</span>()+<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">print</span>(V);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*输出</span></span><br><span class="line"><span class="comment">	0.1  0.4  0.3</span></span><br><span class="line"><span class="comment">	0.1  0.4  0.8  0.3</span></span><br><span class="line"><span class="comment">	0.1  0.3</span></span><br><span class="line"><span class="comment">	0.1  0.3  0.12  0.13  0.14</span></span><br><span class="line"><span class="comment">	*/</span> </span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="list-双向链表"><a class="header-anchor" href="#list-双向链表"> </a>list 双向链表</h3>
<h4 id="感想"><a class="header-anchor" href="#感想"> </a>感想</h4>
<pre><code>感觉list是vector的超集，很多vector有的功能，list都有，除此之外，相比于vector,list的`insert(p,x)`和`erase(p)`的时间复杂度是O（1）,而vector是 O(n)
</code></pre>
<h4 id="问题-v4"><a class="header-anchor" href="#问题-v4"> </a>问题</h4>
<ol>
<li>为什么list的在指定位置插入和删除比vector快
<ul>
<li>答：因为vector插入删除需要挪动内存空间的元素，而list只需要修改相邻结点的指向</li>
</ul>
</li>
<li>list能够通过<code>[]</code>直接进行访问吗？
<ul>
<li>答：不能</li>
</ul>
</li>
</ol>
<hr>
<p>这里书本有误？<br>
<img src="http://algorithm-image.qibinaoe.top/list%E7%94%A8%5B%5D%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE.jpg" alt="挑战程序2第85页"></p>
<hr>
<h4 id="注意-v4"><a class="header-anchor" href="#注意-v4"> </a>注意</h4>
<ul>
<li>以<code>int</code>举例，<code>begin()</code>返回迭代器的是<code>list&lt;int&gt;::iterator</code></li>
<li>获得迭代器元素用解引用符<code>*</code>，比如<code>*it</code></li>
</ul>
<h4 id="知识点总结-v2"><a class="header-anchor" href="#知识点总结-v2"> </a>知识点总结</h4>
<ul>
<li>list底层是带头结点的双向循环链表实现（参考<a href="https://blog.csdn.net/Shuffle_Ts/article/details/98493475">CSDN博客STL中vector和list的区别</a>）,因此字在内存中不是连续空间</li>
<li>list不支持随机访问</li>
<li>list插入和删除效率高，只需要改变相邻的两个结点的指向</li>
<li>可以在链表的两端进行push和pop操作</li>
</ul>
<h4 id="总之-v2"><a class="header-anchor" href="#总之-v2"> </a>总之</h4>
<p>list适合大量插入删除操作的场景，不适合随机访问。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//list是双向链表 </span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* size()  返回表的元素数  O(1) </span></span><br><span class="line"><span class="comment">	* begin()  返回指向表开头的迭代器  O(1) </span></span><br><span class="line"><span class="comment">	* end()  返回指向表的末尾(最后一个元素的后一个位置)的迭代器  O(1) </span></span><br><span class="line"><span class="comment">	* push_front(x) 在表的开头添加元素x  O(1) </span></span><br><span class="line"><span class="comment">	* push_back(x)  在表的末尾添加元素x  O(1) </span></span><br><span class="line"><span class="comment">	* pop_front() 删除位于表的开头的元素  O(1) </span></span><br><span class="line"><span class="comment">	* pop_back()  删除位于表的结尾的元素 O(1) </span></span><br><span class="line"><span class="comment">	* insert(p,x)  在表的位置p插入元素x O(1)  ??为什么呢 与vector区别在哪里 </span></span><br><span class="line"><span class="comment">	* erase(p)  删除表中位置p的元素 O(1) </span></span><br><span class="line"><span class="comment">	* clear()  删除表中的所有元素 O(n) </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	list&lt;<span class="type">char</span>&gt; L;</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">	cout &lt;&lt; L.<span class="built_in">front</span>();</span><br><span class="line">	cout &lt;&lt; L.<span class="built_in">back</span>();</span><br><span class="line">	</span><br><span class="line">	L.<span class="built_in">pop_front</span>();</span><br><span class="line">	L.<span class="built_in">push_back</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">	<span class="comment">//char temp = L[0]; 这样会报错 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<hr>
<h2 id="搜索"><a class="header-anchor" href="#搜索"> </a>搜索</h2>
<h3 id="迭代器-iterator"><a class="header-anchor" href="#迭代器-iterator"> </a>迭代器 iterator</h3>
<p>迭代器是一种对象，用于对STL容器进行迭代操作。对于任何种类的容器，迭代器顺序访问元素使用的语法相同。在处理数组元素时，可以当作C/C++指针来用</p>
<h4 id="迭代器基本运算符"><a class="header-anchor" href="#迭代器基本运算符"> </a>迭代器基本运算符</h4>
<ul>
<li><code>++</code> 让迭代器指向下一个元素</li>
<li><code>==,!=</code> 判断两个迭代器是否指向同一个位置并返回结果</li>
<li><code>=</code> 将右侧的值带入左侧迭代器所引用元素的位置</li>
<li><code>*</code> 返回该位置的元素</li>
</ul>
<h4 id="迭代器函数"><a class="header-anchor" href="#迭代器函数"> </a>迭代器函数</h4>
<ul>
<li><code>begin()</code> 返回指向容器开头的迭代器</li>
<li><code>end()</code> 返回指向容器末尾（最后一个元素的下一个位置）的迭代器</li>
</ul>
<h4 id="迭代器使用示例代码"><a class="header-anchor" href="#迭代器使用示例代码"> </a>迭代器使用示例代码</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//迭代器使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span>(it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">		cout &lt;&lt; *it;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> N = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		v.<span class="built_in">push_back</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>();	</span><br><span class="line">	*it = <span class="number">3</span>;</span><br><span class="line">	it++;</span><br><span class="line">	(*it)++;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">print</span>(v);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="二分搜索"><a class="header-anchor" href="#二分搜索"> </a>二分搜索</h3>
<p>STL在二分搜索提供了<code>binary_search</code>、<code>lower_bound</code>、<code>upper_bound</code>函数。这几个函数的使用的前提是数组是有序且非递减。包含在头文件<code>#include&lt;algorithm&gt;</code>中</p>
<h4 id="lower-bound"><a class="header-anchor" href="#lower-bound"> </a>lower_bound</h4>
<p>lower_bound(起始地址，结束地址，查询值),注意是左开右闭。返回一个迭代器(指针)，该指针指向第一个大于或等于（或者说不小于）指定值的元素的地址。<br>
例如lower_bound(A,A+14,3)，指定数组A的头指针以及距离头指针14的位置，一般为数组的长度A+size。如果A为vector，则可以使用A.begin(),A.end()来指定范围。</p>
<h4 id="upper-bound"><a class="header-anchor" href="#upper-bound"> </a>upper_bound</h4>
<p>upper_bound(起始地址，结束地址，查询值),注意是左开右闭。返回一个迭代器(指针)，该指针指向第一个大于指定值的元素的地址。</p>
<h4 id="binary-search"><a class="header-anchor" href="#binary-search"> </a>binary_search</h4>
<p>binary_search(起始地址，结束地址，查询值),注意是左开右闭。找到元素返回真，找不到返回假.</p>
<p><code>distance()</code>用于返回两个指针间的距离</p>
<h4 id="lower-bound示例"><a class="header-anchor" href="#lower-bound示例"> </a>lower_bound示例</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> A[<span class="number">14</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">15</span>&#125;;</span><br><span class="line">	<span class="type">int</span> *pos;</span><br><span class="line">	<span class="type">int</span> idx;</span><br><span class="line">	pos = <span class="built_in">lower_bound</span>(A,A+<span class="number">14</span>,<span class="number">3</span>);</span><br><span class="line">	idx = <span class="built_in">distance</span>(A,pos);</span><br><span class="line">	cout &lt;&lt; idx &lt;&lt; <span class="string">&quot;  &quot;</span>&lt;&lt;*pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>挑战程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>挑战程序设计2-初等排序</title>
    <url>/2020/10/06/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12-%E5%88%9D%E7%AD%89%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="第二章初等算法"><a class="header-anchor" href="#第二章初等算法"> </a>第二章初等算法</h1>
<h2 id="插入排序"><a class="header-anchor" href="#插入排序"> </a>插入排序</h2>
<!-- more -->
<p>插入排序一个很生动的比喻就是玩扑克牌时，整理自己手中牌的情景，只不过是从左到，从小到大（当然从大到小也可以）。对于插入排序的思路是分为已排序部分和未排序部分，未排序部分在左边，然后不断往右扩充。</p>
<h3 id="思路"><a class="header-anchor" href="#思路"> </a>思路</h3>
<p>（这里i从0开始）<br>
首先从第i=1张牌开始,因为i=0这张牌默认是已排序的。基本思路是先取出第i张牌，腾出一个空位，同时保存<code>A[i]</code>的值，即<code>val = i</code>。然后开始为i之前的牌中，寻找适合i的位置,因此这需要一次遍历，并且是从后往前遍历。所以<code>j = i - 1</code>来开始第二层循环，并且通过判断<code>j &gt;= 0 &amp;&amp; A[j] &gt; val</code>来判断，记住<code>j+1</code>的位置始终是空的，因此我们通过判断<code>A[j]</code>和<code>val</code>(原本的<code>A[i]</code>)的大小来决定是谁填入<code>j+1</code>的这个坑。并且一直遍历下去，如果遍历到j=-1的时候说明j&gt;=0的位置的数字都比val大，而(j+1)为0，即<code>A[0]</code>这个位置填入<code>val</code></p>
<h3 id="稳定性"><a class="header-anchor" href="#稳定性"> </a>稳定性</h3>
<p>因为该算法只会挪动值比val大的值，而不会去挪动与val相等的值，因此具有稳定性</p>
<h3 id="复杂度"><a class="header-anchor" href="#复杂度"> </a>复杂度</h3>
<p>可以看出这两层循环因此最差情况需要O(n^2),(粗略估计，实际要去算的话，最差是1+2+…+N-1)，而最好情况就是所有都是有序的，因此只需遍历第一层循环就好了。</p>
<h3 id="代码"><a class="header-anchor" href="#代码"> </a>代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//插入排序insertionSort</span></span><br><span class="line">	<span class="type">int</span> N = <span class="number">6</span>;</span><br><span class="line">	<span class="type">int</span> A[] = &#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//从左到右 从小到大排序 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> m = <span class="number">0</span>; m &lt; N; m++)&#123;</span><br><span class="line">				cout &lt;&lt; A[m] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			&#125; </span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">		<span class="comment">// i 为要寻找位置的数字的数字 </span></span><br><span class="line">		<span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//首先记录i的数字，腾出位置 </span></span><br><span class="line">		<span class="type">int</span> val = A[i];</span><br><span class="line">		<span class="comment">//j为i之前所有位置 </span></span><br><span class="line">		<span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; A[j]&gt;val)&#123;</span><br><span class="line">			<span class="comment">//该循坏条件代表，在所有i之前的j的数字</span></span><br><span class="line">			<span class="comment">//如果比val值大的位置，应该向右挪</span></span><br><span class="line">			<span class="comment">//此时A[j+1]的位置是空的，因为i的位置已经记录了。</span></span><br><span class="line">			A[j+<span class="number">1</span>] = A[j];</span><br><span class="line">			j--; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//此时j以及j之前的位置，要么不存在，要么都比val小，</span></span><br><span class="line">		<span class="comment">//而j+1的位置是空的，j+1往后的位置比val大，所以j+1的位置填入val</span></span><br><span class="line">		A[j+<span class="number">1</span>] = val; </span><br><span class="line">		<span class="comment">//输出每一步骤的改变</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> m = <span class="number">0</span>; m &lt; N; m++)&#123;</span><br><span class="line">		cout &lt;&lt; A[m] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<hr>
<hr>
<h2 id="冒泡排序"><a class="header-anchor" href="#冒泡排序"> </a>冒泡排序</h2>
<p>冒泡排序就像水中冒泡泡一样，如果想要从左到右，从小到大的话，即每一次遍历，将最小的往最左边移动，因此能够保证最最左边是有序的，而有序的个数跟遍历的次数有关，而最右边不一定保证有序，因此，每一次内层遍历都得从最右边开始。同时，如果在一次内层遍历中，若没有发生元素交换，说明右边无序的部分其实已经是有序的，这时候可以结束算法。</p>
<h3 id="稳定性-v2"><a class="header-anchor" href="#稳定性-v2"> </a>稳定性</h3>
<p>在内层交换中，使用的是<code>A[j] &lt; A[j-1]</code>，因此是稳定的，如果使用<code>(A[j] &lt;= A[j-1]</code>则不稳定</p>
<h3 id="复杂度-v2"><a class="header-anchor" href="#复杂度-v2"> </a>复杂度</h3>
<p>对于最坏的情况也是需要O(n^2)</p>
<h3 id="小知识"><a class="header-anchor" href="#小知识"> </a>小知识</h3>
<p>冒泡排序中的交换次数又称为反序数或逆序数，可体现数列的错乱程度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//冒泡排序 Bubble Sort</span></span><br><span class="line">	<span class="comment">//冒泡排序的思路就是将最小的泡泡往前浮</span></span><br><span class="line">	<span class="type">int</span> N = <span class="number">5</span>;</span><br><span class="line">	<span class="type">int</span> A[] = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//最外层循环 </span></span><br><span class="line">	<span class="comment">//1. int i = 0; i&lt;N; i++</span></span><br><span class="line">	<span class="comment">//2. int i = 0; flag; i++</span></span><br><span class="line">	<span class="comment">//如果一次遍历中，都没有交换，说明后半部分已经是有序的，可以结束遍历 </span></span><br><span class="line">	<span class="type">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; flag; i++)&#123;</span><br><span class="line">		Sflag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = N<span class="number">-1</span>; j &gt; i; j--)&#123;</span><br><span class="line">			<span class="comment">// 判断j是不是最小的泡泡，如果是，往前飘</span></span><br><span class="line">			<span class="keyword">if</span>(A[j] &lt; A[j<span class="number">-1</span>])&#123;</span><br><span class="line">				<span class="comment">//交换</span></span><br><span class="line">				<span class="type">int</span> temp = A[j];</span><br><span class="line">				A[j] = A[j<span class="number">-1</span>];</span><br><span class="line">				A[j<span class="number">-1</span>] = temp; </span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> m = <span class="number">0</span>; m &lt; N; m++)&#123;</span><br><span class="line">		cout &lt;&lt; A[m] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<h2 id="选择排序"><a class="header-anchor" href="#选择排序"> </a>选择排序</h2>
<p>按照从左到右从小打大的排序，即升序来看。选择排序即选择一个最小值放在最左边，它是一种放眼大局来选择一个最小值的，这一点和插入排序不同。插入排序是局部入手减小逆序列。<br>
懂得选择排序的思想写出来就比较简单了，也是左边的是排序部分，右边是未排序部分，而每一次从未排序部分中挑一个最小值，放在排序部分(<code>i</code>)的位置，并且将原来i位置的值，交换到其位置。</p>
<h3 id="稳定性-v3"><a class="header-anchor" href="#稳定性-v3"> </a>稳定性</h3>
<p>由于选择排序是直接交换两个不相邻的元素，所以是不稳定排序，例如（3H 5S 3D 1S）。对于3H 3D，排序后相对位置顺序发生了改变。</p>
<h3 id="复杂度-v3"><a class="header-anchor" href="#复杂度-v3"> </a>复杂度</h3>
<p>O(n^2)</p>
<h3 id="代码-v2"><a class="header-anchor" href="#代码-v2"> </a>代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//选择排序 selection sort</span></span><br><span class="line">	<span class="comment">//从左到右从小到大</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> N = <span class="number">6</span>;</span><br><span class="line">	<span class="type">int</span> A[] = &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	<span class="comment">//选出最小的一个值，放在最左边</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">		<span class="type">int</span> minj = i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; N; j++)&#123;</span><br><span class="line">			<span class="comment">//只是为了找出最小值的位置，在这过程不需要交换 </span></span><br><span class="line">			<span class="keyword">if</span>(A[minj] &gt; A[j])&#123;</span><br><span class="line">				<span class="comment">//交换</span></span><br><span class="line">				minj = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//交换</span></span><br><span class="line">		<span class="type">int</span> tempVal = A[minj];</span><br><span class="line">		A[minj] = A[i];</span><br><span class="line">		A[i] = tempVal;</span><br><span class="line">		<span class="comment">//这样A[i]的值为最小值，然后可以向后继续，同时最左边为排序完的   </span></span><br><span class="line">	&#125; </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> m = <span class="number">0</span>; m &lt; N; m++)&#123;</span><br><span class="line">		cout &lt;&lt; A[m] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<h2 id="希尔排序"><a class="header-anchor" href="#希尔排序"> </a>希尔排序</h2>
<p>希尔排序是插入排序的一种改进，通过借助插入排序可以告诉的处理顺序较为整齐的数据，因此希尔排序先通过将整体的顺序整理得相对整齐，再最后一次进行普通的插入排序。<br>
因此算法中的g其实相当于插入排序的1<br>
(注意g不要超过n)</p>
<h3 id="稳定性-v4"><a class="header-anchor" href="#稳定性-v4"> </a>稳定性</h3>
<p>希尔排序因为除了最后一次插入排序，其他大于1的间隔的排序，会导致其不稳定，因此希尔排序是不稳定的。</p>
<h3 id="复杂度-v4"><a class="header-anchor" href="#复杂度-v4"> </a>复杂度</h3>
<p>希尔排序当g = 1,4,13,40,121 (g<sub>n+1</sub> = 3g<sub>n</sub> +1) 其复杂度基本维持在O(N<sup>1.25</sup>),但是当遇到2的幂指数的是时候（1，2，4，8…），希尔排序效率大打折扣。</p>
<h3 id="代码-v3"><a class="header-anchor" href="#代码-v3"> </a>代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//希尔排序 shell sort</span></span><br><span class="line">	<span class="type">int</span> N = <span class="number">5</span>;</span><br><span class="line">	<span class="type">int</span> A[] = &#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> m = <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> G[] = &#123;<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//希尔排序本质是插入排序的升级版，只不过是间隔G[i]进行排序，这样做会导致</span></span><br><span class="line">	<span class="comment">//在一次排序中，会有(N/G[i])个小部分构成的整体是有序的，</span></span><br><span class="line">	<span class="comment">//其利用插入排序中，当大部分是有序的时候，其效率高的特点，因此先整体进行</span></span><br><span class="line">	<span class="comment">//排序，在最后一次间隔为1做最后的处理</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//这里的m是其排序的次数 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> p = <span class="number">0</span>; p &lt; m; p++)&#123;</span><br><span class="line">		<span class="type">int</span> g = G[p];</span><br><span class="line">		<span class="comment">//进行插入排序</span></span><br><span class="line">		<span class="comment">//i的初始值是第一个要比较的后一个，比如在普通的插入排序中，i的初始值是第二个数（从1开始），来比较第一个数,即i是第一个未排序的位置</span></span><br><span class="line">		 </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = g; i &lt; N; i++)&#123;</span><br><span class="line">			<span class="comment">// j是最后一个已排序的位置 </span></span><br><span class="line">			<span class="type">int</span> j = i - g;</span><br><span class="line">			<span class="comment">// val为需要放入已排序部分的值 </span></span><br><span class="line">			<span class="type">int</span> val = A[i];</span><br><span class="line">			<span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; A[j] &gt; val)&#123;</span><br><span class="line">				<span class="comment">//第一次的时候val的位置是一个坑，可以放东西，即j+g使坑，</span></span><br><span class="line">				<span class="comment">//在普通插入排序中，坑是j+1</span></span><br><span class="line">				A[j+g] = A[j];</span><br><span class="line">				<span class="comment">//比较的位置间隔g，因此不是j--而是j = j-g </span></span><br><span class="line">				j = j-g; </span><br><span class="line">			&#125;</span><br><span class="line">			A[j+g] = val;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> m = <span class="number">0</span>; m &lt; N; m++)&#123;</span><br><span class="line">		cout &lt;&lt; A[m] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	 </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>挑战程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>挑战程序设计2-初等数据结构-双向链表</title>
    <url>/2020/10/27/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12-%E5%88%9D%E7%AD%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="双向链表"><a class="header-anchor" href="#双向链表"> </a>双向链表</h2>
<hr>
<!-- more -->
<p>双向链表能够有以下功能</p>
<ul>
<li>insert x 在链表的开头插含有键值x的结点</li>
<li>delete x 删除第1个键值x的结点</li>
<li>deleteFirst 删除链表表头结点</li>
<li>deleteLast 删除链表的表尾结点</li>
</ul>
<hr>
<h4 id="问题："><a class="header-anchor" href="#问题："> </a>问题：</h4>
<ol>
<li>为什么需要一个特殊的头结点NIL呢（头结点不包含实际数据）</li>
<li>插入结点的先后顺序是怎么样的</li>
<li>删除结点的先后顺序是怎么样的</li>
<li>在遍历链表的时候，临时结点<code>Node *cur = cur-&gt;next;</code>为什么不需要开辟空间分配内存呢</li>
<li>malloc分配的空间是堆的吗?堆和栈的地址大小顺序如何？</li>
<li>头结点的值存的是什么？</li>
<li>C语言中什么时候会造成内存泄露？在函数中返回一个指针会造成泄露吗？</li>
</ol>
<h4 id="感悟："><a class="header-anchor" href="#感悟："> </a>感悟：</h4>
<p>这个版本的双向链表有种循环的感觉，即一个链表遍历到表尾后，表尾的<code>next</code>就是头结点，而头结点的<code>prev</code>是表尾。</p>
<hr>
<h3 id="C-代码实现"><a class="header-anchor" href="#C-代码实现"> </a>C++代码实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	Node* prev;</span><br><span class="line">	Node* next; <span class="comment">// 也可写作Node* prev,*next; </span></span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node *nil;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	nil = (Node *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">	<span class="comment">//将头结点的前后指向自己</span></span><br><span class="line">	nil-&gt;next = nil;</span><br><span class="line">	nil-&gt;prev = nil; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//从头插入结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//分配空间</span></span><br><span class="line">	Node* n = (Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">	n-&gt;key = val;</span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	n-&gt;next = nil-&gt;next;</span><br><span class="line">	n-&gt;prev = nil;</span><br><span class="line">	nil-&gt;next-&gt;prev = n;</span><br><span class="line">	nil-&gt;next = n;</span><br><span class="line"><span class="comment">//	return n;</span></span><br><span class="line"><span class="comment">//注意这里不可以返回n，因为n是在栈中分配空间的，返回会造成内存泄漏。?是吗？ </span></span><br><span class="line"><span class="comment">//那可怎么办？ </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//根据key搜索</span></span><br><span class="line"><span class="function">Node* <span class="title">listSearch</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Node* cur = nil-&gt;next;</span><br><span class="line">	<span class="comment">//注意这里要先判断是否为头结点，否则头结点的值是没有意义的 </span></span><br><span class="line">	<span class="keyword">while</span>(cur!=nil &amp;&amp; cur-&gt;key != key)&#123;</span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(Node* t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t == nil) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//先连后断</span></span><br><span class="line">	t-&gt;next-&gt;prev = t-&gt;prev;</span><br><span class="line">	t-&gt;prev-&gt;next = t-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(t); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第一个</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteFirstNode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">deleteNode</span>(nil-&gt;next);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//删除最后一个</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteLastNode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">deleteNode</span>(nil-&gt;prev);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//删除指定key</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteByKey</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">deleteNode</span>(<span class="built_in">listSearch</span>(key));</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//打印链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Node* cur = nil-&gt;next;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(cur!=nil)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,cur-&gt;key);</span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">		<span class="keyword">if</span>(cur!=nil)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;count);</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">initList</span>();</span><br><span class="line">	<span class="keyword">while</span>(n++ &lt; count)&#123;</span><br><span class="line">		<span class="type">char</span> order[<span class="number">20</span>];</span><br><span class="line">		<span class="type">int</span> key;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,order,&amp;key);</span><br><span class="line">		<span class="keyword">if</span>(order[<span class="number">0</span>] == <span class="string">&#x27;i&#x27;</span>)&#123;</span><br><span class="line">			<span class="built_in">insert</span>(key);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(order[<span class="number">0</span>] == <span class="string">&#x27;d&#x27;</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strlen</span>(order) &gt; <span class="number">6</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(order[<span class="number">6</span>] == <span class="string">&#x27;F&#x27;</span>)&#123;</span><br><span class="line">					<span class="built_in">deleteFirstNode</span>();</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="built_in">deleteLastNode</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="built_in">deleteByKey</span>(key);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printList</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="该版本链表算法复杂度"><a class="header-anchor" href="#该版本链表算法复杂度"> </a>该版本链表算法复杂度</h3>
<ul>
<li>删除：
<ul>
<li>删除链表头和链表尾 O(1)</li>
<li>删除指定键值 O(n)</li>
</ul>
</li>
<li>添加: O(1)</li>
<li>搜索: O(1)</li>
</ul>
<h3 id="问题回答-v2"><a class="header-anchor" href="#问题回答-v2"> </a>问题回答</h3>
<ol>
<li>为什么需要一个特殊的头结点NIL呢（头结点不包含实际数据）
<ul>
<li>答：头结点的数据一般无意义，但是也可以存放链表的长度，用作监视哨</li>
<li>对于单链表中，头结点能够使得单链表的插入和删除操作不需要区别是否为空表或者是否在第一个位置进行，保持单链表操作的一致性</li>
</ul>
</li>
<li>插入结点的先后顺序是怎么样的
<ul>
<li>先将要接上去的结点接到链表上，再修改原来链表上结点连接到新的节点</li>
</ul>
</li>
<li>删除结点的先后顺序是怎么样的
<ul>
<li>删除一个结点就是把它相领接的结点连接上，然后释放空间就可以了</li>
</ul>
</li>
<li>在遍历链表的时候，临时结点<code>Node *cur = cur-&gt;next;</code>为什么不需要开辟空间分配内存呢
<ul>
<li>我认为这里的<code>Node *cur</code>只是一个整形的数字（指针），指向一个指针的地址，不是要开辟一个新的内存来存放新的数据</li>
</ul>
</li>
<li>malloc分配的空间是堆的吗?堆和栈的地址大小顺序如何？
<ul>
<li><strong>这部分需要看书复习</strong></li>
<li>根据<img src="http://algorithm-image.qibinaoe.top/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4.jpg" alt="网上资料"> Linux的堆分配的地址比较低(靠近00)，栈的分配地址比较高(靠近0xFF)，但是栈的生长方向是由高地址向低地址生长，但注意在栈中分配的数组是提前开辟一段空间，从低地址向高地址放。而对于栈是从低地址向高地址生长。</li>
</ul>
</li>
<li>头结点的值存的是什么？
<ul>
<li>参考 1</li>
</ul>
</li>
<li>C语言中什么时候会造成内存泄露？在函数中返回一个指针会造成泄露吗？
<ul>
<li>仔细想想这不会发生内存泄露，因为他返回是一个栈的值，然后在调用它的函数中，有一个新的栈中的变量保存该返回回来的指针的地址，然后之前的栈就被回收，但是记得在释放堆中空间时，该指向地址的指针不能丢。</li>
</ul>
</li>
</ol>
<h4 id="优点"><a class="header-anchor" href="#优点"> </a>优点</h4>
<ul>
<li>链表结构能够克服数组需要预先知道数据大小的缺点，充分利用计算机内存空间</li>
</ul>
<h4 id="缺点"><a class="header-anchor" href="#缺点"> </a>缺点</h4>
<ul>
<li>失去了数组随机读取的优点，同时增加了结点的指针域，空间开销大</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>挑战程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>挑战程序设计2-初等数据结构-栈</title>
    <url>/2020/10/07/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12-%E5%88%9D%E7%AD%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</url>
    <content><![CDATA[<h2 id="初等数据结构——栈"><a class="header-anchor" href="#初等数据结构——栈"> </a>初等数据结构——栈</h2>
<h3 id="栈-Stack-v2"><a class="header-anchor" href="#栈-Stack-v2"> </a>栈 Stack</h3>
<!-- more -->
<p>栈可以内部可以通过数组或者是链表实现(目前我只知道这两种形式)。</p>
<p>栈具有LIFO(Last In first Out后入先出)的特点</p>
<h4 id="操作"><a class="header-anchor" href="#操作"> </a>操作</h4>
<ul>
<li>push(x) 在栈顶部添加元素x</li>
<li>pop() 从栈顶部取出元素</li>
<li>isEmpty() : 检查栈是否为空</li>
<li>isFull(): 检查栈是否已满</li>
</ul>
<h4 id="练习"><a class="header-anchor" href="#练习"> </a>练习</h4>
<p>逆波兰表示法</p>
<p>输入示例：<br>
1 2 + 3 4 - *</p>
<p>输出示例：<br>
-3</p>
<h4 id="代码实现-v6"><a class="header-anchor" href="#代码实现-v6"> </a>代码实现</h4>
<p><em><strong>我想了一会对于读取两位数及以上的数字没有办法，这个问题留下来思考一下。</strong></em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span> </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span>* head;</span><br><span class="line">	<span class="type">int</span> maxLength = <span class="number">2000</span>;</span><br><span class="line">	<span class="type">int</span> A[<span class="number">2000</span>];</span><br><span class="line">	<span class="type">int</span> curr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(curr&lt;maxLength)&#123;</span><br><span class="line">			A[curr] = val;</span><br><span class="line">			curr++;</span><br><span class="line">			<span class="keyword">return</span> curr;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(curr &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">//空的 </span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			curr--;</span><br><span class="line">			<span class="keyword">return</span> A[curr];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(curr &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(curr == maxLength)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//栈 stack </span></span><br><span class="line">	<span class="comment">//逆波兰表示法</span></span><br><span class="line">	</span><br><span class="line">	 MyStack s;</span><br><span class="line">	 string formula = <span class="string">&quot;1 2 + 3 4 - *&quot;</span>;</span><br><span class="line">	 <span class="type">int</span> size = formula.<span class="built_in">size</span>();</span><br><span class="line">	 <span class="type">int</span> num1,num2,result;</span><br><span class="line">	 <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">	 	<span class="type">char</span> cur;</span><br><span class="line">	 	cur = formula[i];</span><br><span class="line">	 	<span class="comment">//判断是否是数字 </span></span><br><span class="line">		<span class="keyword">if</span>(cur &gt;= <span class="number">48</span> &amp;&amp; cur &lt;=<span class="number">57</span>)&#123;</span><br><span class="line">			<span class="type">int</span> val = (<span class="type">int</span>)(cur - <span class="number">48</span>);</span><br><span class="line">			s.<span class="built_in">push</span>(val); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cur == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cur == <span class="string">&#x27;+&#x27;</span> )&#123;</span><br><span class="line">			num1 = s.<span class="built_in">pop</span>();</span><br><span class="line">			num2 = s.<span class="built_in">pop</span>();</span><br><span class="line">			result = num2 + num1;</span><br><span class="line">			s.<span class="built_in">push</span>(result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cur ==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">			num1 = s.<span class="built_in">pop</span>();</span><br><span class="line">			num2 = s.<span class="built_in">pop</span>();</span><br><span class="line">			result = num2 - num1;</span><br><span class="line">			s.<span class="built_in">push</span>(result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>( cur == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">			num1 = s.<span class="built_in">pop</span>();</span><br><span class="line">			num2 = s.<span class="built_in">pop</span>();</span><br><span class="line">			result = num2 * num1;</span><br><span class="line">			s.<span class="built_in">push</span>(result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>( cur ==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">			num1 = s.<span class="built_in">pop</span>();</span><br><span class="line">			num2 = s.<span class="built_in">pop</span>();</span><br><span class="line">			result = num2 / num1;</span><br><span class="line">			s.<span class="built_in">push</span>(result);</span><br><span class="line">		&#125;</span><br><span class="line">	 &#125;</span><br><span class="line">	 cout &lt;&lt; <span class="string">&quot;结果:&quot;</span> &lt;&lt; s.<span class="built_in">pop</span>() &lt;&lt; endl;</span><br><span class="line">	 </span><br><span class="line">	 <span class="comment">//该方法只能读取单个数字</span></span><br><span class="line">	 </span><br><span class="line">	 <span class="comment">//小知识点</span></span><br><span class="line">	 <span class="comment">//atoi是C语言的标准库，用来将字符串形式的数字转换成整型数值</span></span><br><span class="line">	  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="答案解法"><a class="header-anchor" href="#答案解法"> </a>答案解法</h4>
<p>答案的栈的形式跟我自己写的有些不同，答案的栈顶指向栈中的最后一个元素，而我的栈顶指向最后一个元素的后面，即没有元素。同时答案的第一个元素0是空的，从编号1开始存放元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> top, S[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    S[++top] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">    top--;</span><br><span class="line">    <span class="keyword">return</span> S[top+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//答案是边读入边处理</span></span><br><span class="line">    <span class="keyword">while</span>( <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s) != EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>( s[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">            a = pop();</span><br><span class="line">            b = pop();</span><br><span class="line">            push(a+b);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( s[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            b = pop();</span><br><span class="line">            a = pop();</span><br><span class="line">            push(a-b);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( s[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            a = pop();</span><br><span class="line">            b = pop();</span><br><span class="line">            push(a*b);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            push(atoi(s))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;%d\n&quot;</span>, pop());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>挑战程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>挑战程序设计2-初等数据结构-队列</title>
    <url>/2020/10/14/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12-%E5%88%9D%E7%AD%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="初等数据结构-队列Queue"><a class="header-anchor" href="#初等数据结构-队列Queue"> </a>初等数据结构-队列Queue</h2>
<!-- more -->
<h3 id="队列定义"><a class="header-anchor" href="#队列定义"> </a>队列定义</h3>
<p>队列Queue是一个等待处理的行列，按照先进先出(FIFO first in first out)的规则管理数据</p>
<h3 id="基本操作-v2"><a class="header-anchor" href="#基本操作-v2"> </a>基本操作</h3>
<ul>
<li>enqueue(x): 在队列末尾添加元素</li>
<li>dequeue(): 从队列开头去除元素</li>
<li>isEmpty(): 检查队列是否为空</li>
<li>isFull(): 检查队列是否已满</li>
</ul>
<h3 id="题目练习"><a class="header-anchor" href="#题目练习"> </a>题目练习</h3>
<p>题目有点长，详细请见P64页</p>
<h3 id="代码实现-v7"><a class="header-anchor" href="#代码实现-v7"> </a>代码实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Element</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Element</span>(string n,<span class="type">int</span> v):<span class="built_in">name</span>(n),<span class="built_in">val</span>(v)&#123;&#125;</span><br><span class="line">	<span class="comment">//对于这里，设计到C++类的知识</span></span><br><span class="line">	<span class="comment">//如果写了构造函数，就不会生成默认构造函数，但是这对于下面代码中使用</span></span><br><span class="line">	<span class="comment">//以该类形成的数组中，就会报错，因此还需要写一个参数为空的构造器 </span></span><br><span class="line">	<span class="built_in">Element</span>()&#123;&#125;;</span><br><span class="line">	~<span class="built_in">Element</span>()&#123;&#125;; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非循环队列 (顺序队列)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> length = <span class="number">100000</span>;</span><br><span class="line">	<span class="type">int</span> head = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> rear = <span class="number">0</span>;</span><br><span class="line">	Element *A = <span class="keyword">new</span> Element[<span class="number">100000</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyQueue</span>(<span class="type">int</span> len):<span class="built_in">length</span>(len)&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> head == rear;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rear == length<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">enqueue</span><span class="params">(Element e)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">isFull</span>())&#123;</span><br><span class="line">			A[rear] = e;</span><br><span class="line">			rear++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> rear;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Element <span class="title">dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">			head++;</span><br><span class="line">			<span class="keyword">return</span> A[head<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//队列 Queue</span></span><br><span class="line">	<span class="comment">//非循环队列</span></span><br><span class="line">	</span><br><span class="line">	<span class="function">MyQueue <span class="title">queue</span><span class="params">(<span class="number">100000</span>)</span></span>;</span><br><span class="line">	<span class="type">int</span> N = <span class="number">5</span>;</span><br><span class="line">	<span class="type">int</span> q = <span class="number">100</span>;</span><br><span class="line">	<span class="function">Element <span class="title">e1</span><span class="params">(string(<span class="string">&quot;p1&quot;</span>),<span class="number">150</span>)</span></span>;</span><br><span class="line">	<span class="function">Element <span class="title">e2</span><span class="params">(string(<span class="string">&quot;p2&quot;</span>),<span class="number">80</span>)</span></span>;</span><br><span class="line">	<span class="function">Element <span class="title">e3</span><span class="params">(string(<span class="string">&quot;p3&quot;</span>),<span class="number">200</span>)</span></span>;</span><br><span class="line">	<span class="function">Element <span class="title">e4</span><span class="params">(string(<span class="string">&quot;p4&quot;</span>),<span class="number">350</span>)</span></span>;</span><br><span class="line">	<span class="function">Element <span class="title">e5</span><span class="params">(string(<span class="string">&quot;p5&quot;</span>),<span class="number">20</span>)</span></span>;</span><br><span class="line">	queue.<span class="built_in">enqueue</span>(e1);</span><br><span class="line">	queue.<span class="built_in">enqueue</span>(e2);</span><br><span class="line">	queue.<span class="built_in">enqueue</span>(e3);</span><br><span class="line">	queue.<span class="built_in">enqueue</span>(e4);</span><br><span class="line">	queue.<span class="built_in">enqueue</span>(e5);</span><br><span class="line">	<span class="type">int</span> curTime = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!queue.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">		Element curE = queue.<span class="built_in">dequeue</span>();</span><br><span class="line">		<span class="type">int</span> curVal = curE.val;</span><br><span class="line">		<span class="keyword">if</span>(curVal &lt;= q)&#123;</span><br><span class="line">			curTime += curVal;</span><br><span class="line">			cout &lt;&lt; curE.name &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; curTime &lt;&lt; endl;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			curTime += q;</span><br><span class="line">			curE.val -= q;</span><br><span class="line">			queue.<span class="built_in">enqueue</span>(curE);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分析代码存在问题"><a class="header-anchor" href="#分析代码存在问题"> </a>分析代码存在问题</h3>
<pre><code>对于这道题，刚开始的时候不懂得循环队列怎么写，显然非循环队列容易造成空间浪费，形成“假满”的现象，因此考虑使用循环队列。

对于循环队列，还是通过一个数组来实现，而循环队列和非循环队列之间的差别在于，当`head`或者`tail`到达数组尾部时候，通过求模操作能够会到数组头部去。
</code></pre>
<h3 id="循环队列"><a class="header-anchor" href="#循环队列"> </a>循环队列</h3>
<p>对于循环队列，需要解决的两个问题就是<strong>如何判断队列为空</strong>以及<strong>如何判断队列为满</strong>，在顺序队列当中，这两个问题很好解决，即尾部<code>tail</code>到达数组长度为满，当头部<code>head</code>与尾部<code>tail</code>相等时，队列为空。</p>
<p>对于循环队列，当<code>head</code>与<code>tail</code>相等时，到底是为空还是满呢？为了解决问题，参考<a href="https://blog.csdn.net/smile_zhangw/article/details/80894159">CSDN博客</a>后其总结的方法有如下三种。</p>
<ol>
<li>
<p>设置标志位</p>
<p>可以设置初始化值位<code>0</code>，即代表空，当执行插入操作<code>enqueue</code>的时候，标志位置为<code>1</code>；当执行删除操作<code>dequeue</code>的时候，标志位置为0。这样，当判断<code>isEmpty()</code>的时候,如果前提条件<code>head == tail</code>满足，同时标志为为<code>0</code>，队列没有进行过操作，或者是上一个执行的是删除操作，所以队列必然是空；而如果标志位为<code>1</code>，则说明上一个执行的操作是增加，则队列是满的状态。因此就可以区分开来。</p>
</li>
<li>
<p>使用计数器</p>
<p>通过计数器来记录队列中存在的元素个数，然后与队列长度进行比较，就能够知道当<code>head == tail</code>的时候，队列是为空还是满</p>
</li>
<li>
<p>空闲单元法</p>
<p>空闲单元法即人为的浪费一个空间，这样就可以判断；参考<a href="https://blog.csdn.net/lpp0900320123/article/details/20694409?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.channel_param">另一篇CSDN博客</a>，我发现我之前的浪费一个空间有点误解，我之前一位浪费的是一个固定空间，比如在数组第一个元素或者数组最后一个元素；而其实，该故意腾出来的空间跟<code>tail</code>和<code>head</code>一样，不是固定的，而是随着他们相对位置而变化的。</p>
<p>在此之前，先明确几个规定</p>
<ul>
<li>初始化的时候，<code>head</code>和<code>tail</code>都初始化为0</li>
<li>当队列为空的时候，<code>head == tail</code>，但是不一定等于0</li>
<li><code>tail</code>总是指向最后一个元素的下一个位置</li>
<li>尾部<code>tail</code>也叫做<code>rear</code></li>
</ul>
</li>
</ol>
<p>其中，这里的第三条很重要，也是理解这个判断为满的关键</p>
<pre><code>例如这个图![队列为空](http://algorithm-image.qibinaoe.top/%E9%98%9F%E5%88%97%E7%A4%BA%E6%84%8F%E5%9B%BE.png)，`tail`已经指向末尾了，如果这时候要插入一个元素，则`tail`会跑到和`head`同样的位置，这时候就不能分辨空和满了。而当我们把这个tail这个时候指向的这个位置浪费掉，则满的判断就变成了`(tail+1)%SIZE == head`了，这样就区分开来了，而如果队列要进入新的元素，而`(tail+1)%SIZE != head`的时候，则`tail`可以放心的插入元素，即`Q[tail] = x; tail = (tail+1)%SIZE`。不需要考虑浪费的那个空间在哪里。这样就解决了空和满的问题![队列尾部插入](http://algorithm-image.qibinaoe.top/%E9%98%9F%E5%88%97%E7%A4%BA%E6%84%8F%E5%9B%BE2.png)
</code></pre>
<h3 id="代码实现，循环队列版本"><a class="header-anchor" href="#代码实现，循环队列版本"> </a>代码实现，循环队列版本</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Element</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Element</span>(string n,<span class="type">int</span> v):<span class="built_in">name</span>(n),<span class="built_in">val</span>(v)&#123;&#125;</span><br><span class="line">	<span class="comment">//对于这里，设计到C++类的知识</span></span><br><span class="line">	<span class="comment">//如果写了构造函数，就不会生成默认构造函数，但是这对于下面代码中使用</span></span><br><span class="line">	<span class="comment">//以该类形成的数组中，就会报错，因此还需要写一个参数为空的构造器 </span></span><br><span class="line">	<span class="built_in">Element</span>()&#123;&#125;;</span><br><span class="line">	~<span class="built_in">Element</span>()&#123;&#125;; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环队列 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> length = <span class="number">6</span>;</span><br><span class="line">	<span class="type">int</span> head = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> rear = <span class="number">0</span>;</span><br><span class="line">	Element *A = <span class="keyword">new</span> Element[length];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyQueue</span>(<span class="type">int</span> len):<span class="built_in">length</span>(len)&#123;&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> head == rear;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (rear+<span class="number">1</span>)%length == head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">enqueue</span><span class="params">(Element e)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">isFull</span>())&#123;</span><br><span class="line">			A[rear] = e;</span><br><span class="line">			rear = (rear + <span class="number">1</span>) % length;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> rear;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Element <span class="title">dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">			<span class="type">int</span> temp = head;</span><br><span class="line">			head = (head + <span class="number">1</span> ) % length;</span><br><span class="line">			<span class="keyword">return</span> A[temp];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//队列 Queue</span></span><br><span class="line">	<span class="comment">//循环队列</span></span><br><span class="line">	</span><br><span class="line">	<span class="function">MyQueue <span class="title">queue</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">	<span class="type">int</span> N = <span class="number">5</span>;</span><br><span class="line">	<span class="type">int</span> q = <span class="number">100</span>;</span><br><span class="line">	<span class="function">Element <span class="title">e1</span><span class="params">(string(<span class="string">&quot;p1&quot;</span>),<span class="number">150</span>)</span></span>;</span><br><span class="line">	<span class="function">Element <span class="title">e2</span><span class="params">(string(<span class="string">&quot;p2&quot;</span>),<span class="number">80</span>)</span></span>;</span><br><span class="line">	<span class="function">Element <span class="title">e3</span><span class="params">(string(<span class="string">&quot;p3&quot;</span>),<span class="number">200</span>)</span></span>;</span><br><span class="line">	<span class="function">Element <span class="title">e4</span><span class="params">(string(<span class="string">&quot;p4&quot;</span>),<span class="number">350</span>)</span></span>;</span><br><span class="line">	<span class="function">Element <span class="title">e5</span><span class="params">(string(<span class="string">&quot;p5&quot;</span>),<span class="number">20</span>)</span></span>;</span><br><span class="line">	queue.<span class="built_in">enqueue</span>(e1);</span><br><span class="line">	queue.<span class="built_in">enqueue</span>(e2);</span><br><span class="line">	queue.<span class="built_in">enqueue</span>(e3);</span><br><span class="line">	queue.<span class="built_in">enqueue</span>(e4);</span><br><span class="line">	queue.<span class="built_in">enqueue</span>(e5);</span><br><span class="line">	<span class="type">int</span> curTime = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!queue.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">		Element curE = queue.<span class="built_in">dequeue</span>();</span><br><span class="line">		<span class="type">int</span> curVal = curE.val;</span><br><span class="line">		<span class="keyword">if</span>(curVal &lt;= q)&#123;</span><br><span class="line">			curTime += curVal;</span><br><span class="line">			cout &lt;&lt; curE.name &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; curTime &lt;&lt; endl;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			curTime += q;</span><br><span class="line">			curE.val -= q;</span><br><span class="line">			queue.<span class="built_in">enqueue</span>(curE);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>挑战程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>挑战程序设计2-最大利益算法</title>
    <url>/2020/10/05/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12-%E6%9C%80%E5%A4%A7%E5%88%A9%E7%9B%8A%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="求最大利益的算法"><a class="header-anchor" href="#求最大利益的算法"> </a>求最大利益的算法</h2>
<h3 id="问题大致如下："><a class="header-anchor" href="#问题大致如下："> </a>问题大致如下：</h3>
<p>现在将某货币在t时刻的价格Rt(t = 0, 1, …, n-1)作为输入数据，计算出价格差Rj-Ri(其中j&gt;i)的最大值(书本P28页)</p>
<!-- more -->
<h4 id="输入"><a class="header-anchor" href="#输入"> </a>输入</h4>
<p>第1行输入整数n。接下来n行依次给整数Rt(t=0,1,…,n-1)赋值</p>
<h4 id="输出"><a class="header-anchor" href="#输出"> </a>输出</h4>
<p>在单独1行输出最大值</p>
<h4 id="限制"><a class="header-anchor" href="#限制"> </a>限制</h4>
<p>2 &lt;= n &lt;= 200 000<br>
1 &lt;= Rt &lt;= 10^9</p>
<h4 id="输入示例1"><a class="header-anchor" href="#输入示例1"> </a>输入示例1</h4>
<p>6<br>
5<br>
3<br>
1<br>
3<br>
4<br>
3</p>
<h4 id="输出示例1"><a class="header-anchor" href="#输出示例1"> </a>输出示例1</h4>
<p>3</p>
<h4 id="输入示例2"><a class="header-anchor" href="#输入示例2"> </a>输入示例2</h4>
<p>3<br>
4<br>
3<br>
2</p>
<h4 id="输出示例2"><a class="header-anchor" href="#输出示例2"> </a>输出示例2</h4>
<p>-1</p>
<h3 id="感想："><a class="header-anchor" href="#感想："> </a>感想：</h3>
<p>这道题是为了计算两数之间差值最大的问题，同时还要求两个数字有一定的顺序，即Rj必须在Ri之后。</p>
<p>对于解这道题，可以尝试着去从后往前思考。我第一眼看到这道题的时候，是从前往后思考的思维方式，即我现在这个时间点获得的Ri，去计算从这个点到后面的Rj去逐一计算差值。</p>
<p>但是这种思考方式带来的问题是,从第1个数开始，要去知道当前这个数能够构成最小的差值，必须得先遍历一遍，假设每一个值都这样遍历一遍，总共复杂度O(n^2)。</p>
<p>或许假设我们优化一下，将第1遍历得到的结果的最小值保存起来，然后第2次貌似只需要比较这个最小值就可以了，但是带来的问题是，当我们检查到某个数Rk的时候，这个k大于我们最小值的位置，这样就得重新遍历，况且我们还需要保存这个最小值的位置，因此这个方法不可行。</p>
<p>我们先明确我们想要的，就像炒股票的，越往后的值要越大，越前面的值要越小，最理想的情况就是牛市一直往上涨不降，这样只需要最后一个值减去第一个值。</p>
<p>如果想要从前往后的去思考，必须得从后往前推，这句话有点绕口。即我们从最后一个数字与倒数的第二个数字比较，(示例1中是3和4)，显然4到3是降低的，我们4往后退以为，3和3比较，显然是没有改变的，再往后退为1，显然增加了3。依此类推。而每一次比较我们发现，我们只关心当前这个数和它这个时间点之后的最大的数进行比较，因此我们只需要在向后退的过程中，保存目前最大的数，以及最大的差值，通过一次遍历O(n)就可以完成输出最大差值。</p>
<p>而对于书上答案的正解是通过从后一个时间段去看前面的时间段，寻找最小值。两个道理一样，算法的样子相反而已。<br>
正确答案的这种解法是寻找某个点中，它往前的最小值，因此开始的时候我们保存第一个值为最小值，并且在往后退的过程中，一边退一边比较。</p>
<h3 id="两种解法-C"><a class="header-anchor" href="#两种解法-C"> </a>两种解法 C++</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//输入</span></span><br><span class="line">	<span class="type">int</span> n = <span class="number">6</span>;</span><br><span class="line">	<span class="type">int</span> r[] = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="type">time_t</span> begin,end;</span><br><span class="line">	<span class="type">double</span> ret;</span><br><span class="line">	begin = <span class="built_in">clock</span>();</span><br><span class="line">	<span class="comment">//最大值</span></span><br><span class="line">	<span class="type">int</span> maxVal = r[<span class="number">1</span>] - r[<span class="number">0</span>]; </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//解法一</span></span><br><span class="line">	<span class="comment">//从后往前  O(n^2)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i<span class="number">-1</span>; j++)&#123;</span><br><span class="line">			<span class="type">int</span> curVal;</span><br><span class="line">			curVal = r[i] - r[j];</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(curVal &gt; maxVal)&#123;</span><br><span class="line">				maxVal = curVal;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	end = <span class="built_in">clock</span>();</span><br><span class="line">	ret = <span class="built_in">double</span>(end - begin) / CLOCKS_PER_SEC;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;runtime :&quot;</span> &lt;&lt; ret &lt;&lt; <span class="string">&quot;s&quot;</span>  &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;maxVal :&quot;</span> &lt;&lt; maxVal &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//解法二 O(n)</span></span><br><span class="line">	<span class="comment">//记录最小Rj</span></span><br><span class="line">	<span class="comment">//i 指的是后面的一个数</span></span><br><span class="line">	<span class="comment">//j 指的是前面的一个数</span></span><br><span class="line">	begin = <span class="built_in">clock</span>(); </span><br><span class="line">	<span class="type">int</span> minJ = r[<span class="number">0</span>];</span><br><span class="line">	<span class="type">int</span> maxVal2 = r[<span class="number">1</span>] - r[<span class="number">0</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="type">int</span> curVal2;</span><br><span class="line">		curVal2 = r[i] - minJ;</span><br><span class="line">		<span class="keyword">if</span>(curVal2 &gt; maxVal2)&#123;</span><br><span class="line">			maxVal2 = curVal2;</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">if</span>(r[i] &lt;minJ)&#123;</span><br><span class="line">			minJ = r[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	end  = <span class="built_in">clock</span>();</span><br><span class="line">	ret = <span class="built_in">double</span>(end - begin) / CLOCKS_PER_SEC;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;runtime :&quot;</span> &lt;&lt; ret &lt;&lt; <span class="string">&quot;s&quot;</span>  &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;maxVal :&quot;</span> &lt;&lt; maxVal &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>挑战程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>挑战程序设计2—卡车装货Allocation</title>
    <url>/2020/10/31/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12%E2%80%94%E5%8D%A1%E8%BD%A6%E8%A3%85%E8%B4%A7Allocation/</url>
    <content><![CDATA[<h2 id="搜索的应用——计算最优解"><a class="header-anchor" href="#搜索的应用——计算最优解"> </a>搜索的应用——计算最优解</h2>
<!-- more -->
<h3 id="题目-v115"><a class="header-anchor" href="#题目-v115"> </a>题目</h3>
<p><img src="http://algorithm-image.qibinaoe.top/%E9%A2%98%E7%9B%AE1.jpg" alt="题目1"></p>
<p><img src="http://algorithm-image.qibinaoe.top/%E9%A2%98%E7%9B%AE2.jpg" alt="题目2"></p>
<h4 id="解题思路-v91"><a class="header-anchor" href="#解题思路-v91"> </a>解题思路</h4>
<p>这题题意是按照来货的顺序进行装货。而思路就是不断递增最大载货量P，得到一个每一辆车都能装下所有货的值P，但是这样时间复杂度为O(Pn)，因为判断一个P是否符合需要O(n),遍历到P值需要O§。而书上采用的方法是二分法，初始化时，左值为0，右值为每辆车都能装上最重货物，然后不断二分，使得左值为最大不满足P，而右值为最小满足P的。</p>
<h4 id="错误想法"><a class="header-anchor" href="#错误想法"> </a>错误想法</h4>
<p>而我最开始想这道题的时候以为是已知所有货物的重量，给出货物数量n，货车数量k，求得最大载货数量的最小值。于是开始对货物重量进行从大到小的排序，然后思考如何分配这些货物，才能够达到最大值最小化，虽然题意理解错了，但是也编出了一道我不会的题，或许有兴趣可以对这题目进行思考如何求解。<em><strong>询问之后，发现这个问题有名字，叫做“多机调度”</strong></em></p>
<h4 id="实现代码-v2"><a class="header-anchor" href="#实现代码-v2"> </a>实现代码</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> llong;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line">llong T[MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">//k辆最大运输量为P的卡车能装多少货</span></span><br><span class="line"><span class="comment">//如果能把所有货都装下，则返回货的个数n</span></span><br><span class="line"><span class="comment">//如果不能全部装下，返回已装的货的个数i</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(llong P)</span></span>&#123;</span><br><span class="line">	<span class="comment">//P为最大运输量</span></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//第i个货物</span></span><br><span class="line">	<span class="comment">//为每一辆车装货</span></span><br><span class="line">	<span class="comment">//注意：这个是按顺序装货的，意思是一辆车满了就下一辆车，所以不用考虑货物的次序</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++)&#123;</span><br><span class="line">		llong s = <span class="number">0</span>; <span class="comment">//这辆车已装重量</span></span><br><span class="line">		<span class="keyword">while</span>(s + T[i] &lt;= P)&#123;</span><br><span class="line">			s += T[i];</span><br><span class="line">			i++;</span><br><span class="line">			<span class="keyword">if</span>(i == n)&#123;</span><br><span class="line">				<span class="keyword">return</span> n;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	 </span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	llong left = <span class="number">0</span>;</span><br><span class="line">	llong right = <span class="number">10000</span> * <span class="number">100000</span>; <span class="comment">//最重的情况</span></span><br><span class="line">	llong mid;</span><br><span class="line">	<span class="comment">//二分法去查找符合条件的最小P； </span></span><br><span class="line">	<span class="comment">//left指向不符合条件的</span></span><br><span class="line">	<span class="comment">//right指向符合条件的 </span></span><br><span class="line">	<span class="keyword">while</span>(right - left &gt; <span class="number">1</span>)&#123;</span><br><span class="line">		mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">		<span class="type">int</span> v = <span class="built_in">check</span>(mid);</span><br><span class="line">		<span class="keyword">if</span>(v &gt;= n )&#123;</span><br><span class="line">			<span class="comment">//符合条件但是不一定最小</span></span><br><span class="line">			right = mid; </span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//不符合条件</span></span><br><span class="line">			left = mid; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> right;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; n; i++) cin&gt;&gt;T[i];</span><br><span class="line">	llong ans = <span class="built_in">solve</span>();</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>挑战程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>挑战程序设计2—搜索</title>
    <url>/2020/10/30/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12%E2%80%94%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h2 id="搜索-v2"><a class="header-anchor" href="#搜索-v2"> </a>搜索</h2>
<ul>
<li>线性搜索</li>
<li>二分搜索</li>
<li>散列法</li>
</ul>
<!-- more -->
<h3 id="线性搜索"><a class="header-anchor" href="#线性搜索"> </a>线性搜索</h3>
<p>线性搜索是从开头顺序遍历各元素来判断是否与目标值相等，效率低但是适用于任何形式数据。</p>
<h4 id="线性搜索改进"><a class="header-anchor" href="#线性搜索改进"> </a>线性搜索改进</h4>
<p>在线性搜索的过程中引入一个特殊“标记”，在处理大规模数据时会有常数倍的性能提升。例如本题中，将搜索目标<code>key</code>放在数组末尾作为标记，当<code>while</code>遍历的末尾时，就必定会返回相等，但此时意味着没找到。对于性能的提升在于，相比<code>for</code>循环需要两次判断。1次在判断是否到底末尾，1次在判断是否匹配目标。而加入“标记”，只需要判断是否匹配到目标。</p>
<h4 id="代码-v4"><a class="header-anchor" href="#代码-v4"> </a>代码</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n, <span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">	<span class="comment">//才用标记的方法，将要搜索的key作为标记</span></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	A[n] = key;</span><br><span class="line">	<span class="keyword">while</span>(A[i] != key)&#123;</span><br><span class="line">		i++;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> i!=n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 我的做法 </span></span><br><span class="line"><span class="comment">//	int n,q;</span></span><br><span class="line"><span class="comment">//	//线性查找</span></span><br><span class="line"><span class="comment">//	cin &gt;&gt; n;</span></span><br><span class="line"><span class="comment">//	int* p;</span></span><br><span class="line"><span class="comment">//	int temp;</span></span><br><span class="line"><span class="comment">//	p = (int*)malloc(sizeof(int)*n);</span></span><br><span class="line"><span class="comment">//	for(int i = 0; i &lt; n; i++)&#123;</span></span><br><span class="line"><span class="comment">//		cin &gt;&gt; temp;</span></span><br><span class="line"><span class="comment">//		p[i] = temp;</span></span><br><span class="line"><span class="comment">//	&#125; </span></span><br><span class="line"><span class="comment">//	cin &gt;&gt; q;</span></span><br><span class="line"><span class="comment">//	int cur;</span></span><br><span class="line"><span class="comment">//	int count = 0;</span></span><br><span class="line"><span class="comment">//	for(int i = 0; i &lt; q; i++)&#123;</span></span><br><span class="line"><span class="comment">//		cin &gt;&gt; cur;</span></span><br><span class="line"><span class="comment">//		int flag = false;</span></span><br><span class="line"><span class="comment">//		for(int j = 0; j &lt; n; j++)&#123;</span></span><br><span class="line"><span class="comment">//			if(p[j] == cur)&#123;</span></span><br><span class="line"><span class="comment">//				flag = true;</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		if(flag)&#123;</span></span><br><span class="line"><span class="comment">//			count++;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	printf(&quot;%d&quot;,count);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 书上做法，其引用标记的概念，简化for循环的比较以提高效率</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>  i,n,A[<span class="number">10001</span>],q,key,sum=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;A[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; q; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;key);</span><br><span class="line">		<span class="comment">//找到了 </span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">search</span>(A,n,key)) sum++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="二分搜索-v2"><a class="header-anchor" href="#二分搜索-v2"> </a>二分搜索</h3>
<p>二分搜索适用于已经提前按照关键字进行升序排列的数组，由于每一次搜索，数组范围都会减半，因此其时间复杂度为O(logn)</p>
<h4 id="注意点-v2"><a class="header-anchor" href="#注意点-v2"> </a>注意点</h4>
<ul>
<li>二分搜索中需要规定搜索范围的左边和右边，左边<code>left</code>为搜索范围的第一个元素，而右边<code>right</code>为最后一个元素的后一个位置。</li>
<li>因此初始化的时候<code>left = 0</code>，<code>right = n</code>，对于判断的位置<code>middle</code>为<code>middle = (left + right)/2</code>。</li>
<li>在一次判断后，如果我们判断的关键字小于当前位置<code>A[middle] &gt; key</code>，说明<code>key</code>小，要在数组前部分搜索，此时需要改变<code>right</code>位置来缩小范围，而<code>right</code>为搜索范围的最后一个元素的后一个位置，而此时<code>middle</code>已经不在我们的搜索范围了。因此<code>left = middle</code></li>
<li>在一次判断后，如果我们判断的关键字大于当前位置<code>A[middle] &lt; key</code>，说明<code>key</code>大，要在数组后部分搜索，此时需要改变<code>left</code>位置来缩小范围，而<code>left</code>为搜索范围的第一个元素，而此时<code>middle</code>已经不在我们的搜索范围了。因此<code>right = middle+1</code>,<strong>而不是right = middle，虽然这样也能正常运行，但是不是正版的二分搜索</strong></li>
<li>判断条件<code>left &lt; right</code>。
<ul>
<li>假设我们要搜索的关键词小于数组所有元素，则<code>left</code>一直为<code>0</code>，而<code>right</code>在不断的缩小，在最后一次判断中，<code>right</code>注定是<code>1</code>,而<code>middle</code>为<code>(0+1) /2= 0</code>,因此我们判断了<code>A[0]的位置</code>，再进行一次则<code>right == left跳出循环</code>.</li>
<li>假设我们要搜索的关键词大于数组所有元素，则<code>right</code>一直为<code>n</code>，而<code>left</code>在不断的变大，在最后一次判断中，<code>left</code>注定是<code>n-1</code>,而<code>middle</code>为<code>(n-1+n) /2= n-0.5 = n-1</code>,因此我们判断了<code>A[n-1]的位置</code>，再进行一次则<code>right == left == n跳出循环</code>.</li>
</ul>
</li>
<li>对于<code>middle = (right + left) / 2</code>这句语句执行的位置应该为<code>while</code>循环的第一句</li>
</ul>
<h4 id="代码-v5"><a class="header-anchor" href="#代码-v5"> </a>代码</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分搜索 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n, <span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//left指向搜索范围开头元素</span></span><br><span class="line">	<span class="comment">//right指向末尾元素的后一个元素（指向一个不存在的位置） </span></span><br><span class="line">	<span class="type">int</span> right = n;</span><br><span class="line">	<span class="type">int</span> middle;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">		middle = (right + left) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(A[middle] == key)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(A[middle] &lt; key)&#123;</span><br><span class="line">			<span class="comment">//注意，left指向开头第一个元素，而middle已经判断过了无需判断 </span></span><br><span class="line">			left = middle+<span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">//right指向最后一个元素的后一个位置，而我们要判断的是middle前方的数字，因此middle即为最后一个元素的后一个位置 </span></span><br><span class="line">			right =middle;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>  i,n,A[<span class="number">10001</span>],q,key,sum=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;A[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; q; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;key);</span><br><span class="line">		<span class="comment">//找到了 </span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">binarySearch</span>(A,n,key)) sum++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<hr>
<h3 id="散列法"><a class="header-anchor" href="#散列法"> </a>散列法</h3>
<p>散列法是一种搜索算法，能够根据个元素的值来确定储存位置，从而实现数据的告诉搜索。而其中的散列表是一种数据结构，能够对关键字的数据集合高效地执行动态插入、搜索和删除操作。</p>
<h4 id="与链表区别"><a class="header-anchor" href="#与链表区别"> </a>与链表区别</h4>
<ul>
<li>链表在删除和搜索操作中，时间复杂度为O(n)</li>
<li>散列表在不考虑发生冲突的情况下，时间复杂度为O(1)</li>
</ul>
<h4 id="散列表"><a class="header-anchor" href="#散列表"> </a>散列表</h4>
<ul>
<li>散列函数 <code>h(k)</code>： 根据k的值求得数组T的下标的函数</li>
<li>散列值： 散列函数的返回值</li>
<li>数组T的长度为m，则散列值的范围为0 ~ m-1。因此函数内需要使用到求余运算</li>
<li>冲突：不同的key对应到同一个散列值</li>
</ul>
<h5 id="开放地址法"><a class="header-anchor" href="#开放地址法"> </a>开放地址法</h5>
<p>开放地址法是解决冲突的手段之一，这里介绍的是双散列结构里的开放地址法。</p>
<p>在双散列结构中一旦发生冲突，则会调用第二个散列函数求散列值:H(k) = h(k,i) = (h<sub>1</sub>(k)+i*h<sub>2</sub>(k)) mod m</p>
<p>i是发送冲突后计算下一个散列值的次数。当h<sub>1</sub>(k)计算第一个下标冲突后，则会下标移动h<sub>2</sub>(k)个位置，知道不发送冲突为止。</p>
<h4 id="注意-v5"><a class="header-anchor" href="#注意-v5"> </a>注意</h4>
<ul>
<li>
<p>下标每次移动的h<sub>2</sub>(k)个位置应该与数组长度m互质，否则会出现无法生成下标的情况。因此可以让m为质数，而h<sub>2</sub>(k)为小于m的数字</p>
</li>
<li>
<p>在搜索的时候，判断散列表中不存在要搜索的元素时，是通过<code>T[j] == NIL || i &gt;= m</code>的条件</p>
</li>
</ul>
<h4 id="例题"><a class="header-anchor" href="#例题"> </a>例题</h4>
<p><img src="dictionary.JPG" alt="dictionary"></p>
<h4 id="我写的代码"><a class="header-anchor" href="#我写的代码"> </a>我写的代码</h4>
<p>我只是简单的通过将输入值转成ASCILL码相加求余来得散列值。这样做法有以下缺点</p>
<ul>
<li>没有解决冲突问题</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string hashTable[<span class="number">100</span>];</span><br><span class="line">	string order;</span><br><span class="line">	string str;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		cin &gt;&gt; order &gt;&gt; str;</span><br><span class="line">		<span class="type">int</span> code = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(order[<span class="number">0</span>] == <span class="string">&#x27;i&#x27;</span>)&#123;</span><br><span class="line">			<span class="comment">//插入</span></span><br><span class="line">		</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; str.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">				code += str[j];</span><br><span class="line">			&#125;</span><br><span class="line">			code %= <span class="number">100</span>; </span><br><span class="line">			<span class="comment">//放入散列表</span></span><br><span class="line">			hashTable[code] = str;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; str.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">				code += str[j];</span><br><span class="line">			&#125;</span><br><span class="line">			code %= <span class="number">100</span>; </span><br><span class="line">			<span class="keyword">if</span>(hashTable[code] == str)&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;yes&quot;</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;no&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h4 id="书上做法"><a class="header-anchor" href="#书上做法"> </a>书上做法</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 1046572</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NIL (-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L 14</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> H[M][L];</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符转数值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getChar</span><span class="params">(<span class="type">char</span> ch)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;G&#x27;</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符串转成数值并生成key</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getKey</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>,p=<span class="number">1</span>,i;</span><br><span class="line">	<span class="comment">//算出字符串的值 </span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str);i++)&#123;</span><br><span class="line">		sum += p* <span class="built_in">getChar</span>(str[i]);</span><br><span class="line">		<span class="comment">//这里p的作用是将每个字符的数值分散来开，减小冲突概率 </span></span><br><span class="line">		p *= <span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">h1</span><span class="params">(<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> key%M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">h2</span><span class="params">(<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">	<span class="comment">//保证下标值不为零，否则和h1就一样了 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>+key%(M<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> i,key,h;</span><br><span class="line">	<span class="comment">//字符串转成数值</span></span><br><span class="line">	key = <span class="built_in">getKey</span>(str);</span><br><span class="line">	<span class="comment">//不太明白这里，为什么不判断i&lt;M </span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;;i++)&#123;</span><br><span class="line">		h = (<span class="built_in">h1</span>(key)+i*<span class="built_in">h2</span>(key))%M;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strcmp</span>(H[h],str) == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strlen</span>(H[h]) == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> i,h,key;</span><br><span class="line">	key = <span class="built_in">getKey</span>(str);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;;i++)&#123;</span><br><span class="line">		h = (<span class="built_in">h1</span>(key) + i*<span class="built_in">h2</span>(key)) % M;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strcmp</span>(H[h],str) == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strlen</span>(H[h]) == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">strcpy</span>(H[h],str);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i, n, h;</span><br><span class="line">	<span class="type">char</span> str[L], com[<span class="number">9</span>];</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; M; i++) H[i][<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i &lt;n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s %s&quot;</span>,com,str);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(com[<span class="number">0</span>] == <span class="string">&#x27;i&#x27;</span>)&#123;</span><br><span class="line">			<span class="built_in">insert</span>(str);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">find</span>(str))&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;yes\n&quot;</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;no\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="问题-v5"><a class="header-anchor" href="#问题-v5"> </a>问题</h4>
<ul>
<li>散列有哪些方法</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>挑战程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>挑战程序设计2—递归和分治</title>
    <url>/2020/11/02/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12%E2%80%94%E9%80%92%E5%BD%92%E5%92%8C%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<h2 id="挑战程序设计2——第六章递归和分治"><a class="header-anchor" href="#挑战程序设计2——第六章递归和分治"> </a>挑战程序设计2——第六章递归和分治</h2>
<!-- more -->
<h3 id="6-2穷举搜索-Exhaustive-Search"><a class="header-anchor" href="#6-2穷举搜索-Exhaustive-Search"> </a>6.2穷举搜索 Exhaustive Search</h3>
<h4 id="题目-v116"><a class="header-anchor" href="#题目-v116"> </a>题目</h4>
<p><img src="http://algorithm-image.qibinaoe.top/%E7%A9%B7%E4%B8%BE%E6%90%9C%E7%B4%A2%E9%A2%98%E7%9B%AE.jpg" alt="穷举搜索题目"></p>
<h4 id="解题思路-v92"><a class="header-anchor" href="#解题思路-v92"> </a>解题思路</h4>
<p>该题如果用递归的方法去做，首先将数组分成当前数字不能组成，靠接下来的数字中可以组成，或者现在该数字可以组成，然后去递归，因为题目只要求算是否能构成，因此只需返回整型来判断。</p>
<h4 id="时间复杂度"><a class="header-anchor" href="#时间复杂度"> </a>时间复杂度</h4>
<p>由于在每个递归函数中都调用了两个递归函数，因此时间复杂度为O(2<sup>n</sup>)。其中很多次重复计算solve(i,m)，使得很多无用功，因此可以用动态规划区解决</p>
<h4 id="代码实现-v8"><a class="header-anchor" href="#代码实现-v8"> </a>代码实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 2000</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> A[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> rest)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(rest == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">//算完了</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(index&gt;=n)&#123;</span><br><span class="line">		<span class="comment">//遍历完也不可以 </span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> res = <span class="built_in">solve</span>(index+<span class="number">1</span>,rest) || <span class="built_in">solve</span>(index+<span class="number">1</span>,rest-A[index]);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;A[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> q;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;q; i++)&#123;</span><br><span class="line">		<span class="type">int</span> m;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">solve</span>(<span class="number">0</span>,m))&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;yes\n&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;no\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="类似题型"><a class="header-anchor" href="#类似题型"> </a>类似题型</h4>
<p>在思考这题的时候，网上看到一题类似的。</p>
<p>有n个数，从中选取m个数(n &gt;= m &gt; 0),找出所有的组合情况。</p>
<h4 id="解题思路-v93"><a class="header-anchor" href="#解题思路-v93"> </a>解题思路</h4>
<p>如果用递归的解法。</p>
<ol>
<li>对于n个数，要选出m个数，则一个空位能放下n-m个数，因为如果方了n-m+1后的数，那么后面的数就构不成m个了，所以这个空位只能放n-m个</li>
</ol>
<h4 id="代码-v6"><a class="header-anchor" href="#代码-v6"> </a>代码</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//A[]存放 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectMFromN</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> B[],<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> index,<span class="type">int</span> left)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">//挑完了</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">			cout &lt;&lt; A[i] &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">		&#125; </span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> endIndex = n - left;</span><br><span class="line">	<span class="comment">//可以到n-m，因为 n-m 到 n 有m+1个数 </span></span><br><span class="line">	<span class="comment">//而我们没有遍历到的数是n-m+1 ~ n-1(m-1个数).因为n的时候数组越界 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = index; i &lt;=endIndex; i++)&#123;</span><br><span class="line">		A[index] = B[i];</span><br><span class="line">		<span class="built_in">selectMFromN</span>(A,B,n,m,index+<span class="number">1</span>,left<span class="number">-1</span>);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> B[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">	<span class="type">int</span>* A;</span><br><span class="line">	<span class="type">int</span> m = <span class="number">3</span>;</span><br><span class="line">	A = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*m);</span><br><span class="line">	<span class="built_in">selectMFromN</span>(A,B,<span class="number">8</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>挑战程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>挑战程序设计2—高等排序</title>
    <url>/2020/11/05/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12%E2%80%94%E9%AB%98%E7%AD%89%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="高等排序"><a class="header-anchor" href="#高等排序"> </a>高等排序</h2>
<!-- more -->
<h3 id="归并排序"><a class="header-anchor" href="#归并排序"> </a>归并排序</h3>
<h4 id="算法思想"><a class="header-anchor" href="#算法思想"> </a>算法思想</h4>
<ul>
<li>
<p>归并排序以整个数组为对象执行mergeSort</p>
</li>
<li>
<p>归并排序使用的是分治的思想(Divide and Conquer)</p>
<ol>
<li>将给定的包含n个元素的局部数组分割成两个局部数组，每个数组包含n/2个元素。(Divide)</li>
<li>对两个局部数组分别执行mergeSort排序。(Solve)</li>
<li>通过merge将两个已排序完毕的局部数组整合成一个数组。(Conquer)</li>
</ol>
</li>
<li>
<p>对于每两个局部有序数组要合并成一个整体有序的数组时候，我们采用的是通过不断挑选两个数组中最小的一个，并添加到大的数组当中去，因此合并成大的数组时间复杂度为O(n1+n2),同时，这里也需要开辟两个数组空间来存放临时的两个局部数组，因此这里的空间复杂度为O(n)。同时，我们在两个数组的末尾插入哨兵元素(即数组大于比较数值的数)，这样就可以判断为数组的结尾。当其中一个局部数组已经都添加到大数组当中去的时候，只需要将另一个数组拼接上去即可。</p>
</li>
</ul>
<h4 id="特点"><a class="header-anchor" href="#特点"> </a>特点</h4>
<h5 id="递归版本"><a class="header-anchor" href="#递归版本"> </a>递归版本</h5>
<ul>
<li>
<p>时间复杂度: O(nlogn)</p>
</li>
<li>
<p>空间复杂度: O(n)  包括存放结果的n的数组和占空间logn 因此实际空间复杂度为O(n+logn)</p>
</li>
<li>
<p>稳定性: 稳定</p>
<ul>
<li>虽然归并排序包含不相邻的两个元素之间的比较，但是如果在合并两个数组，遇到相同元素时，只要保证前半部分数组优先于后半部分数组，相同元素的顺序就不会颠倒。</li>
</ul>
</li>
</ul>
<h4 id="递归算法实现"><a class="header-anchor" href="#递归算法实现"> </a>递归算法实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 500000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SENTINEL 2000000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> L[MAX/<span class="number">2</span>+<span class="number">2</span>], R[MAX/<span class="number">2</span>+<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//将两个数组合并 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n,<span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义两个数组，存放要比较的两列数组</span></span><br><span class="line">	<span class="type">int</span> n1 = mid - left;</span><br><span class="line">	<span class="type">int</span> n2 = right - mid;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将A中的[left ~ left+n1]存入L</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++)&#123;</span><br><span class="line">		L[i] = A[left+i];</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//将A中的[mid ~ mid+n2]存入R</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n2; i++)&#123;</span><br><span class="line">		R[i] = A[mid+i];</span><br><span class="line">	&#125;</span><br><span class="line">	L[n1] = SENTINEL;</span><br><span class="line">	R[n2] = SENTINEL;</span><br><span class="line">	<span class="comment">//比较大小</span></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k = left; k &lt; right; k++)&#123;</span><br><span class="line">		count++; </span><br><span class="line">		<span class="keyword">if</span>(L[i] &lt;= R[j])&#123;	</span><br><span class="line">			A[k] = L[i];</span><br><span class="line">			i++;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			A[k] = R[j];</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n, <span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left + <span class="number">1</span> &lt; right )&#123;</span><br><span class="line">	</span><br><span class="line">		<span class="type">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">mergeSort</span>(A,n,left,mid);</span><br><span class="line">		<span class="built_in">mergeSort</span>(A,n,mid,right);</span><br><span class="line">		<span class="built_in">merge</span>(A,n,left,mid,right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="type">int</span> A[MAX];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;A[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">mergeSort</span>(A,n,<span class="number">0</span>,n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,A[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,count);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迭代思路"><a class="header-anchor" href="#迭代思路"> </a>迭代思路</h4>
<p>迭代时通过从局部分组长度为1开始，每一次乘2进行翻倍进行比较。例如第一次的局部分组的长度为1，第二次的局部分组的长度为2这样。但是在这过程中，要注意边界条件，即当最右边的局部分组落单了，只剩自己一个时，需要<code>continue</code>,否则会造成越界。同时如果在比较的一个数组中<code>left_start+offset</code>如果大于数组长度时，需要将最右边界置为<code>n</code>，否则也会造成越界。</p>
<h4 id="迭代算法实现"><a class="header-anchor" href="#迭代算法实现"> </a>迭代算法实现</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define MAX 500000</span><br><span class="line">#define SENTINEL 2000000000</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">//归并排序</span><br><span class="line"></span><br><span class="line">int L[MAX/2+2], R[MAX/2+2];</span><br><span class="line"></span><br><span class="line">//将两个数组合并 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void merge(int A[],int n,int left, int mid, int right)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	//定义两个数组，存放要比较的两列数组</span><br><span class="line">	int n1 = mid - left;</span><br><span class="line">	int n2 = right - mid;</span><br><span class="line">	</span><br><span class="line">	//将A中的[left ~ left+n1]存入L</span><br><span class="line">	for(int i = 0; i &lt; n1; i++)&#123;</span><br><span class="line">		L[i] = A[left+i];</span><br><span class="line">	&#125; </span><br><span class="line">	//将A中的[mid ~ mid+n2]存入R</span><br><span class="line">	for(int i = 0; i &lt; n2; i++)&#123;</span><br><span class="line">		R[i] = A[mid+i];</span><br><span class="line">	&#125;</span><br><span class="line">	L[n1] = SENTINEL;</span><br><span class="line">	R[n2] = SENTINEL;</span><br><span class="line">	//比较大小</span><br><span class="line">	int i = 0;</span><br><span class="line">	int j = 0;</span><br><span class="line">	</span><br><span class="line">	for(int k = left; k &lt; right; k++)&#123;</span><br><span class="line">		if(L[i] &lt;= R[j])&#123;	</span><br><span class="line">			A[k] = L[i];</span><br><span class="line">			i++;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			A[k] = R[j];</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">void mergeSort(int A[],int n, int left,int right)</span><br><span class="line">&#123;</span><br><span class="line">	for(int step = 1; step &lt; n; step&lt;&lt;=1)&#123;</span><br><span class="line">		//每一个局部数组的长度为i,因此移动的步长为i+i</span><br><span class="line">		// 最后一次的第一个局部数组的长度为小于n的2的倍数</span><br><span class="line">		int offset  = step+step;</span><br><span class="line">		//offset意思为一次小的局部整理后，移动的步长 </span><br><span class="line">		for(int left_start = 0; left_start &lt; n; left_start+=offset)&#123;</span><br><span class="line">			int right;</span><br><span class="line">			</span><br><span class="line">			if(left_start+step&gt;=n)&#123;</span><br><span class="line">				//只有一组，不需要比较</span><br><span class="line">				continue; </span><br><span class="line">			&#125;</span><br><span class="line">			//right指向最后一个元素的下一个，即不比较right </span><br><span class="line">			if(left_start+offset&gt;n)&#123;</span><br><span class="line">				right = n;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				right = left_start+offset;</span><br><span class="line">			&#125;</span><br><span class="line">			int mid = left_start+step;</span><br><span class="line">			merge(A,n,left_start,mid,right);</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">			cout &lt;&lt; &quot; &quot; &lt;&lt; A[i] &lt;&lt; &quot; &quot; ; </span><br><span class="line">		&#125; </span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">	int A[MAX];</span><br><span class="line">	for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;A[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	mergeSort(A,n,0,n);</span><br><span class="line">	for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">		printf(&quot;%d &quot;,A[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="其他-v2"><a class="header-anchor" href="#其他-v2"> </a>其他</h4>
<ul>
<li>右移一位<code>&gt;&gt;1</code>的效率比直接除2<code>/2</code>效率高</li>
</ul>
<hr>
<h4 id="分割-partition-书上的例题"><a class="header-anchor" href="#分割-partition-书上的例题"> </a>分割 partition (书上的例题)</h4>
<h4 id="题目-v117"><a class="header-anchor" href="#题目-v117"> </a>题目</h4>
<p>输入数组，将数组A[p…r]分割成A[p…q-1]和A[q+1…r]两部分，并返回下标q的值，其中A[p…q-1]中的所有元素小于等于A[q]，A[q+1…r]的所有元素都大于A[q]</p>
<p>题目分割以A[r]为基准，即r为q</p>
<h4 id="输入示例"><a class="header-anchor" href="#输入示例"> </a>输入示例</h4>
<blockquote>
<p>12</p>
</blockquote>
<blockquote>
<p>13 19 9 5 12 8 7 4 21 2 6 11</p>
</blockquote>
<h4 id="输出示例"><a class="header-anchor" href="#输出示例"> </a>输出示例</h4>
<blockquote>
<p>9 5 8 7 4 2 6 [11] 21 23 19 12</p>
</blockquote>
<h4 id="实现思路"><a class="header-anchor" href="#实现思路"> </a>实现思路</h4>
<p>定义一个i指向最后一个小于等于A[r]的位置，即A[i+1]的位置是大于A[r]的</p>
<h4 id="代码实现-v9"><a class="header-anchor" href="#代码实现-v9"> </a>代码实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> p, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//i 指向最后一个小于等于A[r]的位置 </span></span><br><span class="line">	<span class="type">int</span> i = p - <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> val = A[r];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = p; j &lt;= r; j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(A[j] &lt;= val)&#123;</span><br><span class="line">			<span class="comment">// j 这个位置要放前面</span></span><br><span class="line">			i++;</span><br><span class="line">			<span class="comment">//i+1的位置是大于val的位置</span></span><br><span class="line">			<span class="type">int</span> temp = A[i];</span><br><span class="line">			A[i] = A[j];</span><br><span class="line">			A[j] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//i及i之前的都是小于等于val的， i+1及i+1之后的都是大于val的</span></span><br><span class="line">	<span class="comment">//放入所谓的q</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> m = p; m &lt;= r; m++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(m != i)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,A[m]);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;[%d] &quot;</span>,A[m]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n; </span><br><span class="line">	<span class="type">int</span> A[<span class="number">100001</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;A[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">partition</span>(A,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>挑战程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>新建博客的随想与小目标</title>
    <url>/2020/10/05/%E6%96%B0%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%9A%8F%E6%83%B3%E4%B8%8E%E5%B0%8F%E7%9B%AE%E6%A0%87/</url>
    <content><![CDATA[<h2 id="写博客的初衷"><a class="header-anchor" href="#写博客的初衷"> </a>写博客的初衷</h2>
<p>之所以会想到开始写博客，很大的原因是看了<a href="https://space.bilibili.com/384068749/">codesheep</a>B站上的视频，感受到了很多也学到了很多，然后跟上面的教程搭建了博客，准备开始写一些自己学习到的知识或者是技术。</p>
<hr>
<!-- more -->
<h2 id="小目标"><a class="header-anchor" href="#小目标"> </a>小目标</h2>
<p>我想为明年后的校招开始做准备了，很喜欢软件之英的一个学长喜欢的名言</p>
<blockquote>
<p>种一棵树最好的时间是十年前,其次是现在</p>
</blockquote>
<p>所以想要做出什么事得赶紧行动吧。</p>
<p>同时在看一本有关投资理财的儿童读物时，里面也讲着一个颇为哲理的道理。即想做一件事，不能超过72小时，一旦超过这个时间，就很难进行。因此anyway，不想后悔就从现在开始做吧。</p>
<p>我现在就想按照<a href="https://www.codesheep.cn/">codesheep</a>的路线开始发展，虽然可能在本科期间很难完成，但是去做了努力了我觉得就够了，同时也不要浪费太多的时间。</p>
<p><img src="http://algorithm-image.qibinaoe.top/Java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF-%E9%AB%98%E6%B8%85%E7%89%88.jpg" alt="JAVA后端学习路线"></p>
<p>这张图上面有好多好多的词我都没见过，看来道阻且长，但是别怕哈哈哈！</p>
<hr>
<h3 id="近期目标"><a class="header-anchor" href="#近期目标"> </a>近期目标</h3>
<p>现在我会坚持写博客了，然后最近我会开始学习Java核心技术以及挑战程序设计竞赛这两本书，如果学习到什么知识，我就会总结上来！做复习用！</p>
]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2021/03/08/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>本篇学习总结归纳常见的排序算法</p>
<h2 id="参考资料-v3"><a class="header-anchor" href="#参考资料-v3"> </a>参考资料</h2>
<ul>
<li><a href="https://www.cnblogs.com/onepixel/p/7674659.html">十大经典排序算法（动图演示）</a></li>
<li><a href="https://sort.hust.cc/">十大经典排序算法</a></li>
<li>算法第4版</li>
<li>挑战程序设计竞赛二</li>
<li>数据结构（C++语言）（第3版）邓俊辉编著</li>
</ul>
<!-- more -->
<h2 id="排序算法分类"><a class="header-anchor" href="#排序算法分类"> </a>排序算法分类</h2>
<p>可以根据元素间是否进行比较进行划分</p>
<p><strong>比较类排序</strong></p>
<ul>
<li>通过两元素间进行比较，来决定元素间的相对次序，其时间复杂度不能突破O(nlogn)（可根据比较树进行推导），因此也称为非线性时间比较类排序</li>
</ul>
<p><strong>非比较类排序</strong></p>
<ul>
<li>不通过两元素间的比较来决定相对次序，因此可以突破比较类排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序</li>
</ul>
<p><img src="http://algorithm-image.qibinaoe.top/849589-20190306165258970-1789860540.png" alt="img"></p>
<p><img src="http://algorithm-image.qibinaoe.top/849589-20180402133438219-1946132192.png" alt="img"></p>
<hr>
<p>可以根据比较的数据记录所在位置进行划分</p>
<p><strong>内部排序</strong></p>
<ul>
<li>数据记录在内存中进行排序</li>
</ul>
<p><strong>外部排序</strong></p>
<ul>
<li>因数据记录很大，不能一次性都放入内存，所以在排序的过程中需要访问外存</li>
</ul>
<h2 id="冒泡排序-Bubble-Sort"><a class="header-anchor" href="#冒泡排序-Bubble-Sort"> </a>冒泡排序 Bubble Sort</h2>
<p>冒泡排序：重复走访要排序的数列，一次比较两个元素，如果这两个元素顺序错误，则将其交换位置。走访数列的工作进行到没有元素再需要交换为止。</p>
<h3 id="算法步骤"><a class="header-anchor" href="#算法步骤"> </a>算法步骤</h3>
<p>假设排序目标：从左到右，从小到大排列。假设一共n个元素</p>
<ol>
<li>从头开始，比较相邻的两个元素，如果第一个元素大于第二个元素（即顺序错误），则交换这两个元素。</li>
<li>对每一对相邻的元素做相同的操作（比较大小，纠正顺序）。例如第1个元素与第2个元素、第2个元素和第3个元素…第n-1个元素和第n个元素。在这一趟遍历后，会使得最大的元素归位（即到最后一位）</li>
<li>重复以上操作，直到数组没有再需要交换位置的相邻元素</li>
</ol>
<h3 id="动图演示"><a class="header-anchor" href="#动图演示"> </a>动图演示</h3>
<p><img src="http://algorithm-image.qibinaoe.top/bubbleSort.gif" alt="img"></p>
<h3 id="最快情况"><a class="header-anchor" href="#最快情况"> </a>最快情况</h3>
<p>当数据数列已经是按期望有序</p>
<h3 id="最慢情况"><a class="header-anchor" href="#最慢情况"> </a>最慢情况</h3>
<p>当数据数列是反序时</p>
<h3 id="其他话-v2"><a class="header-anchor" href="#其他话-v2"> </a>其他话</h3>
<p>冒泡排序每一趟遍历，都会有一个未排序的最大值归位</p>
<p>冒泡排序有两层for循环，外层for循环代表一共要遍历多少趟。假设有n个元素，每一趟完成一个未排序的最大值归位，那么在第n-1趟时，前n-1大的数字已经归位了，那最小的那一个元素也肯定就留在原地不需要动了。一次外层循环最多遍历n-1次</p>
<p>内层循环代表相邻元素交换位置的过程。因为每一层遍历，都会有一个最大值归位，所以内层循环不需要每次都遍历到数组末尾，只需要将未排序的最大元素放到相应位置即可。</p>
<p><strong>优化</strong>：如果一趟遍历中，没有任何元素进行交换，说明该数组已经有序，可以直接跳出循环，没必要遍历n-1次</p>
<h3 id="代码实现-v10"><a class="header-anchor" href="#代码实现-v10"> </a>代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) &#123;</span><br><span class="line">        <span class="comment">// 对原来数组进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择排序-Selection-Sort"><a class="header-anchor" href="#选择排序-Selection-Sort"> </a>选择排序 Selection Sort</h2>
<p>选择排序的工作原理为：第一步在未排序的数列中，寻找最小的元素，放置排序序列起始位置，构成排序部分。接下来在后面的未排序部分中，不断选择最小的元素，放置排序部分的末尾。直到所有元素都排序完毕</p>
<h3 id="算法步骤-v2"><a class="header-anchor" href="#算法步骤-v2"> </a>算法步骤</h3>
<ol>
<li>初始状态：整个数组都为未排序部分[1,n]</li>
<li>在第i趟排序中(i=1,2,…n)，前i-1个元素为有序部分[1,i-1]，而第i个位置为此趟排序，要将其转换成有序部分。因此从无序部分[i,n]中选择最小的元素，将其与第i个元素进行交换，至此，前i个元素[1,i]就变成有序部分</li>
<li>重复n-1趟</li>
</ol>
<h3 id="动图演示-v2"><a class="header-anchor" href="#动图演示-v2"> </a>动图演示</h3>
<p><img src="http://algorithm-image.qibinaoe.top/selectionSort.gif" alt="img"></p>
<h3 id="其他话-v3"><a class="header-anchor" href="#其他话-v3"> </a>其他话</h3>
<p>选择排序性能稳定，不管怎么数据都是O(n^2)</p>
<h3 id="代码实现-v11"><a class="header-anchor" href="#代码实现-v11"> </a>代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i != minIndex) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                arr[i] = arr[minIndex];</span><br><span class="line">                arr[minIndex] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序-Insertion-Sort"><a class="header-anchor" href="#插入排序-Insertion-Sort"> </a>插入排序 Insertion Sort</h2>
<p>插入排序即为玩扑克牌的时候，整牌的过程。其工作原理为构建有序序列，按顺序对于未排序的数据，在已排序的序列中，从后向前扫描，找到相应的位置并插入</p>
<h3 id="算法步骤-v3"><a class="header-anchor" href="#算法步骤-v3"> </a>算法步骤</h3>
<ol>
<li>数据序列的第一个元素认为是有序序列，因此对从第2个元素至最后一个元素（未排序序列）进行插入排序</li>
<li>取出下一个元素<code>K</code>（第一个未排序元素），在已排序序列中从后向前扫描</li>
<li>如果扫描到的已排序序列的元素<code>J</code>大于<code>K</code>，则将<code>J</code>元素向后移动一位</li>
<li>直到找到已排序序列中的元素<code>J</code>小于或等于<code>K</code>的位置</li>
<li>将<code>K</code>插入到<code>J</code>元素后面</li>
</ol>
<h3 id="动图演示-v3"><a class="header-anchor" href="#动图演示-v3"> </a>动图演示</h3>
<p><img src="http://algorithm-image.qibinaoe.top/insertionSort.gif" alt="img"></p>
<h3 id="其他话-v4"><a class="header-anchor" href="#其他话-v4"> </a>其他话</h3>
<p>对于小数据，使用插入排序效率高</p>
<h3 id="代码实现-v12"><a class="header-anchor" href="#代码实现-v12"> </a>代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; cur) &#123;</span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j+<span class="number">1</span>] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序-Shell-Sort"><a class="header-anchor" href="#希尔排序-Shell-Sort"> </a>希尔排序 Shell Sort</h2>
<p>希尔排序，亦称缩小增量排序（递减增量算法），是插入排序的更高效的改进版本。</p>
<p>希尔排序是基于插入排序的以下两个性质进行改进</p>
<ol>
<li>插入排序对于几乎已经排好的数据操作时，效率高，可以达到线性排序的效率（O(n)）</li>
<li>但是插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位
<ul>
<li>希尔排序会优先比较距离较远的元素</li>
</ul>
</li>
</ol>
<p>希尔排序的基本思想是：先将整个待排序的记录序列分成若干个子序列分别进行直接插入排序，待整个序列中的记录基本有序时，再对整体记录进行一次插入排序</p>
<h3 id="算法步骤-v4"><a class="header-anchor" href="#算法步骤-v4"> </a>算法步骤</h3>
<ol>
<li>选择一个增量序列t1, t2, …, tk, 其中 ti &gt; tj (i &lt; j), tk = 1
<ul>
<li>增量即子序列中两个元素相差的距离</li>
</ul>
</li>
<li>按增量序列个数k，对序列进行k趟排序</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m的子序列，分别对各子表进行直接插入排序。当增量因子为1时（即希尔排序的最后一次排序），将整个序列作为一个表来处理，表长度即为整个序列的长度</li>
</ol>
<h3 id="间隔序列"><a class="header-anchor" href="#间隔序列"> </a>间隔序列</h3>
<p>希尔排序的间隔序列gap（增量序列，说法不一，意思到位就可），当g<sub>n+1</sub> = 3g<sub>n</sub>+1时，算法复杂度基本维持在O(N<sup>1.25</sup>)。</p>
<p>如果遇到2的幂指数（1,2,4,8,…）等g=1之前不需要排序的数列，希尔排序的效率会大幅度降低</p>
<p>增量序列的选取，应该尽可能减少不同增量值之间的公共因子，而一种彻底的方法就是保证它们之间两两互素</p>
<h4 id="Pratt序列"><a class="header-anchor" href="#Pratt序列"> </a>Pratt序列</h4>
<p>pratt = {1，2，3，4，6，8，9，12，16，…，2<sup>p</sup>3<sup>q</sup>，…}</p>
<p>希尔排序最多运行O(log<sup>2</sup>n)</p>
<h4 id="Sedgewick序列"><a class="header-anchor" href="#Sedgewick序列"> </a>Sedgewick序列</h4>
<p>sedgewick = {1，5，19，41，109，209，505，929，2161，3905，8929，…}</p>
<p>通项公式为：9·4<sup>k</sup> - 9·2<sup>k</sup> + 1  或 4<sup>k</sup> - 3·2<sup>k</sup> + 1</p>
<p>最坏时间复杂度为O(n<sup>4/3</sup>)，平均时间复杂度为O(n<sup>7/6</sup>)</p>
<h3 id="代码实现-v13"><a class="header-anchor" href="#代码实现-v13"> </a>代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="comment">// 生成增量数列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(gap &lt; arr.length / <span class="number">3</span>) &#123;</span><br><span class="line">            gap = gap * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一次gap == 1</span></span><br><span class="line">        <span class="keyword">while</span>(gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 默认第一个为已排序</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; arr.length; i += gap) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> arr[i]; <span class="comment">// cur为第一个未排序</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - gap; <span class="comment">// j 为最后一个已排序的</span></span><br><span class="line">                <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; cur) &#123;</span><br><span class="line">                    arr[j+gap] = arr[j];</span><br><span class="line">                    j -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j+gap] = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            gap = (<span class="type">int</span>)Math.floor(gap / <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序-Merge-Sort"><a class="header-anchor" href="#归并排序-Merge-Sort"> </a>归并排序 Merge Sort</h2>
<p>归并排序是建立在归并操作的排序算法。归并排序采用分治法（Divide and Conquer），分而治之。其思路为将已有序的子序列合并，得到完全有序的序列。</p>
<p>归并排序实现的两种方法</p>
<ul>
<li>自上而下的递归</li>
<li>自下而上的迭代</li>
</ul>
<h3 id="算法步骤-v5"><a class="header-anchor" href="#算法步骤-v5"> </a>算法步骤</h3>
<p><strong>自顶向下归并排序</strong></p>
<ol>
<li>申请空间，该空间大小为两个已排序的子序列的大小之和。该空间用于存放合并后的序列</li>
<li>设定两个指针，初始位置分别为两个已排序的子序列的起始位置</li>
<li>比较两个指针所指向的元素的大小，选择相对小的元素放入合并的空间，并将指针移动到下一位</li>
<li>重复步骤3直到某一指针达到序列尾部</li>
<li>将另一个序列剩下的元素直接复制到合并序列的尾部</li>
</ol>
<p><strong>自底向上归并排序</strong></p>
<ol>
<li>申请空间，该空间大小为未排序数组的长度，用于存放数组序列（作用同自顶向下归并排序）</li>
<li>定义每次归并元素的长度<code>size</code></li>
<li>首先两两归并（每个元素为长度为1的数组，<code>size=1</code>），其次四四归并（将两个大小2的数组归并成一个大小为4的有序数组，<code>size=2</code>），接着八八归并，一直下去</li>
<li>直到最后一次归并，第二个子数组的长度可能比第一个子数组要小</li>
</ol>
<h3 id="动图演示-v4"><a class="header-anchor" href="#动图演示-v4"> </a>动图演示</h3>
<p><strong>自顶向下归并排序</strong></p>
<p><img src="http://algorithm-image.qibinaoe.top/mergeSort.gif" alt="img"></p>
<h3 id="其他话-v5"><a class="header-anchor" href="#其他话-v5"> </a>其他话</h3>
<p>归并排序的性能不受输入数据（的无序程度）影响，但是表现比选择排序好，时间复杂度始终为O(nlogn)，但是需要额外的内存空间</p>
<p>若将两个有序表合并成一个有序表，称为2-路归并</p>
<p>自底向上的归并排序比较适合用链表组织的数据</p>
<p><strong>自顶向下的归并排序优化</strong></p>
<ul>
<li>对小规模子数组使用插入排序
<ul>
<li>递归会是小规模问题中方法调用频繁</li>
</ul>
</li>
<li>测试数组是否已经有序
<ul>
<li>当将两个子序列分别排序后，判断<code>if arr[mid] &lt;= arr[mid+1]</code>那么就认为数组已经有序，并跳过<code>merge</code>方法</li>
</ul>
</li>
</ul>
<h3 id="代码实现-v14"><a class="header-anchor" href="#代码实现-v14"> </a>代码实现</h3>
<p><strong>自顶向下归并排序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line">    <span class="comment">//自顶而下 递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="comment">// 辅助数组</span></span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>, temp);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        sort(arr, left, mid, temp);</span><br><span class="line">        sort(arr, mid+<span class="number">1</span>, right, temp);</span><br><span class="line">        <span class="comment">// 如果有序，则可跳过合并</span></span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &lt;= arr[mid+<span class="number">1</span>]) <span class="keyword">return</span>;</span><br><span class="line">        merge(arr, left, mid, right, temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="comment">// 将数组元素拷贝到临时数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> left; k &lt;= right; k++) &#123;</span><br><span class="line">            temp[k] = arr[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> left; k &lt;= right; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; mid) &#123;</span><br><span class="line">                arr[k] = temp[j++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; right) &#123;</span><br><span class="line">                arr[k] = temp[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp[j] &gt; temp[i]) &#123;</span><br><span class="line">                arr[k] = temp[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                arr[k] = temp[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>自底向上的归并排序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort2</span> &#123;</span><br><span class="line">    <span class="comment">// 自底向上 迭代</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length]; <span class="comment">//辅助数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">1</span>; size &lt; arr.length; size += size) &#123;</span><br><span class="line">            <span class="comment">// size为一个子序列的元素长度，开始是两两归并，即1个元素和1个元素组成有序序列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left+size &lt; arr.length; left += size+size) &#123;</span><br><span class="line">                merge(arr, left, left+size-<span class="number">1</span>, Math.min(left+size+size-<span class="number">1</span>, arr.length-<span class="number">1</span>), temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> left; k &lt;= right; k++) &#123;</span><br><span class="line">            temp[k] = arr[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> left; k &lt;= right; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; mid) &#123;</span><br><span class="line">                arr[k] = temp[j++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; right) &#123;</span><br><span class="line">                arr[k] = temp[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp[j] &lt; temp[i]) &#123;</span><br><span class="line">                arr[k] = temp[j++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                arr[k] = temp[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序-Quick-Sort"><a class="header-anchor" href="#快速排序-Quick-Sort"> </a>快速排序 Quick Sort</h2>
<p>快速排序采用分治法（Divide and conquer）策略将一个串行（list）分成两个字串行（sub-lists）。本质上，快速排序是在冒泡排序基础上的递归分治法</p>
<p>快速排序的基本思想是通过一趟排序将记录通过pivot（主元、基准、轴点），将记录分隔成两部分，其中pivot前半部分的元素均比后半部分小，则继续分别对这两部分进行排序，以达到整个序列有序。</p>
<p>对于迭代版的快速排序，即通过一个栈来模拟系统调用栈，每次压入左右边界值即可。</p>
<h3 id="算法步骤-v6"><a class="header-anchor" href="#算法步骤-v6"> </a>算法步骤</h3>
<ol>
<li>从数列中挑出一个元素，称为pivot</li>
<li>分区（切分，partition）操作：将所有元素比pivot小的放在pivot前面，所有元素比pivot大的放在pivot后面（相同的数可以放在任一边）。在这个分区操作结束后，该pivot就处于数列的中间位置。</li>
<li>递归地将小于pivot的子序列和大于pivot的子数列进行排序</li>
</ol>
<h3 id="最快情况-v2"><a class="header-anchor" href="#最快情况-v2"> </a>最快情况</h3>
<p>快速排序最好的情况是每次都能正好将数组对半切分</p>
<h3 id="最坏情况"><a class="header-anchor" href="#最坏情况"> </a>最坏情况</h3>
<p>快速排序最坏运行情况是O(n^2)，比如顺序数列的快排，但它的平摊期望时间是 O(nlogn)，且O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p>
<h3 id="其他话-v6"><a class="header-anchor" href="#其他话-v6"> </a>其他话</h3>
<p>快速排序的特点为，快排是原地排序（只需要很小的辅助栈），且长度为N的数组排序所愮的时间和NlgN成正比</p>
<p><strong>保持随机性</strong></p>
<ul>
<li>将数组元素的顺序打乱。或在<code>partition</code>中随机选择一个切分元素</li>
</ul>
<p><strong>处理切分元素值相同情况</strong></p>
<ul>
<li>左侧扫描最好是遇到大于等于切分元素值时停下来，右侧扫描是遇到小于等于切分元素值停下来。这样可能会有不必要的一些等值元素交换，但是能够避免算法的运行时间变成平方级（包含大量重复值的数组情况）</li>
</ul>
<h3 id="算法改进"><a class="header-anchor" href="#算法改进"> </a>算法改进</h3>
<p><strong>切换到插入排序</strong></p>
<ul>
<li>对于小数组，快速排序比插入排序慢</li>
<li>因为递归，快速排序的sort在小数组中也会调用自己</li>
</ul>
<p>将<code>if(hi &lt;= lo) return;</code>改进成<code>if(hi &lt;= lo + M)&#123;InsertionSort.sort(arr, lo, hi); return;&#125;</code></p>
<p><strong>三取样切分</strong></p>
<p>使用子数组的一小部分元素的中位数来切分数组。取样大小为3，并用大小居中的元素切分</p>
<p>可将取样元素放在数组末尾作为哨兵，来去掉partition中的数组边界测试</p>
<h3 id="代码实现-v15"><a class="header-anchor" href="#代码实现-v15"> </a>代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(arr, lo, hi);</span><br><span class="line">        sort(arr, lo, pivot - <span class="number">1</span>);</span><br><span class="line">        sort(arr, pivot + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[lo];</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">while</span>(lo &lt; hi &amp;&amp; arr[hi] &gt;= pivot) hi--;</span><br><span class="line">            arr[lo] = arr[hi];</span><br><span class="line">            <span class="keyword">while</span>(lo &lt; hi &amp;&amp; arr[lo] &lt;= pivot) lo++;</span><br><span class="line">            arr[hi] = arr[lo];</span><br><span class="line">            <span class="keyword">if</span>(lo &gt;= hi) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[lo] = pivot;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(arr, lo, hi);</span><br><span class="line">        sort(arr, lo, pivot - <span class="number">1</span>);</span><br><span class="line">        sort(arr, pivot + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[lo];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> lo + <span class="number">1</span>; <span class="comment">// index指向比pivot大的第一个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt;= hi; i++) &#123;</span><br><span class="line">            <span class="comment">// index总是&lt;= i, 同时arr[index] ~ arr[i]之间的数都比pivot大</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; pivot) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                arr[i] = arr[index];</span><br><span class="line">                arr[index] = temp;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[lo] = arr[index-<span class="number">1</span>];</span><br><span class="line">        arr[index-<span class="number">1</span>] = pivot;</span><br><span class="line">        <span class="keyword">return</span> index-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">cutoff</span> <span class="operator">=</span> <span class="number">15</span>; <span class="comment">// 阈值， 对于小数据范围采用插入排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left + cutoff &gt;= right) &#123;</span><br><span class="line">            <span class="comment">// 阈值内采用插入排序</span></span><br><span class="line">            insertionSort(arr, left, right);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里已经保证left值小于pivot元素值，right的值大于pivot元素值。而right-1的位置就是pivot</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> median3(arr, left, right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[++i] &lt; arr[pivot]);</span><br><span class="line">            <span class="keyword">while</span> (arr[--j] &gt; arr[pivot]);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">              swap(arr, i, j);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, pivot);</span><br><span class="line">        sort(arr, left, i-<span class="number">1</span>);</span><br><span class="line">        sort(arr, i+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">median3</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 选取pivot</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[left] &gt; arr[mid]) &#123;</span><br><span class="line">            swap(arr, left, mid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[left] &gt; arr[right]) &#123;</span><br><span class="line">            swap(arr, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt; arr[right]) &#123;</span><br><span class="line">            swap(arr, mid, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保证 arr[left] &lt;= arr[mid] &lt;= arr[right]，此时 arr[mid]的值可作为切分元素值</span></span><br><span class="line">        <span class="comment">// 将pivot放在右边</span></span><br><span class="line">        swap(arr, mid, right - <span class="number">1</span>); <span class="comment">// right 元素肯定比mid大，所以不考虑</span></span><br><span class="line">        <span class="keyword">return</span> right - <span class="number">1</span>; <span class="comment">// pivot下标</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; cur) &#123;</span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j+<span class="number">1</span>] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] =temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort4</span> &#123;</span><br><span class="line">    <span class="comment">// 迭代版快速排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) &#123;</span><br><span class="line">        <span class="type">int</span>[] copy = <span class="keyword">new</span> <span class="title class_">int</span>[sourceArray.length];</span><br><span class="line">        System.arraycopy(sourceArray, <span class="number">0</span>, copy, <span class="number">0</span>, sourceArray.length);</span><br><span class="line">        <span class="keyword">return</span> sort(copy, <span class="number">0</span>, copy.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right) &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> arr;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.offerLast(left);</span><br><span class="line">        stack.offerLast(right);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">hi</span> <span class="operator">=</span> stack.pollLast();</span><br><span class="line">            <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> stack.pollLast();</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(arr, lo, hi);</span><br><span class="line">            <span class="keyword">if</span>(lo &lt; pivot-<span class="number">1</span>) &#123;</span><br><span class="line">                stack.offerLast(lo);</span><br><span class="line">                stack.offerLast(pivot - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pivot+<span class="number">1</span> &lt; hi) &#123;</span><br><span class="line">                stack.offerLast(pivot+<span class="number">1</span>);</span><br><span class="line">                stack.offerLast(hi);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[lo];</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">while</span>(lo &lt; hi &amp;&amp; arr[hi] &gt; pivot) hi--;</span><br><span class="line">            arr[lo] = arr[hi];</span><br><span class="line">            <span class="keyword">while</span>(lo &lt; hi &amp;&amp; arr[lo] &lt; pivot) lo++;</span><br><span class="line">            arr[hi] = arr[lo];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[lo] = pivot;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序-Heap-Sort"><a class="header-anchor" href="#堆排序-Heap-Sort"> </a>堆排序 Heap Sort</h2>
<p>堆排序是利用堆的数据结构进行的排序算法。堆积是一个近似完全二叉树的结构，即子结点的键值或索引总是小于（或者大于）其父结点。</p>
<ul>
<li>大顶堆：每个结点的值都大于或等于其子结点的值，在堆排序中算法用于升序排序</li>
<li>小顶堆：每个结点的值都小于或等于其子结点的值，在堆排序中算法用于降序排序</li>
</ul>
<p>堆排序的平均时间复杂度为O(nlogn)</p>
<h3 id="堆的介绍"><a class="header-anchor" href="#堆的介绍"> </a>堆的介绍</h3>
<p>堆的存储是用数组来存放的，因此可以根据数组的索引来访问堆的元素。</p>
<p><strong>对于堆的存放有两种方式</strong></p>
<ol>
<li>使用下标为0的数组空间（根节点放在<code>arr[0]</code>）
<ul>
<li>对于某个元素的下标为<code>k</code>，其父节点的下标为<code>(k-1)/2</code>，其左孩子的下标为<code>(2k+1)</code>，右孩子的下标为<code>(2k+2)</code></li>
</ul>
</li>
<li>不使用下标为0的数组空间，从下标1开始存放堆元素（根节点放在<code>arr[1]</code>）
<ul>
<li>对于某个元素的下标为<code>k</code>，其父节点的下标为<code>k/2</code>，其左孩子的下标为<code>2k</code>，右孩子的下标为<code>2k+1</code></li>
</ul>
</li>
</ol>
<p>在访问某个结点的右孩子时，需要注意其是否存在右孩子</p>
<p><u>下面操作是基于下标从1开始存放堆元素的上浮与下称操作</u></p>
<p><strong>由下至上的堆有序化（上浮swim）</strong></p>
<p>某个结点比它的父节点更大而打破了堆的有序状态。</p>
<p>通过不断的将该结点与其父节点交换，直到其父节点大于该节点，或者该节点成为了堆顶</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(k/<span class="number">2</span>, k)) &#123;</span><br><span class="line">        exchange(k/<span class="number">2</span>, k);</span><br><span class="line">        k = k/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>由上至下的堆有序化（下沉sink）</strong></p>
<p>某个结点比它的两个子节点或是其中之一更小而打破堆的有序状态。</p>
<p>通过将该结点与其两个子结点中较大者交换来恢复堆，交换直到该结点的子结点都比它小或是达到堆的底部</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>*k;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;N &amp;&amp; less(j, j+<span class="number">1</span>)) j++;</span><br><span class="line">        <span class="keyword">if</span>(!less(k, j)) <span class="keyword">break</span>;</span><br><span class="line">        exchange(k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法步骤-v7"><a class="header-anchor" href="#算法步骤-v7"> </a>算法步骤</h3>
<p>这里进行从左到右，从小到大的升序排列。这里选择根节点从0开始存放</p>
<ol>
<li>
<p>堆的构建（建堆）：根据升序降序需求选择大顶堆或小顶堆，这里选择大顶堆</p>
<ol>
<li>从最后一个非叶子结点（最后一层的最后一个叶子结点的父节点）开始，进行下沉操作</li>
<li>从右到左，从下到上对每个非叶子结点进行下沉操作，最后一次为对根节点进行下沉操作</li>
</ol>
<p>（建堆完成后，堆顶为数组中最大元素）</p>
</li>
<li>
<p>下沉排序中销毁堆</p>
<ol>
<li>取出堆顶元素，与堆的最后一个元素交换</li>
<li>堆的长度减一</li>
<li>直到堆中只剩下一个元素中，停止</li>
</ol>
</li>
</ol>
<h3 id="其他话-v7"><a class="header-anchor" href="#其他话-v7"> </a>其他话</h3>
<p>堆排序无法利用缓存：数组元素很少和相邻的其他元素进行比较，因此缓存未命中的次数要远远高于大多数比较都在相邻元素间</p>
<h3 id="动图演示-v5"><a class="header-anchor" href="#动图演示-v5"> </a>动图演示</h3>
<p><img src="http://algorithm-image.qibinaoe.top/heapSort.gif" alt="img"></p>
<h3 id="代码实现-v16"><a class="header-anchor" href="#代码实现-v16"> </a>代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        buildMaxHeap(arr, len);</span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(arr, <span class="number">0</span>, len-<span class="number">1</span>);</span><br><span class="line">            len--;</span><br><span class="line">            sink(arr, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> ((len - <span class="number">2</span>) / <span class="number">2</span>); k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">            sink(arr, k, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">2</span> * k + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(j + <span class="number">1</span> &lt; len &amp;&amp; arr[j+<span class="number">1</span>] &gt; arr[j]) j++;</span><br><span class="line">            <span class="keyword">if</span>(arr[k] &gt;= arr[j]) <span class="keyword">break</span>;</span><br><span class="line">            swap(arr, k, j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="计数排序-Counting-Sort"><a class="header-anchor" href="#计数排序-Counting-Sort"> </a>计数排序 Counting Sort</h2>
<p>计数排序的核心在于将待排序的数列的元素值，转化成额外开辟的数组空间的键。其时间复杂度为O(n)</p>
<p><strong>计数排序的要求</strong></p>
<ul>
<li>待排序的元素必须是整数</li>
<li>待排序的元素的取值要在一定的范围内，并且比较集中</li>
</ul>
<p>满足以上两点才能发挥计数排序的优势</p>
<h3 id="算法步骤-v8"><a class="header-anchor" href="#算法步骤-v8"> </a>算法步骤</h3>
<ol>
<li>找出原数组的最大值</li>
<li>创建一个新数组，其数组元素默认值均为0，长度为最大值+1</li>
<li>遍历原数组，将原数组元素值作为新数组的下标索引，该元素在原数组出现的次数作为新数组的值</li>
<li>根据新数组，反向填充原数组。在新数组中值不为0的元素的下标填入原数组，并且新数组值自减，直至为0</li>
<li>按顺序遍历原数组和新数组。</li>
</ol>
<h3 id="算法改进-v2"><a class="header-anchor" href="#算法改进-v2"> </a><strong>算法改进</strong></h3>
<p>原数组元素的最小元素可能很大，会浪费用来统计的新数组前部分的空间，因此我们只需要对于新数组声明的大小为<code>max-min+1</code>的长度即可（可以理解为将元素值向左移动min位，使得min映射到0）</p>
<h3 id="代码实现-v17"><a class="header-anchor" href="#代码实现-v17"> </a>代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountingSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> getMaxValue(arr);</span><br><span class="line">        <span class="keyword">return</span> countingSort(arr, maxValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] countingSort(<span class="type">int</span>[] arr, <span class="type">int</span> maxValue) &#123;</span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[maxValue + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : arr) &#123;</span><br><span class="line">            count[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(count[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr[index++] = i;</span><br><span class="line">                count[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxValue</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : arr) &#123;</span><br><span class="line">            maxValue = Math.max(maxValue, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountingSort2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : arr) &#123;</span><br><span class="line">            maxValue = Math.max(maxValue, num);</span><br><span class="line">            minValue = Math.min(minValue, num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> countingSort(arr, maxValue, minValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] countingSort(<span class="type">int</span>[] arr, <span class="type">int</span> maxValue, <span class="type">int</span> minValue) &#123;</span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[maxValue - minValue + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : arr) &#123;</span><br><span class="line">            count[num - minValue]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(count[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr[index++] = i + minValue;</span><br><span class="line">                count[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="桶排序-Bucket-Sort"><a class="header-anchor" href="#桶排序-Bucket-Sort"> </a>桶排序 Bucket Sort</h2>
<p>桶排序是计数排序的升级版。计数排序可以看作每个桶只储存相同的元素，而桶排序中每个桶储存一定范围的元素。通过映射函数，将待排序数组中的元素映射到不同的桶中，接着对每个桶中的元素进行排序，最后将非空桶中的元素放入原序列中。</p>
<blockquote>
<p>划分多个范围相同的区间，每个子区间子排序，最后合并</p>
</blockquote>
<ul>
<li>桶排序需要尽量保证元素分散均匀</li>
<li>对于桶中元素的排序，选择何种比较算法对于性能提升影响至关重要</li>
</ul>
<h3 id="最快情况-v3"><a class="header-anchor" href="#最快情况-v3"> </a>最快情况</h3>
<p>输入的数据能够均匀的分配到每一个桶中</p>
<h3 id="最坏情况-v2"><a class="header-anchor" href="#最坏情况-v2"> </a>最坏情况</h3>
<p>输入的数据都分配到同一个桶中</p>
<h3 id="其他话-v8"><a class="header-anchor" href="#其他话-v8"> </a>其他话</h3>
<p>对于桶中，可以使用链表，再排序的时候用插入排序。也可以递归桶排序。或者存放数组，待取出时，先排序再取出</p>
<h3 id="动图演示-v6"><a class="header-anchor" href="#动图演示-v6"> </a>动图演示</h3>
<p><img src="http://algorithm-image.qibinaoe.top/2018033115584192" alt="这里写图片描述"></p>
<h3 id="代码实现-v18"><a class="header-anchor" href="#代码实现-v18"> </a>代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BucketSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="keyword">return</span> bucketSort(arr,<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] bucketSort(<span class="type">int</span>[] arr, <span class="type">int</span> bucketSize) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : arr) &#123;</span><br><span class="line">            maxValue = Math.max(maxValue, num);</span><br><span class="line">            minValue = Math.min(minValue, num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">bucketCount</span> <span class="operator">=</span> (maxValue - minValue) / bucketSize + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[bucketCount + <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (arr[i] - minValue) / bucketSize;</span><br><span class="line">            buckets[index] = arrAppend(buckets[index], arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">InsertionSort</span> <span class="variable">insertionSort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InsertionSort</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">arrIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span>(bucket.length &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            bucket = insertionSort.sort(bucket);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> value : bucket) &#123;</span><br><span class="line">                arr[arrIndex++] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arrAppend(<span class="type">int</span>[] arr, <span class="type">int</span> value) &#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基数排序-Radix-Sort"><a class="header-anchor" href="#基数排序-Radix-Sort"> </a>基数排序 Radix Sort</h2>
<p>基数排序的原理是将整数按位分割成不同的数字，然后按每个位数分别比较。</p>
<p>基数排序也能用于名字、日期和特定格式的浮点数</p>
<h3 id="算法步骤-v9"><a class="header-anchor" href="#算法步骤-v9"> </a>算法步骤</h3>
<ol>
<li>取出数组中的最大值，获取其位数</li>
<li>从低位开始，根据低位的数值进行排序，再放入原数组</li>
<li>向高位进一位，继续排序</li>
</ol>
<h3 id="动图演示-v7"><a class="header-anchor" href="#动图演示-v7"> </a>动图演示</h3>
<p><img src="http://algorithm-image.qibinaoe.top/radixSort.gif" alt="img"></p>
<h3 id="代码实现-v19"><a class="header-anchor" href="#代码实现-v19"> </a>代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BucketSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="keyword">return</span> bucketSort(arr,<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] bucketSort(<span class="type">int</span>[] arr, <span class="type">int</span> bucketSize) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : arr) &#123;</span><br><span class="line">            maxValue = Math.max(maxValue, num);</span><br><span class="line">            minValue = Math.min(minValue, num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">bucketCount</span> <span class="operator">=</span> (maxValue - minValue) / bucketSize + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[bucketCount + <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (arr[i] - minValue) / bucketSize;</span><br><span class="line">            buckets[index] = arrAppend(buckets[index], arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">InsertionSort</span> <span class="variable">insertionSort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InsertionSort</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">arrIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span>(bucket.length &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            bucket = insertionSort.sort(bucket);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> value : bucket) &#123;</span><br><span class="line">                arr[arrIndex++] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arrAppend(<span class="type">int</span>[] arr, <span class="type">int</span> value) &#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器搭建相关</title>
    <url>/2021/01/12/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<ul>
<li><a href="https://mirror.tuna.tsinghua.edu.cn/">清华镜像网站</a></li>
</ul>
<!-- more -->
<h2 id="购买"><a class="header-anchor" href="#购买"> </a>购买</h2>
<h3 id="系统"><a class="header-anchor" href="#系统"> </a>系统</h3>
<p>服务器的操作系统选择的是<code>Centos 7.6</code></p>
<h3 id="购买流程"><a class="header-anchor" href="#购买流程"> </a>购买流程</h3>
<ul>
<li>购买服务器</li>
<li>购买域名</li>
<li>备案</li>
</ul>
<h3 id="登陆"><a class="header-anchor" href="#登陆"> </a>登陆</h3>
<p>通过重置腾讯云默认密码后，可以在腾讯云的webshell进行登陆</p>
<p>也可以通过ssh进行登录</p>
<h4 id="ssh登陆"><a class="header-anchor" href="#ssh登陆"> </a>ssh登陆</h4>
<p>我使用的是Microsoft Store下载的Windows Terminal</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210113171752769.png" alt="image-20210113171752769"></p>
<p>这个控制台内置了<code>ssh</code>的功能</p>
<p>因此可以通过</p>
<p><code>ssh root@公网ip地址</code>进行登陆，同时输入密码</p>
<h2 id="安全设置"><a class="header-anchor" href="#安全设置"> </a>安全设置</h2>
<h3 id="创建新用户"><a class="header-anchor" href="#创建新用户"> </a>创建新用户</h3>
<p>这里用户名用<code>myuser</code>来指代</p>
<p>输入指令</p>
<ul>
<li><code>adduser myuser</code></li>
<li><code>passwd myuser</code></li>
</ul>
<p>这时候会要求输入两次密码：</p>
<blockquote>
<p>Changing password for user myuser.<br>
New password:<br>
Retype new password:<br>
passwd: all authentication tokens updated successfully.</p>
</blockquote>
<p>即可</p>
<h3 id="授权"><a class="header-anchor" href="#授权"> </a>授权</h3>
<p>授权新创建的<code>myuser</code>能够<code>sudo</code>成超级用户的权限</p>
<p><strong>首先查找<code>sudoers</code>文件的位置</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[root@VM-0-11-centos ~]# whereis sudoers</span><br><span class="line">sudoers: /etc/sudoers.d /etc/sudoers /usr/share/man/man5/sudoers.5.gz</span><br></pre></td></tr></table></figure>
<p><strong>查看当前<code>sudoers</code>文件的权限</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[root@VM-0-11-centos ~]# ls -l /etc/sudoers</span><br><span class="line">-r--r----- 1 root root 4328 Nov 28  2019 /etc/sudoers</span><br></pre></td></tr></table></figure>
<p>由于该文件是只读文件，因此先修改文件权限为可写</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[root@VM-0-11-centos ~]# chmod -v u+w /etc/sudoers</span><br><span class="line">mode of ‘/etc/sudoers’ changed from 0440 (r--r-----) to 0640 (rw-r-----)</span><br><span class="line">You have new mail in /var/spool/mail/root</span><br></pre></td></tr></table></figure>
<p><strong>打开文件，追加新增用户</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">vim /etc/sudoers</span><br></pre></td></tr></table></figure>
<p>按<code>i</code>进行编写模式</p>
<p>在文件中找到这个位置</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210113173347812.png" alt="image-20210113173347812"></p>
<p>在<code>root    ALL=(ALL)       ALL</code>位置下面添加我们新的用户</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">myuser    ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210113173530273.png" alt="image-20210113173530273"></p>
<p>如果嫌每次切换成超级用户都要输密码麻烦的话，可以这样修改</p>
<p>即将刚刚那条语句改成</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">myuser    ALL=(ALL)       NOPASSWD:ALL</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210113174601775.png" alt="image-20210113174601775"></p>
<p>保存后退出（按esc退出编写模式，按<code>:wq</code>进行退出保存）</p>
<p>这时候就可以尝试进行切换</p>
<p>当<code>sudo su</code>切换回超级用户时，输入的密码是<code>myuser</code>的密码，不是<code>root</code>的密码（如果弄成免密切换的话，就不需要输入密码）</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">su mysuer</span><br><span class="line">sudo su</span><br></pre></td></tr></table></figure>
<p><strong>将写权限收回</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[root@VM-0-11-centos /]# chmod -v u-w /etc/sudoers</span><br><span class="line">mode of ‘/etc/sudoers’ changed from 0640 (rw-r-----) to 0440 (r--r-----)</span><br><span class="line">[root@VM-0-11-centos /]# ls -l /etc/sudoers</span><br><span class="line">-r--r----- 1 root root 4357 Jan 13 17:46 /etc/sudoers</span><br></pre></td></tr></table></figure>
<h3 id="禁止root用户远程登陆"><a class="header-anchor" href="#禁止root用户远程登陆"> </a>禁止root用户远程登陆</h3>
<p><strong>编辑ssh配置文件</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[root@VM-0-11-centos /]# vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>
<p>寻找到<code>PermitRootLogin</code></p>
<p><img src="%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/-20210113175558899.png" alt="image-20210113175558899"></p>
<p>可通过<code>/PermitRootLogin</code>快速定位</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210113175736330.png" alt="image-20210113175736330"></p>
<p>取消注释，并将<code>yes</code>改成<code>no</code></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210113175843323.png" alt="image-20210113175843323"></p>
<p>保存退出</p>
<p>重启服务</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[root@VM-0-11-centos /]# systemctl restart sshd.service</span><br><span class="line">You have new mail in /var/spool/mail/root</span><br></pre></td></tr></table></figure>
<p>这样就不能用<code>root</code>用户进行ssh远程登陆</p>
<p>因此得先用刚刚新创建的<code>myuser</code>用户进行远程登陆：</p>
<p><code>ssh myuser@公网ip地址</code></p>
<p>输入密码</p>
<p>再<code>sudo su</code>切换到超级用户</p>
<h3 id="配置密钥登陆"><a class="header-anchor" href="#配置密钥登陆"> </a>配置密钥登陆</h3>
<p>通过密钥登陆就省得每次登陆都输入密码了</p>
<p><strong>原理介绍：</strong></p>
<blockquote>
<p>公钥添加到服务器的某个账户上</p>
<p>私钥放在客户端</p>
<p>客户端利用私钥即可完成认证并登陆</p>
<ul>
<li>没有私钥，任何人都无法通过 SSH 暴力破解密码来远程登录到系统</li>
<li>如果将公钥复制到其他账户甚至主机，利用私钥也可以登录</li>
</ul>
</blockquote>
<p>参考来自<a href="https://www.runoob.com/w3cnote/set-ssh-login-key.html">菜鸟教程-设置 SSH 通过密钥登录</a></p>
<p><strong>操作大体流程：</strong></p>
<ul>
<li>主机A（客户端）创建公钥私钥</li>
<li>将公钥复制到主机B（被登陆机）的指定用户下</li>
<li>主机A使用保存私钥的用户登录到主机B对应保存公钥的用户</li>
</ul>
<p>参考来自<a href="https://www.cnblogs.com/henkeyi/p/10487553.html">Linux密钥登录原理和ssh使用密钥实现免密码登陆</a></p>
<p><strong>详细流程：</strong></p>
<p>在<strong>本地</strong>客户端<strong>生成公钥私钥</strong></p>
<p>有几种方法去生成公钥私钥：</p>
<p>1.安装git bash。官网地址<a href="https://git-scm.com/">git bash</a></p>
<p>2.在Microsoft Store安装terminal</p>
<p>3.使用putty</p>
<p>这里使用terminal</p>
<p><strong>输入</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210113195735712.png" alt="image-20210113195735712"></p>
<p>然后连续按<strong>3</strong>次回车，因为我们不为其设置密码</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210113195848933.png" alt="image-20210113195848933"></p>
<p>这样就生成了公钥和私钥</p>
<p>进入上面生成的目录“C:\Users\Administrator/.ssh”即可看到</p>
<p><img src="%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%85%B3/image-20210113200022201.png" alt="image-20210113200022201"></p>
<p><strong>将公钥拷贝到服务器</strong></p>
<p>使用git bash输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub myuser@123.123.123.123</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210113200925540.png" alt="image-20210113200925540"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210113201106957.png" alt="image-20210113201106957"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210113201234523.png" alt="image-20210113201234523"></p>
<p>这里如果使用terminal会失败，显示命令找不到，因此使用git bash进行</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210113200709403.png" alt="image-20210113200709403"></p>
<p>同时注意我们已经把root用户给禁止用ssh登陆了，所以我们写我们创建的普通用户</p>
<p>至此已经将公钥拷到服务器了，可以直接进行ssh登陆，而不用输入密码</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">ssh myuser@123.123.123.123</span><br></pre></td></tr></table></figure>
<p>但是还需要输入用户名和ip地址这一大串挺麻烦的</p>
<p>因此我们到目录“C:\Users\你的电脑用户名/.ssh”中，新建一个config文件</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210113201458213.png" alt="image-20210113201458213"></p>
<p>在里面输入</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Host 登陆别名                                                                      </span><br><span class="line">	HostName 目标主机ip地址</span><br><span class="line">	User 登陆用户名</span><br><span class="line">	Port 登陆端口（默认22）</span><br></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Host freestyle                                                                      </span><br><span class="line">	HostName 123.123.123.123</span><br><span class="line">	User myuser</span><br><span class="line">	Port 22</span><br></pre></td></tr></table></figure>
<p>同时还可以在下面另起一行，意思为间隔120s发送keepalive请求，防止自动断线</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">ServerAliveInterval 120</span><br></pre></td></tr></table></figure>
<p>最终效果如下</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210113202125845.png" alt="image-20210113202125845"></p>
<p>这样我们可以在终端输入</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">ssh freestyle</span><br></pre></td></tr></table></figure>
<p>进行登录了</p>
<h2 id="文件传输"><a class="header-anchor" href="#文件传输"> </a>文件传输</h2>
<p>这里文件传输使用的是<code>WinSCP</code></p>
<p>用<code>WinSCP</code>与我们服务器相连</p>
<blockquote>
<p>Linux scp 命令用于 Linux 之间复制文件和目录。<br>
scp 是 secure copy 的缩写, scp 是 linux 系统下基于 <strong>ssh</strong> 登陆进行安全的远程文件拷贝命令。<br>
scp 是加密的，<a href="https://www.runoob.com/linux/linux-comm-rcp.html">rcp</a> 是不加密的，scp 是 rcp 的加强版。</p>
</blockquote>
<p>参考来自<a href="https://www.runoob.com/linux/linux-comm-scp.html">菜鸟教程</a></p>
<p><strong>打开程序</strong></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210113183635153.png" alt="image-20210113183635153"></p>
<p><strong>点击新建站点</strong></p>
<p>文件协议选择SCP</p>
<p>输入主机名：即ip地址、</p>
<p>输入端口号：默认22号（若修改过则更改，具体依照服务器<strong>ssh</strong>的端口号）</p>
<p>输入用户名：即要登陆的用户，例如<code>root</code>，<strong>但是</strong>我们已经禁止用<code>root</code>进行ssh登陆了，所以我们输入创建的普通用户<code>myuser</code></p>
<p>输入密码：即对应的密码</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210113184148720.png" alt="image-20210113184148720"></p>
<p><strong>点击保存并确定</strong></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210113184306127.png" alt="image-20210113184306127"></p>
<p>这是后双击或者点击登陆即可<strong>登陆</strong></p>
<p>由于是普通用户而不是超级用户，因此对于文件的操作可能会受限。所以通过修改设置来使其切换成超级用户</p>
<p>在登陆界面<strong>点击编辑</strong></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210113184955024.png" alt="image-20210113184955024"></p>
<p><strong>点击高级</strong></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210113185033292.png" alt="image-20210113185033292"></p>
<p>在SFTP中协议选项中的SFTP服务器输入：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">sudo su -c /bin/sftp-server</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210113185047095.png" alt="image-20210113185047095"></p>
<p>在SCP/Shell中的Shell中添加</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">sudo su -</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210113185140995.png" alt="image-20210113185140995"></p>
<p><strong>确定并保存</strong></p>
<p>以上就完成了使用scp进行文件的传输</p>
<p>当然也可以通过ssh的密钥方式进行认证登录，这里就不进行设置</p>
<h2 id="环境搭建"><a class="header-anchor" href="#环境搭建"> </a>环境搭建</h2>
<h3 id="python环境"><a class="header-anchor" href="#python环境"> </a>python环境</h3>
<p>查看python版本</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[qibin@VM-0-11-centos ~]$ python -V</span><br><span class="line">Python 2.7.5</span><br><span class="line">[qibin@VM-0-11-centos ~]$ python3 -V</span><br><span class="line">Python 3.6.8</span><br></pre></td></tr></table></figure>
<p>可以看到已经预装了</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Python 2.7.5</span><br><span class="line">Python 3.6.8</span><br></pre></td></tr></table></figure>
<p>所以就不去折腾下载python3更高的版本了</p>
<h4 id="升级pip版本"><a class="header-anchor" href="#升级pip版本"> </a>升级pip版本</h4>
<p>先看看当前pip版本</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[qibin@VM-0-11-centos ~]$ pip3 show pip</span><br><span class="line">Name: pip</span><br><span class="line">Version: 9.0.3</span><br><span class="line">Summary: The PyPA recommended tool for installing Python packages.</span><br><span class="line">Home-page: https://pip.pypa.io/</span><br><span class="line">Author: The pip developers</span><br><span class="line">Author-email: python-virtualenv@groups.google.com</span><br><span class="line">License: MIT</span><br><span class="line">Location: /usr/lib/python3.6/site-packages</span><br><span class="line">Requires:</span><br></pre></td></tr></table></figure>
<p>升级pip</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[qibin@VM-0-11-centos ~]$ sudo python3 -m pip install --upgrade pip</span><br><span class="line">WARNING: Running pip install with root privileges is generally not a good idea. Try `__main__.py install --user` instead.</span><br><span class="line">Collecting pip</span><br><span class="line">  Downloading http://mirrors.tencentyun.com/pypi/packages/54/eb/4a3642e971f404d69d4f6fa3885559d67562801b99d7592487f1ecc4e017/pip-20.3.3-py2.py3-none-any.whl (1.5MB)</span><br><span class="line">    100% |████████████████████████████████| 1.5MB 3.5MB/s</span><br><span class="line">Installing collected packages: pip</span><br><span class="line">Successfully installed pip-20.3.3</span><br></pre></td></tr></table></figure>
<h4 id="virtualenv环境"><a class="header-anchor" href="#virtualenv环境"> </a>virtualenv环境</h4>
<p>参考资料<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1019273143120480">廖雪峰教程-virtualenv</a></p>
<p>安装包</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">pip3 install virtualenv --user</span><br></pre></td></tr></table></figure>
<p>创建对应项目的虚拟环境</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[qibin@VM-0-11-centos ~]$ pwd</span><br><span class="line">/home/qibin</span><br><span class="line">[qibin@VM-0-11-centos ~]$ mkdir wechat-project</span><br><span class="line">[qibin@VM-0-11-centos ~]$ cd wechat-project/</span><br><span class="line">[qibin@VM-0-11-centos wechat-project]$ virtualenv venv</span><br><span class="line">created virtual environment CPython3.6.8.final.0-64 in 810ms</span><br><span class="line">  creator CPython3Posix(dest=/home/qibin/wechat-project/venv, clear=False, no_vcs_ignore=False, global=False)</span><br><span class="line">  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, wheel=bundle, via=copy, app_data_dir=/home/qibin/.local/share/virtualenv)</span><br><span class="line">    added seed packages: pip==20.3.3, setuptools==51.1.2, wheel==0.36.2</span><br><span class="line">  activators BashActivator,CShellActivator,FishActivator,PowerShellActivator,PythonActivator,XonshActivator</span><br></pre></td></tr></table></figure>
<p>进入该环境</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[qibin@VM-0-11-centos wechat-project]$ ls venv/</span><br><span class="line">bin  lib  lib64  pyvenv.cfg</span><br><span class="line">[qibin@VM-0-11-centos wechat-project]$ source venv/bin/activate</span><br><span class="line">(venv) [qibin@VM-0-11-centos wechat-project]$</span><br></pre></td></tr></table></figure>
<p>下载需要的库</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">(venv) [qibin@VM-0-11-centos wechat-project]$ python3 -m pip install werobot -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line">Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">Collecting werobot</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>退出环境</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">(venv) [qibin@VM-0-11-centos wechat-project]$ deactivate</span><br><span class="line">[qibin@VM-0-11-centos wechat-project]$</span><br></pre></td></tr></table></figure>
<h3 id="pip镜像下载"><a class="header-anchor" href="#pip镜像下载"> </a>pip镜像下载</h3>
<p><code>pip --default-timeout=100 install 库名 -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com</code></p>
<h2 id="Nginx搭建"><a class="header-anchor" href="#Nginx搭建"> </a>Nginx搭建</h2>
<p>主要参考<a href="https://www.kuangstudy.com/bbs/1353634800149213186">kuangstudy</a></p>
<h3 id="安装gcc"><a class="header-anchor" href="#安装gcc"> </a>安装gcc</h3>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">yum install gcc-c++</span><br></pre></td></tr></table></figure>
<p>需要切换成root用户，因为普通用户执行不了</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210202163628970.png" alt="image-20210202163628970"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210202163737610.png" alt="image-20210202163737610"></p>
<p>中间输入<code>y</code>并回车</p>
<h3 id="安装-PCRE-pcre-devel"><a class="header-anchor" href="#安装-PCRE-pcre-devel"> </a>安装 PCRE pcre-devel</h3>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">yum install -y pcre pcre-devel</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210202163903849.png" alt="image-20210202163903849"></p>
<p>这里显示已经安装了</p>
<h3 id="安装-zlib"><a class="header-anchor" href="#安装-zlib"> </a>安装 zlib</h3>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210202164024429.png" alt="image-20210202164024429"></p>
<p>这里也显示已经安装</p>
<h3 id="安装-OpenSSL"><a class="header-anchor" href="#安装-OpenSSL"> </a>安装 OpenSSL</h3>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210202164146542.png" alt="image-20210202164146542"></p>
<h3 id="安装nginx"><a class="header-anchor" href="#安装nginx"> </a>安装nginx</h3>
<p>在官方网站下载<a href="http://nginx.org/en/download.html">nginx官网下载</a>最新的压缩包，然后上传到服务器中，这里我上传至<code>/root</code>文件下</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210202164311344.png" alt="image-20210202164311344"></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210202165014522.png" alt="image-20210202165014522"></p>
<p>进行解压</p>
<blockquote>
<p>tar -zxvf nginx-1.18.0.tar.gz</p>
</blockquote>
<p>解压完后切换到<code>nginx-1.18.0</code>文件夹中</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">cd nginx-1.18.0</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210202165155747.png" alt="image-20210202165155747"></p>
<p>文件配置</p>
<p>执行（这里顺便安装ssl模块，因为后期服务器可能需要使用https）</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">./configure --with-http_ssl_module</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210202165614088.png" alt="image-20210202165614088"></p>
<p>运行完后看到生成了<code>Makefile</code>文件</p>
<p>执行</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210202165734558.png" alt="image-20210202165734558"></p>
<p>再执行</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210202170100257.png" alt="image-20210202170100257"></p>
<p>查找nginx安装在哪个目录下</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">whereis nginx</span><br></pre></td></tr></table></figure>
<p>可以看到安装在<code>/usr/local/nginx</code></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210202170140957.png" alt="image-20210202170140957"></p>
<p>切换目录</p>
<blockquote>
<p>cd /usr/local/nginx</p>
</blockquote>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210202170346163.png" alt="image-20210202170346163"></p>
<h3 id="启动nginx"><a class="header-anchor" href="#启动nginx"> </a>启动nginx</h3>
<p>切换目录</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">cd /usr/local/nginx/sbin</span><br></pre></td></tr></table></figure>
<p>启动</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">./nginx</span><br></pre></td></tr></table></figure>
<p>如果运行后没有输出信息，则代表运行成功</p>
<p>如果有输出信息则意味有错，这里是80端口被占用</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210202171403900.png" alt="image-20210202171403900"></p>
<p>根据端口号查看进程，例如查看80端口</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">netstat -lnp|grep 80</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210202172732596.png" alt="image-20210202172732596"></p>
<p>😅这里失败的原因是因为我已经开启了</p>
<p>成功后访问80端口就可以看到</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210202172839128.png" alt="image-20210202172839128"></p>
<p>在<code>/usr/local/nginx/sbin</code>文件夹下执行以下命令</p>
<p>停止nginx</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">./nginx -s stop</span><br></pre></td></tr></table></figure>
<p>安全退出</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">./nginx -s quit</span><br></pre></td></tr></table></figure>
<h2 id="端口"><a class="header-anchor" href="#端口"> </a>端口</h2>
<h3 id="端口转发"><a class="header-anchor" href="#端口转发"> </a>端口转发</h3>
<p>将本机的80转发到12380端口</p>
<blockquote>
<p>iptables -t nat -A PREROUTING -p tcp --dport 80-j REDIRECT --to-port 12380</p>
</blockquote>
<h3 id="查看端口转发nat表"><a class="header-anchor" href="#查看端口转发nat表"> </a>查看端口转发nat表</h3>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">iptables -t nat -nL --line</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210202172116487.png" alt="image-20210202172116487"></p>
<h3 id="删除端口"><a class="header-anchor" href="#删除端口"> </a>删除端口</h3>
<blockquote>
<p>iptables -t nat -D PREROUTING 序号</p>
</blockquote>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">iptables -t nat -D PREROUTING 1</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210202172244325.png" alt="image-20210202172244325"></p>
<p>如果删除了一条记录，则表中记录的序号会发生改变</p>
<h2 id="git搭建"><a class="header-anchor" href="#git搭建"> </a>git搭建</h2>
<p>参考资料</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/32448646">开发人员学Linux(9)：CentOS7编译安装Git-2.13.1及使用</a></li>
<li><a href="https://blog.csdn.net/qq_35561857/article/details/81590953">带你跳过各种坑，一次性把 Hexo 博客部署到自己的服务器</a></li>
</ul>
<p>首先查看是否已经安装git</p>
<blockquote>
<p>git --version</p>
</blockquote>
<p>在root权限下安装git</p>
<p>方式一：通过yum安装，但是版本有点低（1.8.3.1）</p>
<p>（<code>-y</code>代表默认<code>yes</code>，就不用在安装的时候键入<code>y</code>）</p>
<blockquote>
<p>sudo su</p>
<p>git -y install git</p>
</blockquote>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210206105315750.png" alt="image-20210206105315750"></p>
<p>因此卸载了，通过源码编译去安装新版本的git</p>
<p>卸载git：</p>
<blockquote>
<p>yum remove git</p>
</blockquote>
<p>方式二：源码编译安装</p>
<p>安装git第三方库的依赖</p>
<blockquote>
<p>yum install asciidoc docbook2X xmlto texinfo sgml2xml autoconf openjade -y</p>
<p>yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker -y</p>
</blockquote>
<p>记得这里要卸载git的，因为上面的安装又把低版本的git下载下来了</p>
<blockquote>
<p>yum remove git</p>
</blockquote>
<p>将源码压缩包下载至<code>/root</code>目录下</p>
<p>这里是git各版本的目录<a href="https://mirrors.edge.kernel.org/pub/software/scm/git/">git下载目录</a></p>
<blockquote>
<p>cd /root</p>
<p>wget <a href="https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.29.2.tar.gz">https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.29.2.tar.gz</a></p>
</blockquote>
<p>下载后解压</p>
<blockquote>
<p>tar -zxvf git-2.29.2.tar.gz</p>
</blockquote>
<p>进入目录</p>
<blockquote>
<p>cd /root/git-2.29.2</p>
</blockquote>
<p>编译安装</p>
<blockquote>
<p>make configure</p>
<p>./configure --prefix=/usr/local/git</p>
<p>make all doc</p>
<p>make install install-doc install-html</p>
</blockquote>
<p>配置git环境变量</p>
<p>修改<code>/etc/profile</code>文件</p>
<blockquote>
<p>export GIT_HOME=/usr/local/git<br>
export PATH=$PATH:$GIT_HOME/bin</p>
</blockquote>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210206114435017.png" alt="image-20210206114435017"></p>
<p>使配置文件生效</p>
<blockquote>
<p>source /etc/profile</p>
</blockquote>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210206115355438.png" alt="image-20210206115355438"></p>
<p>添加git运行时的user和usergroup</p>
<blockquote>
<p>groupadd git<br>
useradd git -g git</p>
</blockquote>
<p>设置git用户密码</p>
<blockquote>
<p>passwd git</p>
</blockquote>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210206115925033.png" alt="image-20210206115925033"></p>
<p>将git用户暂时添加进sudoers中，方便接下来命令执行</p>
<p>修改<code>/etc/sudoers</code>文件</p>
<blockquote>
<p>vim /etc/sudoers</p>
</blockquote>
<p>将其添加进去</p>
<blockquote>
<p>git     ALL=(ALL)       ALL</p>
</blockquote>
<p>强制保存<code>:wq!</code></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210206120108892.png" alt="image-20210206120108892"></p>
<p>在git用户下，通过ssh登录本机</p>
<blockquote>
<p>su git</p>
<p>ssh git@localhost</p>
</blockquote>
<p>输入yes并输入密码</p>
<p>通过exit退出</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210206120535502.png" alt="image-20210206120535502"></p>
<p>以git身份执行ssh-keygen,并一直回车</p>
<blockquote>
<p>ssh-keygen</p>
</blockquote>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210206120732212.png" alt="image-20210206120732212"></p>
<p>通过如下命令创建authorized_keys文件</p>
<blockquote>
<p>touch ~/.ssh/authorized_keys &amp;&amp; chmod 600  ~/.ssh/authorized_keys</p>
</blockquote>
<p>将生成的公钥文件id_rsa.pub的内容添加到authorized_keys文件中去（authorized_keys用于存放本机免密码登录的用户公钥）：</p>
<blockquote>
<p>cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</p>
</blockquote>
<p>在git用户下创建仓库</p>
<blockquote>
<p>cd /home/git</p>
<p>mkdir -p project/blog</p>
<p>mkdir repo</p>
<p>cd repo</p>
<p>git init --bare blog.git</p>
<p>cd blog.git/hooks</p>
</blockquote>
<p>创建钩子</p>
<blockquote>
<p>vim post-receive</p>
</blockquote>
<p>输入</p>
<blockquote>
<p>#!/bin/sh git --work-tree=/home/git/project/blog --git-dir=/home/git/repo/blog.git checkout -f</p>
</blockquote>
<p>保存后修改权限</p>
<blockquote>
<p>chmod +x post-receive exit</p>
</blockquote>
<p>切换到root用户</p>
<blockquote>
<p>sudo su</p>
<p>chown -R git:git /home/git/repo/blog.git</p>
</blockquote>
<p>接下来在本地自己的电脑将ssh的密钥上传到服务器</p>
<blockquote>
<p>ssh-copy-id -i ~/.ssh/id_rsa.pub <a href="mailto:git@123.123.123.123">git@123.123.123.123</a></p>
</blockquote>
<p>然后在本地自己的电脑测试git</p>
<blockquote>
<p>git clone git@server_ip:/home/git/repo/blog.git</p>
</blockquote>
<p>在本地如果克隆<code>git clone</code>时，出现错误</p>
<blockquote>
<p>bash: git-upload-pack: command not found</p>
</blockquote>
<p>将git安装目录的<code>git-upload-pack</code>链接到<code>/usr/bin/git-upload-pack</code></p>
<blockquote>
<p>ln -s /usr/local/git/bin/git-upload-pack /usr/bin/git-upload-pack</p>
<p>ln -s /usr/local/git/bin/git-receive-pack /usr/bin/git-receive-pack</p>
</blockquote>
<p>禁止git用户shell登录权限，只允许<code>git clone</code>和<code>git push</code></p>
<p>查看git-shell路径</p>
<blockquote>
<p>which git-shell</p>
</blockquote>
<p>将上一步显示出来的路径添加到<code>/etc/shells</code>中，得先切换到root用户</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210206132611992.png" alt="image-20210206132611992"></p>
<p>修改<code>/etc/passwd</code>文件</p>
<blockquote>
<p>vim /etc/passwd</p>
</blockquote>
<p>拉到最下面，将原本的</p>
<blockquote>
<p><code>git:x:1001:1001::/home/git:/bin/bash</code></p>
</blockquote>
<p>改成</p>
<blockquote>
<p><code>git:x:1001:1001:,,,:/home/git:/bin/git-shell</code></p>
</blockquote>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210206132709858.png" alt="image-20210206132709858"></p>
<p>最后记得将git移除sudoers文件中</p>
<h2 id="Java环境搭建"><a class="header-anchor" href="#Java环境搭建"> </a>Java环境搭建</h2>
<h3 id="Java环境-v2"><a class="header-anchor" href="#Java环境-v2"> </a>Java环境</h3>
<!-- more -->
<ol>
<li>
<p>下载Java JDK</p>
<p><a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">Java JDK下载网站</a>然后选择对应的版本，这里选择<code>Linux x64 Compressed Archive</code>对应的安装包为<code>jdk-8u261-linux-x64.tar.gz</code></p>
</li>
<li>
<p><code>sudo mkdir /usr/local/java</code> 来创建环境(<em><strong>我还不太明白ubuntu下面各个目录的意义是什么</strong></em>)</p>
</li>
<li>
<p><code>sudo mv jdk-8u261-linux-x64.tar.gz /usr/local/java</code> 将JDK移到该目录</p>
</li>
<li>
<p><code>cd /usr/local/java</code></p>
</li>
<li>
<p><code>tar -zxvf jdk-8u261-linux-x64.tar.gz</code> 来解压</p>
</li>
<li>
<p><code>sudo vim /etc/profile</code> 配置环境 (<strong>记得加sudo</strong>否则报错会报错： E212：无法打开并写入文件)</p>
</li>
<li>
<p>在文件末尾加入</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_261</span><br><span class="line">export JRE_HOME=/usr/local/java/jdk1.8.0_261/jre</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line">export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>(复制的时候输入:set paste) (相应取消操作为:set nopaste)</p>
<ol start="8">
<li>
<p><code>source /etc/profile</code></p>
</li>
<li>
<p>查看是否成功<code>java -version</code></p>
</li>
</ol>
<h2 id="mysql环境安装"><a class="header-anchor" href="#mysql环境安装"> </a>mysql环境安装</h2>
<p><a href="http://repo.mysql.com/">MySQL yum源地址</a></p>
<ol>
<li>
<p>下载yum仓库的rpm包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo su</span><br><span class="line">cd /root</span><br><span class="line">wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>yum安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install mysql57-community-release-el7-11.noarch.rpm</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>安装MySQL服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install mysql-community-server</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>启动MySQL</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld.service</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查看MySQL运行状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status mysqld.service</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210428190629038.png" alt="image-20210428190629038"></p>
</li>
<li>
<p>找出root用户的密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@VM-0-11-centos ~]# grep &quot;password&quot; /var/log/mysqld.log</span><br><span class="line">2021-04-28T11:05:27.023205Z 1 [Note] A temporary password is generated for root@localhost: _SzrPNoyY60h</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>记住root密码，登陆mysql</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>登进去后修改密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">密码强度要求是：不少于12字符，必须包含大写字母、小写字母、数字和特殊字符。</span></span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;your passowrd&#x27;;</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210428190918654.png" alt="image-20210428190918654"></p>
</li>
<li>
<p>修改字符集</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_general_ci</span><br></pre></td></tr></table></figure>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210428202844909.png" alt="image-20210428202844909"></p>
</li>
<li>
<p>重启mysql</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart mysqld</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>开启权限给本地和远程访问</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;your password&#x27; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建本地用户</span></span><br><span class="line">CREATE USER &#x27;user&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;password&#x27;;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建远程用户</span></span><br><span class="line">CREATE USER &#x27;user&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;password&#x27;;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建数据库</span></span><br><span class="line">CREATE DATABASE test_db;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看用户权限</span></span><br><span class="line">SHOW GRANTS FOR &#x27;user&#x27;@&#x27;%&#x27;;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赋予用户指定数据库远程访问权限</span></span><br><span class="line">GRANT ALL PRIVILEGES ON test_db.* TO &#x27;user&#x27;@&#x27;%&#x27;;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赋予用户对所有数据库远程访问权限</span></span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;user&#x27;@&#x27;%&#x27;;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赋予用户对所有数据库本地访问权限</span></span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;user&#x27;@&#x27;localhost&#x27;;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">刷新权限</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">收回权限</span></span><br><span class="line">REVOKE ALL PRIVILEGES ON *.* FROM &#x27;test&#x27;@&#x27;%&#x27;;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除本地用户</span></span><br><span class="line">DROP USER &#x27;user&#x27;@&#x27;localhost&#x27;;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除远程用户</span></span><br><span class="line">DROP USER &#x27;user&#x27;@&#x27;%&#x27;;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">刷新权限</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题</title>
    <url>/2022/06/03/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    <content><![CDATA[<h2 id="829-连续整数求和"><a class="header-anchor" href="#829-连续整数求和"> </a>829. 连续整数求和</h2>
<h3 id="题目描述"><a class="header-anchor" href="#题目描述"> </a>题目描述</h3>
<p><a href="https://leetcode.cn/problems/consecutive-numbers-sum/">829. 连续整数求和</a></p>
<h3 id="解题思路-v94"><a class="header-anchor" href="#解题思路-v94"> </a>解题思路</h3>
<p><em>2022-06-03</em></p>
<p>对于一组连续整数，假设其首项为 $a$ , 其最后一项为 $a+i$，和为$n$，那么可以得到等式<br>
$$<br>
n=\frac{(a+a+i)}{(i+1)}=\frac{(2a+i)(i+1)}{2}<br>
$$</p>
<p>可以推到出$a$的关系式<br>
$$<br>
a=[\frac{2n}{i+1} - i] \times \frac{1}{2}=\frac{2n-i^{2}-i}{2i+2}<br>
$$<br>
​	又我们知道 $a$ 和 $i$ 都有范围限制<br>
$$<br>
1 \leq a \leq 且 0 \leq i &lt;n<br>
$$<br>
因此，我们可以将 $i$ 从 $0$ 到 $n$ 进行遍历，求得 $a$，且 $a$ 需要满足 $a$ 为整数且 $a \in [1, n]$。</p>
<p>但是仅仅这样的会超时的，可以发现随着 $i$ 增大， 分子会变小，分母会增大，当分子小于分母的时候，已没计算必要，可以中止程序。</p>
<h3 id="解题代码-v72"><a class="header-anchor" href="#解题代码-v72"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">consecutiveNumbersSum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">son</span> <span class="operator">=</span> <span class="number">2</span>  * n - i * i - i;</span><br><span class="line">            <span class="type">long</span> <span class="variable">mother</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (son % mother == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (son &lt; mother) <span class="keyword">break</span>;</span><br><span class="line">                <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> son / mother;</span><br><span class="line">                <span class="keyword">if</span> (result &gt;= <span class="number">1</span> &amp;&amp; result &lt;= n) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="929-独特的电子邮件地址"><a class="header-anchor" href="#929-独特的电子邮件地址"> </a>929. 独特的电子邮件地址</h2>
<h3 id="题目描述-v2"><a class="header-anchor" href="#题目描述-v2"> </a>题目描述</h3>
<p><a href="https://leetcode.cn/problems/unique-email-addresses/">929. 独特的电子邮件地址</a></p>
<h3 id="解题思路-v95"><a class="header-anchor" href="#解题思路-v95"> </a>解题思路</h3>
<p><em>2022-06-04</em></p>
<p><strong>电子邮件</strong>分为<strong>本地名</strong>和<strong>域名</strong>两部分，对于这两部分分别处理。</p>
<p>本地名有两种限制：</p>
<ol>
<li>&quot;+&quot;后面的字符串忽略</li>
<li>&quot;.&quot;直接删除</li>
</ol>
<p>域名没有任何限制，即域名即为它本身。</p>
<p>对此只需对本地名进行字符串处理，将&quot;+“后面的字符串删除并把所有”.&quot;删除。最后再与域名拼接即可</p>
<h3 id="解题代码-v73"><a class="header-anchor" href="#解题代码-v73"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numUniqueEmails</span><span class="params">(String[] emails)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String mail : emails) &#123;</span><br><span class="line">            String[] components = mail.split(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">remain</span> <span class="operator">=</span> components[<span class="number">0</span>].split(<span class="string">&quot;\\+&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">            remain = remain.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            set.add(remain+<span class="string">&quot;@&quot;</span>+components[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="478-在圆内随机生成点"><a class="header-anchor" href="#478-在圆内随机生成点"> </a>478. 在圆内随机生成点</h2>
<h3 id="题目描述-v3"><a class="header-anchor" href="#题目描述-v3"> </a>题目描述</h3>
<p><a href="https://leetcode.cn/problems/generate-random-point-in-a-circle/">478. 在圆内随机生成点</a></p>
<h3 id="解题思路-v96"><a class="header-anchor" href="#解题思路-v96"> </a>解题思路</h3>
<p><em>2022-06-05</em></p>
<p>一个简单的思路是将圆扩展成正方形，在正方形中随机生成点，如果点在圆内则选取该点，否则重试。</p>
<p>对于半径为<code>r</code>的圆，其正方形变成为<code>2r</code>，因此由于 Java 生成的随机数为[0,1),因此如果要在[-r, r]生成随机一点的话，可先将其转换成[0,2r]，最后再减去一个r，则又转回[-r,r]</p>
<h3 id="解题代码-v74"><a class="header-anchor" href="#解题代码-v74"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> xCenter;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> yCenter;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line">    <span class="keyword">private</span> Random random;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Solution</span><span class="params">(<span class="type">double</span> radius, <span class="type">double</span> x_center, <span class="type">double</span> y_center)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">        <span class="built_in">this</span>.xCenter = x_center;</span><br><span class="line">        <span class="built_in">this</span>.yCenter = y_center;</span><br><span class="line">        <span class="built_in">this</span>.random = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span>[] randPoint() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> random.nextDouble() * (<span class="number">2</span> * radius) - radius;</span><br><span class="line">            <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> random.nextDouble() * (<span class="number">2</span> * radius) - radius;</span><br><span class="line">            <span class="keyword">if</span> (x * x + y * y &lt;= radius * radius) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">double</span>[]&#123;xCenter + x, yCenter + y&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(radius, x_center, y_center);</span></span><br><span class="line"><span class="comment"> * double[] param_1 = obj.randPoint();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> xCenter;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> yCenter;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Solution</span><span class="params">(<span class="type">double</span> radius, <span class="type">double</span> x_center, <span class="type">double</span> y_center)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">        <span class="built_in">this</span>.xCenter = x_center;</span><br><span class="line">        <span class="built_in">this</span>.yCenter = y_center;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span>[] randPoint() &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">length</span> <span class="operator">=</span> Math.sqrt(<span class="built_in">this</span>.radius * <span class="built_in">this</span>.radius * Math.random());</span><br><span class="line">        <span class="type">double</span> <span class="variable">angle</span> <span class="operator">=</span> Math.toRadians(Math.random() * <span class="number">360.0</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">xPosition</span> <span class="operator">=</span> xCenter + length * Math.cos(angle);</span><br><span class="line">        <span class="type">double</span> <span class="variable">yPosition</span> <span class="operator">=</span> yCenter + length * Math.sin(angle);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">double</span>[]&#123;xPosition, yPosition&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(radius, x_center, y_center);</span></span><br><span class="line"><span class="comment"> * double[] param_1 = obj.randPoint();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="732-我的日程安排表-III"><a class="header-anchor" href="#732-我的日程安排表-III"> </a>732. 我的日程安排表 III</h2>
<h3 id="题目描述-v4"><a class="header-anchor" href="#题目描述-v4"> </a>题目描述</h3>
<p><a href="https://leetcode.cn/problems/my-calendar-iii/">732. 我的日程安排表 III</a></p>
<h3 id="解题思路-v97"><a class="header-anchor" href="#解题思路-v97"> </a>解题思路</h3>
<p><em>2022-06-06</em></p>
<p>每次一个新的 book 产生，则会在线段上占据一段左闭右开的区间。题目的问题是，在新的 book 加入后， 在当前线段上，在同一时刻，区间重合的最多次数。</p>
<h3 id="解题代码-v75"><a class="header-anchor" href="#解题代码-v75"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCalendarThree</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCalendarThree</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">book</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="comment">// 一个 start 表示会新增一个 book，则k++</span></span><br><span class="line">        <span class="comment">// 一个 end 表示其中一个 book会结束， 则k--</span></span><br><span class="line">        <span class="comment">// 因此将所有book时间从小到大排序，从小至大遍历，即可获取最多k的时刻</span></span><br><span class="line">        <span class="comment">// Java TreeMap会对key自动从小到大排序</span></span><br><span class="line">        map.put(start, map.getOrDefault(start, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        map.put(end, map.getOrDefault(end, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            count += entry.getValue();</span><br><span class="line">            maxCount = Math.max(maxCount, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCalendarThree object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCalendarThree obj = new MyCalendarThree();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.book(start,end);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="875-爱吃香蕉的珂珂"><a class="header-anchor" href="#875-爱吃香蕉的珂珂"> </a>875. 爱吃香蕉的珂珂</h2>
<h3 id="题目描述-v5"><a class="header-anchor" href="#题目描述-v5"> </a>题目描述</h3>
<p><em>2022-06-07</em></p>
<p><a href="https://leetcode.cn/problems/koko-eating-bananas/">875. 爱吃香蕉的珂珂</a></p>
<h3 id="解题思路-v98"><a class="header-anchor" href="#解题思路-v98"> </a>解题思路</h3>
<p>珂珂吃香蕉速度范围可以得出是至少 <code>k=1</code> ，至多为 <code>k=max(piles[x])</code>。同时题目要求在以<code>k</code>速度时，其时间必须小于或等于<code>h</code>，因此可以根据<strong>二分查找法</strong>的思路，在<code>k∈[1, max(piles[x])]</code>范围内去寻找能够使得时间<code>time</code>满足小于等于<code>h</code>时的<code>k</code>的最小值。</p>
<h3 id="解题代码-v76"><a class="header-anchor" href="#解题代码-v76"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minEatingSpeed</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> pile : piles) &#123;</span><br><span class="line">            max = Math.max(max, pile);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (min &lt; max) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span>  min + (max - min) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">time</span> <span class="operator">=</span> getTime(piles, mid);</span><br><span class="line">            <span class="keyword">if</span> (time &lt;= h) &#123;</span><br><span class="line">                max = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                min = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTime</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">time</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> pile: piles) &#123;</span><br><span class="line">            <span class="comment">// 向上取整</span></span><br><span class="line">            time += ((pile + k - <span class="number">1</span>) / k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1037-有效的回旋镖"><a class="header-anchor" href="#1037-有效的回旋镖"> </a>1037. 有效的回旋镖</h2>
<h3 id="题目描述-v6"><a class="header-anchor" href="#题目描述-v6"> </a>题目描述</h3>
<p><a href="https://leetcode.cn/problems/valid-boomerang/">1037. 有效的回旋镖</a></p>
<h3 id="解题思路-v99"><a class="header-anchor" href="#解题思路-v99"> </a>解题思路</h3>
<p><em>2022-06-08</em></p>
<p>题目跟回旋镖没关系，就是判断三个点，是否<strong>各不相同</strong>且<strong>不在同一条直线上（包括横的、竖的、斜的）</strong></p>
<ul>
<li>
<p>方法一分别判断是否重合和是否在同一条直线上</p>
</li>
<li>
<p>方法二通过高等数学知识：两向量叉乘为0的时候，该两向量平行</p>
<ul>
<li>延展：两向量点乘为0的时候，该两向量垂直</li>
</ul>
</li>
</ul>
<h3 id="解题代码-v77"><a class="header-anchor" href="#解题代码-v77"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBoomerang</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否重合点</span></span><br><span class="line">        Map&lt;Integer, Set&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] point : points) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(point[<span class="number">0</span>])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.get(point[<span class="number">0</span>]).contains(point[<span class="number">1</span>])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.get(point[<span class="number">0</span>]).add(point[<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">                set.add(point[<span class="number">1</span>]);</span><br><span class="line">                map.put(point[<span class="number">0</span>], set);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否同一直线</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">accuracy</span> <span class="operator">=</span> <span class="number">0.0000000001</span>;</span><br><span class="line">        <span class="keyword">if</span> ((points[<span class="number">0</span>][<span class="number">0</span>] == points[<span class="number">1</span>][<span class="number">0</span>] &amp;&amp; points[<span class="number">1</span>][<span class="number">0</span>] == points[<span class="number">2</span>][<span class="number">0</span>]) ||</span><br><span class="line">            (points[<span class="number">0</span>][<span class="number">1</span>] == points[<span class="number">1</span>][<span class="number">1</span>] &amp;&amp; points[<span class="number">1</span>][<span class="number">1</span>] == points[<span class="number">2</span>][<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">k1</span> <span class="operator">=</span> getK(points[<span class="number">0</span>], points[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">double</span> <span class="variable">k2</span> <span class="operator">=</span> getK(points[<span class="number">1</span>], points[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(k2-k1) &lt; accuracy) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getK</span><span class="params">(<span class="type">int</span>[] point1, <span class="type">int</span>[] point2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="type">double</span>)point1[<span class="number">1</span>] - (<span class="type">double</span>)point2[<span class="number">1</span>]) / ((<span class="type">double</span>)point1[<span class="number">0</span>] - (<span class="type">double</span>)point2[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBoomerang</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] v1 = &#123;points[<span class="number">0</span>][<span class="number">0</span>]-points[<span class="number">1</span>][<span class="number">0</span>], points[<span class="number">0</span>][<span class="number">1</span>]-points[<span class="number">1</span>][<span class="number">1</span>]&#125;;</span><br><span class="line">        <span class="type">int</span>[] v2 = &#123;points[<span class="number">1</span>][<span class="number">0</span>]-points[<span class="number">2</span>][<span class="number">0</span>], points[<span class="number">1</span>][<span class="number">1</span>]-points[<span class="number">2</span>][<span class="number">1</span>]&#125;;</span><br><span class="line">        <span class="keyword">return</span> v1[<span class="number">0</span>]*v2[<span class="number">1</span>]-v2[<span class="number">0</span>]*v1[<span class="number">1</span>] == <span class="number">0</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="497-非重叠矩形中的随机点"><a class="header-anchor" href="#497-非重叠矩形中的随机点"> </a>497. 非重叠矩形中的随机点</h2>
<h3 id="题目描述-v7"><a class="header-anchor" href="#题目描述-v7"> </a>题目描述</h3>
<p><a href="https://leetcode.cn/problems/random-point-in-non-overlapping-rectangles/">497. 非重叠矩形中的随机点</a></p>
<h3 id="解题思路-v100"><a class="header-anchor" href="#解题思路-v100"> </a>解题思路</h3>
<p><em>2022-06-09</em></p>
<p><u>题目意思</u>：多个<strong>不重叠</strong>的<strong>矩形</strong>，在这多个矩形中随机求一<strong>整数坐标点</strong>，且要求所有点出现的<strong>概率一致</strong>，返回随机生成的该点</p>
<p><u>错误直白思维</u>：直接在矩形数组<code>rects</code>中，先随机下标获取矩形，再在该矩形随机获取点。这样<strong>概率不一致</strong></p>
<p>qibin思路：<strong>拒绝采样</strong></p>
<ul>
<li>将所有矩形<strong>水平拼在一起</strong>，那么在水平长度中，其随机获取一点的概率是一致的，都是<code>1/拼接后的大矩形宽度</code>。</li>
<li>但是高度的坐标点如果就取各自矩形的高进行随机，则概率又不一致。因此可以取所有矩形中高最高的矩形，那么所有纵坐标的概率就是<code>1/高最高的矩形高度</code>。如果随机到的高度大于了某个矩形的高度，那么重来直到坐标点落到矩形中即可。</li>
</ul>
<p><img src="http://algorithm-image.qibinaoe.top/65392b13c8151cc59153c26992f1e60-1654748119472.jpg" alt="非重叠矩形中的随机点-解题思路示意图"></p>
<p><u>补充说明</u>：在拒绝采样中，提议分布指的是容易采样到的分布区域，例如本解法的外接矩阵。但如果提议分布选取不好则会导致效率低下，例如在本解法中，假如矩阵高度差过大，则可能会导致拒绝次数增多而效率降低</p>
<h3 id="解题代码-v78"><a class="header-anchor" href="#解题代码-v78"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">totalWidthPointCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxHeightPointCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] rects;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Solution</span><span class="params">(<span class="type">int</span>[][] rects)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rects = rects;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] rect : rects) &#123;</span><br><span class="line">            maxHeightPointCount = Math.max(maxHeightPointCount, rect[<span class="number">3</span>]-rect[<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">            totalWidthPointCount += rect[<span class="number">2</span>] - rect[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] pick() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">widthPosition</span> <span class="operator">=</span> random.nextLong(totalWidthPointCount) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">heightPosition</span> <span class="operator">=</span> random.nextInt(maxHeightPointCount) + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 寻找width是在哪个矩形</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">currentWidth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] rect : <span class="built_in">this</span>.rects) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">widthPointCount</span> <span class="operator">=</span> rect[<span class="number">2</span>] - rect[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (currentWidth + widthPointCount &gt;= widthPosition) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> rect[<span class="number">0</span>] + (widthPosition - currentWidth - <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 判断y是否在这个矩形中，如果不在则重新寻找新的点</span></span><br><span class="line">                    <span class="keyword">if</span> (rect[<span class="number">3</span>] - rect[<span class="number">1</span>] + <span class="number">1</span> &gt;= heightPosition) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> rect[<span class="number">1</span>] + heightPosition - <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;(<span class="type">int</span>)x, y&#125;;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    currentWidth += widthPointCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(rects);</span></span><br><span class="line"><span class="comment"> * int[] param_1 = obj.pick();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="926-将字符串翻转到单调递增"><a class="header-anchor" href="#926-将字符串翻转到单调递增"> </a>926. 将字符串翻转到单调递增</h2>
<h3 id="题目描述-v8"><a class="header-anchor" href="#题目描述-v8"> </a>题目描述</h3>
<p><a href="https://leetcode.cn/problems/flip-string-to-monotone-increasing/">926. 将字符串翻转到单调递增</a></p>
<h3 id="解题思路-v101"><a class="header-anchor" href="#解题思路-v101"> </a>解题思路</h3>
<p><em>2022-06-11</em></p>
<p>本题采用<strong>动态规划</strong>的思想，原因是对于这个翻转字符串可以划分成子问题，同时子问题都是一致的。</p>
<p>本体核心问题就是：<strong>翻</strong>或者<strong>不翻</strong>。即对于字符串中的某一个数，是否将其翻转，或者保持不变。而结合动态规划的思想来看，其子问题就是在<code>[0, x]</code>范围内，第<code>x</code>个字符翻或者不翻。其该问题的子问题就是在<code>[0, x-1]</code>范围内，第<code>x-1</code>个字符翻或者不翻</p>
<p>在进一步讨论之前，我们先明确题目意思：题目要求我们能够构造出前部分都为<code>0</code>，后部分都为<code>1</code>的字符串（两种特殊情况是：1. 都为<code>0</code>。 2. 都为<code>1</code>）</p>
<p>根据核心问题，我们可以进一步讨论：对于某个字符<code>x</code> （假设字符串为 <code>abcdxyfg</code>，每个字符都要么是<code>0</code>，要么是<code>1</code>）</p>
<ul>
<li>翻成<code>0</code>或者保持为<code>0</code> =&gt; 那么其右边的字符<code>y</code>可以为<code>0</code>，也可以为<code>1</code></li>
<li>翻成<code>1</code>或者保持为<code>1</code> =&gt; 那么其右边的字符<code>y</code>只能为<code>1</code></li>
</ul>
<p><u>注意</u>：我们只需要讨论<code>x</code>是否翻成另一个数还是保持不变，而不用管其右边的字符<code>y</code>是否是翻转还是保持不变的。这也是动态规划的思想，其将子问题以及子问题的子问题分割开来，在我们求解子问题的子问题的时候，我们只需要知道子问题的结果，而不需要子问题求解过程。</p>
<p>据此，我们确定动态规划的状态，即动态规划的数组</p>
<p><code>dp[i][n] = count</code></p>
<ul>
<li><code>i</code> 代表字符串的第<code>i</code>个字符，<code>i</code>的范围为<code>[0, s.length-1]</code></li>
<li><code>n</code>的取值为<code>0</code>和<code>1</code>，这个是自己定义的，其中令<code>0</code>代表第<code>i</code>个元素不翻转。令<code>1</code>代表第<code>i</code>个元素翻转</li>
<li><code>count</code>表示最小的翻转次数。例如<code>dp[2][1] = count</code>，表示字符串的第2个字符进行翻转后，其最小的翻转次数为<code>count</code></li>
</ul>
<p>在规定好动态规划的数组后，我们来确定<strong>动态规划的转移方程</strong>（从右往左开始计算，<code>s[i]</code>代表原本字符串，<code>s'[i]</code>代表翻转后的字符串）</p>
<ol>
<li>
<p>假设第<code>i</code>个元素不进行翻转</p>
<ul>
<li>如果<code>s[i] == '0'</code>，那么<code>dp[i][0] = min(dp[i+1][0], dp[i+1][1])</code></li>
<li>如果<code>s[i] == '1'</code>，那么<code>s’[i+1]</code>必须为<code>1</code>
<ul>
<li>因此如果<code>s[i+1] == '0'</code>，那么<code>dp[i][0] = dp[i+1][1]</code></li>
<li>如果<code>s[i+1] == '1'</code>，那么<code>dp[i][0] = dp[i+1][0]</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>假设第<code>i</code>个元素进行翻转</p>
<ul>
<li>如果<code>s[i] == '0'</code>，那么翻转后的数字就为<code>1</code>，那么<code>s'[i+1]</code>必须为<code>1</code>
<ul>
<li>因此如果<code>s[i+1] == '0'</code>，那么<code>dp[i][1] = 1 + dp[i+1][1]</code></li>
<li>如果<code>s[i+1] == '1'</code>，那么<code>dp[i][1] = 1 + dp[i+1][0]</code></li>
</ul>
</li>
<li>如果<code>s[i] == '1'</code>，那么翻转后的数字为<code>1</code>，那么<code>s'[i+1]</code>可以为<code>1</code>或者<code>0</code>
<ul>
<li><code>dp[i][1] = 1 + min(dp[i+1][0], dp[i+1][1])</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>最后讨论<strong>初始条件：</strong></p>
<p>我们从右往左开始遍历，所以在右边的第一个字符开始，所以边界的情况是<code>dp[s.length-1][0]=0</code>和<code>dp[s.length-1][1]=1</code>，然后我们从<code>s.length-2</code>开始往左遍历</p>
<h3 id="解题代码-v79"><a class="header-anchor" href="#解题代码-v79"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minFlipsMonoIncr</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] binaryString = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> binaryString.length;</span><br><span class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// binaryString[i] 代表第 i 个元素原本的字符</span></span><br><span class="line">        <span class="comment">// 第一个下标表示第 i 个元素</span></span><br><span class="line">        <span class="comment">// 第二个下标表示： 0 代表不翻转 1 代表翻转</span></span><br><span class="line">        <span class="comment">// dp[i][n] = count    count代表最小翻转次数</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[length][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        dp[length - <span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[length - <span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 从右往左遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> length-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (binaryString[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = Math.min(dp[i+<span class="number">1</span>][<span class="number">0</span>], dp[i+<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (binaryString[i+<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][<span class="number">1</span>] = <span class="number">1</span> + dp[i+<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][<span class="number">1</span>] = <span class="number">1</span> + dp[i+<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][<span class="number">1</span>] = <span class="number">1</span> + Math.min(dp[i+<span class="number">1</span>][<span class="number">0</span>], dp[i+<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (binaryString[i+<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][<span class="number">0</span>] = dp[i+<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][<span class="number">0</span>] = dp[i+<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(dp[<span class="number">0</span>][<span class="number">0</span>],dp[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="890-查找和替换模式"><a class="header-anchor" href="#890-查找和替换模式"> </a>890. 查找和替换模式</h2>
<h3 id="题目描述-v9"><a class="header-anchor" href="#题目描述-v9"> </a>题目描述</h3>
<p><a href="https://leetcode.cn/problems/find-and-replace-pattern/">890. 查找和替换模式</a></p>
<h3 id="解题思路-v102"><a class="header-anchor" href="#解题思路-v102"> </a>解题思路</h3>
<p><em>2022-06-12</em></p>
<blockquote>
<p><em>字母的排列是从字母到字母的双射：每个字母映射到另一个字母，没有两个字母映射到同一个字母。</em></p>
</blockquote>
<p>题目意思是：判断两个相同长度的字符串<code>s1</code>和<code>s2</code>，判断<code>s1</code>的每个字符能不能和<code>s2</code>的每个字符一一对应。即<code>s1</code>的其中一个字符只能对应<code>s2</code>的相应位置的一个字符，而不能是多个。同理，<code>s2</code>的每个字符只能对应<code>s1</code>的相应位置的一个字符，而不能是多个。</p>
<p>反例：</p>
<ul>
<li><code>abb</code>和<code>abc</code> 不能构成双射。因为<code>s1</code>中的<code>b</code>既对应<code>s2</code>的<code>b</code>也对应<code>s2</code>的<code>c</code></li>
</ul>
<p>因此，要判断两个字符串是否满足<strong>双射</strong>的关系，最直接的方法就是建立两个<code>HashMap</code>去记录其两个字符串一一对应的关系。</p>
<ul>
<li>如果出现一个<code>map</code>中有对应关系，另一个<code>map</code>中没对应关系，则说明不能构成双射</li>
<li>如果出现两个<code>map</code>中保存的对应关系不一致，则说明不能构成双射</li>
</ul>
<h3 id="解题代码-v80"><a class="header-anchor" href="#解题代码-v80"> </a>解题代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findAndReplacePattern</span><span class="params">(String[] words, String pattern)</span> &#123;</span><br><span class="line">        Map&lt;Character, Character&gt; wordToPattern = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Character&gt; patternToWord = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> pattern.length();</span><br><span class="line">        List&lt;String&gt; results = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> words[i];</span><br><span class="line">            wordToPattern.clear();</span><br><span class="line">            patternToWord.clear();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (wordToPattern.containsKey(word.charAt(j)) &amp;&amp; patternToWord.containsKey(pattern.charAt(j))) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((wordToPattern.get(word.charAt(j)) != pattern.charAt(j)) || </span><br><span class="line">                        (patternToWord.get(pattern.charAt(j)) != word.charAt(j))) &#123;</span><br><span class="line">                            flag = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wordToPattern.containsKey(word.charAt(j)) ^ patternToWord.containsKey(pattern.charAt(j))) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    wordToPattern.put(word.charAt(j), pattern.charAt(j));</span><br><span class="line">                    patternToWord.put(pattern.charAt(j), word.charAt(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                results.add(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="算法技巧"><a class="header-anchor" href="#算法技巧"> </a>算法技巧</h1>
<h2 id="两数平均值"><a class="header-anchor" href="#两数平均值"> </a>两数平均值</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">average = min + (max - min) / <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="向上取整"><a class="header-anchor" href="#向上取整"> </a>向上取整</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">result = (son + mother - <span class="number">1</span>) / mother</span><br></pre></td></tr></table></figure>
<h1 id="Java-相关问题"><a class="header-anchor" href="#Java-相关问题"> </a>Java 相关问题</h1>
<p><code>null</code>不可与<strong>基本数据类型</strong>进行逻辑比较：</p>
<p>例如<code>if (null != 'a') &#123;..&#125;</code> 则会报错</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>自我能力批判、审视与激励</title>
    <url>/2020/10/30/%E8%87%AA%E6%88%91%E8%83%BD%E5%8A%9B%E6%89%B9%E5%88%A4%E3%80%81%E5%AE%A1%E8%A7%86%E4%B8%8E%E6%BF%80%E5%8A%B1/</url>
    <content><![CDATA[<h2 id="针对自我能力审视"><a class="header-anchor" href="#针对自我能力审视"> </a>针对自我能力审视</h2>
<!-- more -->
<p>我发现我个人能力在各个方面都有很大的缺陷。其中近期我较为关注的是我个人表达能力以及逻辑思考能力。</p>
<p>在上团队激励与沟通课程上，我以小组长的身份上台介绍<em>不存在</em>的小组讨论时候，当教室话筒放大我的音量，我发现我说话时常带着&quot;然后、然后&quot;等词。我对此铭记在心，却没有很大行动加以思考。在今日<code>2020-10-30</code>我看了计算机学院大创答辩时候，也发现许多人都带有自己一定的语言习惯，我认为这很大程度上会影响观众聆听的效果，以及整体演讲的效果。具体对此思考点击看<code>说话、演讲等感悟</code>文章，而最终引起我反思的时候是，我现在正在写技术博客，而发现我的写作用词竟也带着一系列的“然后”。如下</p>
<p><img src="http://algorithm-image.qibinaoe.top/%E5%86%99%E4%BD%9C%E4%B8%AD%E4%B8%80%E7%B3%BB%E5%88%97%E7%84%B6%E5%90%8E.jpg" alt="写作中一系列然后"></p>
<p>我对此开始进行思考与反思，并写下这篇博客。</p>
<p>首先通过知乎渠道进行查询，大多是以下能力欠缺导致的。</p>
<ul>
<li>口头表达能力、语言表达能力欠缺低下</li>
<li>书面表达能力欠缺</li>
<li>词汇量积累不够</li>
<li>大脑思考速度跟不上嘴的表达速度，以<code>然后</code>来弥补时间来思考</li>
<li>语言发表缺乏逻辑性，逻辑不清晰，思路不清晰</li>
</ul>
<p>对于该方面能力的提升，我讲通过视频书籍等方式去提升自己。</p>
<h3 id="题外话"><a class="header-anchor" href="#题外话"> </a>题外话</h3>
<p>我认为个人技术能力固然重要，但是缺乏个人表达能力，逻辑演绎能力等个人素质的体现，很难在社会上站住脚，得到发展。因此不要一心只顾提升个人技术水平，而忘却了素质水平。</p>
]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>自我修养</tag>
      </tags>
  </entry>
  <entry>
    <title>算法4—知识</title>
    <url>/2020/11/14/%E7%AE%97%E6%B3%954%E2%80%94%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="算法4-答疑与知识"><a class="header-anchor" href="#算法4-答疑与知识"> </a>算法4 答疑与知识</h2>
<!-- more -->
<ul>
<li>
<p>Math.abs(-2147483648)的返回值是什么</p>
<ul>
<li>-2147483648</li>
</ul>
</li>
<li>
<p>递归函数的BUG</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">exR2</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> exR2(n-<span class="number">3</span>) + n + exR2(n-<span class="number">2</span>) + n;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>问题出现在该递归函数的基础情况永远不会被访问到</li>
</ul>
</li>
<li>
<p>对象</p>
<ul>
<li>能够承载数据类型的值的实体</li>
</ul>
</li>
<li>
<p>对象三大特性</p>
<ul>
<li>状态
<ul>
<li>数据类型中的值</li>
</ul>
</li>
<li>标识
<ul>
<li>一个对象区别于另一个对象</li>
</ul>
</li>
<li>行为
<ul>
<li>数据类型的操作</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>理财投资课堂笔记</title>
    <url>/2020/12/29/%E7%90%86%E8%B4%A2%E6%8A%95%E8%B5%84%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="第一次课"><a class="header-anchor" href="#第一次课"> </a>第一次课</h2>
<p>标股500</p>
<p>理财要趁早：时间的力量</p>
<p>不能买信托</p>
<p>固定收益类产品也是有风险的</p>
<ul>
<li>信托风险不可控</li>
</ul>
<p>接下来不要买房子</p>
<p>收益和风险权衡</p>
<p>期货、原油</p>
<p>避开不了解的投资领域</p>
<p>美元贬值 &lt;=&gt; 黄金升值</p>
<p>长期年化收益 -&gt; 资产配置 -&gt; 应该多元化投资（分散化）</p>
<p>股市：3000点以下是低位</p>
<p>美国：牛长熊短</p>
<p>中国：熊长牛短</p>
<h3 id="财务健康-制定计划"><a class="header-anchor" href="#财务健康-制定计划"> </a>财务健康 制定计划</h3>
<p>财务状况了解</p>
<p>网购分期付款的利率高</p>
<p>贷款  负债  资产 支出  收入</p>
<p>资产负债表 -&gt; 财务状况</p>
<p>个人利润表 -&gt; 收入来源和支出渠道</p>
<p>财务比率 -&gt; 检查财务健康状况</p>
<p>记账</p>
<p>财务目标</p>
<p>编制</p>
<h4 id="个人资产负债表"><a class="header-anchor" href="#个人资产负债表"> </a>个人资产负债表</h4>
<ul>
<li>资产：asset</li>
<li>负债：debt</li>
<li>净资产（资本）：equity</li>
</ul>
<h5 id="按类别划分"><a class="header-anchor" href="#按类别划分"> </a>按类别划分</h5>
<ul>
<li>应付紧急状况（3-6个月家庭支出）</li>
<li>货币资产：存款、现金、货币基金</li>
<li>投资资产</li>
<li>自用资产</li>
</ul>
<h2 id="第二次课"><a class="header-anchor" href="#第二次课"> </a>第二次课</h2>
<p>净资产=资产-负债</p>
<p>储蓄=收入-支出</p>
<p>净资产：所拥有的资产</p>
<h3 id="资产（按类别划分）"><a class="header-anchor" href="#资产（按类别划分）"> </a>资产（按类别划分）</h3>
<ul>
<li>货币资产
<ul>
<li>流通性高【快速变现】 =&gt; 日常开销、应急支付</li>
<li>价值无损失 =&gt; 目的不是赚钱</li>
</ul>
</li>
<li>投资资产
<ul>
<li>价值增值：股票、房产、债券</li>
<li>（如果房子只有一套，那就属于自用）</li>
</ul>
</li>
<li>自用资产
<ul>
<li>住房、车、家具</li>
</ul>
</li>
</ul>
<p>流通性不强：封闭基金</p>
<p>牛市是亏钱最多的</p>
<p>人性的弱点</p>
<p>熊市播种</p>
<p>计算资产 =&gt; 公平市场价值</p>
<p>记录资产项目</p>
<p>记录资产的总价值</p>
<p><strong>负债（按期限划分）</strong></p>
<ul>
<li>流动负债：必须在一年内还清的债务
<ul>
<li>花呗 ：计算年利率 达20% 非常高</li>
<li>水电费、房租、信用卡</li>
</ul>
</li>
<li>长期负债：一年以后到期的债务
<ul>
<li>房贷：20年、30年</li>
<li>汽车贷款、助学贷款、装修</li>
</ul>
</li>
</ul>
<p>财务自由：未来生活开支，投资能cover生活开支，就不用工作，解放出来</p>
<p>个人净资产=资产-负债</p>
<ul>
<li>衡量个人财富的指标
<ul>
<li>股票是重要投资途径</li>
</ul>
</li>
<li>正值</li>
<li>负值：资不抵债</li>
</ul>
<p>个人净资产应该关注<strong>变化趋势</strong>，而不是多少</p>
<ul>
<li>好的应该是逐年增加</li>
</ul>
<p>房屋净值贷款：二次贷款</p>
<p>货币资产（流动）不能太多也不能太少：10%以下</p>
<p>M2超过10%，房价会上涨</p>
<p>利润表：一段时间，总收入水平，总支出水平</p>
<p><strong>收入</strong></p>
<ul>
<li>工作收入</li>
<li>理财收入</li>
</ul>
<p><strong>支出</strong></p>
<p><strong>储蓄</strong></p>
<p><strong>投资</strong></p>
<h2 id="第三次课"><a class="header-anchor" href="#第三次课"> </a>第三次课</h2>
<h3 id="收入"><a class="header-anchor" href="#收入"> </a>收入</h3>
<ul>
<li>工作收入</li>
<li>理财</li>
</ul>
]]></content>
      <categories>
        <category>大学时代</category>
      </categories>
      <tags>
        <tag>大学时代</tag>
        <tag>理财投资</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/11/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="设计模式读书笔记"><a class="header-anchor" href="#设计模式读书笔记"> </a>设计模式读书笔记</h2>
<p>设计模式的学习书籍我看的是刘伟老师的《设计模式的艺术》</p>
<p>图片来源于《设计模式的艺术》</p>
<!-- more -->
<h2 id="设计模式概念"><a class="header-anchor" href="#设计模式概念"> </a>设计模式概念</h2>
<h3 id="定义"><a class="header-anchor" href="#定义"> </a>定义</h3>
<p>设计模式是一套被<strong>反复使用</strong>的、多数人知晓的、经过分类的、<strong>代码设计经验</strong>的<strong>总结</strong>。</p>
<p>使用设计模式是为了<strong>重用代码</strong>、让代码更容易被他人理解并且保证代码的<strong>可靠性</strong></p>
<h3 id="关键要素"><a class="header-anchor" href="#关键要素"> </a>关键要素</h3>
<p>模式名称、问题、解决方案和效果</p>
<h3 id="学习关键"><a class="header-anchor" href="#学习关键"> </a>学习关键</h3>
<ul>
<li>这个设计模式的意图是什么</li>
<li>解决一个什么样的问题</li>
<li>什么时候可以使用它</li>
<li>如果解决问题</li>
<li>掌握结构图</li>
<li>关键代码</li>
<li>应用实例
<ul>
<li>生活上</li>
<li>软件上</li>
</ul>
</li>
<li>模式的优点</li>
<li>模式的缺点</li>
<li>使用时应该注意什么</li>
</ul>
<h2 id="UML"><a class="header-anchor" href="#UML"> </a>UML</h2>
<h3 id="关联关系-Association"><a class="header-anchor" href="#关联关系-Association"> </a>关联关系 Association</h3>
<p>关联关系是一种<strong>结构化关系</strong></p>
<p>关联关系用来表示一类对象对另一类对象之间<strong>有联系</strong>。</p>
<p>通常将一个类的对象作为另一个类的成员变量</p>
<h3 id="双向关联"><a class="header-anchor" href="#双向关联"> </a>双向关联</h3>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210141048317.png" alt="image-20201210141048317"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Product[] products;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Customer[] customers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单向关联"><a class="header-anchor" href="#单向关联"> </a>单向关联</h3>
<p>单向关联用<strong>带箭头的实线</strong>表示</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210141132832.png" alt="image-20201210141132832"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Customer &#123;</span><br><span class="line">    private Address address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自关联"><a class="header-anchor" href="#自关联"> </a>自关联</h3>
<p>自关联表示类的属性中<strong>存在该类本身</strong>。</p>
<p>例如链表中的结点都包含自身<code>Node next</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多重性关联"><a class="header-anchor" href="#多重性关联"> </a>多重性关联</h3>
<p>多重性关联关系又称为重数性（multiplicity）关联关系，表示<strong>两个关联对象</strong>在<strong>数量上</strong>的对应关系。UML中多重性在关联直线上用数字或数字范围来表示</p>
<table>
<thead>
<tr>
<th style="text-align:center">表示方式</th>
<th style="text-align:center">多重性说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1…1</td>
<td style="text-align:center">表示<strong>另一个类</strong>的<strong>一个对象</strong>只与<strong>该类</strong>的<strong>一个对象</strong>有关系</td>
</tr>
<tr>
<td style="text-align:center">0…*</td>
<td style="text-align:center">表示<strong>另一个类</strong>的<strong>一个对象</strong>与<strong>该类</strong>的<strong>零个或多个对象</strong>有关系</td>
</tr>
<tr>
<td style="text-align:center">1…*</td>
<td style="text-align:center">表示<strong>另一个类</strong>的<strong>一个对象</strong>与<strong>该类</strong>的<strong>一个或多个对象</strong>有关系</td>
</tr>
<tr>
<td style="text-align:center">0…1</td>
<td style="text-align:center">表示<strong>另一个类</strong>的<strong>一个对象</strong>与<strong>该类没有关系</strong>或只与<strong>一个对象</strong>有关系</td>
</tr>
<tr>
<td style="text-align:center">m…n</td>
<td style="text-align:center">表示<strong>另一个类</strong>的<strong>一个对象</strong>与<strong>该类最少有m个，最多n个对象</strong>有关系 （其中m &lt;= n）</td>
</tr>
</tbody>
</table>
<p>注意：这里的<strong>数字范围靠近</strong>的<strong>那个类</strong>，指的是上面”多重性说明“中的<strong>该类</strong>，而离<strong>数字范围远</strong>的那个类指代的是<strong>另一个类</strong></p>
<p>下面例子表示：**0…***靠近Button端，远离Form端。说明，Form的一个对象有Button类的零个或多个对象。</p>
<p>说人话：一个Form界面拥有零个或多个Button按钮。而一个按钮Button只属于一个Form界面</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210142755472.png" alt="image-20201210142755472"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Form</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Button[] buttons;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="聚合关系-Aggregation"><a class="header-anchor" href="#聚合关系-Aggregation"> </a>聚合关系 Aggregation</h3>
<p>聚合关系表示<strong>整体</strong>和<strong>部分</strong>的关系。<strong>成员对象</strong>是<strong>整体对象</strong>的一部分，但是成员对象<strong>可以脱离</strong>整体对象独立存在。</p>
<p>UML中，聚合关系用带<strong>空心菱形</strong>的直线表示。（空心菱形一端指向整体对象）。</p>
<p>汽车发动机可以脱离汽车独立存在</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210145448230.png" alt="image-20201210145448230"></p>
<p>代码实现聚合关系时，成员对象通常通过<strong>构造方法</strong>、Setter方法或业务方法的参数注入到整体对象中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Engine engine;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(Engine engine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEngine</span><span class="params">(Engine engine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组合关系-Composition"><a class="header-anchor" href="#组合关系-Composition"> </a>组合关系 Composition</h3>
<p>组合关系也表示类之间整体和部分的关系。</p>
<p>与<strong>聚合关系</strong>的区别在于，组合关系中的整体对象能够控制成员对象的声明周期。一旦整体对象不存在，成员对象也将不存在。</p>
<p>总而言之，聚合关系中的成员对象可以活着离开整体对象。组合关系中的成员对象不能离开整体对象。</p>
<p>UML中，组合关系用带<strong>实心菱形</strong>的直线表示</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210150154346.png" alt="image-20201210150154346"></p>
<p>在代码实现组合关系时，通常在<strong>整体类</strong>的<strong>构造方法</strong>中直接<strong>实例化</strong>成员类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Head</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Mouth mouth;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Head</span><span class="params">()</span>&#123;</span><br><span class="line">        mouth = <span class="keyword">new</span> <span class="title class_">Mouth</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="依赖关系-Dependency"><a class="header-anchor" href="#依赖关系-Dependency"> </a>依赖关系 Dependency</h3>
<p>依赖关系是一种<strong>使用关系</strong>。</p>
<p>在依赖关系中，某个事物如果发生了改变，则可能会影响到<strong>使用</strong>该事物的<strong>其他事物</strong></p>
<p>在需要表示<strong>一个事物使用另一个事物</strong>时，使用依赖关系</p>
<p>UML中，依赖关系使用<strong>带箭头的虚线</strong>表示，由<strong>依赖</strong>一方<strong>指向被依赖</strong>的一方。（使用的一方指向被使用的一方）</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210151227012.png" alt="image-20201210151227012"></p>
<p>Driver类中<code>drive(Car car)</code>方法中，需要<code>Car</code>类型的对象作为<strong>参数传入</strong>，并且在该方法中调用<code>Car.move</code>的方法。即<code>drive()</code>方法依赖<code>move()</code>方法，所以<code>Driver</code>依赖<code>Car</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">(Car car)</span>&#123;</span><br><span class="line">        car.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码实现时，依赖关系通常通过以下3中方法实现</p>
<ol>
<li>将一个类（被依赖）的<strong>对象</strong>作为另一个类（依赖）中的<strong>方法的参数</strong></li>
<li>在一个类（依赖）的方法中，将另一个类（被依赖）的对象作为其<strong>局部变量</strong></li>
<li>在一个类（依赖）的方法中调用另一个类（被依赖）的<strong>静态方法</strong></li>
</ol>
<h3 id="泛化关系-Generalization"><a class="header-anchor" href="#泛化关系-Generalization"> </a>泛化关系 Generalization</h3>
<p>泛化关系即<strong>继承</strong>关系。用于描述<strong>父类与子类</strong>之间的关系</p>
<p>在UML中，泛化关系用<strong>带空心三角形</strong>的直线表示。（由子类指向父类，即空心三角形位于父类一端）</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210152632642.png" alt="image-20201210152632642"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String studentNo;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String teacherNo;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口与实现关系"><a class="header-anchor" href="#接口与实现关系"> </a>接口与实现关系</h3>
<p>接口通常<strong>只有操作的声明</strong>，没有操作的实现</p>
<p>接口之间也存在<strong>继承</strong>关系和<strong>依赖</strong>关系</p>
<p>接口和<strong>类</strong>之间存在**实现（Realization）**关系</p>
<ul>
<li>类实现了接口</li>
<li>类中的操作实现了接口中所声明的操作</li>
</ul>
<p>在UML中，类与接口之间的<strong>实现关系</strong>用带<strong>空心三角形</strong>的虚线来表示</p>
<p><strong>接口interface</strong>的UML表示</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210160525640.png" alt="image-20201210160525640"></p>
<p>实现关系</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210160601204.png" alt="image-20201210160601204"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Vehicle</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面向对象设计原则"><a class="header-anchor" href="#面向对象设计原则"> </a>面向对象设计原则</h2>
<h3 id="目标"><a class="header-anchor" href="#目标"> </a>目标</h3>
<p><strong>可维护性复用</strong></p>
<ul>
<li>实现设计方案或源代码的<strong>重用</strong></li>
<li>确保系统易于<strong>扩展和维护</strong>，具有灵活性</li>
</ul>
<h3 id="单一职责原则（Single-Responsibility-Principle-SRP）"><a class="header-anchor" href="#单一职责原则（Single-Responsibility-Principle-SRP）"> </a>单一职责原则（Single Responsibility Principle,SRP）</h3>
<h4 id="定义-v2"><a class="header-anchor" href="#定义-v2"> </a>定义</h4>
<p>一个类<strong>只</strong>负责<strong>一个功能领域</strong>中的相应职责。或者说，就一个类而言，应该<strong>只有一个</strong>引起它<strong>变化的原因</strong></p>
<h4 id="作用要求"><a class="header-anchor" href="#作用要求"> </a>作用要求</h4>
<p>控制类的<strong>粒度大小</strong></p>
<ul>
<li>一个类承担的职责越多，它被复用的可能性就越小</li>
<li>一个类程度的职责过多，则职责耦合在一起。其中一个职责变化可能会影响到其他职责运作</li>
<li>应该将不同的职责封装在不同的类，即不同的变化原因封装在不同的类</li>
<li>如果多个职责总是同时发生改变则可以将它们封装在一个类中</li>
</ul>
<blockquote>
<p>单一职责原则是实现高内聚、低耦合的指导方针</p>
</blockquote>
<h4 id="实现"><a class="header-anchor" href="#实现"> </a>实现</h4>
<p>要判断一个类是否符合单一职责原则，可以考虑该类是否有不止一个引起它变化的原因，从而进行拆分。同时也要考虑到其他的类是否需要使用到当前类的方法。</p>
<h5 id="反例"><a class="header-anchor" href="#反例"> </a>反例</h5>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210173445512.png" alt="image-20201210173445512"></p>
<p><strong>修改后</strong></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210174414414.png" alt="image-20201210174414414"></p>
<h3 id="开闭原则（Open-Closed-Principle-OCP）"><a class="header-anchor" href="#开闭原则（Open-Closed-Principle-OCP）"> </a>开闭原则（Open-Closed Principle, OCP）</h3>
<h4 id="定义-v3"><a class="header-anchor" href="#定义-v3"> </a>定义</h4>
<p>软件实体应对<strong>扩展开放</strong>，而对<strong>修改关闭</strong>。即软件实体应尽量在不修改原有代码的情况下进行扩展</p>
<ul>
<li>这里的软件实体指<strong>一个软件模块</strong>、一个有多个类组成的<strong>局部结构</strong>或一个<strong>独立的类</strong></li>
</ul>
<h4 id="作用要求-v2"><a class="header-anchor" href="#作用要求-v2"> </a>作用要求</h4>
<p>开闭原则是面向对象的<strong>可复用设计</strong>的基石。</p>
<p>软件系统面临新的需求时，应该尽量保证系统的设计框架是稳定的。</p>
<ul>
<li>方便对系统进行扩展，且扩展时无须修改现有代码</li>
<li>使得软件系统在拥有<strong>适应性</strong>和<strong>灵活性</strong>的同时具备较好的<strong>稳定性</strong>和<strong>延续性</strong></li>
</ul>
<h4 id="实现-v2"><a class="header-anchor" href="#实现-v2"> </a>实现</h4>
<p><strong>抽象化</strong>是开闭原则的关键</p>
<p>需要对系统进行抽象化设计</p>
<ul>
<li>可以为系统定义相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成</li>
<li>例如接口定义抽象层，再由具体类进行扩展。而只需增加新的具体类来实现新的业务功能即可</li>
</ul>
<h3 id="里氏代换原则（Liskov-Substitution-Principle-LSP）"><a class="header-anchor" href="#里氏代换原则（Liskov-Substitution-Principle-LSP）"> </a>里氏代换原则（Liskov Substitution Principle,LSP）</h3>
<h4 id="定义-v4"><a class="header-anchor" href="#定义-v4"> </a>定义</h4>
<p>所有<strong>引用父类</strong>对象的地方能够透明地<strong>使用其子类</strong>的对象</p>
<blockquote>
<p>在软件中，将一个基类（父类）对象替换成它的子类对象，程序不会产生任何错误和异常，但反之不成立。</p>
</blockquote>
<h4 id="作用要求-v3"><a class="header-anchor" href="#作用要求-v3"> </a>作用要求</h4>
<p>里氏代换原则是实现开闭原则的重要方式之一。</p>
<ul>
<li>在程序中尽量使用<strong>基类类型</strong>来对对象进行<strong>定义</strong>，而在<strong>运行时</strong>，再确定其<strong>子类类型</strong>，用子类来替换父类对象</li>
<li>父类设计为抽象类或接口，让子类继承父类或实现父类接口，并实现在父类声明的方法。运行时子类实例替换父类实例，可以扩展系统的功能，无须修改原子类的代码</li>
</ul>
<h4 id="实现-v3"><a class="header-anchor" href="#实现-v3"> </a>实现</h4>
<p>在Java实现多态的时候，有着里氏代换原则的味道</p>
<h3 id="依赖倒转原则（Dependence-Inversion-Principle-DIP）"><a class="header-anchor" href="#依赖倒转原则（Dependence-Inversion-Principle-DIP）"> </a>依赖倒转原则（Dependence Inversion Principle,DIP）</h3>
<h4 id="定义-v5"><a class="header-anchor" href="#定义-v5"> </a>定义</h4>
<p>抽象<strong>不应该</strong>依赖于细节，细节应该依赖于抽象</p>
<p>要针对<strong>接口编程</strong>，而不是针对实现编程</p>
<h4 id="作用要求-v4"><a class="header-anchor" href="#作用要求-v4"> </a>作用要求</h4>
<p>依赖倒转原则是面向对象设计的主要实现机制之一，是<strong>系统抽象化</strong>的具体实现</p>
<p>依赖倒转原则要求在程序代码中，<strong>传递参数</strong>时或在<strong>关联关系</strong>中，尽量引用层次高的<strong>抽象层</strong>。即使用<strong>接口</strong>和<strong>抽象类</strong>进行<strong>变量类型声明</strong>、<strong>参数类型声明</strong>、<strong>方法返回类型声明</strong>以及<strong>数据类型的转换</strong>等，而不要用具体类做这些事。</p>
<p>一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法</p>
<p>在实现依赖倒置时，需要针对<strong>抽象层编程</strong>，而将<strong>具体的类对象</strong>通过**依赖注入（Dependency Injection，DI）**的方式，注入到其他对象中去。</p>
<p><strong>依赖注入</strong>：一个对象要与其他对象发生<strong>依赖关系</strong>时，通过<strong>抽象</strong>来注入所依赖的<strong>对象</strong></p>
<ul>
<li>构造注入
<ul>
<li>通过构造函数传入具体类的对象</li>
</ul>
</li>
<li>设值注入（Setter注入）
<ul>
<li>通过Setter方法来传入具体类的对象</li>
</ul>
</li>
<li>接口注入
<ul>
<li>通过实现在接口中声明的业务方法来传入具体类的对象</li>
</ul>
</li>
</ul>
<p>这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。</p>
<h4 id="实现-v4"><a class="header-anchor" href="#实现-v4"> </a>实现</h4>
<h5 id="反例-v2"><a class="header-anchor" href="#反例-v2"> </a>反例</h5>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210182814754.png" alt="image-20201210182814754"></p>
<h5 id="修改后"><a class="header-anchor" href="#修改后"> </a>修改后</h5>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210182840381.png" alt="image-20201210182840381"></p>
<ul>
<li>开闭原则是目标</li>
<li>里氏代换原则是基础</li>
<li>依赖倒转是手段</li>
</ul>
<h3 id="接口隔离原则（Interface-Segregation-Principle-ISP）"><a class="header-anchor" href="#接口隔离原则（Interface-Segregation-Principle-ISP）"> </a>接口隔离原则（Interface Segregation Principle,ISP）</h3>
<h4 id="定义-v6"><a class="header-anchor" href="#定义-v6"> </a>定义</h4>
<p>使用多个<strong>专门的接口</strong>，而<strong>不使用</strong>单一的<strong>总接口</strong>。</p>
<p>即客户端<strong>不应该依赖</strong>那些它<strong>不需要的接口</strong></p>
<p><strong>接口含义</strong></p>
<ol>
<li><strong>逻辑上</strong>的抽象：一个<strong>类型</strong>所具有的<strong>方法特征的集合</strong>
<ul>
<li>接口的划分带来<strong>类型</strong>的划分。一个接口只能代表一个角色，每个角色都有它特定的接口</li>
</ul>
</li>
<li>某种语言<strong>具体的“接口 ”定义</strong>，有严格的定义和结构
<ul>
<li>仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来</li>
</ul>
</li>
</ol>
<h4 id="作用要求-v5"><a class="header-anchor" href="#作用要求-v5"> </a>作用要求</h4>
<p>当一个接口<strong>太大时</strong>，需要将它<strong>分割</strong>成一些<strong>更细小的接口</strong>，使用该接口的客户端<strong>仅需知道</strong>与之相关的方法即可。</p>
<p>每一个接口应该承担<strong>一种相对独立</strong>的角色。</p>
<p>需要控制接口的粒度</p>
<ul>
<li>接口太小会导致接口泛滥，不利维护</li>
<li>接口太大会违背接口割离原则，灵活性差，使用不方便</li>
</ul>
<h4 id="解决问题"><a class="header-anchor" href="#解决问题"> </a>解决问题</h4>
<p>如果接口承担太多职责</p>
<ul>
<li>导致接口实现类庞大，需要实现接口中定义的所有方法</li>
<li>灵活性差，出现大量的空方法，导致系统产生大量的无用代码，影响代码质量</li>
<li>破坏程序的封装性</li>
</ul>
<h4 id="反例-v3"><a class="header-anchor" href="#反例-v3"> </a>反例</h4>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210185435843.png" alt="image-20201210185435843"></p>
<p><strong>解决后</strong></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201210185446564.png" alt="image-20201210185446564"></p>
<h3 id="合成复用原则（Composite-Reuse-Principle-CRP）"><a class="header-anchor" href="#合成复用原则（Composite-Reuse-Principle-CRP）"> </a>合成复用原则（Composite Reuse Principle,CRP）</h3>
<h4 id="定义-v7"><a class="header-anchor" href="#定义-v7"> </a>定义</h4>
<p>合成复用原则又称**“组合/聚合复用原则（Composition/Aggregation Reuse Principle）&quot;**</p>
<p>尽量使用<strong>对象组合</strong>，而不是继承来达到复用的目的</p>
<h4 id="要求作用"><a class="header-anchor" href="#要求作用"> </a>要求作用</h4>
<p>合成复用原则是在一个新的对象里，通过<strong>关联关系（包括组合关系和聚合关系）<strong>来使用一些已有的对象，使之成为新对象的</strong>一部分</strong>。</p>
<p>新对象通过委派调用已有对象的方法来达到复用功能的目的。</p>
<blockquote>
<p>复用时，尽量使用组合/聚合关系（关联关系），少用继承</p>
</blockquote>
<h4 id="使用优点"><a class="header-anchor" href="#使用优点"> </a>使用优点</h4>
<p>复用已有的设计和实现的方法</p>
<ol>
<li>通过组合/聚合关系</li>
<li>通过继承</li>
</ol>
<p>组合/聚合可以使系统更加<strong>灵活</strong>，<strong>降低</strong>类与类之间的<strong>耦合度</strong>，一个类的变化对其他类造成的影响较小。</p>
<blockquote>
<p>使用继承时，需要严格遵循里氏代换原则</p>
</blockquote>
<blockquote>
<p>继承来进行复用的主要问题在于继承复用会破坏系统的<strong>封装性</strong>。因为继承会将基类实现<strong>细节暴露</strong>给子类。从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性</p>
</blockquote>
<h3 id="迪米特法则-（Law-of-Demeter-LoD）"><a class="header-anchor" href="#迪米特法则-（Law-of-Demeter-LoD）"> </a>迪米特法则 （Law of Demeter,LoD）</h3>
<h3 id="定义-v8"><a class="header-anchor" href="#定义-v8"> </a>定义</h3>
<p>一个软件实体应当<strong>尽可能少</strong>地与<strong>其他实体</strong>发生<strong>相互作用</strong></p>
<p>迪米特法则又称为<strong>最少知识原则（Least Knowledge Principle，LKP）</strong></p>
<h3 id="要求作用-v2"><a class="header-anchor" href="#要求作用-v2"> </a>要求作用</h3>
<p>如果一个系统符合迪米特法则，那么当其中<strong>某一个模块发生修改</strong>时，就会尽量<strong>少地影响其他</strong>模块，<strong>扩展</strong>会相对<strong>容易</strong>。</p>
<p>迪米特法则要求<strong>限制</strong>软件实体之间<strong>通信的宽度和深度</strong>。</p>
<p>不要和陌生人说话，只与<strong>直接朋友</strong>通信</p>
<p><strong>朋友包括</strong></p>
<ul>
<li>当前对象本身<code>this</code></li>
<li>以<strong>参数形式</strong>传入当前对象<strong>方法</strong>中的对象</li>
<li>当前对象的<strong>成员</strong>对象</li>
<li>如果当前对象的成员对象是一个<strong>集合</strong>，那么<strong>集合中的元素</strong>也都是朋友。</li>
<li>当前对象所<strong>创建的对象</strong>。</li>
</ul>
<p>能够降低系统的<strong>耦合度</strong></p>
<ul>
<li>可以通过引入第三者来降低现有对象之间的耦合</li>
</ul>
<p>在类的结构设计上，每一个类都应当尽量<strong>降低</strong>其<strong>成员变量</strong>和<strong>成员函数</strong>的<strong>访问权限</strong></p>
<h3 id="反例-v4"><a class="header-anchor" href="#反例-v4"> </a>反例</h3>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201211204406607.png" alt="image-20201211204406607"></p>
<p><strong>改善后</strong></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201211204422063.png" alt="image-20201211204422063"></p>
<h2 id="创建型模式-Creational-Pattern"><a class="header-anchor" href="#创建型模式-Creational-Pattern"> </a>创建型模式 Creational Pattern</h2>
<p>创建型模式关注对象的创建过程</p>
<p>将对象的<strong>创建</strong>和使用分离。</p>
<p>在使用对象时<strong>无须关心对象</strong>的<strong>创建细节</strong>，从而<strong>降低</strong>系统的耦合度，让设计方案更易于修改和扩展。</p>
<p><strong>创建模式回答三个问题</strong></p>
<ul>
<li>创建什么</li>
<li>由谁创建</li>
<li>何时创建</li>
</ul>
<h3 id="单例模式-Singleton-Pattern"><a class="header-anchor" href="#单例模式-Singleton-Pattern"> </a>单例模式 Singleton Pattern</h3>
<h4 id="定义-v9"><a class="header-anchor" href="#定义-v9"> </a>定义</h4>
<p>确保某一个类<strong>只有一个实例</strong>，而且<strong>自行实例化</strong>并向<strong>整个系统</strong>提供这个实例，这个类称为<strong>单例类</strong>，它提供<strong>全局访问的方法</strong>。</p>
<p><strong>三个要点</strong></p>
<ol>
<li>某个类只能有一个实例</li>
<li>它必须自行创建这个实例</li>
<li>它必须自行向整个系统提供这个实例</li>
</ol>
<h4 id="内容"><a class="header-anchor" href="#内容"> </a>内容</h4>
<p><strong>举例</strong>：Windows的任务管理器只能打开一个</p>
<p>单例模式的<strong>动机</strong>：确保对象的<strong>唯一性</strong></p>
<ul>
<li>节约系统资源</li>
<li>确保系统中的某个类只有唯一一个实例，该类创建成功后，<strong>无法再创建</strong>同类型的其它对象，所有操作都基于这个<strong>唯一实例</strong></li>
</ul>
<h4 id="单例模式创建过程"><a class="header-anchor" href="#单例模式创建过程"> </a>单例模式创建过程</h4>
<ol>
<li>将该类的<strong>构造器的可见性</strong>改成<code>private</code>
<ul>
<li>禁止类的外部直接使用<code>new</code>来创建对象，确保实例的唯一性</li>
</ul>
</li>
<li>在该类内部创建并<strong>保存</strong>这个<strong>唯一实例</strong>，
<ul>
<li>定义一个<strong>静态</strong>的该类型的<strong>私有成员变量</strong></li>
</ul>
</li>
<li>增加一个<strong>公有</strong>的<strong>静态方法</strong>
<ul>
<li>让外界使用该成员变量，同时需要解决实例化该成员变量的时机</li>
</ul>
</li>
</ol>
<p><strong>示例</strong></p>
<p>修改前</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TaskManager</span><span class="params">()</span>&#123;&#125; <span class="comment">//初始化窗口  构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayProcesses</span><span class="params">()</span> &#123;&#125; <span class="comment">//显示进程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayServices</span><span class="params">()</span>&#123;&#125; <span class="comment">//显示服务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">TaskManager</span> <span class="variable">tm</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">TaskManager</span><span class="params">()</span>&#123;&#125; <span class="comment">//初始化窗口  构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TaskManager <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tm == <span class="literal">null</span>)&#123;</span><br><span class="line">            tm = <span class="keyword">new</span> <span class="title class_">TaskManager</span>(); <span class="comment">//自行实例化</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayProcesses</span><span class="params">()</span> &#123;&#125; <span class="comment">//显示进程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayServices</span><span class="params">()</span>&#123;&#125; <span class="comment">//显示服务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释说明</p>
<ul>
<li><code>public static TaskManager getInstance()</code>首先应该声明为<code>public</code>，以便外界的其他对象访问。其次，应该声明为<code>static</code>，因为该类的构造器已经被声明为<code>private</code>，不能通过<code>new</code>来创建对象，外界可以直接通过类名来访问。</li>
<li>成员变量<code>private static TaskManager tm = null;</code>为什么需要声明为<strong>静态</strong>的呢？
<ul>
<li>首先，<code>getInstance()</code>的方式声明为<code>static</code>的，而<strong>静态方法</strong>中<strong>只能访问静态</strong>的<strong>成员变量</strong></li>
<li>其次，对于<strong>静态字段</strong>，即所有对象都会共享该类的静态字段，但是对于单例模式也只有唯一一个对象，这条作用不大</li>
</ul>
</li>
<li>这种方法叫做<strong>懒汉式单例</strong></li>
</ul>
<p><strong>单例模式结构图</strong></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201216163723612.png" alt="image-20201216163723612"></p>
<h4 id="懒汉式单例存在的问题"><a class="header-anchor" href="#懒汉式单例存在的问题"> </a>懒汉式单例存在的问题</h4>
<p>考虑以下情景</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//负载均衡器 单例类 待优化版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoadBalancer</span> &#123;</span><br><span class="line">    <span class="comment">//储存唯一实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">LoadBalancer</span> <span class="variable">loadBalancer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//服务器集合</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; serverList = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LoadBalancer</span><span class="params">()</span>&#123;</span><br><span class="line">        serverList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// ... (1)</span></span><br><span class="line">        <span class="comment">// ... more work</span></span><br><span class="line">        <span class="comment">// 接下来在真实环境中还有包括大量初始化的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LoadBalancer <span class="title function_">getLoadBalancer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(loadBalancer == <span class="literal">null</span>)&#123;</span><br><span class="line">            loadBalancer = <span class="keyword">new</span> <span class="title class_">LoadBalancer</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> loadBalancer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addServer</span><span class="params">(String server)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeServer</span><span class="params">(String server)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServer</span><span class="params">()</span>&#123;<span class="keyword">return</span> serverList.get(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(serverList.size()));&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>问题发现</strong></p>
<p>在<strong>多线程环境</strong>中,如果<em>线程A</em><strong>第一次</strong>调用<code>getLoadBalancer</code>方法创建并启动负载均衡器时，<code>if(loadBalancer == null)</code>这条语句判断为<code>true</code>，因此进入<strong>实例化</strong>的语句。</p>
<p>在实例化语句中，由于<code>LoadBalancer</code>的<strong>构造器</strong>中需要进行大量的初始化工作，需要<strong>一段时间</strong>才能够完成该操作。</p>
<p>而在此时（即唯一实例的负载均衡器还在创建但是没有创建完成的初始化过程中），如果<strong>另一个</strong><em>线程B</em>也再一次调用了<code>getLoadBalancer</code>方法。由于<em>线程A</em>还在初始化负载均衡器中，实际上该成员变量<code>loadBalancer</code>的值仍为<code>null</code>，因此<em>线程B</em>在<code>if(loadBalancer == null)</code>的条件判断也为<code>true</code>，因此<strong>也去实例化</strong>一个负载均衡器对象。</p>
<p>最终导致创建了多个instance对象，违背了单例模式的初衷，导致系统发生错误。</p>
<p>解决方式<strong>饿汉式单例类（Eager Singleton）<strong>和</strong>懒汉式单例类（Lazy Singleton）</strong></p>
<h4 id="饿汉式单例类"><a class="header-anchor" href="#饿汉式单例类"> </a>饿汉式单例类</h4>
<h5 id="实现方法"><a class="header-anchor" href="#实现方法"> </a>实现方法</h5>
<p>在<strong>定义</strong>静态变量的时候就<strong>实例化</strong>单例类，因此在<strong>类加载</strong>的时候就已经创建了单例对象</p>
<h5 id="实现代码-v3"><a class="header-anchor" href="#实现代码-v3"> </a>实现代码</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EagerSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">EagerSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EagerSingleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EagerSingleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>饿汉式单例结构图</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201216183951684.png" alt="image-20201216183951684"></p>
<h4 id="懒汉式单例类"><a class="header-anchor" href="#懒汉式单例类"> </a>懒汉式单例类</h4>
<p>懒汉式单例模式采用<strong>延时加载（Lazy load）技术</strong>，即需要的时候再加载实例</p>
<ul>
<li>懒汉式单例在<strong>第一次</strong>调用<code>getInstance</code>方法的时才<strong>实例化</strong></li>
<li>在<strong>类加载</strong>时并<strong>不自行实例化</strong></li>
</ul>
<p><strong>线程安全改进，但效率低下版本</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">LazySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相同形式不同写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">LazySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(LazySingleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解释说明</strong></p>
<ul>
<li>在<code>getInstance</code>方法前面增加<strong>关键字<code>synchronized</code><strong>进行</strong>线程锁定</strong>，以处理<strong>多线程同时访问</strong>问题</li>
</ul>
<p><strong>问题</strong></p>
<ul>
<li>每次调用<code>getInstance</code>方法都需要进行<strong>线程锁定判断</strong></li>
<li>在高并发访问的环境中，将会导致性能大大降低</li>
</ul>
<p><strong>改进思考</strong></p>
<p>无须对整个<code>getInstance</code>方法进行锁定，只是在条件判断<code>if(instance == null)</code>中会发生并发访问问题。</p>
<p><strong>只有</strong>实例<strong>不存在</strong>的时候，才需要创建实例，进行加锁实例化。是否可以在<code>if(instance == null)</code>内加锁？这样就可以在实例不为<code>null</code>，不进行<code>synchronized</code>判断。</p>
<p><strong>初步改进，但没有解决问题版本</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">LazySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(LazySingleton.class)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>问题说明</strong></p>
<p>单纯的将锁加在<code>instance = new LazySingleton();</code>中，仍会发生最上面写到的“懒汉式单例存在的问题”中所说的问题，即<strong>对象不唯一</strong>的问题。</p>
<p>当线程A和线程B都调用<code>getInstance()</code>时，如果实例还没创建，则都能通过<code>if (instance == null)</code>的判断。而线程A和线程B只是排队来调用<code>instance = new LazySingleton()</code>这句语句，结果是会产生不止一个实例对象。</p>
<p><strong>懒汉式单例类进一步改进</strong></p>
<p><strong>双重检查锁定（Double-Check Locking）</strong>：在<code>synchronized</code>锁定代码中，再进行一次<code>instance == null</code>判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">LazySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 第一重判断</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 锁定代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span>(LazySingleton.class)&#123;</span><br><span class="line">                <span class="comment">// 第二重判断</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u><strong>注意事项</strong></u></p>
<ul>
<li>使用<strong>双重检查锁定</strong>来实现懒汉式单例类，需要在静态成员变量<code>instance</code>加上修饰符<code>volatile</code>
<ul>
<li>被<code>volatile</code>修饰的成员变量可以确保<strong>多个线程正确处理</strong></li>
<li><code>volatile</code>关键字会屏蔽虚拟机的代码优化，可能会导致系统运行效率低</li>
</ul>
</li>
</ul>
<h4 id="饿汉式单例类和懒汉式单例类比较"><a class="header-anchor" href="#饿汉式单例类和懒汉式单例类比较"> </a>饿汉式单例类和懒汉式单例类比较</h4>
<p><strong>饿汉式单例类</strong></p>
<ul>
<li>在<strong>类被加载</strong>的时候就将自己实例化。</li>
<li><strong>优点</strong>
<ul>
<li>无须考虑多线程访问问题</li>
<li><strong>调用速度</strong>和<strong>反应时间</strong>优于懒汉式单例类</li>
</ul>
</li>
<li><strong>缺点</strong>
<ul>
<li>由于无论系统运行时是否需要使用该单例对象，都会创建，因此<strong>资源利用效率</strong>不及懒汉式单例类</li>
<li>系统加载时，需要创建饿汉式单例对象，加载时间会较长</li>
</ul>
</li>
</ul>
<p><strong>懒汉式单例类</strong></p>
<ul>
<li>在<strong>第一次使用</strong>时创建</li>
<li><strong>优点</strong>
<ul>
<li>无须一直占用系统资源，实现延迟加载</li>
</ul>
</li>
<li><strong>缺点</strong>
<ul>
<li>需要处理多线程同时访问的问题</li>
<li>资源初始化可能耗费大量时间，多线程同时首次引用的概率变大，需要通过双重检查锁等机制进行控制，系统性能收到影响。</li>
</ul>
</li>
</ul>
<h4 id="Initialization-on-Demand-Holder-（IoDH）"><a class="header-anchor" href="#Initialization-on-Demand-Holder-（IoDH）"> </a>Initialization on Demand Holder （IoDH）</h4>
<p>IoDH结合了<strong>懒汉式单例类</strong>和<strong>饿汉式单例类</strong>的优点</p>
<ul>
<li>既实现了<strong>延迟加载</strong>又保证<strong>线程安全</strong>，<strong>不影响系统性能</strong></li>
</ul>
<p><strong>实现方式</strong></p>
<p>单例类中定义一个<strong>静态内部类</strong>。在<strong>内部类</strong>中创建<strong>单例对象</strong>。通过<strong>外部类</strong>的<code>getInstance()</code>返回给外界。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initialization on Demand</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HolderClass</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HolderClass.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解释说明</strong></p>
<ul>
<li><strong>静态单例对象</strong>没有作为<code>Singleton</code>的成员变量直接实例化，类加载时不会实例化<code>Singleton</code></li>
<li>第一次调用<code>getInstance()</code>会<strong>加载内部类</strong><code>HolderClass</code>。内部类中定义<code>static</code>类型变量<code>instance</code>，此时会<strong>首先初始化</strong>这个成员变量，由<strong>Java虚拟机保证线程安全</strong>，确保该成员变量只能初始化一次。</li>
<li><code>getInstance()</code>方法没有任何线程锁定，对性能不会造成影响</li>
</ul>
<h4 id="单例模式总结"><a class="header-anchor" href="#单例模式总结"> </a>单例模式总结</h4>
<p><strong>优点</strong></p>
<ul>
<li>单例模式提供了对<strong>唯一实例</strong>的<strong>受控访问</strong></li>
<li>节约系统资源
<ul>
<li>系统内存中只存在一个对象</li>
<li>对需要<strong>频繁创建和销毁的对象</strong>，单例模式提高性能</li>
</ul>
</li>
<li>基于单例模式的扩展，可以提供允许可变数目的实例（<strong>多例类</strong>）
<ul>
<li>既节省系统资源，又解决了由于<strong>单例对象共享过多有损性能</strong>的问题</li>
</ul>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>
<p>缺少抽象层，扩展性差</p>
</li>
<li>
<p>职责过重，一定程度上违背<strong>单一职责原则</strong></p>
<ul>
<li>即提供<strong>创建</strong>对象方法又提供<strong>业务</strong>方法（创建和本身功能<strong>耦合</strong>）</li>
</ul>
</li>
<li>
<p>由于垃圾回收机制，如果单例对象长时间没用，可能会被当垃圾回收。</p>
<ul>
<li>再次使用时重新实例化，原本的单例对象状态丢失</li>
</ul>
</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>只需要一个<strong>实例对象</strong>
<ul>
<li>例如唯一的序列号生成器、资源管理器</li>
<li>考虑<strong>资源消耗太大</strong>而只允许创建一个对象</li>
</ul>
</li>
<li>只需要一个公共访问点
<ul>
<li>除了该公共访问点，不能通过其他途径访问该实例</li>
</ul>
</li>
</ul>
<h3 id="简单工厂模式-Simple-Factory-Pattern"><a class="header-anchor" href="#简单工厂模式-Simple-Factory-Pattern"> </a>简单工厂模式 Simple Factory Pattern</h3>
<h4 id="定义-v10"><a class="header-anchor" href="#定义-v10"> </a>定义</h4>
<p>定义一个工厂类，它可以<strong>根据参数</strong>的不同<strong>返回不同类的实例</strong>，被创建的实例通常都具有<strong>共同的父类</strong>。</p>
<p>因为在简单工厂模式中用于<strong>创建实例</strong>的方法是静态(static)方法，因此<strong>简单工厂模式</strong>又被称为静态工厂方法(Static<br>
Factory Method)模式，它属于类创建型模式。</p>
<h4 id="内容-v2"><a class="header-anchor" href="#内容-v2"> </a>内容</h4>
<p>要点：需要什么，只需要<strong>传入</strong>一个正确的参数，就可以<strong>获取</strong>所需要的对象，而无须知道其创建细节。</p>
<ul>
<li><strong>客户端</strong>通过<strong>工厂类</strong>来创建一个产品类的实例，而<strong>无须直接使用new关键字</strong>来创建对象</li>
</ul>
<p><strong>简单工厂模式结构图</strong></p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201224175352126.png" alt="image-20201224175352126"></p>
<p>简单工厂模式主要包含<strong>3</strong>种角色</p>
<ul>
<li><strong><code>Factory</code>(工厂角色)</strong>：即工厂类，它是<strong>简单工厂模式的核心</strong>，负责实现<strong>创建</strong>所有产品<strong>实例</strong>的内部逻辑。
<ul>
<li>工厂类<strong>可以被外界直接调用</strong>，<strong>创建</strong>所需的产品<strong>对象</strong>；</li>
<li>在工厂类中提供了<strong>静态的工厂方法</strong><code>factoryMethod()</code>,它的返回类型为<strong>抽象产品类型Product</strong>。</li>
</ul>
</li>
<li><strong><code>Product</code>(抽象产品角色)</strong>：它是工厂类所创建的所有<strong>对象的父类</strong>，<strong>封装了</strong>各种产品对象的<strong>公有方法</strong>.
<ul>
<li>提高系统的<strong>灵活性</strong>，使得在工厂类中只需<strong>定义</strong>一个<strong>通用</strong>的工厂方法，因为所有创建的具体产品对象都是其子类对象。</li>
</ul>
</li>
<li><strong><code>ConcreteProduct</code>(具体产品角色)</strong>：它是简单工厂模式的<strong>创建目标</strong>，所有被创建的对象都充当这个角色的某个<strong>具体类的实例</strong>。
<ul>
<li>每一个具体产品角色都<strong>继承了抽象产品角色</strong>，需要<strong>实现</strong>在抽象产品中声明的<strong>抽象方法</strong>。</li>
</ul>
</li>
</ul>
<h4 id="说明"><a class="header-anchor" href="#说明"> </a>说明</h4>
<ul>
<li>根据实际情况设计一个<strong>产品层次结构</strong>，将所有产品类<strong>公共的代码</strong>移至<strong>抽象产品类</strong>，并在抽象产品类中<strong>声明一些抽象方法</strong>，以供不同的具体产品类来实现</li>
<li>在<strong>没有工厂类之前</strong>，客户端一般会使用new `关键字来直接创建产品对象</li>
<li>在<strong>引人工厂类</strong>之后，客户端可以通过工厂类来创建产品，在简单工厂模式中，工厂类提供了一个<strong>静态工厂方法</strong>供客户端使用，根据所传入的参数不同可以创建不同的产品对象。</li>
</ul>
<h4 id="代码实现-v20"><a class="header-anchor" href="#代码实现-v20"> </a>代码实现</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodSame</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//公共方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">methodDiff</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProduct</span> <span class="keyword">extends</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">    <span class="comment">//实现业务方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodDiff</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//业务方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="comment">//静态工厂方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title function_">getProduct</span><span class="params">(String arg)</span>&#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(arg.equalsIgnoreCase(<span class="string">&quot;A&quot;</span>))&#123;</span><br><span class="line">            product = <span class="keyword">new</span> <span class="title class_">ConcreteProductA</span>();</span><br><span class="line">            <span class="comment">//初始化设置product</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arg.equalsIgnoreCase(<span class="string">&quot;B&quot;</span>))&#123;</span><br><span class="line">            product = <span class="keyword">new</span> <span class="title class_">ConcreteProductB</span>();</span><br><span class="line">            <span class="comment">//初始化设置product</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Product product;</span><br><span class="line">        product = Factory.getProduct(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        product.methodSame();</span><br><span class="line">        product.methodDiff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建对象和使用对象"><a class="header-anchor" href="#创建对象和使用对象"> </a>创建对象和使用对象</h4>
<p><strong>对象</strong>相关的<strong>职责</strong>通常有3类</p>
<ul>
<li>对象<strong>本身</strong>所具有的职责
<ul>
<li>对象本身具有的<strong>数据</strong>和<strong>行为</strong>，可通过<strong>公开</strong>的方法来实现其职责。</li>
</ul>
</li>
<li><strong>创建</strong>对象的职责
<ul>
<li>创建对象的方式
<ol>
<li><code>new</code>关键字直接创建
<ul>
<li><code>new</code>简单。但是灵活性差：创建对象和使用对象耦合在一起，会违背开闭原则</li>
<li>解决办法是引入<strong>工厂类</strong>，降低因为产品或工厂类改变所带来的维护工作量</li>
</ul>
</li>
<li>通过<strong>反射机制</strong>创建对象</li>
<li>通过<code>clone()</code>方法创建对象</li>
<li>通过工厂类创建对象</li>
</ol>
</li>
</ul>
</li>
<li><strong>使用</strong>对象的职责</li>
</ul>
<p>工厂模式<strong>强调</strong>：将对象的<strong>创建</strong>和<strong>使用分离</strong></p>
<ul>
<li>
<p>只能A创建B或A使用B，不能两种关系都有</p>
<ul>
<li>这样更符合单一职责原则，有利于对功能的复用和系统的维护</li>
</ul>
</li>
<li>
<p>能够防止用来实例一个类的数据和代码在多个类到处都是</p>
<ul>
<li>构造对象还需要设置参数，环境配置等</li>
</ul>
</li>
<li>
<p>提供一系列<strong>名字不同</strong>的<strong>工厂方法</strong>，而每个工厂方法对应一个构造函数</p>
<ul>
<li>客服端可以以更加可读易懂的方法来创建对象</li>
</ul>
</li>
</ul>
<h4 id="简单工厂模式的简化"><a class="header-anchor" href="#简单工厂模式的简化"> </a>简单工厂模式的简化</h4>
<p>将<strong>抽象产品类</strong>和<strong>工厂类</strong>合并，将静态工厂方法移至抽象产品类</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20201224201619925.png" alt="image-20201224201619925"></p>
<h4 id="简单工厂类总结"><a class="header-anchor" href="#简单工厂类总结"> </a>简单工厂类总结</h4>
<p><strong>优点</strong></p>
<ul>
<li>实现对象的创建和使用分离</li>
<li>客户端<strong>无须知道</strong>所创建的<strong>具体产品类的类名</strong>，只需要知道具体产品类所对应的<strong>参数</strong>即可</li>
<li>通过引人配置文件，可以在<strong>不修改客户端代码</strong>的情况下<strong>更换和增加</strong>新的<strong>具体产品类</strong>，在一定程度上<strong>提高了系统的灵活性</strong>。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>工厂类责任过重
<ul>
<li>集中所有产品的创建逻辑</li>
</ul>
</li>
<li>简单工厂模式会<strong>增加</strong>系统中<strong>类的个数</strong>
<ul>
<li>增加系统的复杂度和理解难度</li>
</ul>
</li>
<li>系统扩展困难
<ul>
<li>添加新产品需要修改工厂逻辑</li>
<li>产品类型过多时，造成工厂逻辑复杂，不利于系统的扩展和维护</li>
<li>使用了<strong>静态</strong>工厂方法，工厂角色无法形成基于继承的等级结构</li>
</ul>
</li>
</ul>
<p><strong>适用场景</strong></p>
<ul>
<li>工厂类负责创建的对象比较少</li>
<li>客户端<strong>只知道</strong>传入工厂类的<strong>参数</strong>，对于如何创建对象并不关心。</li>
</ul>
<h3 id="工厂方法模式-Factory-Method-Pattern"><a class="header-anchor" href="#工厂方法模式-Factory-Method-Pattern"> </a>工厂方法模式 Factory Method Pattern</h3>
<p>通常说的工厂模式指的是工厂方法模式</p>
<h4 id="定义-v11"><a class="header-anchor" href="#定义-v11"> </a>定义</h4>
<p>定义一个用于<strong>创建对象</strong>的<strong>接口</strong>，让<strong>子类</strong>决定将<strong>哪一个类</strong>实例化。工厂方法模式让一个类的<strong>实例化延迟</strong>到其子类。工厂方法模式又<br>
简称为<strong>工厂模式(Factory Pattern)</strong>,又可称作<strong>虚拟构造器模式(Virtual Constructor Pattern)<strong>或</strong>多态工厂模式(Polymorphic Factory Pattern)</strong>。工厂方法模式是一种类创建型模式。</p>
<h4 id="简单工厂模式存在的缺点"><a class="header-anchor" href="#简单工厂模式存在的缺点"> </a>简单工厂模式存在的缺点</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggerFactory</span> &#123;</span><br><span class="line">    <span class="comment">//静态工厂方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title function_">createLogger</span> <span class="params">(String args)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(args.equalsIgnoreCase(<span class="string">&quot;db&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//连接数据库，代码省略</span></span><br><span class="line">            <span class="comment">//创建数据库日志记录器对象</span></span><br><span class="line">            <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatabaseLogger</span>();</span><br><span class="line">            <span class="comment">//初始化数据库日志记录器，代码省略</span></span><br><span class="line">            <span class="keyword">return</span> logger;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(args.equalsIgnoreCase(<span class="string">&quot;file&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//创建日志文件，代码省略</span></span><br><span class="line">            <span class="comment">//创建文件日志记录器对象</span></span><br><span class="line">            <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileLogger</span>();</span><br><span class="line">            <span class="comment">//初始化文件日志记录器，代码省略</span></span><br><span class="line">            <span class="keyword">return</span> logger;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然简单工厂模式将该对象的创建和使用分离，但存在以下两个问题</p>
<ul>
<li>工厂类过于庞大，包含大量<code>if lese</code>语句，导致维护和测试难道大</li>
<li>系统扩展不灵活，如果要增加新类型的日志记录器，必须修改静态工厂方法的业务逻辑，违反开闭原则</li>
</ul>
<p>而在<strong>工厂方法模式</strong>中，不再提供一个统一的工厂类来创建所有的产品对象，而是针对<strong>不同的产品</strong>提供<strong>不同的工厂</strong>，系统提供一个与产品等级结构对应的工厂等级结构</p>
<h4 id="内容-v3"><a class="header-anchor" href="#内容-v3"> </a>内容</h4>
<p>工厂方法模式提供一个<strong>抽象工厂接口</strong>来声明抽象工厂方法，而由其子类来<strong>具体实现工厂方法</strong>，创建<strong>具体的产品对象</strong>。</p>
<p>工厂模式结构图：</p>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210312090446928.png" alt="image-20210312090446928"></p>
<p>主要有4个角色：</p>
<ol>
<li>Product(抽象产品)：它是定义产品的<strong>接口</strong>，是工厂方法模式所创建对象的<strong>超类型</strong>，也就是产品对象的公共父类。</li>
<li>ConcreteProduct(具体产品)：它实现了<strong>抽象产品接口</strong>，某种类型的<strong>具体产品</strong>由专门的<strong>具体工厂</strong>创建，具体工厂和具体产品之间一一对应。</li>
<li>Factory(抽象工厂)：在抽象工厂类中，声明了工厂方法(Factory Method),用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该<strong>接口</strong>。</li>
<li>ConcreteFactory（具体工厂)：它是抽象工厂类的<strong>子类</strong>，实现了抽象工厂中定义的工厂方法，并可由<strong>客户端调用</strong>，返回一个具体产品类的实例。</li>
</ol>
<h4 id="代码实现-v21"><a class="header-anchor" href="#代码实现-v21"> </a>代码实现</h4>
<p>抽象工厂可以是接口，也可以是抽象类或者具体类。只是声明工厂方法，没有具体实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体产品对象的创建由抽象工厂类的实现类实现。在创建过程中，还可以负责对象的初始化，资源与环境的配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct</span> ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="工厂方法模式优点"><a class="header-anchor" href="#工厂方法模式优点"> </a>工厂方法模式优点</h4>
<ol>
<li>通过工厂方法创建所需的产品，同时隐藏具体产品类实现细节</li>
<li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键，工厂方法模式之所以又被称为多态工厂模式，正是因为所有的具体工厂类都具有同一抽象父类、</li>
<li>系统的可扩展性提高，符合开闭原则，在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以</li>
</ol>
<p><strong>主要缺点</strong></p>
<ol>
<li>增加新的产品，需要写新的具体产品类和具体工厂类，使得系统类的个数成对增加，增加系统复杂度，以及编译开销</li>
<li>客户端使用抽象层进行定义，增加系统的抽象性和理解难度</li>
</ol>
<p><strong>适用场景</strong></p>
<ul>
<li>客户端不知道其所需要的对象的类</li>
<li>抽象工厂类通过其子类来指定具体创建哪个对象：利用对象的多态和里氏代换原则</li>
</ul>
<h3 id="抽象工厂模式-Abstract-Factory-Pattern"><a class="header-anchor" href="#抽象工厂模式-Abstract-Factory-Pattern"> </a>抽象工厂模式 Abstract Factory Pattern</h3>
<p>工厂方法模式的缺点：每一个具体的工厂对应一个具体的产品。大量的工厂类，增加系统的开销</p>
<h4 id="定义-v12"><a class="header-anchor" href="#定义-v12"> </a>定义</h4>
<p>提供一个创建<strong>一系列</strong>相关或相互依赖对象的<strong>接口</strong>，而<strong>无须指定</strong>它们<strong>具体的类</strong>。抽象工厂模式又称为 Kit 模式，它是一种对象创建<br>
型模式。为创建一组对象提供了一种解决方案。</p>
<p><strong>概念</strong></p>
<ul>
<li>产品等级结构：产品等级结构即产品的继承结构。例如抽象电视机和具体品牌的电视机构成一个产品等级结构</li>
<li>产品族：指同一个工厂生产的，位于不同产品等级结构中的一组产品。例如海尔工厂生产的海尔电视机、海尔电冰箱等</li>
</ul>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210508141710004.png" alt="image-20210508141710004"></p>
<p>使用抽象工厂模式：当系统所提供的工厂生产的具体产品并不是一个简单的对象，而是位于多个产品等级结构、属于不同类型的具体产品时</p>
<p>抽象工厂模式包含4个角色：</p>
<ol>
<li>AbstractFactory（抽象工厂）：声明了一组用于创建一族产品的方法，每一个方法对应一种产品。</li>
<li>ConcreteFactory（具体工厂）：实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。</li>
<li>AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。</li>
<li>ConcreteProduct（具体产品）：定义具体工厂生产的具体产品对象，实现在抽象产品接口中声明业务方法</li>
</ol>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210508150529509.png" alt="image-20210508150529509"></p>
<p><strong>抽象工厂模式的开闭原则的倾斜性</strong>： 抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦。</p>
<ul>
<li>增加产品族。抽象工厂模式支持了开闭原则</li>
<li>增加新的产品等级结构。违背了开闭原则：需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法</li>
</ul>
<h3 id="原型模式-Prototype-Pattern"><a class="header-anchor" href="#原型模式-Prototype-Pattern"> </a>原型模式 Prototype Pattern</h3>
<h4 id="定义-v13"><a class="header-anchor" href="#定义-v13"> </a>定义</h4>
<p>使用<strong>原型实例</strong>指定<strong>创建对象的种类</strong>，并且通过<strong>复制</strong>这些<strong>原型</strong>创建新的对象。原型模式是一种对象创建型模式。</p>
<p><strong>工作原理：</strong></p>
<p>将一个<strong>原型对象</strong>传给那个<strong>要发动创建</strong>的对象，这个要发动创建的对象通过<strong>请求原型对象</strong>克隆自己来实现创建过程。创建克隆对象的<strong>工厂</strong>就是<strong>原型类自身</strong>，工厂方法由克隆方法来实现。</p>
<p><strong>注意：</strong></p>
<ul>
<li>通过克隆方法创建的对象是全新的对象
<ul>
<li>内存中拥有新的地址</li>
</ul>
</li>
<li>克隆产生的对象的修改不会对原型对象造成任何影响
<ul>
<li>克隆对象相互独立</li>
</ul>
</li>
</ul>
<p><img src="http://algorithm-image.qibinaoe.top/image-20210512140621752.png" alt="image-20210512140621752"></p>
<p><strong>三种角色：</strong></p>
<ol>
<li>Prototype(抽象原型类)：声明<strong>克隆方法</strong>的接口，是所有具体原型类的<strong>公共父类</strong>，可以是<strong>抽象类</strong>、<strong>接口</strong>、<strong>具体实现类</strong>。</li>
<li>ConcretePrototype(具体原型类)：<strong>实现</strong>在抽象原型类中声明的<strong>克隆方法</strong>，在克隆方法中<strong>返回自己的一个克隆对象</strong>。</li>
<li>Client(客户类)：客户类中直接实例化或通过工厂方法等方式<strong>创建一个原型对象</strong>，再通过<strong>调用该对象的克隆方法</strong>即可得到克隆对象。</li>
</ol>
<blockquote>
<p>Java中，java.lang.Object类提供一个clone方法，但是要调用clone方法必须让该类实现<code>Cloneable</code>接口，并重写clone方法，否则灰抛出<code>CloneNotSupportedException</code>异常</p>
</blockquote>
<h4 id="浅拷贝（浅克隆）"><a class="header-anchor" href="#浅拷贝（浅克隆）"> </a>浅拷贝（浅克隆）</h4>
<ul>
<li>成员变量是值类型（基本数据类型）：复制一份</li>
<li>成员变量是引用类型：指向相同的内存地址</li>
</ul>
<h4 id="深拷贝（深克隆）"><a class="header-anchor" href="#深拷贝（深克隆）"> </a>深拷贝（深克隆）</h4>
<ul>
<li>无论成员变量是值类型还是引用类型都会复制一份</li>
</ul>
<p><strong>深拷贝的复制方式：</strong></p>
<p>可以通过序列化等方式实现。</p>
<p>序列化方式的深拷贝：将序列化对象写入一个流中，再从流里将其读出来</p>
<blockquote>
<p>注意：能够实现序列化的对象类必须实现<code>Serializable</code>接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用序列化技术实现深克隆</span></span><br><span class="line"><span class="keyword">public</span> WeeklyLog <span class="title function_">deepClone</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, OptionalDataException &#123;</span><br><span class="line">    <span class="comment">//将对象写入流中</span></span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">bao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>()；</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bao);</span><br><span class="line">    oos.writeObject(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">//将对象从流中取出</span></span><br><span class="line">    <span class="type">ByteArrayInputstream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bao.toByteArray());</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">    <span class="keyword">return</span> (WeeklyLog)ois.readobject();</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="建造者模式-Builder-Pattern"><a class="header-anchor" href="#建造者模式-Builder-Pattern"> </a>建造者模式 Builder Pattern</h3>
<h4 id="定义-v14"><a class="header-anchor" href="#定义-v14"> </a>定义</h4>
<p>将一个复杂对象的<strong>构建</strong>与它的<strong>表示分离</strong>，使得<strong>同样的构建过程</strong>可以<strong>创建不同的表示</strong></p>
<h2 id="结构型模式-Structural-Pattern"><a class="header-anchor" href="#结构型模式-Structural-Pattern"> </a>结构型模式 Structural Pattern</h2>
<h3 id="适配器模式-Adapter-Pattern"><a class="header-anchor" href="#适配器模式-Adapter-Pattern"> </a>适配器模式 Adapter Pattern</h3>
<h3 id="桥接模式-Bridge-Pattern"><a class="header-anchor" href="#桥接模式-Bridge-Pattern"> </a>桥接模式 Bridge Pattern</h3>
<h3 id="组合模式-Composite-Pattern"><a class="header-anchor" href="#组合模式-Composite-Pattern"> </a>组合模式 Composite Pattern</h3>
<h3 id="装饰模式-Decorator-Pattern"><a class="header-anchor" href="#装饰模式-Decorator-Pattern"> </a>装饰模式 Decorator Pattern</h3>
<h3 id="外观模式-Facade-Pattern"><a class="header-anchor" href="#外观模式-Facade-Pattern"> </a>外观模式 Facade Pattern</h3>
<h3 id="享元模式-Flyweight-Pattern"><a class="header-anchor" href="#享元模式-Flyweight-Pattern"> </a>享元模式 Flyweight Pattern</h3>
<h3 id="代理模式-Proxy-Pattern"><a class="header-anchor" href="#代理模式-Proxy-Pattern"> </a>代理模式 Proxy Pattern</h3>
<h2 id="行为型模式-Behavioral-Pattern"><a class="header-anchor" href="#行为型模式-Behavioral-Pattern"> </a>行为型模式 Behavioral Pattern</h2>
<h3 id="职责链模式-Chain-of-Responsibility-Pattern"><a class="header-anchor" href="#职责链模式-Chain-of-Responsibility-Pattern"> </a>职责链模式 Chain of Responsibility Pattern</h3>
<h3 id="命令模式-Command-Pattern"><a class="header-anchor" href="#命令模式-Command-Pattern"> </a>命令模式 Command Pattern</h3>
<h3 id="解释器模式-Interpreter-Pattern"><a class="header-anchor" href="#解释器模式-Interpreter-Pattern"> </a>解释器模式 Interpreter Pattern</h3>
<h3 id="迭代器模式-Iterator-Pattern"><a class="header-anchor" href="#迭代器模式-Iterator-Pattern"> </a>迭代器模式 Iterator Pattern</h3>
<h3 id="中介者模式-Mediator-Pattern"><a class="header-anchor" href="#中介者模式-Mediator-Pattern"> </a>中介者模式 Mediator Pattern</h3>
<h3 id="备忘录模式-Memento-Pattern"><a class="header-anchor" href="#备忘录模式-Memento-Pattern"> </a>备忘录模式 Memento Pattern</h3>
<h3 id="观察者模式-Observer-Pattern"><a class="header-anchor" href="#观察者模式-Observer-Pattern"> </a>观察者模式 Observer Pattern</h3>
<h3 id="状态模式-State-Pattern"><a class="header-anchor" href="#状态模式-State-Pattern"> </a>状态模式 State Pattern</h3>
<h3 id="策略模式-Strategy-Pattern"><a class="header-anchor" href="#策略模式-Strategy-Pattern"> </a>策略模式 Strategy Pattern</h3>
<h3 id="模板方法模式-Template-Method-Pattern"><a class="header-anchor" href="#模板方法模式-Template-Method-Pattern"> </a>模板方法模式 Template Method Pattern</h3>
<h3 id="访问者模式-Visitor-Pattern"><a class="header-anchor" href="#访问者模式-Visitor-Pattern"> </a>访问者模式 Visitor Pattern</h3>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>说话、演讲等感悟</title>
    <url>/2020/10/29/%E8%AF%B4%E8%AF%9D%E3%80%81%E6%BC%94%E8%AE%B2%E7%AD%89%E6%84%9F%E6%82%9F/</url>
    <content><![CDATA[<h1 id="观察感悟"><a class="header-anchor" href="#观察感悟"> </a>观察感悟</h1>
<ul>
<li>肢体语言适当
<ul>
<li>不能太多</li>
<li>不能完全没有</li>
<li>不要重复一个动作</li>
</ul>
</li>
<li>不能照着PPT全部念，根据主要内容自己说出来</li>
<li>不能一直盯着PPT、电脑， 要尽量跟观众进行眼神交流</li>
<li>在一张PPT上面不能停得太久</li>
<li>不要说某个东西自己也不是很了解</li>
<li>对于讲解PPT的内容，自己要熟知明白，能够脱口而出</li>
<li>少说这里，那里，要指明白讲清楚，所讲的图片的位置</li>
<li>可以讲自己为什么要怎么说 比如最早 ，为什么是最早的  ； 主要产品 。： 因为产品很多</li>
<li>东南亚为玩家超…  : 人口基数大 文化相近</li>
<li>可以说说自己的亲身经历的事情，自己的感想，然后简短的总结</li>
<li>先说现象，然后可以说一句 ：为什么。。。。的反问，然后说，：所以说。。。。</li>
<li>肢体语言可以在举自己的例子的时候，形象的肢体语言</li>
<li>逻辑性要强，讲逻辑才能让听众听得明白，才能更好的表达自己的想法</li>
<li>目光不要单纯在屏幕与PPT这两个角度，要多抬头这正视，扫视听众</li>
<li>不要把PPT和演讲稿分割成两部分，不是放着PPT然后光顾着自己的演讲稿，让人在PPT上找不到演讲人念的根据</li>
<li>开场要问好</li>
<li>不要过多晃动 肢体挥动需要直接了当，不要小幅度晃动</li>
<li>说话要清楚 有力有底气 不要过快</li>
<li>把每一句话都说清楚  不要忽大忽小</li>
<li>说话确实要有逻辑 不能自言自语  要有原因</li>
<li>不要说话表现得上气不接下气</li>
<li>通过适当多举例是不错的选择</li>
<li>面对别人的提问，眼神不要飘忽不定 不要乱扫，而是要注视提问人</li>
<li>在和老师交流的时候 不能打断老师的讲话 ，语气不能过于激进</li>
<li>在面向多数人，大家说话的时候，眼神可以面对观众扫视，看着观众扫视</li>
<li>有激光笔的时候， 不要乱晃</li>
<li>解释一个问题的时候 要解释清楚</li>
<li>注意PPT什么颜色的字在投影的时候会看不清</li>
<li>不要说自己不知道 不太懂 显得态度不对</li>
<li>说话要有层次感与逻辑性，不要话说一半说不通后就不说而另外说</li>
<li>说话不要带太多的“嗯”“啊”“然后”这类的</li>
<li>听众不能仅接受到PPT上显示的信息，也要接受一些PPT上延申的信息</li>
<li>在台上不要傻笑，显得心虚和假</li>
<li>PPT上要展示的图片应该显示重点，不要有太多不能突出重点的，比如展示代码片段，不要把IDE很多空白部分也截进来</li>
<li>说话结束干脆了当，不要说“没了，什么什么”，而是要干脆了当。</li>
<li>最好不要用这个那个，指明不明确</li>
<li>不要用“就是”“就是”，或者一直重复某一个词</li>
<li>不要PPT把要将的内容点都整合在一段，然后漫天讲话，可以分点出来一点一点的介绍</li>
<li>不要用“额”“然后”</li>
<li>说话不能一小段一小段零散的，而是要完整的表达出来一个有核心思想</li>
<li>不要打断老师</li>
<li>PPT不要有动画</li>
<li>说话有精神点</li>
<li>面对老师提问后的思考，不要停留太久</li>
<li>不要挡住屏幕，特别是评委老师的视线</li>
<li>一张PPT展示一种内容，要有核心思想</li>
<li>图看得要清楚</li>
<li>白底黑字（蓝字）挺清楚的 ||  蓝底白字</li>
<li>不要用宋体； 黑体就不错</li>
<li>PPT背景和颜色不要都是深色，比如蓝底黑字，这样完全看不清楚</li>
<li>说话要有营养和具有连贯性</li>
<li>眼神坚定不要乱飘(看天花板、翻白眼等)</li>
<li>如果忘记具体某种物品叫什么了，可以以能做到的最详细具体描述来指明去说，而不是说自己也忘了还是用什么什么来代替</li>
<li>内容硬核是最重要的</li>
<li>模板痕迹不要太强，能够表达自己的内容最重要</li>
<li>目录???需要吗?</li>
<li>语速过快的时候，要注意咬词清晰，不然带口音老师听不清楚</li>
<li>时间记得把握好，时间要卡好</li>
<li><em><strong>记住不要无意识的说出“然后”！！！！！</strong></em></li>
<li>PPT一页上的字不要又大又多，覆盖了整个页面</li>
<li>PPT一页上周围要留白</li>
</ul>
<hr>
<h1 id="自己上台说话的点评"><a class="header-anchor" href="#自己上台说话的点评"> </a>自己上台说话的点评</h1>
<h2 id="2020年11月6日大创答辩"><a class="header-anchor" href="#2020年11月6日大创答辩"> </a>2020年11月6日大创答辩</h2>
<ul>
<li>“然后”无意识的说出来，自己都没有意识到</li>
<li>表达内心思想的时候，逻辑混乱，无用的语气词太多，不能简明扼要的表达出来</li>
<li>普通话不标准</li>
<li>肢体语言还需改进
<ul>
<li>不协调</li>
</ul>
</li>
<li>说话太急</li>
</ul>
<hr>
<h2 id="大创评委老师询问问题"><a class="header-anchor" href="#大创评委老师询问问题"> </a>大创评委老师询问问题</h2>
<p>项目最大的创新点？<br>
困难  怎么解决困难<br>
挑战<br>
开源项目 自己创造性的地方<br>
分工<br>
与现有项目相比，特色、优势</p>
<h2 id="针对大创答辩"><a class="header-anchor" href="#针对大创答辩"> </a>针对大创答辩</h2>
<ul>
<li>需要吹优点</li>
<li>需要吹团队协作</li>
<li>技术点</li>
<li>展示</li>
<li>可以实际操作显示</li>
<li>废话不要太多，直入重点，老师喜欢看做了什么，效果怎么样，而不是项目意义背景等</li>
<li>但是不要夸大其词，要有根据有依据</li>
</ul>
<hr>
<h1 id="如何让说话有逻辑、如何去讲PPT"><a class="header-anchor" href="#如何让说话有逻辑、如何去讲PPT"> </a>如何让说话有逻辑、如何去讲PPT</h1>
<h2 id="咨询黄武老师"><a class="header-anchor" href="#咨询黄武老师"> </a>咨询黄武老师</h2>
<ul>
<li>
<p><em><strong>准备</strong></em> 准备是十分重要的，只有准备才能够知道自己要跟别人传递的信息是什么，才能够有深度与广度的去阐述一个问题</p>
</li>
<li>
<p>说话技巧，可以参考书籍去学习，说话的顺序，说话的结构</p>
</li>
</ul>
<hr>
<h1 id="其他-v3"><a class="header-anchor" href="#其他-v3"> </a>其他</h1>
<ul>
<li>
<p>金字塔原理四项基本原则</p>
</li>
<li>
<p>大脑偏爱简单 偏爱结构</p>
</li>
<li>
<p>用结构话的思维去表达</p>
</li>
<li>
<p>用同理心去换位思考</p>
</li>
<li>
<p>用积极主动去收获成长(要我做和我要做是不同的，对待一个事情的态度不一样)</p>
</li>
<li>
<p>做扩大影响圈的事，收获成长</p>
<ul>
<li>不要埋怨抱怨与自己无关的事情</li>
<li>要抓住影响圈和关注圈的问题</li>
<li>把时间尽力花在自己能改变的事情，而不是过多的在意自己改变不了的事情(当然不是完全不关注)</li>
<li>知道自己要做的事情是什么</li>
</ul>
</li>
<li>
<p>身份转换(每个当下只能由一个身份)</p>
</li>
<li>
<p>环境换框法</p>
<ul>
<li>(领导不重视，培训是不会有效果的)</li>
</ul>
</li>
<li>
<p>意义换框法</p>
<ul>
<li>(因为导师/老板很挑剔，所以我工作不开心)</li>
</ul>
</li>
<li>
<p><em><strong>持续学习</strong></em>去扩大公开象限</p>
<ul>
<li>35岁危机是因为自己掉队了</li>
</ul>
</li>
<li>
<p>把行动形成习惯</p>
<ul>
<li>没有改变不了的习惯，只有你不怎么想改的习惯</li>
</ul>
</li>
</ul>
<p>==================&gt;  <strong>By 中兴  职业规划</strong></p>
<ul>
<li>
<p>职位提升</p>
<ol>
<li>增强自己的能力</li>
<li>扩大自己的公开象限</li>
<li>要事要有亮点()</li>
</ol>
</li>
<li>
<p>社招与校招区别</p>
<ul>
<li>校招看重潜力</li>
<li>社招看重能力、高端人才</li>
</ul>
</li>
<li>
<p>本科生与研究生</p>
<ol>
<li>本科生看重素质</li>
<li>研究生看重项目经验</li>
<li>但是面试的标准是一致的</li>
</ol>
</li>
<li>
<p>本科生没有必要去小公司实习，倒不如学基础做项目</p>
</li>
</ul>
]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>大学时代</tag>
        <tag>随想</tag>
        <tag>演讲</tag>
      </tags>
  </entry>
</search>
